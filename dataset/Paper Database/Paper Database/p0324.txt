Noname manuscript No.
(will be inserted by the editor)
On Constrained Spectral Clustering and Its Applications
Xiang Wang · Buyue Qian · Ian Davidson
Received: date / Accepted: date
Abstract Constrained clustering has been well-studied for algorithms such as Kmeans and hierarchical clustering. However, how to satisfy many constraints in
these algorithmic settings has been shown to be intractable. One alternative to
encode many constraints is to use spectral clustering, which remains a developing
area. In this paper, we propose a ﬂexible framework for constrained spectral clustering. In contrast to some previous eﬀorts that implicitly encode Must-Link and
Cannot-Link constraints by modifying the graph Laplacian or constraining the underlying eigenspace, we present a more natural and principled formulation, which
explicitly encodes the constraints as part of a constrained optimization problem.
Our method oﬀers several practical advantages: it can encode the degree of belief in Must-Link and Cannot-Link constraints; it guarantees to lower-bound how
well the given constraints are satisﬁed using a user-speciﬁed threshold; it can be
solved deterministically in polynomial time through generalized eigendecomposition. Furthermore, by inheriting the objective function from spectral clustering
and encoding the constraints explicitly, much of the existing analysis of unconstrained spectral clustering techniques remains valid for our formulation. We validate the eﬀectiveness of our approach by empirical results on both artiﬁcial and
real datasets. We also demonstrate an innovative use of encoding large number of
constraints: transfer learning via constraints.
Keywords Spectral clustering · Constrained clustering · Transfer learning ·
Graph partition
Department of Computer Science, University of California, Davis. Davis, CA 95616, USA.
E-mail: 
Department of Computer Science, University of California, Davis. Davis, CA 95616, USA.
E-mail: 
I. Davidson
Department of Computer Science, University of California, Davis. Davis, CA 95616, USA.
E-mail: 
Xiang Wang et al.
(a) K-means
(b) Spectral clustering
(c) Spectral clustering
(d) Constrained spectral clustering
Fig. 1 A motivating example for constrained spectral clustering.
1 Introduction
1.1 Background and Motivation
Spectral clustering is an important clustering technique that has been extensively
studied in the image processing, data mining, and machine learning communities ; von Luxburg ; Ng et al ). It is considered
superior to traditional clustering algorithms like K-means in terms of having deterministic polynomial-time solution, the ability to model arbitrary shaped clusters,
and its equivalence to certain graph cut problems. For example, spectral clustering is able to capture the underlying moon-shaped clusters as shown in Fig. 1(b),
whereas K-means would fail (Fig. 1(a)). The advantage of spectral clustering has
also been validated by many real-world applications, such as image segmentation
 ) and mining social networks ).
Spectral clustering was originally proposed to address an unsupervised learning
problem: the data instances are unlabeled, and all available information is encoded
in the graph Laplacian. However, there are cases where unsupervised spectral
clustering becomes insuﬃcient. Using the same toy data, as shown in (Fig. 1(c)),
when the two moons are under-sampled, the clusters become so sparse that the
separation of them becomes diﬃcult. To help spectral clustering recover from an
undesirable partition, we can introduce side information in various forms, in either
small or large amounts. For example:
On Constrained Spectral Clustering and Its Applications
1. Pairwise constraints: Domain experts may explicitly assign constraints that
state a pair of instances must be in the same cluster (Must-Link, ML for short)
or that a pair of instances cannot be in the same cluster (Cannot-Link, CL for
short). For instance, as shown in Fig. 1(d), we assigned several ML (solid
lines) and CL (dashed lines) constraints, then applied our constrained spectral
clustering algorithm, which we will describe later. As a result, the two moons
were successfully recovered.
2. Partial labeling: There can be labels on some of the instances, which are
neither complete nor exhaustive. We demonstrate in Fig. 9 that even small
amounts of labeled information can greatly improve clustering results when
compared against the ground truth partition, as inferred by the labels.
3. Alternative weak distance metrics: In some situations there may be more
than one distance metrics available. For example, in Table 3 and accompanying
paragraphs we describe clustering documents using distance functions based
on diﬀerent languages (features).
4. Transfer of knowledge: In the context of transfer learning ), if we treat the graph Laplacian as the target domain, we could transfer
knowledge from a diﬀerent but related graph, which can be viewed as the source
domain. We discuss this direction in Section 6.3 and 7.5.
All the aforementioned side information can be transformed into pairwise ML and
CL constraints, which could either be hard (binary) or soft (degree of belief). For
example, if the side information comes from a source graph, we can construct
pairwise constraints by assuming that the more similar two instance are in the
source graph, the more likely they belong to the same cluster in the target graph.
Consequently the constraints should naturally be represented by a degree of belief,
rather than a binary assertion.
How to make use of these side information to improve clustering falls into
the area of constrained clustering ). In general, constrained
clustering is a category of techniques that try to incorporate ML and CL constraints into existing clustering schemes. It has been well studied on algorithms
such as K-means clustering, mixture model, hierarchical clustering, and densitybased clustering. Previous studies showed that satisfying all constraints at once
 ), incrementally ), or even pruning constraints ) is intractable. Furthermore, it was
shown that algorithms that build set partitions incrementally (such as K-means
and EM) are prone to being over-constrained ). In contrast, incorporating constraints into spectral clustering is a promising direction
since, unlike existing algorithms, all data instances are assigned simultaneously to
clusters, even if the given constraints are inconsistent.
Constrained spectral clustering is still a developing area. Previous work on this
topic can be divided into two categories, based on how they enforce the constraints.
The ﬁrst category ; Xu et al ; Lu and Carreira-Perpi˜n´an
 ; Wang et al ; Ji and Xu ) directly manipulate the graph Laplacian (or equivalently, the aﬃnity matrix) according to the given constraints; then
unconstrained spectral clustering is applied on the modiﬁed graph Laplacian. The
second category use constraints to restrict the feasible solution space ; Coleman et al ; Li et al ; Yu and Shi ). Existing
methods in both categories share several limitations:
Xiang Wang et al.
– They are designed to handle only binary constraints. However, as we have
stated above, in many real-world applications, constraints are made available
in the form of real-valued degree of belief, rather than a yes or no assertion.
– They aim to satisfy as many constraints as possible, which could lead to inﬂexibility in practice. For example, the given set of constraints could be noisy, and
satisfying some of the constraints could actually hurt the overall performance.
Also, it is reasonable to ignore a small portion of constraints in exchange for a
clustering with much lower cost.
– They do not oﬀer any natural interpretation of either the way that constraints
are encoded or the implication of enforcing them.
1.2 Our Contributions
In this paper, we study how to incorporate large amounts of pairwise constraints
into spectral clustering, in a ﬂexible manner that addresses the limitations of
previous work. Then we show the practical beneﬁts of our approach, including
new applications previously not possible.
We extend beyond binary ML/CL constraints and propose a more ﬂexible
framework to accommodate general-type side information. We allow the binary
constraints to be relaxed to real-valued degree of belief that two data instances
belong to the same cluster or two diﬀerent clusters. Moreover, instead of trying
to satisfy each and every constraint that has been given, we use a user-speciﬁed
threshold to lower bound how well the given constraints must be satisﬁed. Therefore, our method provides maximum ﬂexibility in terms of both representing
constraints and satisfying them. This, in addition to handling large amounts of
constraints, allows the encoding of new styles of information such as entire graphs
and alternative distance metrics in their raw form without considering issues such
as constraint inconsistencies and over-constraining.
Our contributions are:
– We propose a principled framework for constrained spectral clustering that can
incorporate large amounts of both hard and soft constraints.
– We show how to enforce constraints in a ﬂexible way: a user-speciﬁed threshold
is introduced so that a limited amount of constraints can be ignored in exchange
for lower clustering cost. This allows incorporating side information in its raw
form without considering issues such as inconsistency and over-constraining.
– We extend the objective function of unconstrained spectral clustering by encoding constraints explicitly and creating a novel constrained optimization problem. Thus our formulation naturally covers unconstrained spectral clustering
as a special case.
– We show that our objective function can be turned into a generalized eigenvalue
problem, which can be solved deterministically in polynomial time. This is a
major advantage over constrained K-means clustering, which produces nondeterministic solutions while being intractable even for K = 2 ; Davidson and Ravi ).
– We interpret our formulation from both the graph cut perspective and the
Laplacian embedding perspective.
On Constrained Spectral Clustering and Its Applications
– We validate the eﬀectiveness of our approach and its advantage over existing
methods using standard benchmarks and new innovative applications such as
transfer learning.
This paper is an extension of our previous work )
with the following additions: 1) we extend our algorithm from 2-way partition
to K-way partition (Section 6.2); 2) we add a new geometric interpretation to
our algorithm (Section 5.2); 3) we show how to apply our algorithm to a novel
application (Section 6.3), namely transfer learning, and test it with a real-world
fMRI dataset (Section 7.5); 4) we present a much more comprehensive experiment
section with more tasks conducted on more datasets (Section 7.2 and 7.4).
The rest of the paper is organized as follows: In Section 2 we brieﬂy survey
previous work on constrained spectral clustering; Section 3 provides preliminaries
for spectral clustering; in Section 4 we formally introduce our formulation for
constrained spectral clustering and show how to solve it eﬃciently; in Section 5 we
interpret our objective from two diﬀerent perspectives; in Section 6 we discuss the
implementation of our algorithm and possible extensions; we empirically evaluate
our approach in Section 7; Section 8 concludes the paper.
2 Related Work
Constrained clustering is a category of methods that extend clustering from unsupervised setting to semi-supervised setting, where side information is available in
the form of, or can be converted into, pairwise constraints. A number of algorithms
have been proposed on how to incorporate constraints into spectral clustering,
which can be grouped into two categories.
The ﬁrst category manipulates the graph Laplacian directly. Kamvar et al
 proposed the spectral learning algorithm that sets the (i, j)-th entry of
the aﬃnity matrix to 1 if there is a ML between node i and j; 0 for CL. A
new graph Laplacian is then computed based on the modiﬁed aﬃnity matrix. In
 ), the constraints are encoded in the same way, but a random walk
matrix is used instead of the normalized Laplacian. Kulis et al proposed
to add both positive (for ML) and negative (for CL) penalties to the aﬃnity matrix (they then used kernel K-means, instead of spectral clustering, to ﬁnd the
partition based on the new kernel). Lu and Carreira-Perpi˜n´an proposed to
propagate the constraints in the aﬃnity matrix. In Ji and Xu ; Wang et al
 , the graph Laplacian is modiﬁed by combining the constraint matrix as a
regularizer. The limitation of these approaches is that there is no principled way
to decide the weights of the constraints, and there is no guarantee that how well
the give constraints will be satisﬁed.
The second category manipulates the eigenspace directly. For example, the
subspace trick introduced by De Bie et al alters the eigenspace which the
cluster indicator vector is projected onto, based on the given constraints. This
technique was later extended in Coleman et al to accommodate inconsistent constraints. Yu and Shi encoded partial grouping information as
a subspace projection. Li et al enforced constraints by regularizing the spectral embedding. This type of approaches usually strictly enforce given constraints.
As a result, the results are often over-constrained, which makes the algorithms sen-
Xiang Wang et al.
Table 1 Table of notations
An undirected (weighted) graph
The aﬃnity matrix
The degree matrix
The identity matrix
The unnormalized/normalized graph Laplacian
The unnormalized/normalized constraint matrix
The volume of graph G
sitive to noise and inconsistencies in the constraint set. Moreover, it is non-trivial
to extend these approaches to incorporate soft constraints.
In addition, Gu et al proposed a spectral kernel design that combines
multiple clustering tasks. The learned kernel is constrained in such a way that
the data distributions of any two tasks are as close as possible. Their problem
setting diﬀers from ours because we aim to perform single-task clustering by using two (disagreeing) data sources. Wang et al showed how to incorporate
pairwise constraints into a penalized matrix factorization framework. Their matrix
approximation objective function, which is diﬀerent from our normalized min-cut
objective, is solved by an EM-like algorithm.
We would like to stress that the pros and cons of spectral clustering as compared to other clustering schemes, such as K-means clustering, hierarchical clustering, etc., have been thoroughly studied and well established. We do not claim
that constrained spectral clustering is universally superior to other constrained
clustering schemes. The goal of this work is to provide a way to incorporate constraints into spectral clustering that is more ﬂexible and principled as compared
with existing constrained spectral clustering techniques.
3 Background and Preliminaries
In this paper we follow the standard graph model that is commonly used in the
spectral clustering literature. We reiterate some of the deﬁnitions and properties
in this section, such as graph Laplacian, normalized min-cut, eigendecomposition
and so forth, to make this paper self-contained. Readers who are familiar with
the materials can skip to our formulation in Section 4. Important notations used
throughout the rest of the paper are listed in Table 1.
A collection of N data instances is modeled by an undirected, weighted graph
G(V, E, A), where each data instance corresponds to a vertex (node) in V; E is the
edge set and A is the associated aﬃnity matrix. A is symmetric and non-negative.
The diagonal matrix D = diag(D11, . . . , DNN) is called the degree matrix of graph
is called the unnormalized graph Laplacian of G. Assuming G is connected (i.e.
any node is reachable from any other node), L has the following properties:
On Constrained Spectral Clustering and Its Applications
Property 1 )) Let L be
the graph Laplacian of a connected graph, then:
1. L is symmetric and positive semi-deﬁnite.
2. L has one and only one eigenvalue equal to 0, and N −1 positive eigenvalues:
0 = λ0 < λ1 ≤. . . ≤λN−1.
3. 1 is an eigenvector of L with eigenvalue 0 showed that the eigenvectors of the graph Laplacian can
be related to the normalized min-cut (Ncut) of G. The objective function can be
written as:
v∈RN vT ¯Lv, s.t. vT v = vol, v ⊥D1/21.
¯L = D−1/2LD−1/2
is called the normalized graph Laplacian ); vol = PN
i=1 Dii is
the volume of G; the ﬁrst constraint vT v = vol normalizes v; the second constraint
v ⊥D1/21 rules out the principal eigenvector of ¯L as a trivial solution, because
it does not deﬁne a meaningful cut on the graph. The relaxed cluster indicator u
can be recovered from v as:
u = D−1/2v.
Note that the result of spectral clustering is solely decided by the aﬃnity
structure of graph G as encoded in the matrix A (and thus the graph Laplacian
L). We will then describe our extensions on how to incorporate side information
so that the result of clustering will reﬂect both the aﬃnity structure of the graph
and the structure of the side information.
4 A Flexible Framework for Constrained Spectral Clustering
In this section, we show how to incorporate side information into spectral clustering
as pairwise constraints. Our formulation allows both hard and soft constraints.
We propose a new constrained optimization formulation for constrained spectral
clustering. Then we show how to solve the objective function by converting it into
a generalized eigenvalue system.
4.1 The Objective Function
We encode side information with an N × N constraint matrix Q. Traditionally,
constrained clustering only accommodates binary constraints, namely Must-Link
and Cannot-Link:
Qij = Qji =
if ML(i, j)
if CL(i, j)
no side information available
Xiang Wang et al.
Let u ∈{−1, +1}N be a cluster indicator vector, where ui = +1 if node i belongs
to cluster + and ui = −1 if node i belongs to cluster −, then
is a measure of how well the constraints in Q are satisﬁed by the assignment u:
the measure will increase by 1 if Qij = 1 and node i and j have the same sign in
u; it will decrease by 1 if Qij = 1 but node i and j have diﬀerent signs in u or
Qij = −1 but node i and j have the same sign in u.
We extend the above encoding scheme to accommodate soft constraints by
relaxing the cluster indicator vector u as well as the constraint matrix Q such
u ∈RN, Q ∈RN×N.
Qij is positive if we believe nodes i and j belong to the same cluster; Qij is
negative if we believe nodes i and j belong to diﬀerent clusters; the magnitude of
Qij indicates how strong the belief is.
Consequently, uT Qu becomes a real-valued measure of how well the constraints
in Q are satisﬁed in the relaxed sense. For example, Qij < 0 means we believe nodes
i and j belong to diﬀerent clusters; in order to improve uT Qu, we should assign
ui and uj with values of diﬀerent signs; similarly, Qij > 0 means nodes i and j are
believed to belong to the same cluster; we should assign ui and uj with values of
the same sign. The larger uT Qu is, the better the cluster assignment u conforms
to the given constraints in Q.
Now given this real-valued measure, rather than trying to satisfy all the constraints in Q individually, we can lower-bound this measure with a constant α ∈R:
Following the notations in Eq.(1), we substitute u with D−1/2v, above inequality
vT ¯Qv ≥α,
¯Q = D−1/2QD−1/2
is the normalized constraint matrix.
We append this lower-bound constraint to the objective function of unconstrained spectral clustering in Eq.(1) and we have:
Problem 1 (Constrained Spectral Clustering) Given a normalized graph Laplacian ¯L, a normalized constraint matrix ¯Q and a threshold α, we want to optimizes
the following objective function:
v∈RN vT ¯Lv, s.t. vT ¯Qv ≥α, vT v = vol, v ̸= D1/21.
Here vT ¯Lv is the cost of the cut we want to minimize; the ﬁrst constraint vT ¯Qv ≥α
is to lower bound how well the constraints in Q are satisﬁed; the second constraint
vT v = vol normalizes v; the third constraint v ̸= D1/21 rules out the trivial
solution D1/21. Suppose v∗is the optimal solution to Eq.(2), then u∗= D−1/2v∗
is the optimal cluster indicator vector.
On Constrained Spectral Clustering and Its Applications
It is easy to see that the unconstrained spectral clustering in Eq.(1) is covered
as a special case of Eq.(2) where ¯Q = I (no constraints are encoded) and α = vol
(vT ¯Qv ≥vol is trivially satisﬁed given ¯Q = I and vT v = vol).
4.2 Solving the Objective Function
To solve a constrained optimization problem, we follow the Karush-Kuhn-Tucker
Theorem ) to derive the necessary conditions for the optimal solution to the problem. We can ﬁnd a set of candidates, or feasible solutions,
that satisfy all the necessary conditions. Then we choose the optimal solution
among the feasible solutions using brute-force method, given the size of the feasible set is ﬁnite and small.
For our objective function in Eq.(2), we introduce the Lagrange multipliers as
Λ(v, λ, µ) = vT ¯Lv −λ(vT ¯Qv −α) −µ(vT v −vol).
Then according to the KKT Theorem, any feasible solution to Eq.(2) must satisfy
the following conditions:
(Stationarity) ¯Lv −λ ¯Qv −µv = 0,
(Primal feasibility) vT ¯Qv ≥α, vT v = vol,
(Dual feasibility) λ ≥0,
(Complementary slackness) λ(vT ¯Qv −α) = 0.
Note that Eq.(4) comes from taking the derivative of Eq.(3) with respect to v.
Also note that we dismiss the constraint v ̸= D1/21 at this moment, because it
can be checked independently after we ﬁnd the feasible solutions.
To solve Eq.(4)-(7), we start with looking at the complementary slackness
requirement in Eq.(7), which implies either λ = 0 or vT ¯Qv −α = 0. If λ = 0, we
will have a trivial problem because the second term from Eq.(4) will be eliminated
and the problem will be reduced to unconstrained spectral clustering. Therefore
in the following we focus on the case where λ ̸= 0. In this case, for Eq.(7) to hold
vT ¯Qv −α must be 0. Consequently the KKT conditions become:
¯Lv −λ ¯Qv −µv = 0,
vT v = vol,
vT ¯Qv = α,
Under the assumption that α is arbitrarily assigned by user and λ and µ are
independent variables, Eq.(8-11) cannot be solved explicitly, and it may produce
inﬁnite number of feasible solutions, if one exists. As a workaround, we temporarily
drop the assumption that α is an arbitrary value assigned by the user. Instead, we
assume α ≜vT ¯Qv, i.e. α is deﬁned as such that Eq.(10) holds. Then we introduce
an auxiliary variable, β, which is deﬁned as the ratio between µ and λ:
Xiang Wang et al.
Now we substitute Eq.(12) into Eq.(8) we obtain:
¯Lv −λ ¯Qv + λβ
vol v = 0,
or equivalently:
¯Lv = λ( ¯Q −β
We immediately notice that Eq.(13) is a generalized eigenvalue problem for a given
Next we show that the substitution of α with β does not compromise our
original intention of lower bounding vT ¯Qv in Eq.(2).
Lemma 1 β < vT ¯Qv.
Proof Let γ ≜vT ¯Lv, by left-hand multiplying vT to both sides of Eq.(13) we have
vT ¯Lv = λvT ( ¯Q −β
Then incorporating Eq.(9) and α ≜vT ¯Qv we have
γ = λ(α −β).
Now recall that L is positive semi-deﬁnite (Property 1), and so is ¯L, which means
γ = vT ¯Lv > 0, ∀v ̸= D1/21.
Consequently, we have
vT ¯Qv = α > β.
In summary, our algorithm works as follows (the exact implementation is shown
in Algorithm 1):
1. Generating candidates: The user speciﬁes a value for β, and we solve the
generalized eigenvalue system given in Eq.(13). Note that both ¯L and ¯Q−β/volI
are Hermitian matrices, thus the generalized eigenvalues are guaranteed to be
real numbers.
2. Finding the feasible set: Removing generalized eigenvectors associated with
non-positive eigenvalues, and normalize the rest such that vT v = vol. Note
that the trivial solution D1/21 is automatically removed in this step because
if it is a generalized eigenvector in Eq.(13), the associated eigenvalue would be
0. Since we have at most N generalized eigenvectors, the number of feasible
eigenvectors is at most N.
3. Choosing the optimal solution: We choose from the feasible solutions the
one that minimizes vT ¯Lv, say v∗.
According to Lemma 1, v∗is the optimal solution to the objective function in
Eq.(2) for any given β and β < α = v∗T ¯Qv∗.
On Constrained Spectral Clustering and Its Applications
Algorithm 1: Constrained Spectral Clustering
Input: Aﬃnity matrix A, constraint matrix Q, β;
Output: The optimal (relaxed) cluster indicator u∗;
j=1 Aij, D ←diag(PN
2 ¯L ←I −D−1/2AD−1/2, ¯Q ←D−1/2QD−1/2;
3 λmax( ¯Q) ←the largest eigenvalue of ¯Q;
4 if β ≥λmax( ¯Q) · vol then
return u∗= ∅;
Solve the generalized eigenvalue system in Eq.(13);
Remove eigenvectors associated with non-positive eigenvalues and normalize the
rest by v ←
v∗←argminv vT ¯Lv, where v is among the feasible eigenvectors generated in the
previous step;
return u∗←D−1/2v∗;
4.3 A Suﬃcient Condition for the Existence of Solutions
On one hand, our method described above is guaranteed to generate a ﬁnite number of feasible solutions. On the other hand, we need to set β appropriately so that
the generalized eigenvalue system in Eq.(13) combined with the KKT conditions in
Eq.(8-11) will give rise to at least one feasible solution. In this section, we discuss
such a suﬃcient condition:
β < λmax( ¯Q) · vol,
where λmax( ¯Q) is the largest eigenvalue of ¯Q. In this case, the matrix on the right
hand side of Eq.(13), namely ¯Q−β/vol·I, will have at least one positive eigenvalue.
Consequently, the generalized eigenvalue system in Eq.(13) will have at least one
positive eigenvalue. Moreover, the number of feasible eigenvectors will increase if
we make β smaller. For example, if we set β < λmin( ¯Q)vol, λmin( ¯Q) to be the
smallest eigenvalue of ¯Q, then ¯Q −β/vol · I becomes positive deﬁnite. Then the
generalized eigenvalue system in Eq.(13) will generate N −1 feasible eigenvectors
(the trivial solution D1/21 with eigenvalue 0 is dropped).
In practice, we normally choose the value of β within the range
(λmin( ¯Q) · vol, λmax( ¯Q) · vol).
In that range, the greater β is, the more the solution will be biased towards satisfying ¯Q. Again, note that whenever we have β < λmax( ¯Q) · vol, the value of α will
always be bounded by
β < α ≤λmaxvol.
Therefore we do not need to take care of α explicitly.
Xiang Wang et al.
Fig. 2 An illustrative example: the aﬃnity structure says {1, 2, 3} and {4, 5, 6} while the node
labeling (coloring) says {1, 2, 3, 4} and {5, 6}.
4.4 An Illustrative Example
To illustrate how our algorithm works, we present a toy example as follows. In
Fig. 2, we have a graph associated with the following aﬃnity matrix:
0 1 1 0 0 0
1 0 1 0 0 0
1 1 0 1 0 0
0 0 1 0 1 1
0 0 0 1 0 1
0 0 0 1 1 0
Unconstrained spectral clustering will cut the graph at edge (3, 4) and split it into
two symmetric parts {1, 2,3} and {4, 5, 6} (Fig. 3(a)).
Then we introduce constraints as encoded in the following constraint matrix:
+1 +1 +1 +1 −1 −1
+1 +1 +1 +1 −1 −1
+1 +1 +1 +1 −1 −1
+1 +1 +1 +1 −1 −1
−1 −1 −1 −1 +1 +1
−1 −1 −1 −1 +1 +1
Q is essentially saying that we want to group nodes {1, 2, 3,4} into one cluster and
{5, 6} the other. Although this kind of “complete information” constraint matrix
does not happen in practice, we use it here only to make the result more explicit
and intuitive.
¯Q has two distinct eigenvalues: 0 and 2.6667. As analyzed above, β must be
smaller than 2.6667vol to guarantee the existence of a feasible solution, and larger
β means we want more constraints in Q to be satisﬁed (in a relaxed sense). Thus
we set β to vol and 2vol respectively, and see how it will aﬀect the resultant
constrained cuts. We solve the generalized eigenvalue system in Eq.(13), and plot
the cluster indicator vector u∗in Fig. 3(b) and 3(c), respectively. We can see that
as β increases, node 4 is dragged from the group of nodes {5, 6} to the group of
nodes {1, 2,3}, which conforms to our expectation that greater β value implies
better constraint satisfaction.
On Constrained Spectral Clustering and Its Applications
(a) Unconstrained
(b) Constrained, β = vol
(c) Constrained, β = 2vol
Fig. 3 The solutions to the illustrative example in Fig. 2 with diﬀerent β. The x-axis is the
indices of the instances and the y-axis is the corresponding entry values in the optimal (relaxed)
cluster indicator u∗. Notice that node 4 is biased toward nodes {1, 2, 3} as β increases.
5 Interpretations of Our Formulation
5.1 A Graph Cut Interpretation
Unconstrained spectral clustering can be interpreted as ﬁnding the Ncut of an
unlabeled graph. Similarly, our formulation of constrained spectral clustering in
Eq.(2) can be interpreted as ﬁnding the Ncut of a labeled/colored graph.
Speciﬁcally, suppose we have an undirected weighted graph. The nodes of the
graph are colored in such a way that nodes of the same color are advised to
be assigned into the same cluster while nodes of diﬀerent colors are advised to
be assigned into diﬀerent clusters (e.g. Fig. 2). Let v∗be the solution to the
constrained optimization problem in Eq.(2). We cut the graph into two parts based
on the values of the entries of u∗= D−1/2v∗. Then v∗T ¯Lv∗can be interpreted as
the cost of the cut (in a relaxed sense), which we minimize. On the other hand,
α = v∗T ¯Qv∗= u∗T Qu∗
can be interpreted as the purity of the cut (also in a relaxed sense), according
to the color of the nodes in respective sides. For example, if Q ∈{−1, 0,1}N×N
and u∗∈{−1, 1}N, then α equals to the number of constraints in Q that are
satisﬁed by u∗minus the number of constraints violated. More generally, if Qij is
a positive number, then u∗
j having the same sign will contribute positively
to the purity of the cut, whereas diﬀerent signs will contribute negatively to the
purity of the cut. It is not diﬃcult to see that the purity can be maximized when
there is no pair of nodes with diﬀerent colors that are assigned to the same side
of the cut (0 violations), which is the case where all constraints in Q are satisﬁed.
5.2 A Geometric Interpretation
We can also interpret our formulation as constraining the joint numerical range
 ) of the graph Laplacian and the constraint matrix.
Speciﬁcally, we consider the joint numerical range:
J(¯L, ¯Q) ≜{(vT ¯Lv, vT ¯Qv) : vT v = 1}.
J(¯L, ¯Q) essentially maps all possible cuts v to a 2-D plane, where the x-coordinate
corresponds to the cost of the cut, and the y-axis corresponds to the constraint
Xiang Wang et al.
(a) The unconstrained Ncut
(b) The constrained Ncut
Cost of the Cut
Constraint Satisfaction of the Cut
unconstrained cuts
constrained cuts
unconstrained min−cut
constrained min−cut
lower bound α
(c) J(¯L, ¯Q)
Fig. 4 The joint numerical range of the normalized graph Laplacian ¯L and the normalized
constraint matrix ¯Q, as well as the optimal solutions to unconstrained/constrained spectral
clustering.
satisfaction of the cut. According to our objective in Eq.(2), we want to minimize
the ﬁrst term while lower-bounding the second term. Therefore, we are looking for
the leftmost point among those that are above the horizontal line y = α.
In Fig. 4(c), we visualize J(¯L, ¯Q) by plotting all the unconstrained cuts given
by spectral clustering and all the constrained cuts given by our algorithm in the
joint numerical range, based on the graph Laplacian of a Two-Moon dataset with
a randomly generated constraint matrix. The horizontal line and the arrow indicate the constrained area from which we can select feasible solutions. We can see
that most of the unconstrained cuts proposed by spectral clustering are far below
the threshold, which suggests spectral clustering cannot lead to the ground truth
partition (as shown in Fig. 4(b)) without the help of constraints.
On Constrained Spectral Clustering and Its Applications
6 Implementation and Extensions
In this section, we discuss some implementation issues of our method. Then we
show how to generalize it to K-way partition where K ≥2.
6.1 Constrained Spectral Clustering for 2-Way Partition
The routine of our method is similar to that of unconstrained spectral clustering.
The input of the algorithm is an aﬃnity matrix A, the constraint matrix Q, and
a threshold β. Then we solve the generalized eigenvalue problem in Eq.(13) and
ﬁnd all the feasible generalized eigenvectors. The output is the optimal (relaxed)
cluster assignment indicator u∗. In practice, a partition is often derived from u∗by
assigning nodes corresponding to the positive entries in u∗to one side of the cut,
and negative entries to the other side. Our algorithm is summarized in Algorithm 1.
Since our model encodes soft constraints as degree of belief, inconsistent constraints in Q will not corrupt our algorithm. Instead, they are enforced implicitly
by maximizing uT Qu. Note that if the constraint matrix Q is generated from a
partial labeling, then the constraints in Q will always be consistent.
Runtime analysis: The runtime of our algorithm is dominated by that of the
generalized eigendecomposition. In other words, the complexity of our algorithm
is on a par with that of unconstrained spectral clustering in big-O notation, which
is O(kN2), N to be the number of data instances and k to be the number of
eigenpairs we need to compute. Here k is a number large enough to guarantee the
existence of feasible solutions. In practice we normally have 2 < k ≪N.
6.2 Extension to K-Way Partition
Our algorithm can be naturally extended to K-way partition for K > 2, following
what we usually do for unconstrained spectral clustering ):
instead of only using the optimal feasible eigenvector u∗, we preserve top-(K −1)
eigenvectors associated with positive eigenvalues, and perform K-means algorithm
based on that embedding.
Speciﬁcally, the constraint matrix Q follows the same encoding scheme: Qij > 0
if node i and j are believed to belong to the same cluster, Qij < 0 otherwise. To
guarantee we can ﬁnd K −1 feasible eigenvectors, we set the threshold β such that
β < λK−1vol,
where λK−1 is the (K −1)-th largest eigenvalue of ¯Q. Given all the feasible eigenvectors, we pick the top K −1 in terms of minimizing vT ¯Lv 1. Let the K −1
eigenvectors form the columns of V ∈RN×(K−1). We perform K-means clustering
on the rows of V and get the ﬁnal clustering. Algorithm 2 shows the complete
Note that K-means is only one of many possible discretization techniques that
can derive a K-way partition from the relaxed indicator matrix D−1/2V ∗. Due to
1 Here we assume the trivial solution, the eigenvector with all 1’s, has been excluded.
Xiang Wang et al.
Algorithm 2: Constrained Spectral Clustering for K-way Partition
Input: Aﬃnity matrix A, constraint matrix Q, β, K;
Output: The cluster assignment indicator u∗;
j=1 Aij, D ←diag(PN
2 ¯L ←I −D−1/2AD−1/2, ¯Q ←D−1/2QD−1/2;
3 λmax ←the largest eigenvalue of ¯Q;
4 if β ≥λK−1vol then
return u∗= ∅;
Solve the generalized eigenvalue system in Eq.(13);
Remove eigenvectors associated with non-positive eigenvalues and normalize the
rest by v ←
V ∗←argminV ∈RN×(K−1) trace(V T ¯LV ), where the columns of V are a subset of
the feasible eigenvectors generated in the previous step;
return u∗←kmeans(D−1/2V ∗, K);
the orthogonality of the eigenvectors, they can be independently discretized ﬁrst,
e.g. we can replace Step 11 of Algorithm 2 with:
u∗←kmeans(sign(D−1/2V ∗), K).
This additional step can help alleviate the inﬂuence of possible outliers on the
K-means step in some cases.
Moreover, notice that the feasible eigenvectors, which are the columns of V ∗,
are treated equally in Eq.(15). This may not be ideal in practice because these
candidate cuts are not equally favored by graph G, i.e. some of them have higher
costs than the other. Therefore, we can weight the columns of V ∗with the inverse
of their respective costs:
u∗←kmeans(sign(D−1/2V ∗(V ∗T ¯LV ∗)−1), K).
6.3 Using Constrained Spectral Clustering for Transfer Learning
The constrained spectral clustering framework naturally ﬁts into the scenario of
transfer learning between two graphs. Assume we have two graphs, a source graph
and a target graph, which share the same set of nodes but have diﬀerent sets of
edges (or edge weights). The goal is to transfer knowledge from the source graph
so that we can improve the cut on the target graph. The knowledge to transfer is
derived from the source graph in the form of soft constraints.
Speciﬁcally, let GS(V, ES) be the source graph, GT (V, ET ) the target graph. AS
and AT are their respective aﬃnity matrices. Then AS can be considered as a constraint matrix with only ML constraints. It carries the structural knowledge from
the source graph, and we can transfer it to the target graph using our constrained
spectral clustering formulation:
v∈RN vT ¯LT v, s.t. vT ASv ≥α, vT v = vol, v ̸= D1/2
On Constrained Spectral Clustering and Its Applications
α is now the lower bound of how much knowledge from the source graph must be
enforced on the target graph. To solution to this is similar to Eq.(13):
¯LT v = λ( ¯AS −
vol(GT )I)v
Note that since the largest eigenvalue of ¯
AS corresponds to a trivial cut, in practice
we should set the threshold such that β < λ1vol, λ1 to be the second largest
eigenvalue of ¯AS. This will guarantee a feasible eigenvector that is non-trivial.
7 Testing and Innovative Uses of Our Work
We begin with three sets of experiments to test our approach on standard spectral clustering data sets. We then show that since our approach can handle large
amounts of soft constraints in a ﬂexible fashion, this opens up two innovative uses
of our work: encoding multiple metrics for translated document clustering and
transfer learning for fMRI analysis.
We aim to answer the following questions with the empirical study:
– Can our algorithm eﬀectively incorporate side information and generate semantically meaningful partitions?
– Does our algorithm converge to the underlying ground truth partition as more
constraints are provided?
– How does our algorithm perform on real-world datasets, as evaluated against
ground truth labeling, with comparison to existing techniques?
– How well does our algorithm handle soft constraints?
– How well does our algorithm handle large amounts of constraints?
Recall that in Section 1 we listed four diﬀerent types of side information:
explicit pairwise constraints, partial labeling, alternative metrics, and transfer of
knowledge. The empirical results presented in this section are arranged accordingly.
All but one (the fMRI scans) datasets used in our experiments are publicly
available online. We implemented our algorithm in MATLAB, which is available
online at or by contacting the authors.
7.1 Explicit Pairwise Constraints: Image Segmentation
We demonstrate the eﬀectiveness of our algorithm for image segmentation using
explicit pairwise constraints assigned by users.
We choose the image segmentation application for several reasons: 1) it is one
of the applications where spectral clustering signiﬁcantly outperforms other clustering techniques, e.g. K-means; 2) the results of image segmentation can be easily
interpreted and evaluated by human; 3) instead of generating random constraints,
we can provide semantically meaningful constraints to see if the constrained partition conforms to our expectation.
The images we used were chosen from the Berkeley Segmentation Dataset and
Benchmark ). The original images are 480 ×320 grayscale images in jpeg format. For eﬃciency consideration, we compressed them to 10% of
the original size, which is 48 × 32 pixels, as shown in Fig. 5(a) and 6(a). Then
Xiang Wang et al.
(a) Original image
(b) No constraints
(c) Constraint Set 1
(d) Constraint Set 2
Fig. 5 Segmentation of the elephant image. The images are reconstructed based on the relaxed
cluster indicator u∗. Pixels that are closer to the red end of the spectrum belong to one segment
and blue the other. The labeled pixels are as bounded by the black and white rectangles.
(a) Original image
(b) No constraints
(c) Constraint Set 1
(d) Constraint Set 2
Fig. 6 Segmentation of the face image.The images are reconstructed based on the relaxed
cluster indicator u∗. Pixels that are closer to the red end of the spectrum belong to one segment
and blue the other. The labeled pixels are as bounded by the black and white rectangles.
aﬃnity matrix of the image was computed using the RBF kernel, based on both
the positions and the grayscale values of the pixels. As a baseline, we used unconstrained spectral clustering ) to generate a 2-segmentation
of the image. Then we introduced diﬀerent sets of constraints to see if they can
generate expected segmentation. Note that the results of image segmentation vary
with the number of segments. To save us from the complications of parameter tuning, which is irrelevant to the contribution of this work, we always set the number
of segments to be 2.
The results are shown in Fig. 5 and 6. To visualize the resultant segmentation,
we reconstructed the image using the entry values in the relaxed cluster indicator
On Constrained Spectral Clustering and Its Applications
vector u∗. In Fig. 5(b), the unconstrained spectral clustering partitioned the elephant image into two parts: the sky (red pixels) and the two elephants and the
ground (blue pixels). This is not satisfying in the sense that it failed to isolate the
elephants from the background (the sky and the ground). To correct this, we introduced constraints by labeling two 5×5 blocks to be 1 (as bounded by the black
rectangles in Fig. 5(c)): one at the upper-right corner of the image (the sky) and
the other at the lower-right corner (the ground); we also labeled two 5 × 5 blocks
on the heads of the two elephants to be −1 (as bounded by the white rectangles in
Fig. 5(c)). To generate the constraint matrix Q, a ML was added between every
pair of pixels with the same label and a CL was added between every pair of pixels
with diﬀerent labels. The parameter β was set to
β = λmax × vol × (0.5 + 0.4 × # of constraints
where λmax is the largest eigenvalue of ¯Q. In this way, β is always between
0.5λmaxvol and 0.9λmaxvol, and it will gradually increase as the number of constraints increases. From Fig. 5(c) we can see that with the help of user supervision,
our method successfully isolated the two elephants (blue) from the background,
which is the sky and the ground (red). Note that our method achieved this with
very simple labeling: four squared blocks.
To show the ﬂexibility of our method, we tried a diﬀerent set of constraints on
the same elephant image with the same parameter settings. This time we aimed
to separate the two elephants from each other, which is impossible in the unconstrained case because the two elephants are not only similar in color (grayscale
value) but also adjacent in space. Again we used two 5 × 5 blocks (as bounded by
the black and white rectangles in Fig. 5(d)), one on the head of the elephant on
the left, labeled to be 1, and the other on the body of the elephant on the right,
labeled to be −1. As shown in Fig. 5(d), our method cut the image into two parts
with one elephant on the left (blue) and the other on the right (red), just like what
a human user would do.
Similarly, we applied our method on a human face image as shown in Fig. 6(a).
The unconstrained spectral clustering failed to isolate the human face from the
background (Fig. 6(b)). This is because the tall hat breaks the spatial continuity
between the left side of the background and the right side. Then we labeled two
5 × 3 blocks to be in the same class, one on each side of the background. As we
intended, our method assigned the background of both sides into the same cluster
and thus isolated the human face with his tall hat from the background(Fig. 6(c)).
Again, this was achieved simply by labeling two blocks in the image, which covered
about 3% of all pixels. Alternatively, if we labeled a 5 × 5 block in the hat to be
1, and a 5 × 5 block in the face to be −1, the resultant clustering will isolate the
hat from the rest of the image (Fig. 6(d)).
7.2 Explicit Pairwise Constraints: The Double Moon Dataset
We further examine the behavior of our algorithm on a synthetic dataset using
explicit constraints that are derived from underlying ground truth.
We claim that our formulation is a natural extension to spectral clustering. The
question to ask then is whether the output of our algorithm converges to that of
Xiang Wang et al.
(a) A Double Moon sample and its Ncut
Number of Constraints
Adjusted Rand Index
(b) The convergence of our algorithm
Fig. 7 The convergence of our algorithm on 10 random samples of the Double Moon distribution.
spectral clustering. More speciﬁcally, consider the ground truth partition deﬁned
by performing spectral clustering on an ideal distribution. We draw an imperfect
sample from the distribution, on which spectral clustering is unable to ﬁnd the
ground truth partition. Then we perform our algorithm on this imperfect sample.
As more and more constraints are provided, we want to know whether or not the
partition found by our algorithm would converge to the ground truth partition.
To answer the question, we used the Double Moon distribution. As shown in
Fig. 1, spectral clustering is able to ﬁnd the two moons when the sample is dense
enough. In Fig. 7(a), we generated an under-sampled instance of the distribution
with 100 data points, on which unconstrained spectral clustering could no longer
ﬁnd the ground truth partition. Then we performed our algorithm on this imperfect sample, and compared the partition found by our algorithm to the ground
truth partition in terms of adjusted Rand index ).
ARI indicates how well a given partition conform to the ground truth: 0 means
the given partition is no better than a random assignment; 1 means the given partition matches the ground truth exactly. For each random sample, we generated
50 random sets of constraints and recorded the average ARI. We repeated the
process on 10 diﬀerent random samples of the same size and reported the results
in Fig. 7(b). We can see that our algorithm consistently converge to the ground
truth result as more constraints are provided. Notice that there is performance
drop when an extreme small number of constraints are provided (less than 10),
which is expected because such small number of constraints are insuﬃcient to hint
a better partition, and consequentially lead to random perturbation to the results.
As more constraints were provided, the results were quickly stabilized.
To illustrate the robustness of the our approach, we created a Double Moon
sample with uniform background noise, as shown in Fig. 8. Although the sample
is dense enough (600 data instances in total), spectral clustering fails to ﬁnd the
correctly identify the two moons, due to the inﬂuence of background noise (100
data instances). However, with 20 constraints, our algorithm is able to recover the
two moons in spite of the background noise.
On Constrained Spectral Clustering and Its Applications
(a) Spectral Clustering
(b) Constrained Spectral Clustering
Fig. 8 The partition of a noisy Double Moon sample.
Table 2 The UCI benchmarks
#Instances
#Attributes
Ionosphere
7.3 Constraints from Partial Labeling: Clustering the UCI Benchmarks
Next we evaluate the performance of our algorithm by clustering the UCI benchmark datasets ) with constraints derived from ground
truth labeling.
We chose six diﬀerent datasets with class label information, namely Hepatitis, Iris, Wine, Glass, Ionosphere and Breast Cancer Wisconsin (Diagnostic). We
performed 2-way clustering simply by partitioning the optimal cluster indicator
according to the sign: positive entries to one cluster and negative the other. We
removed the setosa class from the Iris data set, which is the class that is known
to be well-separately from the other two. For the same reason we removed Class
3 from the Wine data set, which is well-separated from the other two. We also
removed data instances with missing values. The statistics of the data sets after
preprocessing are listed in Table 2.
For each data set, we computed the aﬃnity matrix using the RBF kernel. To
generate constraints, we randomly selected pairs of nodes that the unconstrained
spectral clustering wrongly partitioned, and ﬁll in the correct relation in Q according to ground truth labels. The quality of the clustering results was measured by
adjusted Rand index. Since the constraints are guaranteed to be correct, we set
the threshold β such that there will be only one feasible eigenvector, i.e. the one
that best conforms to the constraint matrix Q.
In addition to comparing our algorithm (CSP) to unconstrained spectral clustering, we implemented two state-of-the-art techniques:
– Spectral Learning (SL) ) modiﬁes the aﬃnity matrix of
the original graph directly: Aij is set to 1 if there is a ML between node i and
j, 0 for CL.
Xiang Wang et al.
– Semi-Supervised Kernel K-means (SSKK) ) adds penalties
to the aﬃnity matrix based on the given constraints, and then performs kernel
K-means on the new kernel to ﬁnd the partition.
We also tried the algorithm proposed by Yu and Shi , which encodes partial grouping information as a projection matrix, the subspace trick proposed by De Bie et al , and the aﬃnity propagation algorithm proposed by
Lu and Carreira-Perpi˜n´an . However, we were not able to use these algorithms to achieve better results than SL and SSKK, hence their results are not
reported. Xu et al proposed a variation of SL, where the constraints are
encoded in the same way, but instead of the normalized graph Laplacian, they
suggested to use the random walk matrix. We performed their algorithm on the
UCI datasets, which produced largely identical results to that of SL.
We report the adjusted Rand index against the number of constraints used
(ranging from 50 to 500) so that we can see how the quality of clustering varies
when more constraints are provided. At each stop, we randomly generated 100
sets of constraints. The mean, maximum and minimum ARI of the 100 random
trials are reported in Fig. 9. We also report the ratio of the constraints that were
satisﬁed by the constrained partition in Fig. 10. The observations are:
– Across all six datasets, our algorithm is able to eﬀectively utilize the constraints and improve over unconstrained spectral clustering (Baseline). On the
one hand, our algorithm can quickly improve the results with a small amount
of constraints. On the other hand, as more constraints are provided, the performance of our algorithm consistently increases and converges to the ground
truth partition (Fig. 9).
– Our algorithm outperforms the competitors by a large margin in terms of
ARI (Fig. 9). Since we have control over the lower-bounding threshold α, our
algorithm is able to satisfy almost all the given constraints (Fig. 10).
– The performance of our algorithm has signiﬁcantly smaller variance over different random constraint sets than its competitors (Fig. 9 and 10), and the
variance quickly diminishes as more constraints are provided. This suggests
that our algorithm would perform more consistently in practice.
– Our algorithm performs especially well on sparse graphs, i.e. Fig. 9(e)(f), where
the competitors suﬀer. The reason is that when the graph is too sparse, it implies many “free” cuts that are equally good to unconstrained spectral clustering. Even after introducing a small number of constraints, the modiﬁed graph
remains too sparse for SL and SSKK, which are unable to identify the ground
truth partition. In contrast, these free cuts are not equivalent when judged by
the constraint matrix Q of our algorithm, which can easily identify the one cut
that minimizes vT ¯Qv. As a result, our algorithm outperforms SL and SSKK
signiﬁcantly in this scenario.
7.4 Constraints from Alternative Metrics: The Reuters Multilingual Dataset
We test our algorithm using soft constraints derived from alternative metrics of
the same set of data instances.
We used the Reuters Multilingual dataset, ﬁrst introduced by Amini et al
 . Each time we randomly sampled 1000 documents which were originally
On Constrained Spectral Clustering and Its Applications
Number of Constraints
Adjusted Rand Index
(a) Hepatitis
Number of Constraints
Adjusted Rand Index
Number of Constraints
Adjusted Rand Index
Number of Constraints
Adjusted Rand Index
Number of Constraints
Adjusted Rand Index
(e) Ionosphere
Number of Constraints
Adjusted Rand Index
(f) Breast Cancer
Fig. 9 The performance of our algorithm (CSP) on six UCI datasets, with comparison to unconstrained spectral clustering (Baseline) and the Spectral Learning algorithm (SL). Adjusted
Rand index over 100 random trials is reported (mean, min, and max).
written in one language and then translated into four others, respectively. The
statistics of the dataset is listed in Table 3. These documents came with ground
truth labels that categorize them into six topics (K = 6). We constructed one
graph based on the original language, and another graph based on the translation. The aﬃnity matrix was the cosine similarity between the tf-idf vectors of
two documents. Then we used one of the two graphs as the constraint matrix Q,
whose entries can then be viewed as soft ML constraints. We enforce this constraint matrix to the other graph to see if it can help improve the clustering. We
Xiang Wang et al.
Number of Constraints
Ratio of Constraints Satisfied
(a) Hepatitis
Number of Constraints
Ratio of Constraints Satisfied
Number of Constraints
Ratio of Constraints Satisfied
Number of Constraints
Ratio of Constraints Satisfied
Number of Constraints
Ratio of Constraints Satisfied
(e) Ionosphere
Number of Constraints
Ratio of Constraints Satisfied
(f) Breast Cancer
Fig. 10 The ratio of constraints that are actually satisﬁed.
did not compare our algorithm to existing techniques because they are unable to
incorporate soft constraints.
As shown in Fig. 11, unconstrained spectral clustering performs better on the
original version than the translated versions, which is not surprising. If we use the
original version as the constraints and enforce that onto a translated version using
our algorithm, we yield a constrained clustering that is not only better than the
unconstrained clustering on the translated version, but also even better than the
unconstrained clustering on the original version. This indicates that our algorithm
is not merely a tradeoﬀbetween the original graph and the given constraints.
On Constrained Spectral Clustering and Its Applications
Table 3 The Reuters Multilingual dataset
#Documents
Adjusted Rand Index
Translation
Trans. → EN
EN → Trans.
(a) English Documents and Translations
Adjusted Rand Index
Translation
Trans. → FR
FR → Trans.
(b) French Documents and Translations
Fig. 11 The performance of our algorithm on Reuters Multilingual dataset.
Instead it is able to integrate the knowledge from the constraints into the original
graph and achieve a better partition.
7.5 Transfer of Knowledge: Resting-State fMRI Analysis
Finally we apply our algorithm to transfer learning on the resting-state fMRI data.
An fMRI scan of a person consists of a sequence of 3D images over time. We
can construct a graph from a given scan such that a node in the graph corresponds
to a voxel in the image, and the edge weight between two nodes is (the absolute
value of) the correlation between the two time sequences associated with the two
voxels. Previous work has shown that by applying spectral clustering to the restingstate fMRI we can ﬁnd the substructures in the brain that are periodically and
simultaneously activated over time in the resting state, which may indicate a
network associated with certain functions ).
One of the challenges of resting-state fMRI analysis is instability. Noise can be
easily introduced into the scan result, e.g. the subject moved his/her head during
the scan, the subject was not at resting state (actively thinking about things during
the scan), etc. Consequently, the result of spectral clustering becomes instable. If
we apply spectral clustering to two fMRI scans of the same person on two diﬀerent
days, the normalized min-cuts on the two diﬀerent scans are so diﬀerent that they
provide little insight into the brain activity of the subject (Fig. 12(a) and (b)). To
overcome this problem, we use our formulation to transfer knowledge from Scan 1
to Scan 2 and get a constrained cut, as shown in Fig. 12(c). This cut represents
what the two scans agree on. The pattern captured by Fig. 12(c) is actually the
default mode network (DMN), which is the network that is periodically activated at
resting state (Fig. 12(d) shows the idealized DMN as speciﬁed by domain experts).
To further illustrate the practicability of our approach, we transfer the idealized
DMN in Fig. 12(d) to a set of fMRI scans of elderly subjects. The dataset was
Xiang Wang et al.
(a) Ncut of Scan 1
(b) Ncut of Scan 2
(c) Constrained cut by transferring Scan 1
(d) An idealized default mode network
Fig. 12 Transfer learning on fMRI scans.
collected and processed within the research program of the University of California
at Davis Alzheimer’s Disease Center (UCD ADC). The subjects were categorized
into two groups: those diagnosed with cognitive syndrome (20 individuals) and
those without cognitive syndrome (11 individuals). For each individual scan, we
encode the idealized DMN into a constraint matrix (using the RBF kernel), and
enforce the constraints onto the original fMRI scan. We then compute the cost
of the constrained cut that is the most similar to the DMN. If the cost of the
constrained cut is high, it means there is great disagreement between the original
graph and the given constraints (the idealized DMN), and vice versa. In other
words, the cost of the constrained cut can be interpreted as the cost of transferring
the DMN to the particular fMRI scan.
In Fig. 13, we plot the costs of transferring the DMN to both subject groups.
We can clearly see that the costs of transferring the DMN to people without
cognitive syndrome tend to be lower than to people with cognitive syndrome. This
conforms well to the observation made in a recent study that the DMN is often
disrupted for people with the Alzheimer’s disease ).
8 Conclusion
In this work we proposed a principled and ﬂexible framework for constrained spectral clustering that can incorporate large amounts of both hard and soft con-
On Constrained Spectral Clustering and Its Applications
Cost of Transferring the DMN
individuals without cognitive syndrome
individuals with cognitive syndrome
Fig. 13 The costs of transferring the idealized default mode network to the fMRI scans of
two groups of elderly individuals.
straints. The ﬂexibility of our framework lends itself to the use of all types of
side information: pairwise constraints, partial labeling, alternative metrics, and
transfer learning. Our formulation is a natural extension to unconstrained spectral clustering and can be solved eﬃciently using generalized eigendecomposition.
We demonstrated the eﬀectiveness of our approach on a variety of datasets: the
synthetic Two-Moon dataset, image segmentation, the UCI benchmarks, the multilingual Reuters documents, and resting-state fMRI scans. The comparison to
existing techniques validated the advantage of our approach.
9 Acknowledgments
We gratefully acknowledge support of this research via ONR grants N00014-09-1-
0712 Automated Discovery and Explanation of Event Behavior, N00014-11-1-0108
Guided Learning in Dynamic Environments and NSF Grant NSF IIS-0801528
Knowledge Enhanced Clustering.