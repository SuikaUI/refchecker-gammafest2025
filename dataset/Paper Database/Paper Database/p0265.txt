Scatter Component Analysis: A Uniﬁed Framework
for Domain Adaptation and Domain Generalization
Muhammad Ghifary, David Balduzzi, W. Bastiaan Kleijn, and Mengjie Zhang
Victoria University of Wellington
{muhammad.ghifary,bastiaan.kleijn,mengjie.zhang}@ecs.vuw.ac.nz, 
Abstract—This paper addresses classiﬁcation tasks on a particular target domain in which labeled training data are only available from
source domains different from (but related to) the target. Two closely related frameworks, domain adaptation and domain generalization, are
concerned with such tasks, where the only difference between those frameworks is the availability of the unlabeled target data: domain
adaptation can leverage unlabeled target information, while domain generalization cannot. We propose Scatter Component Analyis (SCA), a
fast representation learning algorithm that can be applied to both domain adaptation and domain generalization. SCA is based on a simple
geometrical measure, i.e., scatter, which operates on reproducing kernel Hilbert space. SCA ﬁnds a representation that trades between
maximizing the separability of classes, minimizing the mismatch between domains, and maximizing the separability of data; each of which is
quantiﬁed through scatter. The optimization problem of SCA can be reduced to a generalized eigenvalue problem, which results in a fast and
exact solution. Comprehensive experiments on benchmark cross-domain object recognition datasets verify that SCA performs much faster
than several state-of-the-art algorithms and also provides state-of-the-art classiﬁcation accuracy in both domain adaptation and domain
generalization. We also show that scatter can be used to establish a theoretical generalization bound in the case of domain adaptation.
Index Terms—Domain adaptation, domain generalization, feature learning, kernel methods, scatter, object recognition.
INTRODUCTION
Supervised learning is perhaps the most popular task in machine
learning and has recently achieved dramatic successes in many
applications such as object recognition , , object detection ,
speech recognition , and machine translation . These successes
derive in large part from the availability of massive labeled datasets
such as PASCAL VOC2007 and ImageNet . Unfortunately,
obtaining labels is often a time-consuming and costly process that
requires human experts. Furthermore, the process of collecting samples is prone to dataset bias , , i.e., a learning algorithm
trained on a particular dataset generalizes poorly across datasets. In
object recognition, for example, training images may be collected
under speciﬁc conditions involving camera viewpoints, backgrounds,
lighting conditions, and object transformations. In such situations, the
classiﬁers obtained with learning algorithms operating on samples
from one dataset cannot be directly applied to other related datasets.
Developing learning algorithms that are robust to label scarcity and
dataset bias is therefore an important and compelling problem.
Domain adaptation and domain generalization have
been proposed to overcome the fore-mentioned issues. In this context,
a domain represents a probability distribution from which the samples
are drawn and is often equated with a dataset. The domain is
usually divided into two different types: the source domain and
the target domain, to distinguish between a domain with labeled
samples and a domain without labeled samples. These two domains
are related but different, which limits the applicability of standard
supervised learning models on the target domain. In particular, the
basic assumption in standard supervised learning that training and
test data come from the same distribution is violated.
The goal of domain adaptation is to produce good models on
a target domain, by training on labels from the source domain(s)
and leveraging unlabeled samples from the target domain as supplementary information during training. Domain adaptation has demonstrated signiﬁcant successes in various applications, such as sentiment
classiﬁcation , , visual object recognition , , ,
 , and WiFi localization .
Finally, the problem of domain generalization arises in situations
where unlabeled target samples are not available, but samples from
multiple source domains can be accessed. Examples of domain generalization applications are automatic gating of ﬂow cytometry ,
 and visual object recognition , , .
The main practical issue is that several state-of-the-art domain
adaptation and domain generalization algorithms for object recognition result in optimization problems that are inefﬁcient to solve ,
 , , . Therefore, they may not be suitable in situations
that require a real-time learning stage. Furthermore, although domain
adaptation and domain generalization are closely related problems,
domain adaptation algorithms cannot in general be applied directly
to domain generalization, since they rely on the availability of
(unlabeled) samples from the target domain. It is highly desirable
to develop algorithms that can be computed more efﬁciently, are
compatible with both domain adaptation and domain generalization,
and provides state-of-the-art performance.
Goals and Objectives
To address the fore-mentioned issues, we propose a fast uniﬁed
algorithm for reducing dataset bias that can be used for both domain
adaptation and domain generalization. The basic idea of our algorithm
is to learn representations as inputs to a classiﬁer that are invariant to
dataset bias. Intuitively, the learnt representations should incorporate
four requirements: (i) separate points with different labels and (ii)
separate the data as a whole (high variance), whilst (iii) not separating
points sharing a label and (iv) reducing mismatch between the two or
more domains. The main contributions of this paper are as follows:
• The ﬁrst contribution is scatter, a simple geometric function that
quantiﬁes the mean squared distance of a distribution from its
centroid. We show that the above four requirements can be encoded
through scatter and establish the relationship with Linear DisarXiv:1510.04373v2 [cs.CV] 26 Jul 2016
criminant Analysis , Principal Component Analysis, Maximum
Mean Discrepancy and Distributional Variance .
• The second contribution is a fast scatter-based feature learning
algorithm that can be applied to both domain adaptation and domain generalization problems, Scatter Component Analysis (SCA),
see Algorithm 1. To the best of our knowledge, SCA is the
ﬁrst multi-purpose algorithm applicable across a range of domain
adaptation and generalization tasks. The SCA optimization reduces
to a generalized eigenproblem that admits a fast and exact solution
on par with Kernel PCA in terms of time complexity.
• The third contribution is the derivation of a theoretical bound for
SCA in the case of domain adaptation. Our theoretical analysis
shows that domain scatter controls the generalization performance
of SCA. We demonstrate that domain scatter controls the discrepancy distance under certain conditions. The discrepancy distance
has previously been shown to control the generalization performance of domain adaptation algorithms .
We performed extensive experiments to evaluate the performance
of SCA against a large suite of alternatives in both domain adaptation
and domain generalization settings. We found that SCA performs
considerably faster than the prior state-of-the-art across a range of
visual object cross-domain recognition, with competitive or better
performance in terms of accuracy.
Organization of the Paper
This paper is organized as follows. Section 2 describes the problem
deﬁnitions and reviews existing work on domain adaptation and
domain generalization. Sections 3 and 4 describes our proposed
tool and also the corresponding feature learning algorithm, Scatter
Component Analysis (SCA). The theoretical domain adaptation bound
for SCA is then presented in Section 5. Comprehensive evaluation
results and analyses are provided in Sections 6 and 7. Finally, Section
8 concludes the paper.
BACKGROUND AND LITERATURE REVIEW
This section establishes the basic deﬁnitions of domains, domain
adaptation, and domain generalization. It then reviews existing work
in domain adaptation and domain generalization, particularly in the
area of computer vision and object recognition.
A domain is a probability distribution PXY on X × Y, where
X and Y are the input and label spaces respectively. For the
sake of simplicity, we equate PXY
with P. The terms domain
and distribution are used interchangeably throughout the paper. Let
S = {xi, yi}n
i=1 ∼P be an i.i.d. sample from a domain. It is
convenient to use the notation ˆP for the corresponding empirical
distribution ˆP(x, y) =
i=1 δ(xi,yi)(x, y), where δ is the Dirac
delta. We deﬁne domain adaptation and domain generalization as
Deﬁnition 1 (Domain Adaptation). Let Ps and Pt be a source
and target domain respectively, where Ps ̸= Pt. Denote by Ss =
i=1 ∼Ps and St
X samples drawn from
both domains. The task of domain adaptation is to learn a good
labeling function fPt : X →Y given Ss and St
u as the training
Deﬁnition 2 (Domain Generalization). Let ∆= {P1, . . . , Pm} be
a set of m source domains and Pt /∈∆be a target domain. Denote
by Sd = {xd
i=1 ∼Pd samples drawn from m source domains.
The task of domain generalization is to learn a labeling function
fPt : X →Y given Sd, ∀d = 1, ..., m as the training examples.
It is instructive to compare these two related deﬁnitions. The main
difference between domain adaptation and domain generalization is
on the availability of the unlabeled target samples. Both have the
same goal: learning a labeling function f : X →Y that performs
well on the target domain. In practice, domain generalization requires
m > 1 to work well although m = 1 might not violate Deﬁnition 2.
Note that domain generalization can be exactly reduced to domain
adaptation if m = 2 and Pt
Domain adaptation and domain generalization have recently attracted great interest in machine learning. We present a review of
recent literature that is organized into two parts: i) domain adaptation
and ii) domain generalization.
Domain Adaptation
Earlier studies on domain adaptation focused on natural language
processing, see, e.g., and references therein. Domain adaptation
has gained increasing attention in computer vision for solving dataset
bias in object recognition , , , , , and object
detection . The reader is encouraged to consult the recent survey
in visual domain adaptation for a more comprehensive review.
We classify domain adaptation algorithms into three categories: i) the
classiﬁer adaptation approach, ii) the selection/reweighting approach,
and iii) the feature transformation-based approach.
The classiﬁer adaptation approach aims to learn a good, adaptive
classiﬁer on a target domain by leveraging knowledge from source
or auxiliary domains , , , , . Adaptive Support
Vector Machines (A-SVMs) utilize auxiliary classiﬁers to adapt
a primary classiﬁer that performs well on a target domain, where
the optimization criterion is similar to standard SVMs. The Domain
Adaptation Machine (DAM) employs both a domain-dependent
regularizer based on a smoothness assumption and a sparsity regularizer in Least-Squares SVMs . Recently, a multi-instance learning
based classiﬁer for action and event recognition, trained on weakly
labeled web data, was proposed .
The reweighting/selection approach reduces sample bias by
reweighting or selecting source instances that are ‘close’ to target
instances – selection can be considered as the ‘hard’ version of
reweighting. The basic idea has been studied under the name of
covariate shift . Gong et al. applied a convex optimization
strategy to select some source images that are maximally similar to
the target images according to Maximum Mean Discrepancy –
referred to as landmarks. The landmarks are then used to construct
multiple auxiliary tasks as a basis for composing domain-invariant
features. Transfer Joint Matching (TJM) uses a reweighting
strategy as a regularizer based on ℓ2,1-norm structured sparsity on
the source subspace bases.
The feature transformation-based approach is perhaps the most
popular approach in domain adaptation. Daume III proposed a
simple feature augmentation method by replicating the source and
target data, both are in Rd, as well as zero-padding such that the
resulting features are in R3d. Li et al. extended the method for the
case of heterogeneous features, i.e., source and target features have
different dimensionality, by introducing a common subspace learnt
via the standard SVM formulation. A subspace learning-based algorithm, Transfer Component Analysis (TCA) and its semi-supervised
version SSTCA , utilizes the Maximum Mean Discrepancy
(MMD) to minimize dataset bias in WiFi localization and text
classiﬁcation applications. Metric learning-based domain adaptation
approaches have been proposed , , which were early studies
in object recognition on the Ofﬁce dataset. The idea of extracting
‘intermediate features’ to minimize dataset bias by projecting data
onto multiple intermediate subspaces was also considered. Sampling
Geodesic Flow (SGF) and Geodesic Flow Kernel (GFK) 
generate multiple subspaces via an interpolation between the source
and the target subspace on a Grassmann manifold – a point on the
manifold is a subspace. Subspace Alignment (SA) transforms
a source PCA subspace into a new subspace that is well-aligned
to a target PCA subspace without requiring intermediate subspaces.
A recent method called Correlation Alignment (CORAL) facilitates
adaptive features by aligning the source and target covariance matrices . Other subspace learning-based methods such as Transfer
Sparse Coding (TSC) and Domain Invariant Projection (DIP)
 make use of MMD, following TCA, to match the source and
target distributions in the feature space. One of the methods proposed
in follows a similar intuition by using Hellinger distance as an
alternative to MMD. Algorithms based on hierarchical non-linear
features or deep learning are also capable of producing powerful
domain adaptive features , , , , , .
Several works have addressed Probably Approximately Correct
theoretical bounds for domain adaptation. Ben-David et al. 
presented the ﬁrst theoretical analysis of domain adaptation, that is,
an adaptation bound in classiﬁcation tasks based on the dA-distance
 . Mansour et al. extended this work in several ways built
on Rademacher complexity and the discrepancy distance, as
an alternative to dA-distance. In this paper, we provide a domain
adaptation bound for our new algorithm based on the latter analysis.
Domain Generalization
Domain generalization is a newer line of research than domain
adaptation. Blanchard et al. ﬁrst studied this issue and proposed
an augmented SVM that encodes empirical marginal distributions into
the kernel for solving automatic gating of ﬂow cytometry. A feature
projection-based algorithm, Domain-Invariant Component Analysis
(DICA) , was then introduced to solve the same problem.
DICA extends Kernel PCA by incorporating the distributional
variance to reduce the dissimilarity across domains and the central
subspace to capture the functional relationship between the
features and their corresponding labels.
Domain generalization algorithms also have been used in object
recognition. Khosla et al. proposed a multi-task max-margin
classiﬁer, which we refer to as Undo-Bias, that explicitly encodes
dataset-speciﬁc biases in feature space. These biases are used to push
the dataset-speciﬁc weights to be similar to the global weights. Fang
et al. developed Unbiased Metric Learning (UML) based on a
learning-to-rank framework. Validated on weakly-labeled web images, UML produces a less biased distance metric that provides good
object recognition performance. Xu et al. extended an exemplar-
SVM to domain generalization by adding a nuclear norm-based
regularizer that captures the likelihoods of all positive samples. The
proposed model is referred to as LRE-SVM that provides the state-ofthe-art performance. More recently, an autoencoder based algorithm
to extract domain-invariant features via multi-task learning has been
proposed .
Although both domain adaptation and domain generalization have
the same goal (reducing dataset bias), the approaches are generally
not compatible to each other – domain adaptation methods cannot
be directly applied to domain generalization or vice versa. To our
best knowledge, only LRE-SVM can be applied to both domain
adaptation and domain generalization. The domain generalization
algorithm formulation as in DICA, Undo-Bias, or UML typically does
not allow to take into account unlabeled data from the target domain.
Furthermore, several state-of-the-art domain adaptation and domain
generalization algorithms such as TJM and LRE-SVM, require the
solution of a computationally complex optimization that induces high
complexity in time. In this work, we establish a fast algorithm that
overcomes the above issues.
We work in a feature space that is a reproducing kernel Hilbert space
(RKHS) H. The main motivation is to transform original inputs onto
H, which is high or possibly inﬁnite dimensional space, with the
hope that the new features are linearly separable. The most important
property of RKHS is perhaps to allow a computationally feasible
transformation onto H by virtue of the kernel trick.
Deﬁnition 3 (Reproducing Kernel Hilbert Space). Let X be
an arbitrary set and H ⊂{f : X →R} a Hilbert space of
functions on X . Deﬁne the evaluation functional Lx : H →R by
Lx[h] := h(x), ∀h ∈H. Then H is a reproducing kernel Hilbert
space (RKHS) if the functional Lx is always bounded: i.e. for all
x ∈X there exists an λ > 0 such that
|Lx[h]| = |h(x)| ≤λ∥h∥H.
It follows that there is a function φ : X →H (referred to as the
canonical feature map) satisfying:
Lx[h] = ⟨h, φ(x)⟩= h(x)
for all h ∈H and x ∈X.
Consequently, for each t ∈X , one can write
⟨φ(t), φ(x)⟩=: κ(t, x).
The function κ : X × X →R is referred to as the reproducing
Expression (1) is the weakest condition that ensures the existence of
an inner product and also the ability to evaluate each function in H
at every point in the domain, while (2) provides more useful notion
in practice.
Before introducing scatter, it is convenient to ﬁrst represent
domains as points in RKHS using the mean map :
Deﬁnition 4 (Mean map). Suppose that X is equipped with a kernel,
and that H is the corresponding RKHS with feature map φ : X →H.
Let ∆X denote the set of probability distributions on X . The mean
map takes distributions on X to points in H:
µ : ∆X →H : P 7→E
Geometrically, the mean map is the centroid of the image of the
distribution under φ. We deﬁne scatter as the variance of points in
the image around its centroid:
Deﬁnition 5 (Scatter). The scatter of distribution P on X relative to
Ψφ(P) := E
where ∥· ∥H is the norm on H.
The scatter of a domain cannot be computed directly; instead it is
estimated from observations. The scatter of a ﬁnite set of observations
{x1, . . . , xn} is computed with respect to the empirical distribution
bP(x) := 1
We provide a theorem that shows how the difference between the
true scatter and a ﬁnite sample estimate decreases with the sample
Theorem 1 (Scatter Bound). Suppose P is a true distribution over
all samples of size n and ˆP is its empirical distribution. Further
suppose that ∥φ(x)∥2 ≤M for all x ∈X . Then, with probability
Ψφ(P) −Ψφ(ˆP)
Proof. See Supplementary material.
Note that the right hand site of the bound is smaller for lower values
of M and higher values of n. Furthermore, if κ is in the form of
Gaussian kernel, the bound only depends on n since M = 1.
We provide an example for later use. If the input space is a vector
space and φ is the identity then it follows immediately that
Lemma 2 (Total variance as scatter). The scatter of the set of pdimensional points (in a matrix form) X = [x1, . . . , xn]⊤∈Rn×p
relative to the identity map φ(x) := x, is the total variance:
n Tr(X −¯X)⊤(X −¯X) = Tr Cov(X),
where Tr(·) denotes the trace operation and ¯X = [¯x, . . . , ¯x]⊤with
We utilize scatter to formulate a feature learning algorithm
referred to as Scatter Component Analysis (SCA). Speciﬁcally, scatter quantiﬁes requirements needed in SCA to develop an effective
solution for both domain adaptation and generalization, which will
be described in the next section.
SCATTER COMPONENT ANALYSIS (SCA)
SCA aims to efﬁciently learn a representation that improves both
domain adaptation and domain generalization. The strategy is to
convert the observations into a conﬁguration of points in feature
space such that the domain mismatch is reduced. SCA then ﬁnds
a representation of the problem (that is, a linear transformation
of feature space) for which (i) the source and target domains are
similar and (ii) elements with the same label are similar; whereas
(iii) elements with different labels are well separated and (iv) the
variance of the whole data is maximized. Each requirement can be
quantiﬁed through scatter that leads to four consequences: (i) domain
scatter, (ii) between-class scatter, (iii) within-class scatter, and (iv)
total scatter.
The remainder of the subsection deﬁnes the above four scatter
quantities in more detail (along the way relating the terms to principal
component analysis, the maximum mean discrepancy, and Fisher’s
linear discriminant) and describes the SCA’s learning algorithm. We
will also see that SCA can be easily switched to either domain
adaptation or domain generalization by modifying the conﬁguration
of the input domains.
Total Scatter
Given m domains P1
X, . . . , Pm
X on X , we deﬁne the total domain as
the mean ¯PX = 1
X. The total scatter is then deﬁned by
total scatter = Ψφ (¯PX) .
It is worth emphasizing that this deﬁnition is general in the sense that
it covers both domain adaptation (m = 2 and one of them is the
target domain) and domain generalization (m > 2).
Total scatter is estimated from data as follows. Let X =
[x1, ..., xn]⊤∈Rn×p be the matrix of unlabeled samples from all
m domains (n = Pm
d=1 nd, where nd is the number of examples
in the d-th domain). Given a feature map φ : Rp →H corresponding to kernel κ, deﬁne a set of functions arranged in a column
vector Φ = [φ(x1), ..., φ(xn)]⊤. After centering {φ(xi)}n
subtracting the mean, the covariance matrix is Cov(Φ) = 1
By Lemma 2,
= Tr Cov(Φ).
We are interested in the total scatter after applying a linear
transform to a ﬁnite relevant subspace W : H →Rk. To avoid
the direct computation of φ : X →H, which could be expensive
or undoable, we use the kernel trick. Let Z = ΦW ∈Rn×k be the
n transformed feature vectors and [K]ij = [ΦΦ⊤]ij = [κ(xi, xj)].
After ﬁxing B ∈Rn×k such that W = Φ⊤B, the total transformed
scatter is
 = Tr ( 1
We remark that, in our notation, Kernel Principal Component Analysis (KPCA) corresponds to the optimization problem
Domain Scatter
Suppose we are given m domains P1
X, . . . , Pm
X on X . We can think
of the set {µP1
X, . . . , µPm
X } ⊂H as a sample from some latent
distribution on domains. Equipping the sample with the empirical
distribution and computing scatter relative to the identity map on H
yields domain scatter:
X, . . . , µPm
where ¯µ =
i=1 µPi. Note that domain scatter coincides with
the distributional variance introduced in . Domain scatter is also
closely related to the Maximum Mean Discrepancy (MMD), used in
some domain adaptation algorithms , , .
Deﬁnition 6. Let F be a set of functions f : X →R. The maximum
mean discrepancy between domains P and Q is
MMDF[P, Q] := sup
P [f(x)] −E
The MMD measures the extent to which two domains resemble
one another from the perspective of function class F. The following
theorem relates domain scatter to MMD given two domains, where
the case of interest is bounded linear functions on the feature space:
Lemma 3 (Scatter recovers MMD). The scatter of domains P and
Q on X is their (squared) maximum mean discrepancy:
Ψ({µP, µQ}) = 1
where F = {f : X →R | f is linear and ∥f∥F ≤1}.
In particular, if φ is induced by a characteristic kernel on X then
Ψ({µP, µQ}) = 0 if and only if P = Q.
Proof. Note that the theorem involves two levels of probability
distributions: (i) the domains P and Q on X , and (ii) the empirical
distribution on F that assigns probability p =
2 to the points µP
and µQ, and p = 0 to everything else. Let ¯µ = 1
2(µP + µQ). By
Deﬁnition 5,
Ψ({µP, µQ}) = 1
2∥¯µ −µP∥2
2∥¯µ −µQ∥2
4∥µP −µQ∥2
The result follows from Theorem 2.2 of .
Lemma 3 also tells that the domain scatter is a valid metric if the
kernel on X is characteristic . The most important example of a
characteristic kernel is the Gaussian RBF kernel, which is the kernel
used in the theoretical results and experiments below. We also remark
that MMD can be estimated from observed data with bound provided
in , which is analogous to Theorem 1.
Domain scatter in a transformed feature space in Rk is estimated
as follows. Suppose we have m samples Sd
Recall that Z = ΦW = K⊤B, where Z = [z1, . . . , zn]⊤contains
projected samples from all domains: zi = W⊤φ(xi) and
is the corresponding kernel matrix, where [Kkl]ij = κ(xk
some algebra, the domain scatter is
 = Tr(B⊤KLKB),
where L ∈Rn×n is a coefﬁcient matrix with [Lkl]ij =
k = l, and −
m2nknl otherwise.
Class Scatter
For each class k ∈{1, . . . , C}, let Pl
X|k denote the conditional
distribution on X induced by the total labeled domain Pl
XY when Y = k (the number of labeled domains q does
not necessarily equal to the number of source domains m). We deﬁne
the within-class scatter and between-class scatter as
within-class-k scatter
X|k=1, . . . , µPl
between-class scatter
The class scatters are estimated as follows. Let Sw
xj∈k denote the nk-tuple of source samples in class k.
The centroid of Sw
xi∈k φ(xi). Furthermore, let
Sb = (µ1, . . . , µ|C|) denote the n-tuple of all class centroids where
centroid k appears nk times in Sb. The centroid of Sb is then the
centroid of the source domain: ¯µs = 1
k=1 nkµk. It follows that
the within-class scatter is
(φ(xjk) −µk) (φ(xjk) −µk)⊤
and the between-class scatter is
nk(µk −¯µ)(µk −¯µ)⊤
The right-hand sides of the above equations are the classical deﬁnitions of within- and between- class scatter . The classical linear
discriminant is thus a ratio of scatters
Fisher’s linear discriminant =
Maximizing Fisher’s linear discriminant increases the separation of
the data points with respect to the class clusters.
Given a linear transformation W : H →Rk, it follows from
Lemma 2 that the class scatters in the projected feature space ˜H are
Tr(W⊤Cov(Sb)W)
Tr(B⊤PsB),
Tr(W⊤Cov(Sw
Tr(B⊤QsB),
nk(mk −¯m)(mk −¯m)⊤,
j=1 κ(·, xjk), ¯m = 1
j=1 κ(·, xj), [Kk]ij =
[κ(xik, xjk)], and the centering matrix Hk = Ink −
where Ink denotes a nk ×nk identity matrix and 1nk ∈Rnk denotes
a vector of ones.
The Algorithm
Here we formulate the SCA’s learning algorithm by incorporating the
above four quantities. The objective of SCA is to seek a representation
by solving an optimization problem in the form of the following
expression
sup {total scatter} + {between-class scatter}
{domain scatter} + {within-class scatter}.
Using (5), (9), (11), and (12), the above expression can then be
speciﬁed in more detail:
Maximizing the numerator encourages SCA to preserve the total
variability of the data and the separability of classes. Minimizing
the denominator encourages SCA to ﬁnd a representation for which
the source and target domains are similar, and source samples sharing
a label are similar.
Objective function. We reformulate (16) in three ways. First,
we express it in terms of linear algebra. Second, we insert hyperparameters that control the trade-off between scatters as one scatter
quantity could be more important than others in a particular case.
Third, we impose the constraint that W⊤W = B⊤KB is small to
control the scale of the solution.
Explicitly, SCA ﬁnds a projection matrix B = [b1, b2, ..., bk]
that solves the constrained optimization
 B⊤( (1−β)
 B⊤(δKLK + Q + K)B
and β, δ > 0 are the trade-off parameters controlling the total and
between-class scatter, and domain scatter respectively.
Observe that the above optimization is invariant to rescaling B 7→
αB. Therefore, optimization (17) can be rewritten as
 B⊤((1 −β)
 B⊤(δKLK + Q + K)B
which results in Lagrangian
J(B) = Tr(B⊤((1 −β)
KK + βP)B) −
Tr((B⊤(δKLK + Q + K)B −Ik)Λ).
To solve (17), set the ﬁrst derivative
= 0, inducing the
generalized eigenproblem
 δKLK + K + Q
where Λ = diag(λ1, ..., λk) are the k leading eigenvalues and B =
[b1, ..., bk] contains the corresponding eigenvectors.1 Algorithm 1
provides a complete summary of SCA.
1. In the implementation, a numerically more stable variant is obtained by using
(20) using δKLK + K + Q + ϵI, where ϵ > 0 is a ﬁxed small constant.
Algorithm 1 Scatter Component Analysis
• Sets of training datapoints Sd
i=1, ∀d = 1, . . . , m and
their corresponding matrices X =
X1; . . . ; Xm ∈Rn×p, where
1, . . . , xd
• Training labels yl = [y1
1, . . . , y1
n1, . . . , yq
1, . . . , yq
• Hyper-parameters β, δ > 0; kernel bandwidth σ;
• Number of subspace bases k;
1: Construct kernel matrix K from X, matrices L, P and Q based
on (8), (13), (14), and (18);
2: Apply the centering operation K ←K−1nK−K1n+1nK1n,
where n = Pm
d=1 nd and [1n]ij := 1
3: Obtain the transformation B∗and its corresponding eigenvalues
Λ by solving the generalized eigendecomposition problem in Eq.
(20) and selecting the k leading eigenvectors;
4: Target feature extraction: Let Su
u be the total training sample and St
u be a target sample (for domain
adaptation, St
u ⊂Su). Construct a kernel matrix [Kt]ij =
κ(xi, tj), ∀xi ∈Su, tj ∈St
u. The extracted features are given
by Zt = Kt⊤B∗Λ−1
• Optimal transformation matrix B∗∈Rn×k;
• Feature matrix Zt ∈Rnt×k.
Relation to other methods
SCA is closely related to a number of feature learning and domain
adaptation methods. To see this, let us observe Lagrangian (19).
Setting the hyper-parameters β = δ = 0 and Q = 0 in (19)
recovers KPCA. Setting β = 1 and δ = 0 recovers the Kernel
Fisher Discriminant (KFD) method . KFD with linear kernel is
equivalent to Fisher’s linear discriminant, which is the basis of a
domain adaptation method for object detection proposed in .
Setting β = 0 and Q = 0 (that is, ignoring class separation)
yields a new algorithm: unsupervised Scatter Component Analysis
(uSCA), which is closely related to TCA. The difference between
the two algorithms is that TCA constrains the total variance and
regularizes the transform, whereas uSCA trades-off the total variance
and constrains the transform (recall that W⊤W should be small)
motivated by Theorem 1. It turns out that uSCA consistently outperforms TCA in the case of domain adaptation, see Section 6.
Eliminating the term B⊤KB from the denominator in (17) from
uSCA yields TCA . The semi-supervised extension SSTCA of
TCA differs markedly from SCA. Instead of incorporating withinand between- class scatter into the objective function, SSTCA incorporates a term derived from the Hilbert-Schmidt Independence
Criterion that maximizes the dependence of the embedding on labels.
uSCA is essentially equivalent to unsupervised Domain Invariant
Component Analysis (uDICA) in the case of two domains . However, as for SSTCA, supervised DICA incorporates label-information
differently from SCA – via the notion of a central subspace. In
particular, supervised DICA requires that all data points are labeled,
and so it cannot be applied in our experiments.
Computational Complexity
Here we analyze the computation complexity of the SCA algorithm.
Suppose that we have m domains with n1, . . . , nm are the number of
samples for each domain (m > 2 covers the domain generalization
case). Denote the total number of samples by n = n1 +. . .+nm and
the number of leading eigenvectors by k ≪n. Computing the matrices K, L, P, and Q takes O(n2) (Line 1 at Algorithm 1). Hence,
the total complexity of SCA after solving the eigendecomposition
problem (Line 2) takes O(kn2), or quadratic in n. This complexity
is similar to that of KPCA and Transfer Component Analysis .
In comparison to Transfer Joint Matching (TJM) , the prior
state-of-the-art domain adaptation algorithm for object recognition,
TJM uses an alternating eigendecomposition procedure in which T
iterations are needed. Using our notation, the complexity of TJM is
O(Tkn2), i.e., TJM is T times slower than SCA.
Hyper-parameter Settings
Before reporting the detailed evaluation results, it is important to
explain how SCA hyper-parameters were tuned. The formulation of
SCA described in Section 4 has four hyper-parameters: 1) the choice
of the kernel, 2) the number of subspace bases k, 3) the betweenclass and total scatters trade-off β, and 4) the domain scatter δ,.
Tuning all those hyper-parameters using a standard strategy, e.g., a
grid-search, might be impractical due to two reasons. The ﬁrst is of
the computational complexity. The second, which is crucial, is that
cross-validating a large number of hyper-parameters may worsen the
generalization on the target domain, since labeled samples from the
target domain are not available.
Our strategy to deal with the issue is to reduce the number of
tunable hyper-parameters. For the kernel selection, we chose the RBF
kernel exp( −∥a−b∥2
), ∀a, b ∈X , where the kernel bandwidth σ
was set analytically to the median distance between samples in the
aggregate domain following ,
σ = median(∥a −b∥2
2), ∀a, b ∈Ss ∪St.
For domain adaptation, δ was ﬁxed at 1. Thus, only two hyperparameters remain tunable: k and β. For domain generalization,
β was set at 1, i.e., the total scatter was eliminated, and δ was
allowed to be tuned – the number of tunable hyper-parameters
remains unchanged. The conﬁguration is based on an empirical
observation that setting 0 < β < 1 is no better (if not worse) than
β = 1 in terms of both the cross-validation and test performance for
domain generalization cases. In all evaluations, we used 5-fold cross
validation using source labeled data to ﬁnd the optimal k and β. We
found that this strategy is sufﬁcient to produce good SCA models for
both domain adaptation and generalization cases.
ANALYSIS OF ADAPTATION PERFORMANCE
We derive a bound for domain adapation that shows how the MMD
controls generalization performance in the case of the squared loss
ℓ(y, y′) = (y −y′)2. Despite the widespread use of the MMD for
domain adaptation , , , , , to the best of our
knowledge, this is the ﬁrst generalization bound. The main idea is
to incorporate the MMD (that is, domain scatter) into the adaptation
bound proven for the discrepancy distance . A generalization
bound for domain generalization in terms of domain scatter is given
in , see remark 1.
Let Hyp := {h : X →Y} denote a hypothesis class of functions
from X to Y where X is a compact set. Given a loss function deﬁned
over pairs of labels ℓ: Y × Y →R+ and a distribution D over X ,
 h, h′ = Ex∼D[ℓ(h(x), h′(x))] denote the expected loss for
any two hypotheses h, h′ ∈Hyp. We consider the case where the
hypothesis set Hyp is a subset of an RKHS H.
We ﬁrst introduce discrepancy distance, discHyp(P, Q), which
measures the difference between two distributions P and Q.
Deﬁnition 7 (Discrepancy Distance ). Let Hyp ⊂{f : X →
Y} be a set of functions mapping from X to Y. The discrepancy
distance between two distributions P and Q over X is deﬁned by
disc(P, Q) =
LP(h, h′) −LQ(h, h′)
The discrepancy is symmetric and satisﬁes the triangle inequality,
but it does not deﬁne a distance in general: ∃P ̸= Q such that
discHyp(P, Q) = 0 .
If we assume that we have a universal kernel , , i.e. H =
C(X) as topological spaces, and the loss ℓis the squared loss 
then the discrepancy is a metric. The most important example of a
universal kernel is the Gaussian RBF kernel, which is the kernel used
in the experiments below.
The main step of the proof is to ﬁnd a relationship between
domain scatter and the discrepancy distance. We are able to do so in
the special case where the kernel is universal and the loss is the meansquare error. The main technical challenge is that the discrepancy
distance is quadratic in the hypotheses (involving terms of the form
h(x)2 and h(x)h′(x)) whereas the MMD is linear. We therefore need
to bound the effects of the multiplication operator:
Deﬁnition 8 (Multiplication Operator). Let C(X) be the space
of continuous functions on the compact set X equipped with the
supremum norm ∥· ∥∞. Given g ∈C(X), deﬁne the multiplication
operator as the bounded linear operator Mg : C(X) →C(X)
Mg(h)(x) = g(x)h(x).
Note that a general RKHS is not closed under the multiplication
operator . However, since the kernel is universal, it follows that H
is closed under multiplication since the space of continuous functions
C(X) is closed under multiplication. Moreover, we can deﬁne the
sup-norm ∥· ∥∞on H using its identiﬁcation with C(X).
The following Lemma upper bounds the norm of multiplication
operator, which will be useful to prove our main theorem.
Lemma 4. Given g, h ∈H, where H is equipped with a universal
kernel, it holds that ∥Mg(h)∥H = ∥g · h∥H ≤∥g∥∞· ∥f∥H.
Proof. Straightforward calculation. The Lemma requires a universal
kernel since ∥g · h∥H is only deﬁned if g · h ∈H.
We now show that the domain scatter of two distributions upperbounds the discrepancy distance.
Lemma 5 (Domain scatter bounds discrepancy). Let H be an
RKHS with a universal kernel. Suppose that ℓ(y, y′) = (y −y′)2 is
the square loss, and consider the hypothesis set
Hyp = {f ∈H : ∥f∥H ≤1 and ∥f∥∞≤r},
where r > 0 is a constant Let P and Q be two domains over X . Then
the following inequality holds:
discℓ(P, Q)
discrepancy
Ψφ({µP, µQ})
domain scatter
Proof. See Supplementary material.
Lemma 5 allows us to relate domain scatter to generalization
bounds for domain adaptation proven in . Before stating the
bounds, we introduce Rademacher complexity , which measures
the degree to which a class of functions can ﬁt random noise. This
measure is the basis of bounding the empirical loss and expected loss.
Deﬁnition 9 (Rademacher Complexity). Let G be a family of functions mapping from X × Y to [a, b] and S = (z1, ..., zn) ∈X × Y
be a ﬁxed sample of size n. The empirical Rademacher complexity of
G with respect to the sample S is
ˆRS(G) = E
where σ = (σ1, . . . , σn)⊤are Rademacher variables, with σis
independent uniform random variables taking values in {−1, +1}.
The Rademacher complexity over all samples of size n is
The supplementary material discusses how to associate a family
of functions to a loss function, and provides a useful Rademacher
bound. We now have all the ingredients to derive domain adaptation
bounds in terms of domain scatter.
Let fP and fQ be the true labeling functions on domain P and
Q respectively, and h∗
P := argminh∈Hyp LP(h, fP) and h∗
argminh∈Hyp LQ(h, fQ) be the minimizers. For a successful domain
adaptation, we shall assume that LP(h∗
Q) is small. The following
theorem provides a domain adaptation bound in terms of scatter
(recall that the MMD is a special case of scatter by Lemma 3).
Theorem 6 (Adaptation bounds with domain scatter). Let Hyp be
a family of functions mapping from X to R, SP
1, . . . , xt
1, . . . , xt
nt) ∼Q be a source and target sample
respectively. Let the rest of the assumptions be as in Lemma 5 and
Theorem 8 in the supplementary material. For any hypothesis h ∈
Hyp, with probability at least 1 −δ, the following adaptation bound
regret on target domain
LQ(h, fQ) −LQ(h∗
empirical loss
Rademacher complexity
sample size)
Ψφ({µQ, µP})
domain scatter
deviation of optimal solns
Proof. Fix h ∈Hyp. Since the square loss is symmetric and
obeys the triangle inequality, Theorem 8 in (see supplementary
material) implies that
LQ(h, fQ) −LQ(h∗
Q, fQ) ≤LP(h, h∗
P) + discℓ(Q, P)
The result then follows by Lemma 5 combined with the Rademacher
bound in the supplementary material.
It is instructive to compare Theorem 6 above with Theorem 9 in
 , which is the analog if we expand discl(Q, P) in (27) with its
empirical measure. It is also straightforward to rewrite the bound in
term of the empirical scatter Ψφ({µˆP, µˆQ}) by applying Theorem 1.
The signiﬁcance of Theorem 6 is twofold. First, it highlights that
the scatter Ψφ({µP, µQ}) controls the generalization performance
in domain adaptation. Second, the bound shows a direct connection
between scatter (also MMD) and the domain adaptation theory
proposed in . Note that the bound might not be useful for
practical purposes, since it is loose and pessimistic as they hold for
all hypotheses and all possible data distributions.
Remark 1 (The role of scatter in domain generalization). Theorem 5 of shows that the domain scatter (or, alternatively,
the distributional variance) is one of the key terms arising in a
generalization bound in the setting of domain generalization.
EXPERIMENT I : DOMAIN ADAPTATION
The ﬁrst set of experiments evaluated the domain adaptation performance of SCA on synthetic data and real-world object recognition
tasks. The synthetic data was designed to understand the behavior
of the learned features compared to other algorithms, whereas the
real-world images were utilized to verify the performance of SCA.
The experiments are divided into two parts. Section 6.1 visualizes
performance on synthetic data. Section 6.2 evaluates performance
on a range of cross-domain object recognition tasks with a standard
yet realistic hyper-parameter tuning. Some additional results with a
tuning protocol established in the literature are also reported in the
supplementary material for completeness.
Synthetic data
Figure 1 depicts synthetic data that consists of two dimensional data
points under three classes with six clusters. The data points in each
cluster were generated from a Gaussian distribution xc
i ∼N(µc, σc),
where µc and σc is the mean and standard deviation of the cth cluster. The RBF kernel k(a, b) = exp(−∥a−b∥2
) was used
for all algorithms. All tunable hyper-parameters were selected according to 1-nearest neighbor’s test accuracy. We compare features
extracted from Kernel Principal Component Analysis (KPCA), Semi-
Supervised Transfer Component Analysis (SSTCA) , Transfer
Joint Matching (TJM) , and SCA.
The top row of Figure 1 illustrates how the features extracted from
the MMD-based algorithms (SSTCA, TJM, and SCA) reduce the
domain mismatch. Red and blue colors indicate the source and target
domains, respectively. Good features for domain adaptation should
have a conﬁguration of which the red and blue colors are mixed. This
effect can be seen in features extracted from SSTCA, TJM, and SCA,
which indicates that the domain mismatch is successfully reduced in
the feature space. In classiﬁcation, domain adaptive features should
also have a certain level of class separability. The bottom row
highlights a major difference between SCA and the other algorithms
in terms of the class separability: the SCA features are more clustered
with respect to the classes, with more prominent gaps among clusters.
This suggests that it would be easier for a simple function to correctly
classify SCA features.
Real world object recognition
We summarize the complete domain adaptation results over a range
of cross-domain object recognition tasks. Several real-world image
datasets were utilized such as handwritten digits (MNIST and
USPS ) and general objects (MSRC , VOC2007 , Caltech-
256 , Ofﬁce ). Three cross-domain pairs were constructed
from these datasets: USPS+MNIST, MSRC+VOC2007, and Of-
ﬁce+Caltech.
Data Setup
The USPS+MNIST pair consists of raw images subsampled from
datasets of handwritten digits. MNIST contains 60,000 training
images and 10,000 test images of size 28 × 28. USPS has 7,291
training images and 2,007 test images of size 16 × 16 . The pair
was constructed by randomly sampling 1,800 images from USPS
and 2,000 images from MNIST. Images were uniformly rescaled to
size 16 × 16 and encoded into feature vectors representing the grayscale pixel values. Two SOURCE →TARGET classiﬁcation tasks were
constructed: USPS →MNIST and MNIST →USPS.
The MSRC+VOC2007 pair consist of 240-dimensional images
that share 6 object categories: “aeroplane”, “bicycle”,“bird”, “car”,
“cow”, and “sheep” taken from the MSRC and VOC2007 datasets.
The pair was constructed by selecting all 1,269 images in MSRC and
1,530 images in VOC2007. As in , features were extracted from
the raw pixels as follows. First, images were uniformly rescaled to be
256 pixels in length. Second, 128-dimensional dense SIFT (DSIFT)
features were extracted using the VLFeat open source package .
Finally, a 240-dimensional codebook was created using K-means
clustering to obtain the codewords.
The Ofﬁce+Caltech consists of 2,533 images of ten categories
(8 to 151 images per category per domain), that forms four domains: (A) AMAZON, (D) DSLR, (W) WEBCAM, and (C) CALTECH.
AMAZON images were acquired in a controlled environment with
studio lighting. DSLR consists of high resolution images captured
by a digital SLR camera in a home environment under natural
lighting. WEBCAM images were acquired in a similar environment
to DSLR, but with a low-resolution webcam. Finally, CALTECH
images were collected from Google Images . Taking all possible
source-target combinations yields 12 cross-domain datasets denoted
by A →W, A →D, A →C, . . . , C →D. We used two types
of extracted features from these datasets that are publicly available:
SURF-BoW2 and DeCAF63 . SURF-BoW features were
extracted using SURF and quantized into 800-bin histograms
with codebooks computed by K-means on a subset of AMAZON
images. The ﬁnal histograms were standardized to have zero mean
and unit standard deviation in each dimension. Deep Convolutional
Activation Features (DeCAF) were constructed by using the
deep convolutional neural network architecture in . The model
inputs are the mean-centered raw RGB pixel values that are forward
propagated through 5 convolutional layers and 3 fully-connected
layers. We used the outputs from the 6th layer as the features, leading
to 4, 096 dimensional DeCAF6 features.
Baselines and Protocol
We compared the classiﬁcation performance of the following algorithms: 1) a classiﬁer on raw features (Raw), 2) KPCA, 3) Transfer
Component Analysis (TCA) , 4) SSTCA, 5) Geodesic Flow
Kernel (GFK) , 6) Transfer Sparse Coding (TSC) , 7) Subspace Alignment (SA) , 8) TJM , 9) unsupervised Scatter
Component Analysis, and 10) SCA. For a realistic setting, the tunable
hyper-parameters were selected via 5-fold cross validation, according
to labels from source domains only.
The above feature learning algorithms were evaluated on three
different classiﬁers: 1) 1-nearest neighbor (1NN), 2) support vector
machines with linear kernel (L-SVM) , and 3) domain adaptation
machines (DAM) . 1NN and L-SVM are the standard off-theshelf classiﬁers, while DAM is speciﬁcally designed for domain
adaptation. DAM is an extension of SVM that incorporates a domaindependent regularization to encourage the target classiﬁer sharing
similar prediction values with the source classiﬁers. We also utilize
the linear kernel for DAM.
Classiﬁcation Accuracy with 1-Nearest Neighbor
We ﬁrst report the classiﬁcation accuracy of the competing algorithms
according to 1NN classiﬁer. The goal is to clearly highlight the
adaptation impact induced purely from the representations, since 1NN
basically just measures the distance between features.
summarizes
classiﬁcation
USPS+MNIST and MSRC+VOC2007 pairs. We can see that SCA
is the best model on average, while the prior state-of-the-art TJM
is the second best. Other domain adaptation algorithms (TCA,
SSTCA, GFK, and TSC) do not perform well, even worse than one
without adaptation strategy: KPCA. Surprisingly, the unsupervised
version of our algorithm, uSCA, has the highest accuracy on two
MSRC+VOC2007 cases. This indicates that the label incorporation
does not help improve domain adaptation on the MSRC+VOC2007,
while it clearly does on the USPS+MNIST. Furthermore, SCA and
uSCA always provide improvement over the raw features, while other
algorithms, including TJM, fail to do so in MNIST →USPS case.
2. 
3. learning domain adaptation/domain
adaptation home.html
(a) Raw (28%)
(b) KPCA (28%)
(c) SSTCA (36%)
(d) TJM (44%)
(e) SCA (77%)
Fig. 1. Visualization. Projections of synthetic data onto the ﬁrst two leading eigenvectors. Numbers in brackets indicate the classiﬁcation accuracy on the
target using 1-nearest neighbor (1NN). The top and bottom rows show the domains and classes respectively.
Accuracy % on the USPS+MNIST and MSRC+VOC2007 datasets. Bold-red and bold-black indicate the best and second best performance.
USPS →MNIST
MNIST →USPS
Accuracy % on the Ofﬁce+Caltech images with SURF-BoW features. 1NN was used as the base classiﬁer.
Accuracy % on the Ofﬁce+Caltech images with DeCAF6 features. 1NN was used as the base classiﬁer.
Surprisingly, SSTCA, which also incorporates label information
during training, does not perform competitively. The ﬁrst possible
explanation is that SCA directly improves class separability, whereas
SSTCA maximizes a dependence criterion that relates indirectly to
separability. The second is that SSTCA incorporates the manifold
regularization that requires a similarity graph, i.e., afﬁnity matrix.
This graph is parameterized by k-nearest neighbor with l2 distance,
which might not be suitable in these cases.
The results on the Ofﬁce+Caltech pair are summarized in Table 2
(SURF-BoW) and Table 3 (DeCAF6). In general, DeCAF6 induces
stronger discriminative performance than SURF-BoW features, since
DeCAF6 with 1NN only has already provided signiﬁcantly better
performance. SCA consistently has the best average performance on
both features, slightly better than the prior state-of-the-art, TJM. On
SURF-BoW, SCA is the best model on 3 out of 12 cases and the
second best on other 4 cases. The trend on DeCAF6 is better – SCA
has the best performance on 5 out of 12 cases, while comes second on
other 6 cases. Although the closest competitor, TJM, has the highest
number of individual best cross-domain performance, it requires
higher computational complexity than SCA, see Section 6.2.5 below.
Recall that the algorithms’ hyper-parameters used to produce all
the above results were tuned using labels from the source domain
only. This is the only valid tuning protocol for the unsupervised
domain adaptation setting. Nevertheless, some of the best results
established in the literature were obtained using the hyper-parameter
tuning on target labels. For completeness, we also report the results
under this tuning-on-target protocol in the supplementary material.
Average accuracy (%) on Raw features.
MNIST+USPS, MSRC+VOC
Ofﬁce+Caltech (SURF-BoW)
Ofﬁce+Caltech (DeCAF6)
Classiﬁcation Accuracy with L-SVM and DAM
Next we report the results with L-SVM and DAM as the base
classiﬁers for the feature learning algorithms. For succinctness, we
compare the performance of ﬁve algorithms: KPCA, SSTCA, SA,
TJM, and SCA, presented in Figure 2. The bar chart shows the
average accuracies relative to the performance on Raw features
(indicated by line y = 0 in red); the numbers alongside the bars
indicate the absolute accuracies. Table 4 summarizes the absolute
accuracies on Raw features.
In general, all feature learning algorithms rectify the domain
adaptation performances over Raw features, except in two cases:
SA on the Ofﬁce+Caltech with SURF-BoW features and KPCA on
the Ofﬁce+Caltech with DeCAF6 features. Considering the absolute
accuracies, we ﬁnd that the best average performances on each dataset
are still provided by SCA, a similar trend as in the 1NN results. This
conﬁrms the effectiveness of SCA regardless of the classiﬁer choice,
at least, among 1NN, L-SVM, and DAM.
Let us now compare the absolute average performance of L-
SVM and DAM with the performance of 1NN. L-SVM and DAM
evidently provide a considerable performance improvement only on
the Ofﬁce+Caltech dataset. Their performances on less powerful
features, that is, the features extracted from the MNIST+USPS and
MSRC+VOC, are even worse than 1NN. A useful lesson from this
ﬁnding is that one should make use better features to take the
real beneﬁt of more advanced classiﬁers in the context of domain
adaptation.
Finally, we seek to investigate the performance impact induced by
DAM in comparison to L-SVM. DAM is expected to provide a better
performance, since it is speciﬁcally designed for domain adaptation.
From Table 4 we can see that DAM outperforms L-SVM when
operating on Raw features. Surprisingly, that is not always the case
when a feature learning algorithm is applied. Moreover, L-SVM always produces higher performance gain relative to Raw features.than
DAM. This could be attributed to overﬁtting considering that DAM
has more hyper-parameters than L-SVM. That is, combining DAM
with a feature learning algorithm complicates the whole processs –
recall that the hyper-parameter selection is based on a validation on
source data.
Runtime Performance
Table 5 compares the average runtime performance of SCA with
some other algorithms: KPCA, TCA, SA, TSC, and TJM, on the
MNIST+USPS, MSRC+VOC, and Ofﬁce+Caltech (with DeCAF6).
All algorithms were executed with MATLAB R2014b by a machine
with Intel Core i5-240 CPU, Arch Linux 64-bit OS, and 4GB RAM.
Note that KPCA, TCA, and SCA basically utilizes the same optimization procedure: a single iteration of the eigenvalue decomposition.
TJM requires several iterations of the eigenvalue decomposition with
an additional gradient update in each iteration, while TSC solves the
dictionary learning and sparse coding with an iterative procedure.
In general, SCA is signiﬁcantly faster than TJM, the closest
competitor in accuracy, and TSC. Speciﬁcally, SCA is 3 to 6× faster
than TJM, and > 50× faster than TSC. SCA runs at about the
same speed as TCA on the MNIST+USPS and MSRC+VOC, and
the same speed as SA on the Ofﬁce+Caltech. In several other cases,
SCA performs slower than KPCA, TCA, and SA. Note that KPCA,
TCA, and SA are less competitive in accuracy compared to SCA and
TJM so that the runtime gap is less interesting to be concerned about.
Average runtime (seconds) over all cross-domain tasks in each dataset.
MNIST+USPS
Ofﬁce+Caltech
EXPERIMENT II : DOMAIN GENERALIZATION
In the second set of experiments, we show that our proposed algorithm is also applicable for domain generalization and achieves
state-of-the-art performance on some object and action recognition
datasets. We evaluated our algorithms on three cross-domain datasets:
the VLCS, Ofﬁce+Caltech, and IXMAS .
Data setup
The ﬁrst cross-domain dataset, which we refer to as the VLCS
consists of images from PASCAL VOC2007 (V) , LabelMe
(L) , Caltech-101 (C) , and SUN09 (S) datasets, each
of which represents one domain. These datasets share ﬁve object
categories: bird, car, chair, dog, and person. Each domain in the
VLCS dataset was divided into a training set (70%) and a test set
(30%) by random selection from the overall dataset. The detailed
training-test conﬁguration for each domain is summarized in the
supplementary material. We employed the DeCAF6 features with
dimensionality of 4,096 as inputs to the algorithms. These features are
publicly available.4
The second cross-domain dataset is the Ofﬁce+Caltech dataset,
see Section 6.2.1 for a detailed explanation about this dataset. We
also used DeCAF6 features extracted from this dataset.5 The third
dataset is the IXMAS dataset that contains videos of the 11
actions, recorded with different actors, cameras, and viewpoints.
This dataset has been used as a benchmark for evaluating human
action recognition models. To simulate the domain generalization
problem, we followed the setup proposed in : only frames from
ﬁve actions were utilized (check watch, cross arms, scratch head,
sit down, and get up) with domains represented represented by
camera viewpoints (Cam 0, Cam 1, ..., Cam 4). The task is to learn
actions from particular camera viewpoints and classify actions on
unseen viewpoints. In the experiment, we used the dense trajectories
features extracted from the raw frames and applied K-means
clustering to build a codebook with 1,000 clusters for each of the
ﬁve descriptors: trajectory, HOG, HOF, MBHx, MBHy. The bag-ofwords features were then concatenated forming a 5,000 dimensional
features for each frame.
4. page/FXR iccv13/index.php
5. learning domain adaptation/
(a) MNIST+USPS, MSRC+VOC
(b) Ofﬁce+Caltech (SURF-BoW)
(c) Ofﬁce+Caltech (DeCAF6)
Fig. 2. L-SVM and DAM average performance accuracy (%) relative to the performance on Raw features. The numbers on the top or bottom of the bars
show the absolute accuracy. The red line indicates the Raw baseline performance, see Table 4 for the exact numbers.
The groundtruth 1NN accuracy % of ﬁve-class classiﬁcation when training on one dataset (the left-most column) and testing on another (the upper-most
row). The bold black numbers indicate in-domain performance, while the plain black indicate cross-domain performance. “Self” refers to training and
testing on the same dataset, same as the bold black numbers and “mean others” refers to the average performance over all cross-domain cases.
Training/Test
Caltech-101
Mean others
Percent drop ( (Self−MeanOthers)∗100
Caltech-101
Mean others
Domain generalization performance accuracy (%) on the VLCS dataset with DeCAF6 features as inputs. The accuracy of all feature learning-based
algorithms: Raw, KPCA, uSCA, DICA, SCA is according to 1-nearest neighbor (1NN) classiﬁer. Bold red and bold black indicate the best and the second
best performance, respectively.
Domain generalization performance accuracy (%) on the Ofﬁce+Caltech dataset with DeCAF6 features as inputs.
Domain generalization performance accuracy (%) on the IXMAS dataset with dense trajectory-based features.
Cam 0,1,2,3
Baselines and Protocol
We compared our algorithms with the following baselines:
• 1NN: 1-nearest neighbor classiﬁer.
• L-SVM: SVM classiﬁer with linear kernel.
• KPCA : Kernel Principal Component Analysis.
• Undo-Bias : a multi-task SVM-based algorithm for undoing
dataset bias. Three hyper-parameters (λ, C1, C2) require tuning.
Since the original formulation was designed for binary classiﬁcation, we performed the following setup for multi-class classi-
ﬁcation purposes. We trained C individual Undo-Bias classiﬁers
: Rd →{−1, 1}, ∀k = 1, . . . , C, where C is the number
of classes. At the prediction stage, given a test instance (ˆx, ˆy) we
computed ˆY := {k|∀k = 1, . . . , C : f ub
= 1}. Finally, we
veriﬁed whether ˆy ∈ˆY .
• UML : a structural metric learning-based algorithm that aims
to learn a less biased distance metric for classiﬁcation tasks. The
initial tuning proposal for this method was using a set of weaklylabeled data retrieved from querying class labels to search engine.
However, here we tuned the hyper-parameters using the same kfold cross-validation strategy as others for a fair comparison.
• DICA : a kernel feature extraction method for domain generalization. DICA has three tunable hyper-parameters.
• LRE-SVM : a non-linear exemplar-SVMs model with a nuclear norm regularization to impose a low-rank likelihood matrix.
LRE-SVM has four hyper-parameters (λ1, λ2, C1, C2) that require
Undo-Bias, UML, and LRE-SVM are the prior state-of-the-art domain generalization algorithms for object recognition tasks. Note
that Undo-Bias, DICA, and UML cannot be applied to the domain
adaptation setting – they do not all
We used 1-nearest neighbor (1NN) as the base classiﬁer for
all feature learning-based algorithms: KPCA, DICA, uSCA/uDICA,
and SCA. The tunable hyper-parameters were selected according
to labels from source domains. For all kernel-based methods, the
kernel function is the RBF kernel, k(a, b) = exp(−∥a−b∥2
a kernel bandwidth σ computed by median heuristic. Note that the
unsupervised DICA (uDICA) is almost identical to uSCA in this case.
The only difference is that uSCA has a control parameter δ > 0 for
the domain scatter/distributional variance term.
Results on the VLCS Dataset
On this dataset, we ﬁrst conducted the standard training-test evaluation using 1-nearest neighbor (1NN), i.e., learning the model on
a training set from one domain and testing it on a test set from
another domain, to check the groundtruth performance and also to
identify the existence of the dataset bias. The groundtruth evaluation
results are summarized in Table 6. In general, the dataset bias
indeed exists despite the use of the state-of-the-art deep convolution
neural network features DeCAF6. For example, the average crossdomain performance, i.e., ”Mean others”, is 56.63%, which is 25%
drop from the corresponding in-domain performance: 75.96%. In
particular, Caltech-101 has the highest bias, while LabelMe is the
least biased dataset indicated by the largest and smallest performance
drop, respectively.
We then evaluated the domain generalization performance over
seven cross-domain recognition tasks. The complete results are summarized in Table 7. We can see that SCA is the best model on 5
out of 7 tasks, outperforms the prior state-of-the-art, LRE-SVM. It
almost always has better performance than the ‘raw’ baseline, except
when Caltech-101 is the target domain. On average, SCA is about
2% better than its closest competitor on this dataset, Undo-Bias. The
VLCS cross-domain recognition is a hard task in general, since the
best model (SCA) only provides < 4% average improvement over
the raw baseline. Furthermore, three algorithms, two of which are the
domain generalization-based methods (uSCA, DICA), cannot achieve
even better performance than the raw baseline.
Results on the Ofﬁce+Caltech Dataset
We evaluated our algorithms on several cross-domain cases constructed from the Ofﬁce+Caltech dataset. The detailed evaluation
results on four cases with DeCAF6 are reported in Table 8. We do
not report other cross-domain cases that are possibly constructed from
this dataset, such as A, D, C →W and A, W, C →D, since 1NN
on Raw features has already provided high accuracies (> 95%).
The closest competitor to SCA is LRE-SVM. Although LRE-
SVM performs best on average, SCA has the best performance on
three out of four cross-domain cases and comes second on average.
The only case when SCA underperforms LRE-SVM is that of
D, W →A, C. Note that the LRE-SVM algorithm is more complex
than SCA both in the optimization procedure and in the number of
tunable hyper-parameters.
However, the unsupervised version of our algorithm, uSCA,
which is the same as uDICA in the domain generalization case,
cannot compete with the state-of-the-art models. It is only slightly
better than KPCA on average. This suggests that incorporating
labeled information from source domains during feature learning does
improve domain generalization on the Ofﬁce+Caltech cases.
Results on the IXMAS dataset
Table 9 summarizes the classiﬁcation accuracies on the IXMAS
dataset over three cross-domain cases. We can see that the standard
baselines (Raw, KPCA) cannot match other algorithms with domain
generalization strategies. In this dataset, SCA has the best performance on two out of three cases and on average. In particular, SCA is
signiﬁcantly better than others on Cam 2,3,4 →Cam 0,1 case. LRE-
SVM remains the closest competitor of SCA – it has the second best
average performance with one best cross-domain case.
Runtime Performance
Next we report the average (training) runtime performance over
all cross-domain recognition tasks in each dataset. All algorithms
were executed using the same software and machine as described in
Section 6.2.5. From Table 10, we can see that the runtime of SCA is
on par with KPCA and DICA, which is expected since they utilize
the same optimization procedure: a single run with a generalized
eigenvalue decomposition.
SCA is signiﬁcantly faster than some prior state-of-the-art domain generalization methods (Undo-Bias, UML, and LRE-SVM).
For example, on the VLCS dataset, Undo-Bias, UML, and LRE-
SVM require ∼30 minutes, while SCA only needs ∼5 minutes
average training time. An analogous trend can also be seen in the
case of Ofﬁce+Caltech and IXMAS datasets. This outcome indicates
that SCA is better suited for domain generalization tasks than the
competing algorithms if a training stage in real time is required.
Average domain generalization runtime (seconds) over all cross-domain
recognition tasks in each dataset.
Ofﬁce+Caltech
CONCLUSIONS
The scatter-based objective function is a straightforward way to
encode the relevant structure of the domain adaptation and domain
generalization problems. SCA uses variances between subsets of the
data to construct a linear transformation that dampens unimportant
distinctions (within labels and between domains) and ampliﬁes useful
distinctions (between labels and overall variability). Extensive experiments on several cross-domain image datasets show that SCA is much
faster than competing algorithms and provides the state-of-the-art
performance on both domain adaptation and domain generalization.
Our theoretical analysis shows that scatter with two input domains, i.e., domain scatter, provides generalization bounds for domain adaptation . In the setting of domain generalization, recall
remark 1, prior work has shown that the distributional variance (which
is a special case of scatter) arises as one of the terms controlling
generalization performance . Scatter is thus a unifying quantity
that controls generalization performance in domain adaptation and
generalization.
SCA is a natural extension of Kernel PCA, Kernel Fisher Discriminant and TCA. In contrast, many domain adaptation methods
use objective functions that combine the total variance and MMD
with quantities that are fundamentally different in kind such as the
graph Laplacian , sparsity constraints , , the Hilbert-
Schmidt independence criterion or the central subspace .
SCA can easily be extended to semi-supervised domain adaptation, by
incorporating target labels into the class scatters. Finally, we remark
that it should be possible to speed up SCA for large-scale problems
using random features .
In general, dataset bias remains far from solved. Existing algorithms perform satisfactorily (≥80% accuracy) only in several crossdomain tasks, even when using powerful feature extraction methods
such as DeCAF6 (for images) and dense trajectory-based features (for
videos). Using less powerful features (raw pixels or SURF-BoW) is
clearly unsatisfactory. Thus, it is crucial to develop more fundamental
feature learning algorithms that signiﬁcantly reduce dataset bias in a
wide range of situations.
ACKNOWLEDGMENTS
The authors would like to thank Zheng Xu for sharing the extracted
dense trajectories features from the IXMAS dataset, and also Chen
Fang for sharing the Unbiased Metric Learning code and useful
discussions.