Machine Learning, 38, 257–286, 2000.
c⃝2000 Kluwer Academic Publishers. Printed in The Netherlands.
Reduction Techniques for Instance-Based
Learning Algorithms
D. RANDALL WILSON
 
TONY R. MARTINEZ
 
Neural Network & Machine Learning Laboratory, Computer Science Department, Brigham Young University,
Provo, Utah 84602, USA
Editor: Robert Holte
Instance-based learning algorithms are often faced with the problem of deciding which instances to
store for use during generalization. Storing too many instances can result in large memory requirements and slow
execution speed, and can cause an oversensitivity to noise. This paper has two main purposes. First, it provides a
survey of existing algorithms used to reduce storage requirements in instance-based learning algorithms and other
exemplar-based algorithms. Second, it proposes six additional reduction algorithms called DROP1–DROP5 and
DEL that can be used to remove
instances from the concept description. These algorithms and 10 algorithms from the survey are compared on 31
classiﬁcation tasks. Of those algorithms that provide substantial storage reduction, the DROP algorithms have the
highest average generalization accuracy in these experiments, especially in the presence of uniform class noise.
instance-based learning, nearest neighbor, instance reduction, pruning, classiﬁcation
Introduction
In supervised learning, a machine learning algorithm is shown a training set, T , which is a
collection of training examples called instances. Each instance has an input vector and an
output value. After learning from the training set, the learning algorithm is presented with
additional input vectors, and the algorithm must generalize, i.e., it must use some inductive
bias to decide what the
output value should be even if the new input vector was not in the training set.
A large number of machine learning algorithms compute a distance between the input
vector and stored exemplars when generalizing. Exemplars can be instances from the original training set, or can be in other forms such as hyperrectangles, prototypes, or rules. Many
such exemplar-based learning algorithms exist, and they are often faced with the problem of
decidinghowmanyexemplarstostore,andwhatportionoftheinputspacetheyshouldcover.
Instance-based learning (IBL) algorithms are
a subset of exemplar-based learning algorithms that use original instances from the training
set as exemplars. One of the most straightforward instance-based learning algorithms is
the nearest neighbor algorithm . During
generalization, instance-based learning algorithms use a distance function to determine how
close a new input vector ⃗y is to each stored instance, and use the nearest instance or instances
to predict the output class of ⃗y (i.e., to classify ⃗y).
WILSON AND MARTINEZ
Other exemplar-based machine learning paradigms include memory-based reasoning
 , exemplar-based generalization , and case-based reasoning (CBR) . Such algorithms have had much success on a wide variety of domains. There are also several exemplarbased neural network learning algorithms, including probabilistic neural networks (PNN)
 and other radial basis function networks
 , as well as counterpropagation networks , ART , and
competitive learning .
Exemplar-based learning algorithms must often decide what exemplars to store for use
during generalization in order to avoid excessive storage and time complexity, and possibly
to improve generalization accuracy by avoiding noise and overﬁtting.
For example, the basic nearest neighbor algorithm retains all of the training instances.
It learns very quickly because it need only read in the training set without much further
processing, and it generalizes accurately for many applications. However, since the basic
nearest neighbor algorithm stores all of the training instances, it has relatively large memory
requirements. It must search through all available instances to classify a new input vector, so
it is slow during classiﬁcation. Also, since it stores every instance in the training set, noisy
instances (i.e., those with errors in the input vector or output class, or those not representative
of typical cases) are stored as well, which can degrade generalization accuracy.
Techniques such as k-d trees and projection can reduce the time required to ﬁnd the nearest
neighbor(s) of an input vector, but they do not reduce storage requirements, nor do they
address the problem of noise. In addition, they often become much less effective as the
dimensionality of the problem (i.e., the number of input attributes) grows .
On the other hand, when some of the instances are removed from the training set, the
storage requirements and time necessary for generalization are correspondingly reduced.
This paper focuses on the problem of reducing the size of the stored set of instances
(or other exemplars) while trying to maintain or even improve generalization accuracy.
It accomplishes this by ﬁrst providing a relatively thorough survey of machine learning
algorithms used to reduce the number of instances needed by learning algorithms, and then
by proposing several new reduction techniques.
Section 2 discusses several issues related to the problem of instance set reduction, and
provides a framework for the discussion of individual reduction algorithms. Section 3
surveys much of the work done in this area. Section 4 presents a collection of six additional
algorithmscalledDROP1–DROP5andDELthatareusedtoreducethesizeofthetrainingset
while maintaining or even improving generalization accuracy. Section 5 presents empirical
results comparing 10 of the surveyed techniques with the six additional techniques presented
in Section 4 on 31 datasets. Section 6 provides conclusions and future research directions.
Issues in instance set reduction
This section provides a framework for the discussion of the instance reduction algorithms presented in later sections. The issues discussed in this section include exemplar
REDUCTION TECHNIQUES
representation, the order of the search, the choice of distance function, the general intuition
of which instances to keep, and how to evaluate the different reduction strategies.
Representation
One choice in designing a training set reduction algorithm is to decide whether to retain
a subset of the original instances or to modify the instances using a new representation.
For example, some algorithms use hyperrectangles to represent collections of instances; instances can be generalized into rules
 ; and prototypes can be used to represent a cluster of instances
 , even if no original instance occurred at the point where the prototype is
On the other hand, many algorithms (i.e., instance-based algorithms) seek to retain a
subset of the original instances. One problem with using the original data points is that
there may not be any data points located at the precise points that would make for the most
accurate and concise concept description. Prototypes, on the other hand, can be artiﬁcially
constructed to exist exactly where they are needed, if such locations can be accurately
determined. Similarly, rules and hyperrectangles can be constructed to reduce the need for
instances in certain areas of the input space.
Direction of search
When searching for a subset S of instances to keep from training set T , there are also a
variety of directions the search can proceed, including incremental, decremental, and batch.
2.2.1. Incremental.
An incremental search begins with an empty subset S, and adds each
instance in T to S if it fulﬁlls some criteria. In this case the order of presentation of
instances can be very important. In particular, the ﬁrst few instances may have a very
different probability of being included in S than they would if they were visited later.
Under such schemes, the order of presentation of instances in T to the algorithm is
typically random because by deﬁnition, an incremental algorithm should be able to handle
new instances as they become available without all of them being present at the beginning.
In addition, some incremental algorithms do not retain all of the previously seen instances
even during the learning phase, which can also make the order of presentation important.
One advantage of an incremental scheme is that if instances are made available later,
after training is complete, they can continue to be added to S according to the same criteria.
Another advantage of incremental algorithms is that they can be faster and use less storage
during learning than non-incremental algorithms, since they can ignore some of the discarded instances when adding others. Thus instead of O(n2) time and O(n) storage during
the learning phase, they can use O(ns) time and O(s) storage, where n is the number of
training instances and s is the number of instances retained in the subset.
The main disadvantage is that incremental algorithms are sensitive to the order of presentation of the instances, and their early decisions are based on very little information,
and are therefore prone to errors until more information is available. Some incremental
WILSON AND MARTINEZ
algorithms use a small number of instances (e.g., 100) in an
initial “batch” phase to help alleviate these problems.
Some algorithms add instances to S in a somewhat incremental fashion, but they examine
all available instances to help select which instance to add next. This makes the algorithm
not truly incremental, but may improve its performance substantially.
2.2.2. Decremental.
The decremental search begins with S = T , and then searches for
instances to remove from S. Again the order of presentation is important, but unlike the
incremental process, all of the training examples are available for examination at any time,
so a search can be made to determine which instance would be best to remove during each
step of the algorithm. Decremental algorithms discussed in Section 3 include RNN , SNN , ENN , VSM , and the SHRINK
(SUBTRACTIVE) Algorithm . RISE can also be
viewed as a decremental algorithm, except that instead of simply removing instances from
S, instances are generalized into rules. Similarly, Chang’s prototype rule 
operates in a decremental order, but prototypes are merged into each other instead of being
simply removed.
One disadvantage with the decremental rule is that it is often computationally more
expensive than incremental algorithms. For example, in order to ﬁnd the nearest neighbor
in T of an instance, n distance calculations must be made. On the other hand, there are
fewer than n instances in S (zero initially, and some fraction of T eventually), so ﬁnding
the nearest neighbor in S of an instance takes less computation.
However, if the application of a decremental algorithm can result in greater storage
reduction, then the extra computation during learning (which is done just once) can be
well worth the computational savings during execution thereafter. Increased generalization
accuracy, if it can be achieved, is also typically worth some extra time during learning.
2.2.3. Batch.
Another way to apply a training set reduction rule is in batch mode. This
involves deciding if each instance meets the removal criteria before removing any of them.
Then all those that do meet the criteria are removed at once. For example, the ALL K-NN rule
 operates this way. This can relieve the algorithm from having to constantly
update lists of nearest neighbors and other information when instances are individually
However, there are also dangers in batch processing. For example, assume the following
rule is applied to an instance set:
Remove an instance if it has the same output class as its k nearest neighbors.
This could result in entire clusters disappearing if there are no instances of a different
class nearby. If done in decremental mode, however, some instances would remain, because
eventually enough neighbors would be removed that one of the k nearest neighbors of an
instance would have to be of another class, even if it was originally surrounded by those of
its own class.
As with decremental algorithms, batch processing suffers from increased time complexity
over incremental algorithms.
REDUCTION TECHNIQUES
Border points vs. central points
Another factor that distinguishes instance reduction techniques is whether they seek to
retain border points, central points, or some other set of points.
The intuition behind retaining border points is that “internal” points do not affect the
decision boundaries as much as border points, and thus can be removed with relatively little
effect on classiﬁcation.
On the other hand, some algorithms instead seek to remove border points. They remove
points that are noisy or do not agree with their neighbors. This removes close border points,
leaving smoother decision boundaries behind. However, such algorithms do not remove
internal points that do not necessarily contribute to the decision boundary.
It may take a large number of border points to completely deﬁne a border, so some
algorithms retain center points in order to use those instances which are most typical of
a particular class to classify instances near them. This can dramatically affect decision
boundaries, because the decision boundaries depend on not only where the instances of one
classlie,butwherethoseofotherclasseslieaswell.Roughlyspeaking(i.e.,assuming k = 1),
the decision boundary lies halfway between two nearest instances of opposing classes, so
center points must be chosen carefully in order to keep the decision boundaries in the correct
general vicinity.
Distance function
The distance function (or its complement, the similarity function) is used to decide which
neighbors are closest to an input vector and can have a dramatic effect on an instance-based
learning system.
The nearest neighbor algorithm and its derivatives usually use variants of the Euclidean
distance function, which is deﬁned as:
E(⃗x, ⃗y) =
where ⃗x and ⃗y are the two input vectors, m is the number of input attributes, and xi
and yi are the input values for input attribute i. This function is appropriate when all
the input attributes are numeric and have ranges of approximately equal width. When the
attributes have substantially different ranges, the attributes can be normalized by dividing
the individual attribute distances by the range or standard deviation of the attribute.
A variety of other distance functions are also available for continuously-valued attributes, including the Minkowsky , Mahalanobis ,
Camberra, Chebychev, Quadratic, Correlation, and Chi-square distance metrics ; the Context-Similarity measure ;
the Contrast Model ; hyperrectangle distance functions and others. Several of these functions are deﬁned in ﬁgure 1 .
WILSON AND MARTINEZ
Equations of selected distance functions. (x and y are vectors of m attribute values).
When nominal (discrete, unordered) attributes are included in an application, a distance
metric is needed that supports them. Some learning algorithms have used the overlap metric,
which deﬁnes the distance for an attribute as 0 if the values are equal, or 1 if they are different,
regardless of which two values they are.
An alternative distance function for nominal attributes is the Value Difference Metric
(VDM) . Using the VDM, the distance between two values x and
y of a single attribute a is given as:
VDMa(x, y) =
where Na,x is the number of times attribute a had value x; Na,x,c is the number of times
attribute a had value x and the output class was c; and C is the number of output classes.
REDUCTION TECHNIQUES
Using this distance measure, two values are considered to be closer if they have more similar
classiﬁcations, regardless of the order of the values.
In order to handle heterogeneous applications—those with both numeric and nominal
attributes—it is possible to use a heterogeneous distance function such as HVDM , which is deﬁned as:
HVDM(⃗x, ⃗y) =
d2a(xa, ya)
where the function da(x, y) is the distance for attribute a and is deﬁned as:
da(x, y) =
if x or y is unknown; otherwise...
VDMa(x, y),
if a is nominal, else
if a is numeric.
where VDMa(x, y) is the function given in (2), and σa is the standard deviation of the
values occurring for attribute a in the instances in the training set T . This distance function
provides appropriate normalization between numeric and nominal attributes, as well as
between numeric attributes of different scales. It handles unknown input values by assigning
them a large distance so that instances with missing attributes will be less likely to be used
as neighbors than those with all attributes speciﬁed. Using a constant for the distance to an
unknown attribute value also serves to effectively ignore such attributes when an instance
to be classiﬁed is missing a value, since the distance to that attribute will be the same for
all instances in the system.
2.4.1. Weighting.
Several algorithms use weighting schemes that alter the distance measurements and voting inﬂuence of each instance. In this paper we focus on training set
reduction, and thus will not use any weighting schemes in our experiments other than those
needed for normalization in the distance function, as explained above. A good survey of
weighting schemes is given by Wettschereck, Aha and Mohri .
Another decision that must be made for many algorithms is the choice of k, which is the number of neighbors used to decide the output class of an input vector. The value of k is typically
a small, odd integer (e.g., 1, 3 or 5). Usually each such nearest neighbor gets exactly one vote,
so even values of k could result in “ties” that would have to be resolved arbitrarily or through
some more complicated scheme. There are some algorithms which give closer neighbors
more inﬂuence than further ones, such as the Distance-Weighted kNN Rule .
Such modiﬁcations reduce the sensitivity of the algorithm to the selection of k. Radial Basis
Function networks and Probabilistic Neural Networks 
use a Gaussian weighting of inﬂuence and allow all instances to “vote”, though instances
WILSON AND MARTINEZ
that are very far from the input have only negligible inﬂuence. This does away with the
need for the k parameter, but introduces a need for weight-spreading parameters.
One common way of determining the value of k is to use leave-one-out cross-validation.
For each of several values of k, each instance is classiﬁed by its k nearest neighbors other
than the instance itself, to see if it is classiﬁed correctly. The value for k that produces the
highest accuracy is chosen.
In the basic nearest neighbor rule, setting k greater than 1 decreases the sensitivity of the
algorithm to noise, and tends to smooth the decision boundaries somewhat . It is also important for many instance set reduction algorithms to
have a k > 1. However, once reduction has taken place, it is possible that the value of k
should be changed. For example, if the training set has been reduced to the point that there
is only one instance representing what was formerly a cluster of instances, then perhaps
k = 1 would be more appropriate than k > 1, especially if the noisy instances have been
removed during the reduction process. In other cases, the value of k should remain the same.
Thus, it may be appropriate to ﬁnd a value of k for use during the reduction process, and
then redetermine the best value for k after reduction is completed.
It may even be advantageous to update k dynamically during the reduction process. For
example, if a very large value of k were used initially, the order of removal of instances
from the subset might be improved.
Evaluation strategies
In comparing training set reduction algorithms, there are a number of criteria that can be used
to compare the relative strengths and weaknesses of each algorithm. These include speed
increase (during execution), storage reduction, noise tolerance, generalization accuracy,
time requirements (during learning), and incrementality.
2.6.1. Storage reduction.
One of the main goals of training set reduction algorithms is to
reduce storage requirements. It is important to note that if alternate representations are used
(e.g., hyperrectangles or rules), any increase in the size of the new representation must be
taken into account along with the reduction in number of instances stored.
2.6.2. Speed increase.
Another main goal is to speed up classiﬁcation. A reduction in
the number of stored instances will typically yield a corresponding reduction in the time
it takes to search through these instances and classify a new input vector. Again, more
complex representations such as hyperrectangles may not need as many comparisons, but
may require more computation for each comparison, and this must be taken into account.
2.6.3. Generalization accuracy.
A successful algorithm will often be able to signiﬁcantly
reduce the size of the training set without signiﬁcantly reducing generalization accuracy.
In some cases generalization accuracy can increase with the reduction of instances, such
as when noisy instances are removed and when decision boundaries are smoothed to more
closely match the true underlying function rather than the sampling distribution.
REDUCTION TECHNIQUES
2.6.4. Noise tolerance.
Algorithms also differ with respect to how well they work in the
presence of noise. In the presence of class noise, for example, there are two main problems
that can occur. The ﬁrst is that very few instances will be removed from the training set
because many instances are needed to maintain the noisy (and thus overly complex) decision
boundaries. The second problem is that generalization accuracy can suffer, especially if
noisy instances are retained while good instances are removed. In such cases the reduced
training set can be much less accurate than the full training set in classifying new input
2.6.5. Learning speed.
The learning process is done just once on a training set, so it is not
quite as important for the learning phase to be fast. However, if the learning phase takes
too long it can become impractical for real applications. Ironically, it is on especially large
training sets that reduction algorithms are most badly needed, so a reasonable (e.g., O(n2)
or faster) time bound is desirable.
2.6.6. Incremental.
In some cases it is convenient to have an incremental algorithm so that
additional instances can be added over time as they become available. On the other hand,
it is possible to use a non-incremental algorithm on an initial database and then employ a
separate incremental algorithm once a reasonable starting point has been achieved.
Note that not all algorithms attempt to meet all of these goals. For example, a hybrid
hyperrectangle and nearest-neighbor algorithm by Wettschereck saves all of the
training set in addition to the hyperrectangles, and thus actually increases storage requirements. However, it uses the hyperrectangles to quickly classify most input vectors, and only
uses the entire training set when necessary. Thus, it sacriﬁces the goal of storage reduction
in favor of the goals of classiﬁcation speed and maintaining or increasing generalization
Survey of instance reduction algorithms
Many researchers have addressed the problem of training set size reduction. This section
surveys several techniques, discusses them in light of the framework presented in Section2,
and points out their interesting differences. This survey builds upon an earlier survey done
by Dasarathy . Most of the algorithms discussed here use a subset S of the original
instances in the training set T as their representation, and though most have primarily used
the Euclidean distance function in the past, they can typically make use of the HVDM
distance function or other distance functions when needed. Most of the algorithms also tend
to use k = 1 except where noted, though in most cases the algorithms can be modiﬁed to
use k > 1.
Nearest neighbor editing rules
3.1.1. Condensed nearest neighbor rule.
Hart made one of the ﬁrst attempts to
reduce the size of the training set with his Condensed Nearest Neighbor Rule (CNN). His
algorithm ﬁnds a subset S of the training set T such that every member of T is closer to
WILSON AND MARTINEZ
a member of S of the same class than to a member of S of a different class. In this way,
the subset S can be used to classify all the instances in T correctly (assuming that T is
consistent, i.e., that no two instances in T have identical inputs but different classes).
This algorithm begins by randomly selecting one instance belonging to each output class
from T and putting them in S. Then each instance in T is classiﬁed using only the instances
in S. If an instance is misclassiﬁed, it is added to S, thus ensuring that it will be classiﬁed
correctly. This process is repeated until there are no instances in T that are misclassiﬁed.
This algorithm ensures that all instances in T are classiﬁed correctly, though it does not
guarantee a minimal set.
This algorithm is especially sensitive to noise, because noisy instances will usually be
misclassiﬁed by their neighbors, and thus will be retained. This causes two problems. First,
storage reduction is hindered, because noisy instances are retained, and because they are
there, often non-noisy instances nearby will also need to be retained. The second problem
is that generalization accuracy is hurt because noisy instances are usually exceptions and
thus do not represent the underlying function well. Since some neighbors have probably
been removed, a noisy instance in S will often cover more of the input space than it did in
T , thus causing even more misclassiﬁcations than before reduction.
3.1.2. Selective nearest neighbor rule.
Ritter et al. extended the condensed NN
method in their Selective Nearest Neighbor Rule (SNN) such that every member of T
must be closer to a member of S of the same class than to any member of T (instead
of S) of a different class. Further, the method ensures a minimal subset satisfying these
conditions.
The algorithm for SNN is more complex than most other reduction algorithms, and
the learning time is signiﬁcantly greater, due to the manipulation of an n × n matrix and
occasional recursion. The SNN algorithm begins by constructing a binary n × n matrix A
(where n is the number of instances in T ), where Ai j is set to 1 when instance j is of the
same class as instance i, and it is closer to instance i than i’s nearest enemy, i.e., the nearest
neighbor of i in T that is of a different class than i. Aii is always set to 1.
Once this array is set up, the following 5 steps are taken until no columns remain in the
1. For all columns i that have exactly one bit on, let j be the row with the bit on in column
i. All columns with a bit on in row j are removed, row j is removed, and instance j is
added to S.
2. For all rows j, delete row j if for all (remaining) columns i and for some (remaining)
row k, A ji ≤Aki. In other words, row j is deleted if for some other row k, whenever
row j contains a 1, row k also contains a 1. In this case instance j is not added to S.
3. Delete any column i if for all (remaining) rows j and some (remaining) column k,
A ji ≥A jk. In other words, column i is deleted if there is some other column k that
has zeroes in every row that column i does (and possibly zeroes in other rows as well).
Again instance i is not added to S.
4. Continue to repeat steps 1–3 until no further progress can be made. If no columns remain
in the array, then S is complete and the algorithm is ﬁnished. Otherwise, go on to step 5.
REDUCTION TECHNIQUES
5. Find the row j that when included in S requires the fewest other rows to also be included
in S. This is done as follows:
(a) For each remaining row j, assume that instance j will be added to S, and that row
j and any (remaining) columns with a bit on in row j will be deleted (but do not
actually remove row j or the columns yet). Subject to this assumption, ﬁnd the
fewest number of additional rows it would take to get at least as many 1’s as there
are remaining columns. From the minimums found for each row j, keep track of the
absolute minimum found by any row j.
(b) For each row j in (a) that resulted in the absolute minimum number of additional
rows that might be needed, actually remove j and columns with bits on in row j and
call the algorithm recursively beginning with step 1. If the minimum number of rows
was really used, then add j to S and stop: S is complete. Otherwise, restore row j
and the removed columns, and try the next possible row j.
(c) If no row j is successful in achieving the minimum number, increment the absolute
minimum and try (b) again until successful.
Note that the only steps in which instances are chosen for inclusion in S are steps 1 and 5.
This algorithm takes approximately O(mn2 + n3) time, compared to the O(mn2) or less
time required by most other algorithms surveyed. It also requires O(n2) storage during the
learning phase for the matrix, though this matrix is discarded after learning is complete. The
algorithm is sensitive to noise, though it will tend to sacriﬁce storage more than accuracy
when noise is present. For an example of how this algorithm works, the reader is referred
to Ritter et al. , which also appears in Dasarathy . An implementation in C is
also available in the on-line appendix to this paper.
3.1.3. Reduced nearest neighbor rule.
Gates introduced the Reduced Nearest
Neighbor Rule (RNN). The RNN algorithm starts with S = T and removes each instance
from S if such a removal does not cause any other instances in T to be misclassiﬁed by
the instances remaining in S. It is computationally more expensive than Hart’s Condensed
NN rule, but will always produce a subset of CNN, and is thus less expensive in terms of
computation and storage during the classiﬁcation stage.
Since the instance being removed is not guaranteed to be classiﬁed correctly, this algorithm is able to remove noisy instances and internal instances while retaining border
3.1.4. Edited nearest neighbor rule.
Wilson developed the Edited Nearest Neighbor (ENN) algorithm in which S starts out the same as T , and then each instance in S
is removed if it does not agree with the majority of its k nearest neighbors (with k = 3,
typically). This edits out noisy instances as well as close border cases, leaving smoother
decision boundaries. It also retains all internal points, which keeps it from reducing the storage requirements as much as most other reduction algorithms. The Repeated ENN (RENN)
applies the ENN algorithm repeatedly until all instances remaining have a majority of their
neighbors with the same class, which continues to widen the gap between classes and
smooths the decision boundary.
WILSON AND MARTINEZ
3.1.5. All k-NN.
Tomek extended the ENN with his All k-NN method of editing.
This algorithm works as follows: for i = 1 to k, ﬂag as bad any instance not classiﬁed
correctly by its i nearest neighbors. After completing the loop all k times, remove any
instances from S ﬂagged as bad. In his experiments, RENN produced higher accuracy than
ENN, and the ALL K-NN method resulted in even higher accuracy yet. As with ENN, this
method can leave internal points intact, thus limiting the amount of reduction that it can
accomplish. These algorithms serve more as noise ﬁlters than serious reduction algorithms.
Kubat & Matwin extended Tomek’s algorithm to remove internal instances as
well as border instances. They ﬁrst apply a variant of Hart’s CNN rule , and then
remove any instances that participate in Tomek Links, i.e., pairs of instances of different
classes that have each other as their nearest neighbors. Their algorithm was developed for
the purpose of handling cases where one class was much more rare than the other(s), so
only instances in the majority class are removed by their reduction algorithm, and all of the
instances in the minority class are retained.
3.1.6. Variable similarity metric.
Lowe presented a Variable Similarity Metric
(VSM) learning system that produces a conﬁdence level of its classiﬁcations. In order to
reduce storage and remove noisy instances, an instance t is removed if all k of its neighbors
are of the same class, even if they are of a different class than t (in which case t is likely to
be noisy). This removes noisy instances as well as internal instances, while retaining border
instances. The instance is only removed, however, if its neighbors are at least 60% sure of
their classiﬁcation. The VSM system typically uses a fairly large k (e.g., k = 10), and the
reductioninstorageisthusquiteconservative,butitcanprovideanincreaseingeneralization
accuracy. Also, the VSM system used distance-weighted voting, which makes a larger value
of k more appropriate.
“Instance-Based” learning algorithms
Aha et al. presented a series of instance-based learning algorithms. IB1
(Instance Based learning algorithm 1) was simply the 1-NN algorithm, and was used as a
3.2.1. IB2.
The IB2 algorithm is incremental: it starts with S initially empty, and each
instance in T is added to S if it is not classiﬁed correctly by the instances already in S
(with the ﬁrst instance always added). An early case study calls
this algorithm the Growth (Additive) Algorithm. This algorithm is quite similar to Hart’s
Condensed NN rule, except that IB2 does not seed S with one instance of each class, and
does not repeat the process after the ﬁrst pass through the training set. This means that IB2
will not necessarily classify all instances in T correctly.
This algorithm retains border points in S while eliminating internal points that are surrounded by members of the same class. Like the CNN algorithm, IB2 is extremely sensitive
to noise, because erroneous instances will usually be misclassiﬁed, and thus noisy instances
will almost always be saved, while more reliable instances are removed.
REDUCTION TECHNIQUES
3.2.2. Shrink (subtractive) algorithm.
Kibler & Aha also presented an algorithm
that starts with S = T , and then removes any instances that would still be classiﬁed correctly
by the remaining subset. This is similar to the Reduced Nearest Neighbor (RNN) rule,
except that it only considers whether the removed instance would be classiﬁed correctly,
whereas RNN considers whether the classiﬁcation of other instances would be affected by
the instance’s removal. Like RNN and many of the other algorithms, it retains border points,
but unlike RNN, this algorithm is sensitive to noise.
3.2.3. IB3.
The IB3 algorithm is another incremental algorithm that addresses IB2’s problem of keeping noisy instances by retaining only acceptable
misclassiﬁed instances. The algorithm proceeds as shown below.
For each instance t in T
Let a be the nearest acceptable instance in S to t.
(if there are no acceptable instances in S, let a be a random instance in S)
If class(a) ̸= class(t) then add t to S.
For each instance s in S
If s is at least as close to t as a is
Then update the classiﬁcation record of s
and remove s from S if its classiﬁcation record is signiﬁcantly poor.
Remove all non-acceptable instance from S.
An instance is acceptable if the lower bound on its accuracy is statistically signiﬁcantly
higher (at a 90% conﬁdence level) than the upper bound on the frequency of its class.
Similarly, an instance is dropped from S if the upper bound on its accuracy is statistically
signiﬁcantly lower (at a 70% conﬁdence level) than the lower bound on the frequency of
its class. Other instances are kept in S during training, and then dropped at the end if they
do not prove to be acceptable.
The formula for the upper and lower bounds of the conﬁdence interval is:
p + z2/2n ± z
where for the accuracy of an instance in S, n is the number of classiﬁcation attempts since
introduction of the instance to S (i.e., the number of times it was at least as close to t as
a was), p is the accuracy of such attempts (i.e., the number of times the instance’s class
matched t’s class, divided by n), and z is the conﬁdence (.9 for acceptance, .7 for dropping).
For the frequency of a class, p is the frequency (i.e. proportion of instances so far that are
of this class), n is the number of previously processed instances, and z is the conﬁdence (.9
for acceptance, .7 for dropping).
IB3 was able to achieve greater reduction in the number of instances stored and also
achieved higher accuracy than IB2, due to its reduced sensitivity to noise on the applications
on which it was tested.
WILSON AND MARTINEZ
3.2.4. IB4 and IB5.
In order to handle irrelevant attributes, IB4 extends IB3
by building a set of attribute weights for each class. It requires fewer instances to generalize
well when irrelevant attributes are present in a dataset. IB5 extends IB4 to
handle the addition of new attributes to the problem after training has already begun. These
extensions of IB3 address issues that are beyond the scope of this paper, and are thus only
brieﬂy mentioned here.
3.2.5. MCS.
Brodley introduced a Model Class Selection (MCS) system that uses
an instance-based learning algorithm (which claims to be “based loosely on IB3”) as part
of a larger hybrid learning algorithm. Her algorithm for reducing the size of the training
set is to keep track of how many times each instance was one of the k nearest neighbors of
another instance (as instances were being added to the concept description), and whether
its class matched that of the instance being classiﬁed. If the number of times it was wrong
is greater than the number of times it was correct then it is thrown out. This tends to avoid
noise, though it uses a simpler approach than IB3.
3.2.6. TIBL.
Zhang used a different approach called the Typical Instance Based
Learning (TIBL) algorithm, which attempted to save instances near the center of clusters
rather than on the border. This can result in much more drastic reduction in storage and
smoother decision boundaries, and is robust in the presence of noise.
The typicality of an instance is deﬁned as the ratio of its average similarity to instances
of the same class to its average similarity to instances of other classes. The similarity of
two instances x and y is deﬁned as 1 −distance(x, y), where
distance(⃗x, ⃗y) =
maxi −mini
In this equation m is the number of input attributes, and maxi and mini are the maximum and
minimum values occurring for attribute i, respectively. For nominal attributes, the distance
for that attribute is 0 if they are equal or 1 if they are different (i.e., the overlap metric).
Each instance x has a weight wx that is multiplied by the distance to compute a weighted
distance for use during training and subsequent classiﬁcation.
The learning algorithm proceeds as follows. Pick the most typical instance x in T −S
that is incorrectly classiﬁed by the instances in S. Find the most typical instance y in T −S
which causes x to be correctly classiﬁed, and add it to S. Note that x itself is not added at
this point. Set y’s weight to be wy = 1/typicality(y). Repeat this process until all instances
in T are classiﬁed correctly.
This strategy shows great reduction in storage, especially when the application has
“graded structures” in which some instances are more typical of a class than others in a
fairly continuous way. The TIBL algorithm also avoids saving noisy instances. It is pseudoincremental, i.e., it proceeds in an incremental fashion, but it uses the entire training set to
determine the typicality of each instance and the range of each input attribute.
The TIBL algorithm may have difﬁculty on problems with complex decision surfaces, and
requires modiﬁcations to handle disjoint geometric regions that belong to the same class.
REDUCTION TECHNIQUES
3.2.7. Random mutation hill climbing.
Skalak used random mutation hill climbing
 to select instances to use in S. The method begins with
m randomly-selected instances in S (where m is a parameter that is supplied by the user).
Then for each iteration (called a mutation), one randomly-selected instance in S is removed
and replaced with another randomly-selected instance in T −S. If this strictly improves
classiﬁcation of the instances in T , the change is retained, otherwise it is undone. This
process is repeated for n iterations, where n is another parameter provided by the user.
Skalak used n = 100.
Since it does not determine the number m of instances to retain in the subset, this method
only solves part of the problem.
3.2.8. Encoding length.
Cameron-Jones used an encoding length heuristic to determine how good the subset S is in describing T . The basic algorithm begins with a growing
phase that takes each instance i in T and adds it to S if that results in a lower cost than not
adding it. As with IB3, the growing phase can be affected by the order of presentation of
the instances.
The cost (i.e., the value to be minimized) of the instance-based model is
COST(m, n, x) = F(m, n) + m log2(C) + F(x, n −m) + x log2(C −1)
where n is the number of instances in T , m is the number of instances in S, and x is the
number of exceptions (i.e., the number of instances seen so far that are misclassiﬁed by the
instances in S). C is the number of classes in the classiﬁcation task. F(m, n) is the cost of
encoding which m instances of the n available are retained, and is deﬁned as:
F(m, n) = log∗
where log∗(x) is the sum of the positive terms of log2(x), log2(log2(x)), etc.
After all instances are seen, instance reduction is done, where each instance i in S is
removed if doing so lowers the cost of the classiﬁer. Cameron-Jones calls this method the
“Pre/All” method, since it is not truly incremental, but to better distinguish it from other
techniques in this paper, we call it the Encoding Length Grow (ELGROW) method.
The Explore method begins by growing and reducing S using the
ELGROW method, and then performs 1000 mutations to try to improve the classiﬁer. Each
mutation tries adding an instance to S, removing one from S, or swapping one in S with
one in T −S, and keeps the change if it does not increase the cost of the classiﬁer. The
generalization accuracy of the EXPLORE method is quite good empirically, and its storage
reduction is much better than most other algorithms.
Prototypes and other modiﬁcations of the instances
Some algorithms seek to reduce storage requirements and speed up classiﬁcation by modifying the instances themselves, instead of just deciding which ones to keep.
WILSON AND MARTINEZ
3.3.1. Prototypes.
Chang introduced an algorithm in which each instance in T is
initially treated as a prototype. The nearest two instances that have the same class are merged
into a single prototype (using a weighted averaging scheme) that is located somewhere
between the two prototypes. This process is repeated until classiﬁcation accuracy starts to
This method achieved good results, though it requires modiﬁcation to handle applications
that have one or more nominal input attributes.
3.3.2. RISE.
Domingos introduced the RISE 2.0 system which treats each instance
in T as a rule in R. For each rule r in R, the nearest example n in T of the same class as r
is found that is not yet covered by r. The rule r is then minimally generalized to cover n,
unless that harms accuracy. This process is repeated until no rules are generalized during
an entire pass through all the rules in R.
During generalization, the nearest rule to an input vector is used to provide the output
class. If two rules are equally close, the one with higher generalization accuracy on the
training set is used.
3.3.3.EACH.
Salzberg introducedtheNestedGeneralizedExemplar(NGE)theory,
in which hyperrectangles are used to take the place of one or more instances, thus reducing
storage requirements. The program used to implement NGE is called the Exemplar-Aided
Constructor of Hyperrectangles (EACH). EACH seeds the system with several randomlyselected instances from the training set, after which it operates incrementally. As each
instance is presented, EACH ﬁnds the distance to the nearest exemplar (i.e., a point or
hyperrectangle), which is 0 if the instance is inside a hyperrectangle. A point inside multiple
hyperrectangles is considered to be closest to the smallest one.
When the new instance has the same class as its nearest exemplar, the exemplar is
generalized (i.e., the hyperrectangle is grown) so that it also covers the new instance. When
the classes are different, EACH attempts to change the shape of the second-closest exemplar
so that it becomes the closest one. If it cannot do so, then the new instance becomes a
new exemplar. Weights are maintained for each exemplar that reduce the effect of noisy
exemplars and irrelevant attributes.
Wettschereck & Dietterich introduced a hybrid nearest-neighbor and nearesthyperrectangle algorithm that uses hyperrectangles to classify input vectors if they fall inside
the hyperrectangle, and KNN to classify inputs that were not covered by any hyperrectangle.
This algorithm must store the entire training set T , but accelerates classiﬁcation by using
relatively few hyperrectangles whenever possible.
Ordered removal
Given the issues in Section 2 to consider, our research has been directed towards ﬁnding
instance reduction techniques that provide noise tolerance, high generalization accuracy,
insensitivity to the order of presentation of instances, and signiﬁcant storage reduction,
which in turn improves generalization speed.
This section presents a collection of new heuristics used to decide which instances to keep
and which instances to remove from a training set. Unlike most previous methods, these
REDUCTION TECHNIQUES
algorithms take careful note of the order in which instances are removed. The ﬁrst three
methods, DROP1–DROP3, were previously introduced by the authors under the names
RT1–RT3, respectively .
In order to avoid repeating lengthy deﬁnitions, some notation is introduced here. A
training set T consists of n instances (or prototypes) P1..n. Each instance P has k nearest
neighbors P.N1..k (ordered from nearest to furthest), where k is typically a small odd integer
such as 1, 3 or 5. P also has a nearest enemy, P.E, which is the nearest instance with a
different output class. Those instances that have P as one of their k nearest neighbors are
called associates of P, and are notated as P.A1..a (sorted from nearest to furthest) where a
is the number of associates that P has.
The ﬁrst new reduction technique we present is the Decremental Reduction Optimization
Procedure 1, or DROP1. This algorithm is identical to RNN with the exception
that the accuracy is checked on S instead of T . It is included here mostly as a baseline for
comparison with the other DROP algorithms, and to provide a framework on which to build
the others.
DROP1 uses the following basic rule to decide if it is safe to remove an instance from
the instance set S (where S = T originally):
Remove P if at least as many of its associates in S would be classiﬁed correctly without
To see if an instance P can be removed using this rule, each associate (i.e., each instance
that has P as one of its neighbors) is checked to see what effect the removal of P would
have on it.
Removing P causes each associate P.Ai to use its k+1st nearest neighbor (P.Ai.Nk+1) in
place of P. If P has the same class as P.Ai, and P.Ai.Nk+1 has a different class than P.Ai,
this weakens its classiﬁcation, and could cause P.Ai to be misclassiﬁed by its neighbors.
On the other hand, if P is a different class than P.Ai and P.Ai.Nk+1 is the same class
as P.Ai, the removal of P could cause a previously misclassiﬁed instance to be classiﬁed
correctly.
In essence, this rule tests to see if removing P would degrade leave-one-out crossvalidation generalization accuracy, which is an estimate of the true generalization ability
of the resulting classiﬁer. An instance is removed when it results in the same level of
generalization with lower storage requirements. By maintaining lists of k + 1 neighbors
and an average of k + 1 associates (and their distances), the leave-one-out cross-validation
can be computed in O(k) time for each instance instead of the usual O(mn) time, where n
is the number of instances in the training set, and m is the number of input attributes. An
O(mn) step is only required once an instance is selected for removal. This efﬁcient method
is similar to the method used in RISE .
WILSON AND MARTINEZ
The algorithm for DROP1 proceeds as follows.
1. DROP1(Training set T ): Instance set S.
Let S = T .
For each instance P in S:
Find P.N1..k+1, the k + 1 nearest neighbors of P in S.
Add P to each of its neighbors’ lists of associates.
For each instance P in S:
Let with = # of associates of P classiﬁed correctly with P as a neighbor.
Let without = # of associates of P classiﬁed correctly without P.
If without ≥with
Remove P from S.
For each associate A of P
Remove P from A’s list of nearest neighbors.
Find a new nearest neighbor for A.
Add A to its new neighbor’s list of associates.
For each neighbor N of P
Remove P from N’s lists of associates.
This algorithm begins by building a list of nearest neighbors for each instance, as well
as a list of associates. Then each instance in S is removed if its removal does not hurt the
classiﬁcation of the instances remaining in S. When an instance P is removed, all of its
associates must remove P from their list of nearest neighbors, and then must ﬁnd a new
nearest neighbor so that they still have k + 1 neighbors in their list. When they ﬁnd a new
neighbor N, they also add themselves to N’s list of associates so that at all times every
instance has a current list of neighbors and associates.
This algorithm removes noisy instances, because a noisy instance P usually has associates
that are mostly of a different class, and such associates will be at least as likely to be
classiﬁed correctly without P. DROP1 also removes instances in the center of clusters,
because associates there are not near their enemies, and thus continue to be classiﬁed
correctly without P.
Near the border, the removal of some instances can cause others to be classiﬁed incorrectly
because the majority of their neighbors can become enemies. Thus this algorithm tends to
keep non-noisy border points. At the limit, there is typically a collection of border instances
such that the majority of the k nearest neighbors of each of these instances is the correct
DROP2: using more information and ordering the removal
There is a potential problem that can arise in DROP1 with regard to noisy instances. A noisy
instance will typically have associates of a different class, and will thus cover a somewhat
small portion of the input space. However, if its associates are removed by the above rule,
REDUCTION TECHNIQUES
the noisy instance may cover more and more of the input space. Eventually it is hoped that
the noisy instance itself will be removed. However, if many of its neighbors are removed
ﬁrst, its associates may eventually include instances of the same class from the other side
of the original decision boundary, and it is possible that removing the noisy instance at that
point could cause some of its distant associates to be classiﬁed incorrectly.
DROP2 solves this problem by considering the effect of the removal of an instance on
all the instances in the original training set T instead of considering only those instances
remaining in S. In other words, an instance P is removed from S only if at least as many of
its associates—including those that may have already been removed from S—are classiﬁed
correctly without it.
Thus, the removal criterion can be restated as:
Remove P if at least as many of its associates in T would be classiﬁed correctly without
Using this modiﬁcation, each instance P in the original training set T continues to
maintain a list of its k + 1 nearest neighbors in S, even after P is removed from S. This in
turn means that instances in S have associates that are both in and out of S, while instances
that have been removed from S have no associates (because they are no longer a neighbor
of any instance). This modiﬁcation makes use of additional information that is available
for estimating generalization accuracy, and also avoids some problems that can occur with
DROP1 such as removing entire clusters. This change is made by removing lines 15 and 16
from the pseudo-code for DROP1 in Section 4.1 so that instances that have been removed
from S will still be associates of their nearest neighbors in S.
DROP2 also changes the order of removal of instances. It initially sorts the instances in
S by the distance to their nearest enemy. Instances are then checked for removal beginning
at the instance furthest from its nearest enemy. This tends to remove instances furthest from
the decision boundary ﬁrst, which in turn increases the chance of retaining border points.
DROP3: ﬁltering noise
DROP2 sorts S in an attempt to remove center points before border points. One problem
with this method is that noisy instances are also “border” points, and cause the order of
removal to be drastically changed. One noisy point in the center of a cluster causes many
points in that cluster to be considered border points, and some of these can remain in S even
after the noisy point is removed.
Two passes through S can remove the dangling center points, but unfortunately, by that
time some border points may have already been removed that should have been kept.
DROP3 therefore uses a noise-ﬁltering pass before sorting the instances in S. This is
done using a rule similar to ENN : Any instance misclassiﬁed by its k
nearest neighbors is removed. This removes noisy instances, as well as close border points,
which can in turn smooth the decision boundary slightly. This helps to avoid “overﬁtting”
the data, i.e., using a decision surface that goes beyond modeling the underlying function
and starts to model the data sampling distribution as well.
WILSON AND MARTINEZ
After removing noisy instances from S in this manner, the instances are sorted by distance
to their nearest enemy remaining in S, and thus points far from the real decision boundary
are removed ﬁrst. This allows points internal to clusters to be removed early in the process,
even if there were noisy points nearby.
DROP4: more carefully ﬁltering noise
DROP4 is identical to DROP3 except that instead of blindly applying ENN, the noise-
ﬁltering pass removes each instance only if it is (1) misclassiﬁed by its k nearest neighbors,
and (2) it does not hurt the classiﬁcation of other instances. While DROP3 usually works
well, it can in rare cases remove far too many instances in the noise-reduction pass. In one
experiment, it went so far as to remove all of them. DROP4 avoids such problems and thus
protects against especially poor generalization accuracy in such rare cases, at the expense
of slightly higher storage requirements on average.
DROP5: smoothing the decision boundary
DROP5 modiﬁes DROP2 so that instances are considered for removal beginning with
instances that are nearest to their nearest enemy, and proceeding outward. This serves as
a noise-reduction pass, but will also cause most internal points to be removed as well. By
removing points near the decision boundary ﬁrst, the decision boundary is smoothed. After
this pass, the furthest-to-nearest pass as done by DROP2 is done repeatedly until no further
improvement can be made.
A modiﬁed version of DROP5 was used in the Reduced Probabilistic Neural Network
(RPNN) , which is a Radial Basis Function (RBF) network
used for classiﬁcation. The RPNN used a reduction technique that included a conservative
nearest-to-furthest noise-ﬁltering pass followed by a more aggressive furthest-to-nearest
node instance reduction pass.
Decremental encoding length
The Decremental Encoding Length (DEL) algorithm is the same as DROP3, except that it
uses the encoding length heuristic (as is used in ELGROW and EXPLORE in Section 3.2.8) to
decide in each case whether an instance can be removed. DEL starts with S = T , and begins
with a noise-ﬁltering pass in which each instance is removed if (a) it is misclassiﬁed by its
k nearest neighbors, and (b) removing the instance does not increase the encoding length
cost. The remaining instances are then sorted by the distance to their nearest enemy, and
as long as any improvement is being made, the remaining instances are removed (starting
with the instance furthest from its nearest enemy) if doing so does not increase the encoding
length cost.
Experimental results
Many of the reduction techniques surveyed in Section 3 and all of the techniques proposed in
Section 4 were implemented and tested on 31 datasets from the Machine Learning Database
REDUCTION TECHNIQUES
Repository at the University of California, Irvine . Those included in
these experiments are CNN, SNN, ENN, RENN, ALL K-NN, IB2, IB3, ELGROW, EXPLORE,
DEL, and DROP1–DROP5.
These experiments were limited to those algorithms that choose a subset S from the
training set T to use for subsequent classiﬁcation. Therefore, the methods that modify the
instances themselves were not included, i.e., rule-based, prototype, and hyperrectanglebuilding methods. Similarly, VSM and MCS were excluded since they are part of more
complicated systems. RMHC was excluded because it does not specify how many instances to retain, and its method is subsumed by EXPLORE. Similarly, RNN and SHRINK
(SUBTRACTIVE) are improved upon by DROP2 and DROP1, respectively, and are thus not
included for the sake of parsimony.
The basic k nearest neighbor (KNN) algorithm that retains 100% of the training set is
also included for comparison.
All of the algorithms use k = 3, and in our experiments they all use the HVDM distance
function. (Experiments were also done using a more traditional Euclidean distance metric
with overlap metric for nominal attributes, but the average accuracy for every one of the
algorithms was higher using HVDM.)
Ten-fold cross-validation was used for each experiment. Each dataset was divided into 10
partitions and each reduction technique was given a training set T consisting of 9 of the
partitions (i.e., 90% of the data), from which it returned a subset S. The remaining partition
(i.e., the other 10% of the data) was classiﬁed using only the instances in S. Ten such trials
were run for each dataset with each reduction algorithm, using a different one of the 10
partitions as the test set for each trial. The average accuracy over the 10 trials is reported for
each reduction algorithm on each dataset in Table 1. The average percentage of instances
in T that were included in S is also reported for each experiment under the column “%”.
The average accuracy and storage percentage for each method over all of the 31 datasets
is shown in bold near the bottom of Table 1. Due to the size of Table 1, it is broken into
three parts, but the overall average of all of the reduction techniques on each dataset and
the results for the KNN algorithm are included with each part for comparison.
DROP3 seemed to have the best mix of storage reduction and generalization accuracy
of the DROP methods, so it was selected for comparisons with all of the other methods.
Three tests were used to see how DROP3 compared to the other reduction algorithms on
this entire set of classiﬁcation tasks. The ﬁrst is a count of how often DROP3 was “better”
and “worse” than each of the other algorithms, where “better” means higher accuracy or
lower storage requirements in the respective columns. These counts are given as a pair of
numbers in the row labeled “#DROP3 better/worse.” For example, under CNN, “26–5” in
the accuracy column and “25–6” in the storage column indicates that DROP3 had higher
average accuracy than CNN on 26 of the 31 datasets, and lower average storage requirements
on 25 of them.
Since many differences were not statistically signiﬁcant, a one-tailed paired t-test was
used on the 10-fold cross-validation results for each dataset to measure whether the average
WILSON AND MARTINEZ
Empirical results on 31 datasets. The left column shows generalization accuracy and the right column
(“%”) shows what percent of the original training set was retained by the reduction algorithm. (a) Accuracy and
storage percentage for CNN, SNN 1B2, 1B3 and DEL.
Australian
Breast Cancer(WI)
Echocardiogram
Heart(Cleveland)
Heart(Hungarian)
Heart(Long Beach VA)
Heart(More)
Heart(Swiss)
Horse Colic
Image Segmentation
Ionosphere
LED Creator+17
LED Creator
Liver (Bupa)
Pima Diabetes
Soybean (Large)
#DROP3 better/worse
#Sig. better/worse
accuracy for DROP3 was signiﬁcantly higher (when its average accuracy was higher) or
lower (when its average accuracy was lower) than each of the other methods. In Table 1, the
superscripts“+”and“++”indicatethatDROP3’saverageaccuracywassigniﬁcantlyhigher
than the other method’s average accuracy at a 90% and 95% conﬁdence level, respectively.
Similarly, “−” and “−−” indicate that DROP3 had signiﬁcantly lower average accuracy
than the other method at a 90% and 95% conﬁdence level, respectively.
The row labeled “#sig. better/worse” gives a count of how often DROP3 was signiﬁcantly
“better” and “worse” than each of the other algorithms at a 90% or higher conﬁdence level.
A t-test was also done to test the signiﬁcance of differences in storage requirements for
each experiment, and the results are summarized in this same row, though the “+’s” and
“−’s” were not included in the storage column due to space constraints.
In a further effort to verify whether differences in accuracy and storage requirements
on this entire set of classiﬁcation tasks were statistically signiﬁcant, a one-tailed Wilcoxon
Signed Ranks test was used to compare DROP3 with each
of the other reduction techniques. The conﬁdence level of a signiﬁcant difference is shown
in the “Wilcoxon” row of Table 1. Positive values indicate the conﬁdence that DROP3 is
REDUCTION TECHNIQUES
Table 1(b).
Accuracy and storage percentage for DROP1–DROP5.
Australian
Breast Cancer(WI)
Echocardiogram
Heart(Cleveland)
Heart(Hungarian)
Heart(Long Beach VA)
Heart(More)
Heart(Swiss)
Horse Colic
Image Segmentation
Ionosphere
LED Creator+17
LED Creator
Liver (Bupa)
Pima Diabetes
Soybean (Large)
#DROP3 better/worse
#Sig. better/worse
“better” (i.e., higher accuracy or lower storage requirements) than the other method on these
datasets, while negative values indicate the conﬁdence that DROP3 is “worse.” Conﬁdence
values with a magnitude of at least 90% can be considered signiﬁcant differences, and
throughout the remainder of this paper, the word “signiﬁcant” will be used to refer to
statistical signiﬁcance with at least a 90% conﬁdence level.
The accuracy and storage percentages for each of the 10 trials for each method on each
dataset are available in an on-line appendix, along with standard deviations,t-test conﬁdence
values, source code and data ﬁles (see the Appendix of this paper for details).
Analysis of results
Several observations can be made from the results in this table. CNN and IB2 achieve almost
identical results (less than 1% difference in both size and accuracy in most cases), due to the
similarity of their algorithms. SNN had lower accuracy and higher storage requirements on
average when compared to CNN and IB2, and the SNN algorithm is much more complex
and substantially slower than the others as well. IB3 was able to achieve higher accuracy
and lower storage than SNN, CNN and IB2, with the only disadvantage being a learning
algorithm that is somewhat more complex (though not much slower) than CNN or IB2.
WILSON AND MARTINEZ
Table 1(c).
Accuracy and storage percentage for ENN, RENN, ALL K-NN, ELGROW, and EXPLORE.
Australian
Breast Cancer(WI)
Echocardiogram
Heart(Cleveland)
Heart(Hungarian)
Heart(Long Beach VA)
Heart(More)
Heart(Swiss)
Horse Colic
Image Segmentation
Ionosphere
LED Creator+17
LED Creator
Liver (Bupa)
Pima Diabetes
Soybean (Large)
#DROP3 better/worse
#Sig. better/worse
DROP3 had signiﬁcantly higher accuracy than all of these four methods at over a 99%
conﬁdence level (according to the Wilcoxon test) on these datasets. It also had signiﬁcantly
lower storage requirements than all of these methods at over a 99% conﬁdence level, except
on IB3, where the conﬁdence of lower storage requirements was still over 90%.
As expected, ENN, RENN and ALL K-NN all retained over 75% of the instances, due to
their retention of internal (non-border) instances. They all had fairly good accuracy, largely
because they still had access to most of the original instances. In agreement with Tomek
 , the ALL K-NN method achieved better reduction and higher accuracy than RENN,
which in turn had higher reduction (though slightly lower accuracy) than ENN. All three
of these methods had higher average accuracy than DROP3, though only ENN’s accuracy
was signiﬁcantly higher, but this is mostly due to retaining most of the instances.
The ELGROW and EXPLORE techniques had by far the best storage reduction of any
of the algorithms. The ELGROW algorithm achieved the best average reduction (retaining
only 1.67% of the training instances) but also suffered a signiﬁcant drop in generalization
accuracy when compared to the original (unreduced) KNN system. However, the EXPLORE
methodachievedbetteraverageaccuracythanELGROWwithonlyaslightincreaseinstorage
over ELGROW, indicating that the random mutation hill climbing step was successful in
ﬁnding a better subset S after the growing and reduction phases were complete. DROP3 had
REDUCTION TECHNIQUES
signiﬁcantly better accuracy than both of these algorithms, but their storage requirements
were signiﬁcantly better than that of DROP3.
The ordered reduction techniques DROP2–DROP5 all had average generalization accuracy that was within 1% of the full KNN classiﬁer. Their average accuracy was higher
than any of the other reduction methods. DROP2 and DROP3 both had average storage
requirements of about 14%, which is lower than any of the other methods except ELGROW
and EXPLORE. DROP1 retained about half as many instances as the other ordered reduction
techniques (signiﬁcantly better than DROP3), but had the worst generalization accuracy
of any of them (signiﬁcantly worse than DROP3), because it fails to use information provided by previously removed instances in determining whether further instances should be
The DEL approach also had good accuracy, but was not quite as high as DROP2–DROP5,
and its storage requirements were not quite as low as most of the DROP methods. DROP3
had lower storage and signiﬁcantly higher accuracy than DEL.
Effect of noise
Since several of these algorithms are designed to be robust in the presence of noise, the
same experiments were repeated with 10% uniform class noise artiﬁcially added to each
dataset. This was done by randomly changing the output class of 10% of the instances in
the training set to an incorrect value (with an equal probability for each of the incorrect
classes). The output class of the instances in the test set are not noisy, so the results indicate
how well each model is able to predict the correct output even if some of its training data
is mislabeled.
Table 2 shows the average accuracy and storage requirements over all 31 datasets for
each algorithm, including the basic (unreduced) KNN algorithm.
As can be seen from Table 2, the accuracy for the KNN algorithm dropped just over 3%
on average. Note that some of the effect of noise is already handled by the use of k = 3 in
these experiments. Otherwise the drop in accuracy would be more on the order of 8% (i.e.,
10% of the 82% already classiﬁed correctly).
As expected, CNN and IB2 increased storage and suffered large reductions in accuracy
in the presence of noise. SNN dropped only slightly in accuracy when uniform class noise
was added, but it retained almost half of the instances in the training set due to its strict (and
noise intolerant) requirements as to which instances must be in S.
In agreement with Aha’s results , IB3 had higher accuracy and lower storage
requirements in the presence of noise than IB2, though it still suffered a dramatic decrease
in accuracy (and a slight increase in storage) when compared to its performance in the noisefree case. In our experiments we found that when the number of instances in the training
set was small, IB3 would occasionally end up with an empty subset S, because none of
the instances gets enough statistical strength to be acceptable. This problem worsens in
the presence of noise, and thus more training data (or a modiﬁcation of the algorithm) is
required to handle small, noisy datasets.
DROP1 did not fall much in accuracy, but its accuracy was already poor to begin with.
However, all of the other DROP methods (DROP2–DROP5) achieved accuracy higher than
WILSON AND MARTINEZ
Average accuracy and storage requirements in the presence of 10% uniform class noise.
the KNN method, while using less than one-sixth of the original instances. DROP3 had the
highest accuracy of the DROP methods, and had the lowest storage of the accurate ones
(DROP2–DROP5), using less than 12% of the original instances.
The ENN, RENN, and ALL K-NN methods also achieved higher accuracy than KNN,
since they were designed speciﬁcally for noise ﬁltering. They also required about 10% less
storage than in the noise-free case, probably because they were throwing most of the noisy
instances (as well as a few good instances that were made to appear noisy due to the added
The encoding-length heuristic methods all dropped about 2% in accuracy when noise
was added leaving them closer to—but still below—the KNN method in terms of accuracy.
ELGROW had fairly poor accuracy compared to the others, but EXPLORE was within 1%
of the KNN method in terms of accuracy while using only about 2% of the instances for
Conclusions and future research directions
Many techniques have been proposed to reduce the number of instances used for classiﬁcation in instance-based and other exemplar-based learning algorithms. In experiments on 31
datasets, the results make possible the division of the tested algorithms into several groups.
The ﬁrst group consists of algorithms which had low generalization accuracy and are thus
REDUCTION TECHNIQUES
mostly of historical signiﬁcance. This group includes CNN, SNN, IB2 (which led to the
development of IB3) and DROP1 (which led to the more successful DROP algorithms).
These had low generalization even before noise was introduced, and dropped further when
it was. Of this group, only DROP1 kept less than 25% of the instances on average, so the
storage reduction did not make up for the lack of accuracy.
The second group consists of the three similar noise-ﬁltering algorithms: ENN, RENN,
and ALL K-NN. These had high accuracy but also kept most of the instances. In the noisefree environment, they achieved slightly lower accuracy than KNN, but when uniform class
noise was added, their accuracy was higher than KNN, indicating that they are successful
in the situation for which they were designed. These algorithms are useful when this type
of noise is expected in the data and when it is reasonable to retain most of the data. Of this
group, ALL K-NN had the highest accuracy and lowest storage requirements in the presence
The third group consists of two algorithms, ELGROW and EXPLORE, that were able to
achieve reasonably good accuracy with only about 2% of the data. ELGROW had the lowest
storage (about 1.8%) but its accuracy was somewhat poor, especially in the noisy domain.
The EXPLORE method had fairly good accuracy, especially in the noisy arena, though it
was not quite as accurate as the DROP methods. However, its aggressive storage reduction
would make this trade-off acceptable in many cases.
The ﬁnal group consists of algorithms which had high accuracy and reasonably good
storage reduction. These include IB3, DROP2–DROP5 and DEL. IB3 was designed to
overcome the noise-sensitivity of IB2, and in our experiments it had better accuracy and
storage reduction than IB2, especially in the noisy case. However, its accuracy still dropped
substantially in the noisy experiments, and it had lower average accuracy and higher average
storage than the EXPLORE method both with and without noise.
The algorithms DROP2–DROP5 had higher average accuracy than IB3 on the original
data, and had much higher average accuracy in the noisy case. They also improved in terms
of average storage reduction as well. DROP2–DROP5 all had an accuracy within about
1% of KNN on the original data, and were about 1% higher when uniform class noise was
added, with storage ranging from 11% to 18%. DEL had slightly lower accuracy than the
DROP2–DROP5 methods, but had lower storage in the noisy domain.
DROP3 seemed to have the best mix of generalization accuracy and storage requirements
of the DROP methods. DROP3 had signiﬁcantly higher accuracy and lower storage than
any of the algorithms in the ﬁrst group; somewhat lower accuracy but signiﬁcantly lower
storage than any of the algorithms in the second group; and signiﬁcantly worse storage but
signiﬁcantly better accuracy than the algorithms in the third group.
This paper has reviewed much of the work done in the area of reducing storage requirements in instance-based learning systems. The effect of uniform output class noise on many
of the algorithms has also been observed on a collection of datasets. Other factors that
inﬂuence the success of each algorithm must still be identiﬁed. Continued research should
help determine under what conditions each of these algorithms is successful so that an
appropriate algorithm can be automatically chosen when needed. Current research is also
focused on combining the reduction techniques proposed here with various weighting techniques in order to develop learning systems that can more dynamically adapt to problems of
WILSON AND MARTINEZ
An on-line appendix is available at the following location.
ftp://axon.cs.byu.edu/pub/randy/ml/drop/
This site contains the complete source code used for these experiments, including the cost
function for the encoding-length methods and the code used to generate t-test and Wilcoxon
test statistics. The FTP site also contains all of the data sets and complete experimental
results, including the accuracy for all 10 trials of each experiment, standard deviations, etc.
Acknowledgments
The authors would like to thank Mike Cameron-Jones for providing code needed to implement the encoding-length heuristic techniques. Thanks also to David Aha who provided his
code on-line and supplied many useful pointers to references relevant to this research. Pedro
Domingos provided suggestions on including signiﬁcance results which have strengthened
the conclusions of this paper. Thanks also go out to Dan Ventura for his proofreading and
to the anonymous reviewers for their help in bringing this paper into its ﬁnal form.