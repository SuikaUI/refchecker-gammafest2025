Robust Principal Component Analysis?
Emmanuel J. Cand`es1,2, Xiaodong Li2, Yi Ma3,4, and John Wright4
1 Department of Statistics, Stanford University, Stanford, CA 94305
2 Department of Mathematics, Stanford University, Stanford, CA 94305
3,4 Electrical and Computer Engineering, UIUC, Urbana, IL 61801
4 Microsoft Research Asia, Beijing, China
December 17, 2009
This paper is about a curious phenomenon. Suppose we have a data matrix, which is the
superposition of a low-rank component and a sparse component. Can we recover each component
individually? We prove that under some suitable assumptions, it is possible to recover both the
low-rank and the sparse components exactly by solving a very convenient convex program called
Principal Component Pursuit; among all feasible decompositions, simply minimize a weighted
combination of the nuclear norm and of the ℓ1 norm. This suggests the possibility of a principled
approach to robust principal component analysis since our methodology and results assert that
one can recover the principal components of a data matrix even though a positive fraction of its
entries are arbitrarily corrupted. This extends to the situation where a fraction of the entries
are missing as well. We discuss an algorithm for solving this optimization problem, and present
applications in the area of video surveillance, where our methodology allows for the detection of
objects in a cluttered background, and in the area of face recognition, where it oﬀers a principled
way of removing shadows and specularities in images of faces.
Keywords. Principal components, robustness vis-a-vis outliers, nuclear-norm minimization,
ℓ1-norm minimization, duality, low-rank matrices, sparsity, video surveillance.
Introduction
Motivation
Suppose we are given a large data matrix M, and know that it may be decomposed as
M = L0 + S0,
where L0 has low-rank and S0 is sparse; here, both components are of arbitrary magnitude. We
do not know the low-dimensional column and row space of L0, not even their dimension. Similarly,
we do not know the locations of the nonzero entries of S0, not even how many there are. Can we
hope to recover the low-rank and sparse components both accurately (perhaps even exactly) and
eﬃciently?
A provably correct and scalable solution to the above problem would presumably have an impact
on today’s data-intensive scientiﬁc discovery.1 The recent explosion of massive amounts of high-
1Data-intensive computing is advocated by Jim Gray as the fourth paradigm for scientiﬁc discovery .
dimensional data in science, engineering, and society presents a challenge as well as an opportunity
to many areas such as image, video, multimedia processing, web relevancy data analysis, search,
biomedical imaging and bioinformatics. In such application domains, data now routinely lie in
thousands or even billions of dimensions, with a number of samples sometimes of the same order
of magnitude.
To alleviate the curse of dimensionality and scale,2 we must leverage on the fact that such data
have low intrinsic dimensionality, e.g. that they lie on some low-dimensional subspace , are
sparse in some basis , or lie on some low-dimensional manifold . Perhaps the simplest and
most useful assumption is that the data all lie near some low-dimensional subspace. More precisely,
this says that if we stack all the data points as column vectors of a matrix M, the matrix should
have (approximately) low-rank: mathematically,
M = L0 + N0,
where L0 has low-rank and N0 is a small perturbation matrix.
Classical Principal Component
Analysis (PCA) seeks the best (in an ℓ2 sense) rank-k estimate of L0 by solving
subject to
rank(L) ≤k.
(Throughout the paper, ∥M∥denotes the 2-norm; that is, the largest singular value of M.) This
problem can be eﬃciently solved via the singular value decomposition (SVD) and enjoys a number
of optimality properties when the noise N0 is small and i.i.d. Gaussian.
Robust PCA.
PCA is arguably the most widely used statistical tool for data analysis and dimensionality reduction today. However, its brittleness with respect to grossly corrupted observations
often puts its validity in jeopardy – a single grossly corrupted entry in M could render the estimated
ˆL arbitrarily far from the true L0. Unfortunately, gross errors are now ubiquitous in modern applications such as image processing, web data analysis, and bioinformatics, where some measurements
may be arbitrarily corrupted (due to occlusions, malicious tampering, or sensor failures) or simply
irrelevant to the low-dimensional structure we seek to identify. A number of natural approaches
to robustifying PCA have been explored and proposed in the literature over several decades. The
representative approaches include inﬂuence function techniques , multivariate trimming ,
alternating minimization , and random sampling techniques . Unfortunately, none of these
existing approaches yields a polynomial-time algorithm with strong performance guarantees under
broad conditions3. The new problem we consider here can be considered as an idealized version of
Robust PCA, in which we aim to recover a low-rank matrix L0 from highly corrupted measurements
M = L0+S0. Unlike the small noise term N0 in classical PCA, the entries in S0 can have arbitrarily
large magnitude, and their support is assumed to be sparse but unknown4.
2We refer to either the complexity of algorithms that increases drastically as dimension increases, or to their
performance that decreases sharply when scale goes up.
3Random sampling approaches guarantee near-optimal estimates, but have complexity exponential in the rank of
the matrix L0. Trimming algorithms have comparatively lower computational complexity, but guarantee only locally
optimal solutions.
4The unknown support of the errors makes the problem more diﬃcult than the matrix completion problem that
has been recently much studied.
Applications.
There are many important applications in which the data under study can naturally be modeled as a low-rank plus a sparse contribution. All the statistical applications, in which
robust principal components are sought, of course ﬁt our model. Below, we give examples inspired
by contemporary challenges in computer science, and note that depending on the applications,
either the low-rank component or the sparse component could be the object of interest:
• Video Surveillance. Given a sequence of surveillance video frames, we often need to identify
activities that stand out from the background.
If we stack the video frames as columns
of a matrix M, then the low-rank component L0 naturally corresponds to the stationary
background and the sparse component S0 captures the moving objects in the foreground.
However, each image frame has thousands or tens of thousands of pixels, and each video
fragment contains hundreds or thousands of frames. It would be impossible to decompose M
in such a way unless we have a truly scalable solution to this problem. In Section 4, we will
show the results of our algorithm on video decomposition.
• Face Recognition. It is well known that images of a convex, Lambertian surface under varying
illuminations span a low-dimensional subspace . This fact has been a main reason why
low-dimensional models are mostly eﬀective for imagery data.
In particular, images of a
human’s face can be well-approximated by a low-dimensional subspace. Being able to correctly
retrieve this subspace is crucial in many applications such as face recognition and alignment.
However, realistic face images often suﬀer from self-shadowing, specularities, or saturations
in brightness, which make this a diﬃcult task and subsequently compromise the recognition
performance. In Section 4, we will show how our method is able to eﬀectively remove such
defects in face images.
• Latent Semantic Indexing. Web search engines often need to analyze and index the content
of an enormous corpus of documents. A popular scheme is the Latent Semantic Indexing
(LSI) . The basic idea is to gather a document-versus-term matrix M whose entries
typically encode the relevance of a term (or a word) to a document such as the frequency it
appears in the document (e.g. the TF/IDF). PCA (or SVD) has traditionally been used to
decompose the matrix as a low-rank part plus a residual, which is not necessarily sparse (as
we would like). If we were able to decompose M as a sum of a low-rank component L0 and a
sparse component S0, then L0 could capture common words used in all the documents while
S0 captures the few key words that best distinguish each document from others.
• Ranking and Collaborative Filtering. The problem of anticipating user tastes is gaining increasing importance in online commerce and advertisement. Companies now routinely collect
user rankings for various products, e.g., movies, books, games, or web tools, among which
the Netﬂix Prize for movie ranking is the best known . The problem is to use incomplete
rankings provided by the users on some of the products to predict the preference of any given
user on any of the products. This problem is typically cast as a low-rank matrix completion
problem. However, as the data collection process often lacks control or is sometimes even
ad hoc – a small portion of the available rankings could be noisy and even tampered with.
The problem is more challenging since we need to simultaneously complete the matrix and
correct the errors. That is, we need to infer a low-rank matrix L0 from a set of incomplete
and corrupted entries. In Section 1.6, we will see how our results can be extended to this
situation.
Similar problems also arise in many other applications such as graphical model learning, linear
system identiﬁcation, and coherence decomposition in optical systems, as discussed in . All in
all, the new applications we have listed above require solving the low-rank and sparse decomposition
problem for matrices of extremely high dimension and under much broader conditions, a goal this
paper aims to achieve.
A surprising message
At ﬁrst sight, the separation problem seems impossible to solve since the number of unknowns to
infer for L0 and S0 is twice as many as the given measurements in M ∈Rn1×n2. Furthermore, it
seems even more daunting that we expect to reliably obtain the low-rank matrix L0 with errors in
S0 of arbitrarily large magnitude.
In this paper, we are going to see that very surprisingly, not only can this problem be solved,
it can be solved by tractable convex optimization.
Let ∥M∥∗:= P
i σi(M) denote the nuclear
norm of the matrix M, i.e. the sum of the singular values of M, and let ∥M∥1 = P
ij |Mij| denote
the ℓ1-norm of M seen as a long vector in Rn1×n2. Then we will show that under rather weak
assumptions, the Principal Component Pursuit (PCP) estimate solving5
∥L∥∗+ λ∥S∥1
subject to
exactly recovers the low-rank L0 and the sparse S0. Theoretically, this is guaranteed to work even if
the rank of L0 grows almost linearly in the dimension of the matrix, and the errors in S0 are up to a
constant fraction of all entries. Algorithmically, we will see that the above problem can be solved by
eﬃcient and scalable algorithms, at a cost not so much higher than the classical PCA. Empirically,
our simulations and experiments suggest this works under surprisingly broad conditions for many
types of real data. In Section 1.5, we will comment on the similar approach taken in the paper ,
which was released during the preparation of this manuscript.
When does separation make sense?
A normal reaction is that the objectives of this paper cannot be met. Indeed, there seems to not be
enough information to perfectly disentangle the low-rank and the sparse components. And indeed,
there is some truth to this, since there obviously is an identiﬁability issue. For instance, suppose
the matrix M is equal to e1e∗
1 (this matrix has a one in the top left corner and zeros everywhere
else). Then since M is both sparse and low-rank, how can we decide whether it is low-rank or
sparse? To make the problem meaningful, we need to impose that the low-rank component L0 is
not sparse. In this paper, we will borrow the general notion of incoherence introduced in for the
matrix completion problem; this is an assumption concerning the singular vectors of the low-rank
component. Write the singular value decomposition of L0 ∈Rn1×n2 as
L0 = UΣV ∗=
5Although the name naturally suggests an emphasis on the recovery of the low-rank component, we reiterate that
in some applications, the sparse component truly is the object of interest.
where r is the rank of the matrix, σ1, . . . , σr are the positive singular values, and U = [u1, . . . , ur],
V = [v1, . . . , vr] are the matrices of left- and right-singular vectors. Then the incoherence condition
with parameter µ states that
∥U∗ei∥2 ≤µr
∥V ∗ei∥2 ≤µr
Here and below, ∥M∥∞= maxi,j |Mij|, i.e. is the ℓ∞norm of M seen as a long vector. Note
that since the orthogonal projection PU onto the column space of U is given by PU = UU∗, (1.2)
is equivalent to maxi ∥PUei∥2 ≤µr/n1, and similarly for PV . As discussed in earlier references
 , the incoherence condition asserts that for small values of µ, the singular vectors are
reasonably spread out – in other words, not sparse.
Another identiﬁability issue arises if the sparse matrix has low-rank. This will occur if, say, all
the nonzero entries of S occur in a column or in a few columns. Suppose for instance, that the ﬁrst
column of S0 is the opposite of that of L0, and that all the other columns of S0 vanish. Then it is
clear that we would not be able to recover L0 and S0 by any method whatsoever since M = L0 +S0
would have a column space equal to, or included in that of L0. To avoid such meaningless situations,
we will assume that the sparsity pattern of the sparse component is selected uniformly at random.
Main result
The surprise is that under these minimal assumptions, the simple PCP solution perfectly recovers
the low-rank and the sparse components, provided of course that the rank of the low-rank component is not too large, and that the sparse component is reasonably sparse. Below, n(1) = max(n1, n2)
and n(2) = min(n1, n2).
Theorem 1.1 Suppose L0 is n × n, obeys (1.2)–(1.3), and that the support set of S0 is uniformly
distributed among all sets of cardinality m. Then there is a numerical constant c such that with
probability at least 1−cn−10 (over the choice of support of S0), Principal Component Pursuit (1.1)
with λ = 1/√n is exact, i.e. ˆL = L0 and ˆS = S0, provided that
rank(L0) ≤ρrn µ−1(log n)−2
Above, ρr and ρs are positive numerical constants. In the general rectangular case where L0 is
n1×n2, PCP with λ = 1/√n(1) succeeds with probability at least 1−cn−10
(1) , provided that rank(L0) ≤
ρrn(2) µ−1(log n(1))−2 and m ≤ρs n1n2.
In other words, matrices L0 whose singular vectors—or principal components—are reasonably
spread can be recovered with probability nearly one from arbitrary and completely unknown corruption patterns (as long as these are randomly distributed). In fact, this works for large values of
the rank, i.e. on the order of n/(log n)2 when µ is not too large. We would like to emphasize that
the only ‘piece of randomness’ in our assumptions concerns the locations of the nonzero entries
of S0; everything else is deterministic. In particular, all we require about L0 is that its singular
vectors are not spiky. Also, we make no assumption about the magnitudes or signs of the nonzero
entries of S0. To avoid any ambiguity, our model for S0 is this: take an arbitrary matrix S and set
to zero its entries on the random set Ωc; this gives S0.
A rather remarkable fact is that there is no tuning parameter in our algorithm. Under the
assumption of the theorem, minimizing
n(1) = max(n1, n2)
always returns the correct answer. This is surprising because one might have expected that one
would have to choose the right scalar λ to balance the two terms in ∥L∥∗+ λ∥S∥1 appropriately
(perhaps depending on their relative size). This is, however, clearly not the case. In this sense, the
choice λ = 1/√n(1) is universal. Further, it is not a priori very clear why λ = 1/√n(1) is a correct
choice no matter what L0 and S0 are. It is the mathematical analysis which reveals the correctness
of this value. In fact, the proof of the theorem gives a whole range of correct values, and we have
selected a suﬃciently simple value in that range.
Another comment is that one can obtain results with larger probabilities of success, i.e. of the
form 1 −O(n−β) (or 1 −O(n−β
(1))) for β > 0 at the expense of reducing the value of ρr.
Connections with prior work and innovations
The last year or two have seen the rapid development of a scientiﬁc literature concerned with the
matrix completion problem introduced in , see also and the references therein. In
a nutshell, the matrix completion problem is that of recovering a low-rank matrix from only a small
fraction of its entries, and by extension, from a small number of linear functionals. Although other
methods have been proposed , the method of choice is to use convex optimization :
among all the matrices consistent with the data, simply ﬁnd that with minimum nuclear norm.
The papers cited above all prove the mathematical validity of this approach, and our mathematical
analysis borrows ideas from this literature, and especially from those pioneered in . Our methods
also much rely on the powerful ideas and elegant techniques introduced by David Gross in the
context of quantum-state tomography . In particular, the clever golﬁng scheme plays a
crucial role in our analysis, and we introduce two novel modiﬁcations to this scheme.
Despite these similarities, our ideas depart from the literature on matrix completion on several
fronts. First, our results obviously are of a diﬀerent nature. Second, we could think of our separation problem, and the recovery of the low-rank component, as a matrix completion problem.
Indeed, instead of having a fraction of observed entries available and the other missing, we have
a fraction available, but do not know which one, while the other is not missing but entirely corrupted altogether. Although, this is a harder problem, one way to think of our algorithm is that
it simultaneously detects the corrupted entries, and perfectly ﬁts the low-rank component to the
remaining entries that are deemed reliable. In this sense, our methodology and results go beyond
matrix completion. Third, we introduce a novel de-randomization argument that allows us to ﬁx
the signs of the nonzero entries of the sparse component. We believe that this technique will have
many applications. One such application is in the area of compressive sensing, where assumptions
about the randomness of the signs of a signal are common, and merely made out of convenience
rather than necessity; this is important because assuming independent signal signs may not make
much sense for many practical applications when the involved signals can all be non-negative (such
as images).
We mentioned earlier the related work , which also considers the problem of decomposing a
given data matrix into sparse and low-rank components, and gives suﬃcient conditions for convex
programming to succeed. These conditions are phrased in terms of two quantities. The ﬁrst is the
maximum ratio between the ℓ∞norm and the operator norm, restricted to the subspace generated
by matrices whose row or column spaces agree with those of L0. The second is the maximum ratio
between the operator norm and the ℓ∞norm, restricted to the subspace of matrices that vanish
oﬀthe support of S0. Chandrasekaran et. al. show that when the product of these two quantities
is small, then the recovery is exact for a certain interval of the regularization parameter .
One very appealing aspect of this condition is that it is completely deterministic: it does not
depend on any random model for L0 or S0. It yields a corollary that can be easily compared to
our result: suppose n1 = n2 = n for simplicity, and let µ0 be the smallest quantity satisfying (1.2),
then correct recovery occurs whenever
j {i : [S0]ij ̸= 0} ×
µ0r/n < 1/12.
The left-hand side is at least as large as ρs√µ0nr, where ρs is the fraction of entries of S0 that are
nonzero. Since µ0 ≥1 always, this statement only guarantees recovery if ρs = O((nr)−1/2); i.e.,
even when rank(L0) = O(1), only vanishing fractions of the entries in S0 can be nonzero.
In contrast, our result shows that for incoherent L0, correct recovery occurs with high probability
for rank(L0) on the order of n/[µ log2 n] and a number of nonzero entries in S0 on the order of n2.
That is, matrices of large rank can be recovered from non-vanishing fractions of sparse errors. This
improvement comes at the expense of introducing one piece of randomness: a uniform model on
the error support.6
Our analysis has one additional advantage, which is of signiﬁcant practical importance: it identiﬁes a simple, non-adaptive choice of the regularization parameter λ. In contrast, the conditions
on the regularization parameter given by Chandrasekaran et al. depend on quantities which in
practice are not known a-priori. The experimental section of suggests searching for the correct
λ by solving many convex programs. Our result, on the other hand, demonstrates that the simple
choice λ = 1/√n works with high probability for recovering any square incoherent matrix.
Implications for matrix completion from grossly corrupted data
We have seen that our main result asserts that it is possible to recover a low-rank matrix even
though a signiﬁcant fraction of its entries are corrupted.
In some applications, however, some
of the entries may be missing as well, and this section addresses this situation. Let PΩbe the
orthogonal projection onto the linear space of matrices supported on Ω⊂[n1] × [n2],
(i, j) ∈Ω,
(i, j) /∈Ω.
Then imagine we only have available a few entries of L0 + S0, which we conveniently write as
Y = PΩobs(L0 + S0) = PΩobsL0 + S′
6Notice that the bound of depends only on the support of S0, and hence can be interpreted as a worst case
result with respect to the signs of S0. In contrast, our result does not randomize over the signs, but does assume that
they are sampled from a ﬁxed sign pattern. Although we do not pursue it here due to space limitations, our analysis
also yields a result which holds for worst case sign patterns, and guarantees correct recovery with rank(L0) = O(1),
and a sparsity pattern of cardinality ρn1n2 for some ρ > 0.
that is, we see only those entries (i, j) ∈Ωobs ⊂[n1] × [n2]. This models the following problem: we
wish to recover L0 but only see a few entries about L0, and among those a fraction happens to be
corrupted, and we of course do not know which one. As is easily seen, this is a signiﬁcant extension
of the matrix completion problem, which seeks to recover L0 from undersampled but otherwise
perfect data PΩobsL0.
We propose recovering L0 by solving the following problem:
∥L∥∗+ λ∥S∥1
subject to
PΩobs(L + S) = Y.
In words, among all decompositions matching the available data, Principal Component Pursuit
ﬁnds the one that minimizes the weighted combination of the nuclear norm, and of the ℓ1 norm. Our
observation is that under some conditions, this simple approach recovers the low-rank component
exactly. In fact, the techniques developed in this paper establish this result:
Theorem 1.2 Suppose L0 is n × n, obeys the conditions (1.2)–(1.3), and that Ωobs is uniformly
distributed among all sets of cardinality m obeying m = 0.1n2. Suppose for simplicity, that each
observed entry is corrupted with probability τ independently of the others. Then there is a numerical
constant c such that with probability at least 1 −cn−10, Principal Component Pursuit (1.5) with
0.1n is exact, i.e. ˆL = L0, provided that
rank(L0) ≤ρr nµ−1(log n)−2,
Above, ρr and τs are positive numerical constants. For general n1 × n2 rectangular matrices, PCP
with λ = 1/p0.1n(1) succeeds from m = 0.1n1n2 corrupted entries with probability at least 1−cn−10
provided that rank(L0) ≤ρr n(2)µ−1(log n(1))−2.
In short, perfect recovery from incomplete and corrupted entries is possible by convex optimization.
On the one hand, this result extends our previous result in the following way. If all the entries
are available, i.e. m = n1n2, then this is Theorem 1.1.
On the other hand, it extends matrix
completion results. Indeed, if τ = 0, we have a pure matrix completion problem from about a
fraction of the total number of entries, and our theorem guarantees perfect recovery as long as r
obeys (1.6), which for large values of r, matches the strongest results available. We remark that
the recovery is exact, however, via a diﬀerent algorithm. To be sure, in matrix completion one
typically minimizes the nuclear norm ∥L∥∗subject to the constraint PΩobsL = PΩobsL0. Here, our
program would solve
∥L∥∗+ λ∥S∥1
subject to
PΩobs(L + S) = PΩobsL0,
and return ˆL = L0, ˆS = 0! In this context, Theorem 1.2 proves that matrix completion is stable
vis a vis gross errors.
We have stated Theorem 1.2 merely to explain how our ideas can easily be adapted
to deal with low-rank matrix recovery problems from undersampled and possibly grossly corrupted
data. In our statement, we have chosen to see 10% of the entries but, naturally, similar results
hold for all other positive fractions provided that they are large enough. We would like to make it
clear that a more careful study is likely to lead to a stronger version of Theorem 1.2. In particular,
for very low rank matrices, we expect to see similar results holding with far fewer observations;
that is, in the limit of large matrices, from a decreasing fraction of entries. In fact, our techniques
would already establish such sharper results but we prefer not to dwell on such reﬁnements at the
moment, and leave this up for future work.
We provide a brief summary of the notations used throughout the paper. We shall use ﬁve norms
of a matrix. The ﬁrst three are functions of the singular values and they are: 1) the operator norm
or 2-norm denoted by ∥X∥; 2) the Frobenius norm denoted by ∥X∥F ; and 3) the nuclear norm
denoted by ∥X∥∗. The last two are the ℓ1 and ℓ∞norms of a matrix seen as a long vector, and
are denoted by ∥X∥1 and ∥X∥∞respectively. The Euclidean inner product between two matrices
is deﬁned by the formula ⟨X, Y ⟩:= trace(X∗Y ), so that ∥X∥2
F = ⟨X, X⟩.
Further, we will also manipulate linear transformations which act on the space of matrices, and
we will use calligraphic letters for these operators as in PΩX. We shall also abuse notation by also
letting Ωbe the linear space of matrices supported on Ω. Then PΩ⊥denotes the projection onto
the space of matrices supported on Ωc so that I = PΩ+ PΩ⊥, where I is the identity operator. We
will consider a single norm for these, namely, the operator norm (the top singular value) denoted
by ∥A∥, which we may want to think of as ∥A∥= sup{∥X∥F =1} ∥AX∥F ; for instance, ∥PΩ∥= 1
whenever Ω̸= ∅.
Organization of the paper
The paper is organized as follows. In Section 2, we provide the key steps in the proof of Theorem
1.1. This proof depends upon on two critical properties of dual certiﬁcates, which are established in
the separate Section 3. The reason why this is separate is that in a ﬁrst reading, the reader might
want to jump to Section 4, which presents applications to video surveillance, and computer vision.
Section 5 introduces algorithmic ideas to ﬁnd the Principal Component Pursuit solution when M
is of very large scale. We conclude the paper with a discussion about future research directions in
Section 6. Finally, the proof of Theorem 1.2 is in the Appendix, Section 7, together with those of
intermediate results.
Architecture of the Proof
This section introduces the key steps underlying the proof of our main result, Theorem 1.1. We
will prove the result for square matrices for simplicity, and write n = n1 = n2. Of course, we shall
indicate where the argument needs to be modiﬁed to handle the general case. Before we start,
it is helpful to review some basic concepts and introduce additional notation that shall be used
throughout. For a given scalar x, we denote by sgn(x) the sign of x, which we take to be zero if
x = 0. By extension, sgn(S) is the matrix whose entries are the signs of those of S. We recall that
any subgradient of the ℓ1 norm at S0 supported on Ω, is of the form
sgn(S0) + F,
where F vanishes on Ω, i.e. PΩF = 0, and obeys ∥F∥∞≤1.
We will also manipulate the set of subgradients of the nuclear norm. From now on, we will
assume that L0 of rank r has the singular value decomposition UΣV ∗, where U, V ∈Rn×r just as
in Section 1.3. Then any subgradient of the nuclear norm at L0 is of the form
where U∗W = 0, WV = 0 and ∥W∥≤1. Denote by T the linear space of matrices
T := {UX∗+ Y V ∗, X, Y ∈Rn×r},
and by T ⊥its orthogonal complement. It is not hard to see that taken together, U∗W = 0 and
WV = 0 are equivalent to PT W = 0, where PT is the orthogonal projection onto T. Another way to
put this is PT ⊥W = W. In passing, note that for any matrix M, PT ⊥M = (I −UU∗)M(I −V V ∗),
where we recognize that I −UU∗is the projection onto the orthogonal complement of the linear
space spanned by the columns of U and likewise for (I −V V ∗). A consequence of this simple
observation is that for any matrix M, ∥PT ⊥M∥≤∥M∥, a fact that we will use several times in the
sequel. Another consequence is that for any matrix of the form eie∗
F = ∥(I −UU∗)ei∥2∥(I −V V ∗)ej∥2 ≥(1 −µr/n)2,
where we have assumed µr/n ≤1. Since ∥PT eie∗
F + ∥PT ⊥eie∗
F = 1, this gives
For rectangular matrices, the estimate is ∥PT eie∗
min(n1,n2).
Finally, in the sequel we will write that an event holds with high or large probability whenever
it holds with probability at least 1 −O(n−10) (with n(1) in place of n for rectangular matrices).
An elimination theorem
We begin with a useful deﬁnition and an elementary result we shall use a few times.
Deﬁnition 2.1 We will say that S′ is a trimmed version of S if supp(S′) ⊂supp(S) and S′
whenever S′
In words, a trimmed version of S is obtained by setting some of the entries of S to zero. Having said
this, the following intuitive theorem asserts that if Principal Component Pursuit correctly recovers
the low-rank and sparse components of M0 = L0 + S0, it also correctly recovers the components of
a matrix M′
0 = L0 + S′
0 where S′
0 is a trimmed version of S0. This is intuitive since the problem is
somehow easier as there are fewer things to recover.
Theorem 2.2 Suppose the solution to (1.1) with input data M0 = L0 + S0 is unique and exact,
and consider M′
0 = L0 + S′
0, where S′
0 is a trimmed version of S0. Then the solution to (1.1) with
0 is exact as well.
Proof Write S′
0 = PΩ0S0 for some Ω0 ⊂[n] × [n] and let (ˆL, ˆS) be the solution of (1.1) with input
∥ˆL∥∗+ λ∥ˆS∥1 ≤∥L0∥∗+ λ∥PΩ0S0∥1
and, therefore,
∥ˆL∥∗+ λ∥ˆS∥1 + λ∥PΩ⊥
0 S0∥1 ≤∥L0∥∗+ λ∥S0∥1.
Note that (ˆL, ˆS + PΩ⊥
0 S0) is feasible for the problem with input data L0 + S0, and since ∥ˆS +
0 S0∥1 ≤∥ˆS∥1 + ∥PΩ⊥
0 S0∥1, we have
∥ˆL∥∗+ λ∥ˆS + PΩ⊥
0 S0∥1 ≤∥L0∥∗+ λ∥S0∥1.
The right-hand side, however, is the optimal value, and by unicity of the optimal solution, we must
have ˆL = L0, and ˆS + PΩ⊥
0 S0 = S0 or ˆS = PΩ0S0 = S′
0. This proves the claim.
The Bernoulli model.
In Theorem 1.1, probability is taken with respect to the uniformly
random subset Ω= {(i, j) : Sij ̸= 0} of cardinality m. In practice, it is a little more convenient to
work with the Bernoulli model Ω= {(i, j) : δij = 1}, where the δij’s are i.i.d. variables Bernoulli
taking value one with probability ρ and zero with probability 1−ρ, so that the expected cardinality
of Ωis ρn2. From now on, we will write Ω∼Ber(ρ) as a shorthand for Ωis sampled from the
Bernoulli model with parameter ρ.
Since by Theorem 2.2, the success of the algorithm is monotone in |Ω|, any guarantee proved for
the Bernoulli model holds for the uniform model as well, and vice versa, if we allow for a vanishing
shift in ρ around m/n2. The arguments underlying this equivalence are standard, see , and
may be found in the Appendix for completeness.
Derandomization
In Theorem 1.1, the values of the nonzero entries of S0 are ﬁxed. It turns out that it is easier
to prove the theorem under a stronger assumption, which assumes that the signs of the nonzero
entries are independent symmetric Bernoulli variables, i.e. take the value ±1 with probability
1/2 (independently of the choice of the support set). The convenient theorem below shows that
establishing the result for random signs is suﬃcient to claim a similar result for ﬁxed signs.
Theorem 2.3 Suppose L0 obeys the conditions of Theorem 1.1 and that the locations of the nonzero
entries of S0 follow the Bernoulli model with parameter 2ρs, and the signs of S0 are i.i.d. ±1 as
above (and independent from the locations). Then if the PCP solution is exact with high probability,
then it is also exact with at least the same probability for the model in which the signs are ﬁxed and
the locations are sampled from the Bernoulli model with parameter ρs.
This theorem is convenient because to prove our main result, we only need to show that it is true
in the case where the signs of the sparse component are random.
Proof Consider the model in which the signs are ﬁxed. In this model, it is convenient to think of
S0 as PΩS, for some ﬁxed matrix S, where Ωis sampled from the Bernoulli model with parameter
ρs. Therefore, S0 has independent components distributed as
w. p. 1 −ρs.
Consider now a random sign matrix with i.i.d. entries distributed as
w. p. 1 −2ρs,
and an “elimination” matrix ∆with entries deﬁned by
if Eij[sgn(S)]ij = −1,
otherwise.
Note that the entries of ∆are independent since they are functions of independent variables.
Consider now S′
0 = ∆◦(|S| ◦E), where ◦denotes the Hadamard or componentwise product so
0]ij = ∆ij (|Sij|Eij). Then we claim that S′
0 and S0 have the same distribution. To see why
this is true, it suﬃces by independence to check that the marginals match. For Sij ̸= 0, we have
0]ij = Sij) = P(∆ij = 1 and Eij = [sgn(S)]ij)
= P(Eij[sgn(S)]ij ̸= −1 and Eij = [sgn(S)]ij)
= P(Eij = [sgn(S)]ij) = ρs,
which establishes the claim.
This construction allows to prove the theorem. Indeed, |S|◦E now obeys the random sign model,
and by assumption, PCP recovers |S| ◦E with high probability. By the elimination theorem, this
program also recovers S′
0 = ∆◦(|S| ◦E). Since S′
0 and S0 have the same distribution, the theorem
Dual certiﬁcates
We introduce a simple condition for the pair (L0, S0) to be the unique optimal solution to Principal
Component Pursuit. These conditions are stated in terms of a dual vector, the existence of which
certiﬁes optimality. (Recall that Ωis the space of matrices with the same support as the sparse
component S0, and that T is the space deﬁned via the the column and row spaces of the low-rank
component L0 (2.1).)
Lemma 2.4 Assume that ∥PΩPT ∥< 1. With the standard notations, (L0, S0) is the unique solution if there is a pair (W, F) obeying
UV ∗+ W = λ(sgn(S0) + F),
with PT W = 0, ∥W∥< 1, PΩF = 0 and ∥F∥∞< 1.
Note that the condition ∥PΩPT ∥< 1 is equivalent to saying that Ω∩T = {0}.
Proof We consider a feasible perturbation (L0 + H, S0 −H) and show that the objective increases
whenever H ̸= 0, hence proving that (L0, S0) is the unique solution. To do this, let UV ∗+ W0 be
an arbitrary subgradient of the nuclear norm at L0, and sgn(S0) + F0 be an arbitrary subgradient
of the ℓ1-norm at S0. By deﬁnition of subgradients,
∥L0 + H∥∗+ λ∥S0 −H∥1 ≥∥L0∥∗+ λ∥S0∥1 + ⟨UV ∗+ W0, H⟩−λ⟨sgn(S0) + F0, H⟩.
Now pick W0 such that ⟨W0, H⟩= ∥PT ⊥H∥∗and F0 such that ⟨F0, H⟩= −∥PΩ⊥H∥1.7 We have
∥L0 + H∥∗+ λ∥S0 −H∥1 ≥∥L0∥∗+ λ∥S0∥1 + ∥PT ⊥H∥∗+ λ∥PΩ⊥H∥1 + ⟨UV ∗−λsgn(S0), H⟩.
7For instance, F0 = −sgn(PΩ⊥H) is such a matrix. Also, by duality between the nuclear and the operator norm,
there is a matrix obeying ∥W∥= 1 such that ⟨W, PT ⊥H⟩= ∥PT ⊥H∥∗, and we just take W0 = PT ⊥(W).
By assumption
|⟨UV ∗−λsgn(S0), H⟩| ≤|⟨W, H⟩| + λ|⟨F, H⟩| ≤β(∥PT ⊥H∥∗+ λ∥PΩ⊥H∥1)
for β = max(∥W∥, ∥F∥∞) < 1 and, thus,
∥L0 + H∥∗+ λ∥S0 −H∥1 ≥∥L0∥∗+ λ∥S0∥1 + (1 −β)
∥PT ⊥H∥∗+ λ∥PΩ⊥H∥1
Since by assumption, Ω∩T = {0}, we have ∥PT ⊥H∥∗+ λ∥PΩ⊥H∥1 > 0 unless H = 0.
Hence, we see that to prove exact recovery, it is suﬃcient to produce a ‘dual certiﬁcate’ W
PΩ(UV ∗+ W) = λsgn(S0),
∥PΩ⊥(UV ∗+ W)∥∞< λ.
Our method, however, will produce with high probability a slightly diﬀerent certiﬁcate. The idea
is to slightly relax the constraint PΩ(UV ∗+ W) = λsgn(S0), a relaxation that has been introduced
by David Gross in in a diﬀerent context. We prove the following lemma.
Lemma 2.5 Assume ∥PΩPT ∥≤1/2 and λ < 1. Then with the same notation, (L0, S0) is the
unique solution if there is a pair (W, F) obeying
UV ∗+ W = λ(sgn(S0) + F + PΩD)
with PT W = 0 and ∥W∥≤1
2, PΩF = 0 and ∥F∥∞≤1
2, and ∥PΩD∥F ≤1
Proof Following the proof of Lemma 2.4, we have
∥L0 + H∥∗+ λ∥S0 −H∥1 ≥∥L0∥∗+ λ∥S0∥1 + 1
∥PT ⊥H∥∗+ λ∥PΩ⊥H∥1
−λ⟨PΩD, H⟩
≥∥L0∥∗+ λ∥S0∥1 + 1
∥PT ⊥H∥∗+ λ∥PΩ⊥H∥1
4 ∥PΩH∥F .
Observe now that
∥PΩH∥F ≤∥PΩPT H∥F + ∥PΩPT ⊥H∥F
2∥H∥F + ∥PT ⊥H∥F
2∥PΩH∥F + 1
2∥PΩ⊥H∥F + ∥PT ⊥H∥F
and, therefore,
∥PΩH∥F ≤∥PΩ⊥H∥F + 2∥PT ⊥H∥F .
In conclusion,
∥L0 + H∥∗+ λ∥S0 −H∥1 ≥∥L0∥∗+ λ∥S0∥1 + 1
(1 −λ)∥PT ⊥H∥∗+ λ
and the term between parenthesis is strictly positive when H ̸= 0.
As a consequence of Lemma 2.5, it now suﬃces to produce a dual certiﬁcate W obeying
∥PΩ(UV ∗−λsgn(S0) + W)∥F ≤λ/4,
∥PΩ⊥(UV ∗+ W)∥∞< λ/2.
Further, we would like to note that the existing literature on matrix completion gives good
bounds on ∥PΩPT ∥, see Theorem 2.6 in Section 2.5.
Dual certiﬁcation via the golﬁng scheme
In the papers , Gross introduces a new scheme, termed the golﬁng scheme, to construct a
dual certiﬁcate for the matrix completion problem, i.e. the problem of reconstructing a low-rank
matrix from a subset of its entries. In this section, we will adapt this clever golﬁng scheme, with
two important modiﬁcations, to our separation problem.
Before we introduce our construction, our model assumes that Ω∼Ber(ρ), or equivalently that
Ωc ∼Ber(1 −ρ). Now the distribution of Ωc is the same as that of Ωc = Ω1 ∪Ω2 ∪. . . ∪Ωj0, where
each Ωj follows the Bernoulli model with parameter q, which has an explicit expression. To see
this, observe that by independence, we just need to make sure that any entry (i, j) is selected with
the right probability. We have
P((i, j) ∈Ω) = P(Bin(j0, q) = 0) = (1 −q)j0,
so that the two models are the same if
ρ = (1 −q)j0,
hence justifying our assertion. Note that because of overlaps between the Ωj’s, q ≥(1 −ρ)/j0.
We now propose constructing a dual certiﬁcate
W = W L + W S,
where each component is as follows:
1. Construction of W L via the golﬁng scheme.
Fix an integer j0 ≥1 whose value shall be
discussed later, and let Ωj, 1 ≤j ≤j0, be deﬁned as above so that Ωc = ∪1≤j≤j0Ωj. Then
starting with Y0 = 0, inductively deﬁne
Yj = Yj−1 + q−1PΩjPT (UV ∗−Yj−1),
W L = PT ⊥Yj0.
This is a variation on the golﬁng scheme discussed in , which assumes that the Ωj’s
are sampled with replacement, and does not use the projector PΩj but something more
complicated taking into account the number of times a speciﬁc entry has been sampled.
2. Construction of W S via the method of least squares. Assume that ∥PΩPT ∥< 1/2. Then
∥PΩPT PΩ∥< 1/4 and, thus, the operator PΩ−PΩPT PΩmapping Ωonto itself is invertible;
we denote its inverse by (PΩ−PΩPT PΩ)−1. We then set
W S = λPT ⊥(PΩ−PΩPT PΩ)−1sgn(S0).
Clearly, an equivalent deﬁnition is via the convergent Neumann series
W S = λPT ⊥
(PΩPT PΩ)ksgn(S0).
Note that PΩW S = λPΩ(I −PT )(PΩ−PΩPT PΩ)−1sgn(S0) = λsgn(S0).
With this, the
construction has a natural interpretation: one can verify that among all matrices W ∈T ⊥
obeying PΩW = λsgn(S0), W S is that with minimum Frobenius norm.
Since both W L and W S belong to T ⊥and PΩW S = λsgn(S0), we will establish that W L + W S is
a valid dual certiﬁcate if it obeys
∥W L + W S∥< 1/2,
∥PΩ(UV ∗+ W L)∥F ≤λ/4,
∥PΩ⊥(UV ∗+ W L + W S)∥∞< λ/2.
Key lemmas
We now state three lemmas, which taken collectively, establish our main theorem. The ﬁrst may
be found in .
Theorem 2.6
[8, Theorem 4.1] Suppose Ω0 is sampled from the Bernoulli model with parameter
ρ0. Then with high probability,
0 PT PΩ0PT ∥≤ϵ,
provided that ρ0 ≥C0 ϵ−2 µr log n
for some numerical constant C0 > 0 (µ is the incoherence parameter). For rectangular matrices, we need ρ0 ≥C0 ϵ−2 µr log n(1)
Among other things, this lemma is important because it shows that ∥PΩPT ∥≤1/2, provided
|Ω| is not too large. Indeed, if Ω∼Ber(ρ), we have
∥PT −(1 −ρ)−1PT PΩ⊥PT ∥≤ϵ,
with the proviso that 1 −ρ ≥C0 ϵ−2 µr log n
. Note, however, that since I = PΩ+ PΩ⊥,
PT −(1 −ρ)−1PT PΩ⊥PT = (1 −ρ)−1(PT PΩPT −ρPT )
and, therefore, by the triangular inequality
∥PT PΩPT ∥≤ϵ(1 −ρ) + ρ∥PT ∥= ρ + ϵ(1 −ρ).
Since ∥PΩPT ∥2 = ∥PT PΩPT ∥, we have established the following:
Corollary 2.7 Assume that Ω∼Ber(ρ), then ∥PΩPT ∥2 ≤ρ+ϵ, provided that 1−ρ ≥C0 ϵ−2 µr log n
where C0 is as in Theorem 2.6. For rectangular matrices, the modiﬁcation is as in Theorem 2.6.
The lemma below is proved is Section 3.
Lemma 2.8 Assume that Ω∼Ber(ρ) with parameter ρ ≤ρs for some ρs > 0. Set j0 = 2⌈log n⌉
(use log n(1) for rectangular matrices). Then under the other assumptions of Theorem 1.1, the
matrix W L (2.5) obeys
(a) ∥W L∥< 1/4,
(b) ∥PΩ(UV ∗+ W L)∥F < λ/4,
(c) ∥PΩ⊥(UV ∗+ W L)∥∞< λ/4.
Since ∥PΩPT ∥< 1 with large probability, W S is well deﬁned and the following holds.
Lemma 2.9 Assume that S0 is supported on a set Ωsampled as in Lemma 2.8, and that the signs
of S0 are i.i.d. symmetric (and independent of Ω). Then under the other assumptions of Theorem
1.1, the matrix W S (2.6) obeys
(a) ∥W S∥< 1/4,
(b) ∥PΩ⊥W S∥∞< λ/4.
The proof is also in Section 3. Clearly, W L and W S obey (2.8), hence certifying that Principal
Component Pursuit correctly recovers the low-rank and sparse components with high probability when the signs of S0 are random. The earlier “derandomization” argument then establishes
Theorem 1.1.
Proofs of Dual Certiﬁcation
This section proves the two crucial estimates, namely, Lemma 2.8 and Lemma 2.9.
Preliminaries
We begin by recording two results which shall be useful in proving Lemma 2.8. While Theorem 2.6
asserts that with large probability,
0 PT PΩ0Z∥F ≤ϵ∥Z∥F ,
for all Z ∈T, the next lemma shows that for a ﬁxed Z, the sup-norm of Z −ρ−1
0 PT PΩ0(Z) also
does not increase (also with large probability).
Lemma 3.1 Suppose Z ∈T is a ﬁxed matrix, and Ω0 ∼Ber(ρ0). Then with high probability,
0 PT PΩ0Z∥∞≤ϵ∥Z∥∞
provided that ρ0 ≥C0 ϵ−2 µr log n
(for rectangular matrices, ρ0 ≥C0 ϵ−2 µr log n(1)
) for some numerical constant C0 > 0.
The proof is an application of Bernstein’s inequality and may be found in the Appendix. A similar
but somewhat diﬀerent version of (3.1) appears in .
The second result was proved in .
[8, Theorem 6.3] Suppose Z is ﬁxed, and Ω0 ∼Ber(ρ0). Then with high probability,
0 PΩ0)Z∥≤C′
for some small numerical constant C′
0 > 0 provided that ρ0 ≥C0
(or ρ0 ≥C′
µ log n(1)
rectangular matrices in which case n(1) log n(1) replaces n log n in (3.2)).
As a remark, Lemmas 3.1 and 3.2, and Theorem 2.6 all hold with probability at least 1 −O(n−β),
β > 2, if C0 is replaced by Cβ for some numerical constant C > 0.
Proof of Lemma 2.8
We begin by introducing a piece of notation and set Zj = UV ∗−PT Yj obeying
Zj = (PT −q−1PT PΩjPT )Zj−1.
Obviously Zj ∈T for all j ≥0. First, note that when
q ≥C0 ϵ−2 µr log n
(for rectangular matrices, take q ≥C0 ϵ−2 µr log n(1)
), we have
∥Zj∥∞≤ϵ∥Zj−1∥∞
by Lemma 3.1. (This holds with high probability because Ωj and Zj−1 are independent, and this
is why the golﬁng scheme is easy to use.) In particular, this gives that with high probability
∥Zj∥∞≤ϵj∥UV ∗∥∞.
When q obeys the same estimate,
∥Zj∥F ≤ϵ∥Zj−1∥F
by Theorem 2.6. In particular, this gives that with high probability
∥Zj∥F ≤ϵj∥UV ∗∥F = ϵj√r.
Below, we will assume ϵ ≤e−1.
Proof of (a).
We prove the ﬁrst part of the lemma and the argument parallels that in , see
also . From
q−1PΩjZj−1,
∥W L∥= ∥PT ⊥Yj0∥≤
∥q−1PT ⊥PΩjZj−1∥
∥PT ⊥(q−1PΩjZj−1 −Zj−1)∥
∥q−1PΩjZj−1 −Zj−1∥
ϵj−1∥UV ∗∥∞
The fourth step follows from Lemma 3.2 and the ﬁfth from (3.5). Since ∥UV ∗∥∞≤√µr/n, this
for some numerical constant C′ whenever q obeys (3.3).
Proof of (b).
Since PΩYj0 = 0,
PΩ(UV ∗+ PT ⊥Yj0) = PΩ(UV ∗−PT Yj0) = PΩ(Zj0),
and it follows from (3.6) that
∥Zj0∥F ≤ϵj0∥UV ∗∥F = ϵj0√r.
Since ϵ ≤e−1 and j0 ≥2 log n, ϵj0 ≤1/n2 and this proves the claim.
Proof of (c).
We have UV ∗+ W L = Zj0 + Yj0 and know that Yj0 is supported on Ωc. Therefore,
since ∥Zj0∥F ≤λ/8, it suﬃces to show that ∥Yj0∥∞≤λ/8. We have
∥Yj0∥∞≤q−1 X
∥PΩjZj−1∥∞
ϵj∥UV ∗∥∞.
Since ∥UV ∗∥∞≤√µr/n, this gives
µr(log n)2
for some numerical constant C′ whenever q obeys (3.3). Since λ = 1/√n, ∥Yj0∥∞≤λ/8 if
µr(log n)2
We have seen that (a) and (b) are satisﬁed if ϵ is suﬃciently small and j0 ≥2 log n. For
(c), we can take ϵ on the order of (µr(log n)2/n)1/4, which will be suﬃciently small as well provided
that ρr in (1.4) is suﬃciently small. Note that everything is consistent since C0 ϵ−2 µr log n
This concludes the proof of Lemma 2.8.
Proof of Lemma 2.9
It is convenient to introduce the sign matrix E = sgn(S0) distributed as
w. p. ρ/2,
w. p. 1 −ρ,
w. p. ρ/2.
We shall be interested in the event {∥PΩPT ∥≤σ} which holds with large probability when σ =
√ρ + ϵ, see Corollary 2.7. In particular, for any σ > 0, {∥PΩPT ∥≤σ} holds with high probability
provided ρ is suﬃciently small.
Proof of (a).
By construction,
W S = λPT ⊥E + λPT ⊥
(PΩPT PΩ)kE
:= PT ⊥W S
0 + PT ⊥W S
For the ﬁrst term, we have ∥PT ⊥W S
0 ∥= λ∥E∥. Then standard arguments about the norm
of a matrix with i.i.d. entries give 
with large probability. Since λ = 1/√n, this gives ∥W S
0 ∥≤4√ρ. When the matrix is rectangular,
∥E∥≤4pn(1)ρ
with high probability. Since λ = 1/√n(1) in this case, ∥W S
0 ∥≤4√ρ as well.
k≥1(PΩPT PΩ)k and observe that R is self-adjoint. For the second term, ∥PT ⊥W S
1 ∥, where W S
1 = λR(E). We need to bound the operator norm of the matrix R(E), and use a
standard covering argument to do this. Throughout, N denotes an 1/2-net for Sn−1 of size at most
6n (such a net exists, see [31, Theorem 4.16]). Then a standard argument shows that
x,y∈Sn−1⟨y, R(E)x⟩≤4 sup
⟨y, R(E)x⟩.
For a ﬁxed pair (x, y) of unit-normed vectors in N × N, deﬁne the random variable
X(x, y) := ⟨y, R(E)x⟩= ⟨R(yx∗), E⟩.
Conditional on Ω= supp(E), the signs of E are i.i.d. symmetric and Hoeﬀding’s inequality gives
P(|X(x, y)| > t | Ω) ≤2 exp
Now since ∥yx∗∥F = 1, the matrix R(yx∗) obeys ∥R(yx∗)∥F ≤∥R∥and, therefore,
|X(x, y)| > t | Ω
≤2|N|2 exp
P(∥R(E)∥> t | Ω) ≤2|N|2 exp
On the event {∥PΩPT ∥≤σ},
and, therefore, unconditionally,
P(∥R(E)∥> t) ≤2|N|2 exp
+ P(∥PΩPT ∥≥σ),
This gives
P(λ∥R(E)∥> t) ≤2 × 62n exp
+ P(∥PΩPT ∥≥σ).
With λ = 1/√n,
∥W S∥≤1/4,
with large probability, provided that σ, or equivalently ρ, is small enough.
Proof of (b).
Observe that
PΩ⊥W S = −λPΩ⊥PT (PΩ−PΩPT PΩ)−1E.
Now for (i, j) ∈Ωc, W S
ij = ⟨ei, W Sej⟩= ⟨eie∗
j, W S⟩, and we have
ij = λ⟨X(i, j), E⟩,
where X(i, j) is the matrix −(PΩ−PΩPT PΩ)−1PΩPT (eie∗
j). Conditional on Ω= supp(E), the
signs of E are i.i.d. symmetric, and Hoeﬀding’s inequality gives
ij| > tλ | Ω) ≤2 exp
∥X(i, j)∥2
and, thus,
ij| > tλ | Ω
supi,j ∥X(i, j)∥2
Since (2.2) holds, we have
∥PΩPT (eie∗
j)∥F ≤∥PΩPT ∥∥PT (eie∗
on the event {∥PΩPT ∥≤σ}. On the same event, ∥(PΩ−PΩPT PΩ)−1∥≤(1−σ2)−1 and, therefore,
∥X(i, j)∥2
Then unconditionally,
+ P(∥PΩPT ∥≥σ),
γ = (1 −σ2)2
This proves the claim when µr < ρ′
rn(log n)−1 and ρ′
r is suﬃciently small.
Numerical Experiments and Applications
In this section, we perform numerical experiments corroborating our main results and suggesting
their many applications in image and video analysis. We ﬁrst investigate Principal Component
Pursuit’s ability to correctly recover matrices of various rank from errors of various density. We then
sketch applications in background modeling from video and removing shadows and specularities
from face images.
While the exact recovery guarantee provided by Theorem 1.1 is independent of the particular
algorithm used to solve Principal Component Pursuit, its applicability to large scale problems
depends on the availability of scalable algorithms for nonsmooth convex optimization. For the
experiments in this section, we use the an augmented Lagrange multiplier algorithm introduced
in .8
In Section 5, we describe this algorithm in more detail, and explain why it is our
algorithm of choice for sparse and low-rank separation.
One important implementation detail in our approach is the choice of λ. Our analysis identiﬁes
one choice, λ = 1/
max(n1, n2), which works well for incoherent matrices. In order to illustrate the
theory, throughout this section we will always choose λ = 1/
max(n1, n2). For practical problems,
however, it is often possible to improve performance by choosing λ according to prior knowledge
about the solution. For example, if we know that S is very sparse, increasing λ will allow us to
recover matrices L of larger rank. For practical problems, we recommend λ = 1/
max(n1, n2) as
a good rule of thumb, which can then be adjusted slightly to obtain the best possible result.
Exact recovery from varying fractions of error
We ﬁrst verify the correct recovery phenomenon of Theorem 1.1 on randomly generated problems.
We consider square matrices of varying dimension n = 500, . . . , 3000. We generate a rank-r matrix
L0 as a product L0 = XY ∗where X and Y are n × r matrices with entries independently sampled
from a N(0, 1/n) distribution. S0 is generated by choosing a support set Ωof size k uniformly at
random, and setting S0 = PΩE, where E is a matrix with independent Bernoulli ±1 entries.
Table 1 (top) reports the results with r = rank(L0) = 0.05 × n and k = ∥S0∥0 = 0.05 × n2.
Table 1 (bottom) reports the results for a more challenging scenario, rank(L0) = 0.05 × n and
8Both have posted a version of their code online.
Dimension n
1.1 × 10−6
1.2 × 10−6
1.2 × 10−6
2.3 × 10−6
rank(L0) = 0.05 × n, ∥S0∥0 = 0.05 × n2.
Dimension n
1.2 × 10−6
2.4 × 10−6
2.4 × 10−6
2.5 × 10−6
rank(L0) = 0.05 × n, ∥S0∥0 = 0.10 × n2.
Table 1: Correct recovery for random problems of varying size. Here, L0 = XY ∗∈Rn×n
with X, Y ∈Rn×r; X, Y have entries i.i.d. N(0, 1/n). S0 ∈{−1, 0, 1}n×n has support chosen
uniformly at random and independent random signs; ∥S0∥0 is the number of nonzero entries
in S0. Top: recovering matrices of rank 0.05 × n from 5% gross errors. Bottom: recovering
matrices of rank 0.05 × n from 10% gross errors. In all cases, the rank of L0 and ℓ0-norm of
S0 are correctly estimated. Moreover, the number of partial singular value decompositions (#
SVD) required to solve PCP is almost constant.
k = 0.10×n2. In all cases, we set λ = 1/√n. Notice that in all cases, solving the convex PCP gives
a result (L, S) with the correct rank and sparsity. Moreover, the relative error ∥L −L0∥F /∥L0∥F
is small, less than 10−5 in all examples considered.9
The last two columns of Table 1 give the number of partial singular value decompositions
computed in the course of the optimization (# SVD) as well as the total computation time. This
experiment was performed in Matlab on a Mac Pro with dual quad-core 2.66 GHz Intel Xenon
processors and 16 GB RAM. As we will discuss in Section 5 the dominant cost in solving the
convex program comes from computing one partial SVD per iteration. Strikingly, in Table 1, the
number of SVD computations is nearly constant regardless of dimension, and in all cases less than
17.10 This suggests that in addition to being theoretically well-founded, the recovery procedure
advocated in this paper is also reasonably practical.
Phase transition in rank and sparsity
Theorem 1.1 shows that convex programming correctly recovers an incoherent low-rank matrix
from a constant fraction ρs of errors. We next empirically investigate the algorithm’s ability to
recover matrices of varying rank from errors of varying sparsity. We consider square matrices of
9We measure relative error in terms of L only, since in this paper we view the sparse and low-rank decomposition
as recovering a low-rank matrix L0 from gross errors. S0 is of course also well-recovered: in this example, the relative
error in S is actually smaller than that in L.
10One might reasonably ask whether this near constant number of iterations is due to the fact that random problems
are in some sense well-conditioned. There is some validity to this concern, as we will see in our real data examples. 
suggests a continuation strategy (there termed “Inexact ALM”) that produces qualitatively similar solutions with a
similarly small number of iterations. However, to the best of our knowledge its convergence is not guaranteed.
dimension n1 = n2 = 400. We generate low-rank matrices L0 = XY ∗with X and Y independently
chosen n × r matrices with i.i.d. Gaussian entries of mean zero and variance 1/n. For our ﬁrst
experiment, we assume a Bernoulli model for the support of the sparse term S0, with random signs:
each entry of S0 takes on value 0 with probability 1 −ρ, and values ±1 each with probability ρ/2.
For each (r, ρ) pair, we generate 10 random problems, each of which is solved via the algorithm of
Section 5. We declare a trial to be successful if the recovered ˆL satisﬁes ∥L −L0∥F /∥L0∥F ≤10−3.
Figure 1 (left) plots the fraction of correct recoveries for each pair (r, ρ). Notice that there is a
large region in which the recovery is exact. This highlights an interesting aspect of our result: the
recovery is correct even though in some cases ∥S0∥F ≫∥L0∥F (e.g., for r/n = ρ, ∥S0∥F is √n = 20
times larger!). This is to be expected from Lemma 2.4: the existence (or non-existence) of a dual
certiﬁcate depends only on the signs and support of S0 and the orientation of the singular spaces
However, for incoherent L0, our main result goes one step further and asserts that the signs of
S0 are also not important: recovery can be guaranteed as long as its support is chosen uniformly
at random. We verify this by again sampling L0 as a product of Gaussian matrices and choosing
the support Ωaccording to the Bernoulli model, but this time setting S0 = PΩsgn(L0). One might
expect such S0 to be more diﬃcult to distinguish from L0. Nevertheless, our analysis showed that
the number of errors that can be corrected drops by at most 1/2 when moving to this more diﬃcult
model. Figure 1 (middle) plots the fraction of correct recoveries over 10 trials, again varying r and
ρ. Interestingly, the region of correct recovery in Figure 1 (middle) actually appears to be broader
than that in Figure 1 (left). Admittedly, the shape of the region in the upper-left corner is puzzling,
but has been ‘conﬁrmed’ by several distinct simulation experiments (using diﬀerent solvers).
Finally, inspired by the connection between matrix completion and robust PCA, we compare
the breakdown point for the low-rank and sparse separation problem to the breakdown behavior of
the nuclear-norm heuristic for matrix completion. By comparing the two heuristics, we can begin
to answer the question how much is gained by knowing the location Ωof the corrupted entries?
Here, we again generate L0 as a product of Gaussian matrices.
However, we now provide the
algorithm with only an incomplete subset M = PΩ⊥L0 of its entries. Each (i, j) is included in Ω
independently with probability 1 −ρ, so rather than a probability of error, here, ρ stands for the
probability that an entry is omitted. We solve the nuclear norm minimization problem
subject to
PΩ⊥L = PΩ⊥M
using an augmented Lagrange multiplier algorithm very similar to the one discussed in Section 5.
We again declare L0 to be successfully recovered if ∥L−L0∥F /∥L0∥F < 10−3. Figure 1 (right) plots
the fraction of correct recoveries for varying r, ρ. Notice that nuclear norm minimization successfully
recovers L0 over a much wider range of (r, ρ). This is interesting because in the regime of large
k, k = Ω(n2), the best performance guarantees for each heuristic agree in their order of growth
– both guarantee correct recovery for rank(L0) = O(n/ log2 n). Fully explaining the diﬀerence in
performance between the two problems may require a sharper analysis of the breakdown behavior
Application sketch: background modeling from surveillance video
Video is a natural candidate for low-rank modeling, due to the correlation between frames. One
of the most basic algorithmic tasks in video surveillance is to estimate a good model for the
(a) Robust PCA, Random Signs
(b) Robust PCA, Coherent Signs
(c) Matrix Completion
Figure 1: Correct recovery for varying rank and sparsity. Fraction of correct recoveries
across 10 trials, as a function of rank(L0) (x-axis) and sparsity of S0 (y-axis). Here, n1 = n2 =
400. In all cases, L0 = XY ∗is a product of independent n × r i.i.d. N(0, 1/n) matrices. Trials
are considered successful if ∥ˆL−L0∥F /∥L0∥F < 10−3. Left: low-rank and sparse decomposition,
sgn(S0) random. Middle: low-rank and sparse decomposition, S0 = PΩsgn(L0). Right: matrix
completion. For matrix completion, ρs is the probability that an entry is omitted from the
observation.
background variations in a scene. This task is complicated by the presence of foreground objects:
in busy scenes, every frame may contain some anomaly. Moreover, the background model needs to
be ﬂexible enough to accommodate changes in the scene, for example due to varying illumination.
In such situations, it is natural to model the background variations as approximately low rank.
Foreground objects, such as cars or pedestrians, generally occupy only a fraction of the image
pixels and hence can be treated as sparse errors.
We investigate whether convex optimization can separate these sparse errors from the lowrank background. Here, it is important to note that the error support may not be well-modeled
as Bernoulli: errors tend to be spatially coherent, and more complicated models such as Markov
random ﬁelds may be more appropriate . Hence, our theorems do not necessarily guarantee
the algorithm will succeed with high probability. Nevertheless, as we will see, Principal Component
Pursuit still gives visually appealing solutions to this practical low-rank and sparse separation
problem, without using any additional information about the spatial structure of the error.
We consider two example videos introduced in . The ﬁrst is a sequence of 200 grayscale
frames taken in an airport. This video has a relatively static background, but signiﬁcant foreground
variations. The frames have resolution 176 × 144; we stack each frame as a column of our matrix
M ∈R25,344×200. We decompose M into a low-rank term and a sparse term by solving the convex
PCP problem (1.1) with λ = 1/√n1. On a desktop PC with a 2.33 GHz Core2 Duo processor
and 2 GB RAM, our Matlab implementation requires 806 iterations, and roughly 43 minutes to
converge.11 Figure 2(a) shows three frames from the video; (b) and (c) show the corresponding
columns of the low rank matrix ˆL and sparse matrix ˆS (its absolute value is shown here). Notice
that ˆL correctly recovers the background, while ˆS correctly identiﬁes the moving pedestrians. The
person appearing in the images in ˆL does not move throughout the video.
Figure 2 (d) and (e) compares the result obtained by Principal Component Pursuit to a state-of-
11The paper suggests a variant of ALM optimization procedure, there termed the “Inexact ALM” that ﬁnds
a visually similar decomposition in far fewer iterations (less than 50). However, since the convergence guarantee for
that variant is weak, we choose to present the slower, exact result here.
(a) Original frames
(b) Low-rank ˆL
(c) Sparse ˆS
(d) Low-rank ˆL
(e) Sparse ˆS
Convex optimization (this work)
Alternating minimization 
Figure 2: Background modeling from video. Three frames from a 200 frame video sequence
taken in an airport .
(a) Frames of original video M.
(b)-(c) Low-rank ˆL and sparse
components ˆS obtained by PCP, (d)-(e) competing approach based on alternating minimization
of an m-estimator .
PCP yields a much more appealing result despite using less prior
knowledge.
the-art technique from the computer vision literature, .12 That approach also aims at robustly
recovering a good low-rank approximation, but uses a more complicated, nonconvex m-estimator,
which incorporates a local scale estimate that implicitly exploits the spatial characteristics of natural
This leads to a highly nonconvex optimization, which is solved locally via alternating
minimization. Interestingly, despite using more prior information about the signal to be recovered,
this approach does not perform as well as the convex programming heuristic: notice the large
artifacts in the top and bottom rows of Figure 2 (d).
In Figure 3, we consider 250 frames of a sequence with several drastic illumination changes.
Here, the resolution is 168 × 120, and so M is a 20, 160 × 250 matrix.
For simplicity, and to
illustrate the theoretical results obtained above, we again choose λ = 1/√n1.13 For this example,
on the same 2.66 GHz Core 2 Duo machine, the algorithm requires a total of 561 iterations and 36
minutes to converge.
Figure 3 (a) shows three frames taken from the original video, while (b) and (c) show the
recovered low-rank and sparse components, respectively.
Notice that the low-rank component
correctly identiﬁes the main illuminations as background, while the sparse part corresponds to the
motion in the scene. On the other hand, the result produced by the algorithm of treats some
12We use the code package downloaded from modi-
ﬁed to choose the rank of the approximation as suggested in .
13For this example, slightly more appealing results can actually be obtained by choosing larger λ (say, 2/√n1).
(a) Original frames
(b) Low-rank ˆL
(c) Sparse ˆS
(d) Low-rank ˆL
(e) Sparse ˆS
Convex optimization (this work)
Alternating minimization 
Figure 3: Background modeling from video. Three frames from a 250 frame sequence taken in
a lobby, with varying illumination . (a) Original video M. (b)-(c) Low-rank ˆL and sparse ˆS
obtained by PCP. (d)-(e) Low-rank and sparse components obtained by a competing approach
based on alternating minimization of an m-estimator . Again, convex programming yields
a more appealing result despite using less prior information.
of the ﬁrst illumination as foreground. PCP again outperforms the competing approach, despite
using less prior information. These results suggest the potential power for convex programming as
a tool for video analysis.
Notice that the number of iterations for the real data is typically higher than that of the
simulations with random matrices given in Table 1.
The reason for this discrepancy might be
that the structures of real data could slightly deviate from the idealistic low-rank and sparse
model. Nevertheless, it is important to realize that practical applications such as video surveillance
often provide additional information about the signals of interest, e.g. the support of the sparse
foreground is spatially piecewise contiguous, or even impose additional requirements, e.g.
recovered background needs to be non-negative etc. We note that the simplicity of our objective
and solution suggests that one can easily incorporate additional constraints and more accurate
models of the signals so as to obtain much more eﬃcient and accurate solutions in the future.
Application sketch: removing shadows and specularities from face images
Face recognition is another problem domain in computer vision where low-dimensional linear models
have received a great deal of attention. This is mostly due to the work of Basri and Jacobs, who
showed that for convex, Lambertian objects, images taken under distant illumination lie near an
approximately nine-dimensional linear subspace known as the harmonic plane . However, since
faces are neither perfectly convex nor Lambertian, real face images often violate this low-rank
Figure 4: Removing shadows, specularities, and saturations from face images. (a) Cropped
and aligned images of a person’s face under diﬀerent illuminations from the Extended Yale
B database. The size of each image is 192 × 168 pixels, a total of 58 diﬀerent illuminations
were used for each person. (b) Low-rank approximation ˆL recovered by convex programming.
(c) Sparse error ˆS corresponding to specularities in the eyes, shadows around the nose region,
or brightness saturations on the face. Notice in the bottom left that the sparse term also
compensates for errors in image acquisition.
model, due to cast shadows and specularities. These errors are large in magnitude, but sparse in
the spatial domain. It is reasonable to believe that if we have enough images of the same face,
Principal Component Pursuit will be able to remove these errors. As with the previous example,
some caveats apply: the theoretical result suggests the performance should be good, but does not
guarantee it, since again the error support does not follow a Bernoulli model. Nevertheless, as we
will see, the results are visually striking.
Figure 4 shows two examples with face images taken from the Yale B face database . Here,
each image has resolution 192 × 168; there are a total of 58 illuminations per subject, which we
stack as the columns of our matrix M ∈R32,256×58. We again solve PCP with λ = 1/√n1. In
this case, the algorithm requires 642 iterations to converge, and the total computation time on the
same Core 2 Duo machine is 685 seconds.
Figure 4 plots the low rank term ˆL and the magnitude of the sparse term ˆS obtained as the
solution to the convex program. The sparse term ˆS compensates for cast shadows and specular
regions. In one example (bottom row of Figure 4 left), this term also compensates for errors in image
acquisition. These results may be useful for conditioning the training data for face recognition, as
well as face alignment and tracking under illumination variations.
Algorithms
Theorem 1.1 shows that incoherent low-rank matrices can be recovered from nonvanishing fractions
of gross errors in polynomial time. Moreover, as the experiments in the previous section attest,
the low computation cost is guaranteed not only in theory, the eﬃciency is becoming practical for
real imaging problems. This practicality is mainly due to the rapid recent progress in scalable
algorithms for nonsmooth convex optimization, in particular for minimizing the ℓ1 and nuclear
norms. In this section, we brieﬂy review this progress, and discuss our algorithm of choice for this
For small problem sizes, Principal Component Pursuit
∥L∥∗+ λ∥S∥1
subject to
can be performed using oﬀ-the-shelf tools such as interior point methods . This was suggested
for rank minimization in and for low-rank and sparse decomposition (see also ).
However, despite their superior convergence rates, interior point methods are typically limited to
small problems, say n < 100, due to the O(n6) complexity of computing a step direction.
The limited scalability of interior point methods has inspired a recent ﬂurry of work on ﬁrst-order
methods. Exploiting an analogy with iterative thresholding algorithms for ℓ1-minimization ,
Cai et. al. developed an algorithm that performs nuclear-norm minimization by repeatedly shrinking
the singular values of an appropriate matrix, essentially reducing the complexity of each iteration
to the cost of an SVD .
However, for our low-rank and sparse decomposition problem, this
form of iterative thresholding converges slowly, requiring up to 104 iterations. Ma et. al. 
suggest improving convergence using continuation techniques, and also demonstrate how Bregman
iterations can be applied to nuclear norm minimization.
The convergence of iterative thresholding has also been greatly improved using ideas from
Nesterov’s optimal ﬁrst-order algorithm for smooth minimization , which was extended to nonsmooth optimization in , and applied to ℓ1-minimization in . Based on , Toh et.
al. developed a proximal gradient algorithm for matrix completion which they termed Accelerated
Proximal Gradient (APG). A very similar APG algorithm was suggested for low-rank and sparse
decomposition in . That algorithm inherits the optimal O(1/k2) convergence rate for this class of
problems. Empirical evidence suggests that these algorithms can solve the convex PCP problem at
least 50 times faster than straightforward iterative thresholding (for more details and comparisons,
see ).
However, despite its good convergence guarantees, the practical performance of APG depends
strongly on the design of good continuation schemes. Generic continuation does not guarantee good
accuracy and convergence across a wide range of problem settings.14 In this paper, we have chosen
to instead solve the convex PCP problem (1.1) using an augmented Lagrange multiplier (ALM)
algorithm introduced in .
In our experience, ALM achieves much higher accuracy than
APG, in fewer iterations. It works stably across a wide range of problem settings with no tuning
of parameters. Moreover we observe an appealing (empirical) property: the rank of the iterates
often remains bounded by rank(L0) throughout the optimization, allowing them to be computed
especially eﬃciently. APG, on the other hand, does not have this property.
14In our experience, the optimal choice may depend on the relative magnitudes of the L and S terms and the
sparsity of the corruption.
The ALM method operates on the augmented Lagrangian
l(L, S, Y ) = ∥L∥∗+ λ∥S∥1 + ⟨Y, M −L −S⟩+ µ
2 ∥M −L −S∥2
A generic Lagrange multiplier algorithm would solve PCP by repeatedly setting (Lk, Sk) =
arg minL,S l(L, S, Yk), and then updating the Lagrange multiplier matrix via Yk+1 = Yk + µ(M −
For our low-rank and sparse decomposition problem, we can avoid having to solve a sequence of
convex programs by recognizing that minL l(L, S, Y ) and minS l(L, S, Y ) both have very simple and
eﬃcient solutions. Let Sτ : R →R denote the shrinkage operator Sτ[x] = sgn(x) max(|x| −τ, 0),
and extend it to matrices by applying it to each element. It is easy to show that
S l(L, S, Y ) = Sλµ−1(M −L + µ−1Y ).
Similarly, for matrices X, let Dτ(X) denote the singular value thresholding operator given by
Dτ(X) = USτ(Σ)V ∗, where X = UΣV ∗is any singular value decomposition. It is not diﬃcult to
L l(L, S, Y ) = Dµ−1(M −S −µ−1Y ).
Thus, a more practical strategy is to ﬁrst minimize l with respect to L (ﬁxing S), then minimize l
with respect to S (ﬁxing L), and then ﬁnally update the Lagrange multiplier matrix Y based on
the residual M −L −S, a strategy that is summarized as Algorithm 1 below.
Algorithm 1 (Principal Component Pursuit by Alternating Directions )
1: initialize: S0 = Y0 = 0, µ > 0.
2: while not converged do
compute Lk+1 = Dµ−1(M −Sk −µ−1Yk);
compute Sk+1 = Sλµ−1(M −Lk+1 + µ−1Yk);
compute Yk+1 = Yk + µ(M −Lk+1 −Sk+1);
6: end while
7: output: L, S.
Algorithm 1 is a special case of a more general class of augmented Lagrange multiplier algorithms
known as alternating directions methods . The convergence of these algorithms has been wellstudied (see e.g. and the many references therein, as well as discussion in ). Algorithm
1 performs excellently on a wide range of problems: as we saw in Section 3, relatively small numbers
of iterations suﬃce to achieve good relative accuracy.
The dominant cost of each iteration is
computing Lk+1 via singular value thresholding. This requires us to compute those singular vectors
of M −Sk −µ−1Yk whose corresponding singular values exceed the threshold µ−1. Empirically,
we have observed that the number of such large singular values is often bounded by rank(L0),
allowing the next iterate to be computed eﬃciently via a partial SVD.15 The most important
implementation details for this algorithm are the choice of µ and the stopping criterion. In this
work, we simply choose µ = n1n2/4∥M∥1, as suggested in . We terminate the algorithm when
∥M −L −S∥F ≤δ∥M∥F , with δ = 10−7.
15Further performance gains might be possible by replacing this partial SVD with an approximate SVD, as suggested
in for nuclear norm minimization.
Very similar ideas can be used to develop simple and eﬀective augmented Lagrange multiplier
algorithms for matrix completion , and for the robust matrix completion problem (1.5) discussed
in Section 1.6, with similarly good performance.
In the preceding section, all simulations and
experiments are therefore conducted using ALM-based algorithms. For a more thorough discussion,
implementation details and comparisons with other algorithms, please see .
Discussion
This paper delivers some rather surprising news: one can disentangle the low-rank and sparse
components exactly by convex programming, and this provably works under very broad conditions
that are much broader than those provided by the best known results. Further, our analysis has
revealed rather close relationships between matrix completion and matrix recovery (from sparse
errors) and our results even generalize to the case when there are both incomplete and corrupted
entries (i.e.
Theorem 1.2).
In addition, Principal Component Pursuit does not have any free
parameter and can be solved by simple optimization algorithms with remarkable eﬃciency and
accuracy. More importantly, our results may point to a very wide spectrum of new theoretical and
algorithmic issues together with new practical applications that can now be studied systematically.
Our study so far is limited to the low-rank component being exactly low-rank, and the sparse
component being exactly sparse. It would be interesting to investigate when either or both these
assumptions are relaxed. One way to think of this is via the new observation model M = L0 +S0 +
N0, where N0 is a dense, small perturbation accounting for the fact that the low-rank component
is only approximately low-rank and that small errors can be added to all the entries (in some sense,
this model uniﬁes the classical PCA and the robust PCA by combining both sparse gross errors and
dense small noise). The ideas developed in in connection with the stability of matrix completion
under small perturbations may be useful here. Even more generally, the problems of sparse signal
recovery, low-rank matrix completion, classical PCA, and robust PCA can all be considered as
special cases of a general measurement model of the form
M = A(L0) + B(S0) + C(N0),
where A, B, C are known linear maps. An ambitious goal might be to understand exactly under what
conditions, one can eﬀectively retrieve or decompose L0 and S0 from such noisy linear measurements
via convex programming.
The remarkable ability of convex optimizations in recovering low-rank matrices and sparse
signals in high-dimensional spaces suggest that they will be a powerful tool for processing massive
data sets that arise in image/video processing, web data analysis, and bioinformatics. Such data
are often of millions or even billions of dimensions so the computational and memory cost can be
far beyond that of a typical PC. Thus, one important direction for future investigation is to develop
algorithms that have even better scalability, and can be easily implemented on the emerging parallel
and distributed computing infrastructures.
Equivalence of sampling models
We begin by arguing that a recovery result under the Bernoulli model automatically implies a
corresponding result for the uniform model. Denote by PUnif(m) and PBer(p) probabilities calculated
under the uniform and Bernoulli models and let “Success” be the event that the algorithm succeeds.
PBer(p)(Success) =
PBer(p)(Success | |Ω| = k) PBer(p)(|Ω| = k)
PBer(p)(|Ω| = k) +
PUnif(k)(Success) PBer(p)(|Ω| = k)
≤PBer(p)(|Ω| < m) + PUnif(m)(Success),
where we have used the fact that for k ≥m, PUnif(k)(Success) ≤PUnif(m)(Success), and that the
conditional distribution of Ωgiven its cardinality is uniform. Thus,
PUnif(m)(Success) ≥PBer(p)(Success) −PBer(p)(|Ω| < m).
Take p = m/n2 + ϵ, where ϵ > 0. The conclusion follows from PBer(p)(|Ω| < m) ≤e−ϵ2n2
2p . In the
other direction, the same reasoning gives
PBer(p)(Success) ≥
PBer(p)(Success | |Ω| = k) PBer(p)(|Ω| = k)
≥PUnif(m)(Success)
PBer(p)(|Ω| = k)
= PUnif(m)(Success) P(|Ω| ≤m),
and choosing m such that P(|Ω| > m) is exponentially small, establishes the claim.
Proof of Lemma 3.1
The proof is essentially an application of Bernstein’s inequality, which states that for a sum of
uniformly bounded independent random variables with |Yk −E Yk| < c,
(Yk −E Yk) > t
2σ2 + 2ct/3
where σ2 is the sum of the variances, σ2 ≡Pn
k=1 Var(Yk).
Deﬁne Ω0 via Ω0 = {(i, j) : δij = 1} where {δij} is an independent sequence of Bernoulli
variables with parameter ρ0. With this notation, Z′ = Z −ρ−1
0 PT PΩ0Z is given by
0 δij)ZijPT (eie∗
so that Z′
i0j0 is a sum of independent random variables,
Yij = (1 −ρ−1
0 δij)Zij⟨PT (eie∗
Var(Yij) = (1 −ρ0)ρ−1
|Zij|2|⟨PT (eie∗
≤(1 −ρ0)ρ−1
j, PT (ei0e∗
= (1 −ρ0)ρ−1
∞∥PT (ei0e∗
≤(1 −ρ0)ρ−1
where the last inequality holds because of (2.2). Also, it follows from (1.2) that |⟨PT (eie∗
j)∥F ∥PT (ei0e∗
j0)∥F ≤2µr/n so that |Yij| ≤ρ−1
0 ∥Z∥∞µr/n. Then Bernstein’s inequality
ij| > ϵ∥Z∥∞) ≤2 exp
If ρ0 is as in Lemma 3.1, the union bound proves the claim.
Proof of Theorem 1.2
This section presents a proof of Theorem 1.2, which resembles that of Theorem 1.1. Here and
0 = PΩobsS0 so that the available data are of the form Y = PΩobsL0 + S′
0. We make three
observations.
• If PCP correctly recovers L0 from the input data PΩobsL0 + S′
0 (note that this means that
ˆL = L0 and ˆS = S′
0), then it must correctly recover L0 from PΩobsL0 + S′′
0, where S′′
a trimmed version of S′
0. The proof is identical to that of our elimination result, namely,
Theorem 2.2. The derandomization argument then applies and it suﬃces to consider the case
where the signs of S′
0 are i.i.d. symmetric Bernoulli variables.
• It is of course suﬃcient to prove the theorem when each entry in Ωobs is revealed with
probability p0 := 0.1, i.e. when Ωobs ∼Ber(p0).
• We establish the theorem in the case where n1 = n2 = n as slight modiﬁcations would give
the general case.
Further, there are now three index sets of interest:
• Ωobs are those locations where data are available.
• Γ ⊂Ωobs are those locations where data are available and clean; that is, PΓY = PΓL0.
• Ω= Ωobs \ Γ are those locations where data are available but totally unreliable.
The matrix S′
0 is thus supported on Ω. If Ωobs ∼Ber(p0), then by deﬁnition, Ω∼Ber(p0τ).
Dual certiﬁcation.
We begin with two lemmas concerning dual certiﬁcation.
Lemma 7.1 Assume ∥PΓ⊥PT ∥< 1. Then (L0, S′
0) is the unique solution if there is a pair (W, F)
UV ∗+ W = λ(sgn(S′
with PT W = 0, ∥W∥< 1, PΓ⊥F = 0 and ∥F∥∞< 1.
The proof is about the same as that of Lemma 2.4, and is discussed in very brief terms. The idea
is to consider a feasible perturbation of the form (L0 + HL, S′
0 −HS) obeying PΩobsHL = PΩobsHS,
and show that this increases the objective functional unless HL = HS = 0. Then a sequence of
steps similar to that in the proof of Lemma 2.4 establishes
∥L0 + HL∥∗+ λ∥S′
0 −HS∥1 ≥∥L0∥∗+ λ∥S′
0∥1 + (1 −β)(∥PT ⊥HL∥∗+ λ∥PΓHL∥1),
where β = max(∥W∥, ∥F∥∞). Finally, ∥PT ⊥HL∥∗+λ∥PΓHL∥1 vanishes if and only if HL ∈Γ⊥∩T =
Lemma 7.2 Assume that for any matrix M, ∥PT PΓ⊥M∥F ≤n∥PT ⊥PΓ⊥M∥F and take λ > 4/n.
Then (L0, S′
0) is the unique solution if there is a pair (W, F) obeying
UV ∗+ W + PT D = λ(sgn(S′
with PT W = 0, ∥W∥< 1/2, PΓ⊥F = 0 and ∥F∥∞< 1/2, and ∥PT D∥F ≤n−2.
Note that ∥PT PΓ⊥M∥F ≤n∥PT ⊥PΓ⊥M∥F implies Γ⊥∩T = {0}, or equivalently ∥PΓ⊥PT ∥< 1.
Indeed if M ∈Γ⊥∩T, PT PΓ⊥M = M while PT ⊥PΓ⊥M = 0, and thus M = 0.
Proof It follows from (7.2) together with the same argument as in the proof of Lemma 7.2 that
∥L0 + HL∥∗+ λ∥S′
0 −HS∥1 ≥∥L0∥∗+ λ∥S′
∥PT ⊥HL∥∗+ λ∥PΓHL∥1
n2 ∥PT HL∥F .
Observe now that
∥PT HL∥F ≤∥PT PΓHL∥F + ∥PT PΓ⊥HL∥F
≤∥PT PΓHL∥F + n∥PT ⊥PΓ⊥HL∥F
≤∥PT PΓHL∥F + n(∥PT ⊥PΓHL∥F + ∥PT ⊥HL∥F )
≤(n + 1)∥PΓHL∥F + n∥PT ⊥HL∥F .
Using both ∥PΓHL∥F ≤∥PΓHL∥1 and ∥PT ⊥HL∥F ≤∥PT ⊥HL∥∗, we obtain
∥L0 + HL∥∗+ λ∥S′
0 −HS∥1 ≥∥L0∥∗+ λ∥S′
∥PT ⊥HL∥∗+
The claim follows from Γ⊥∩T = {0}.
Lemma 7.3 Under the assumptions of Theorem 1.2, the assumption of Lemma 7.2 is satisﬁed with
high probability. That is, ∥PT PΓ⊥M∥F ≤n∥PT ⊥PΓ⊥M∥F for all M.
Set ρ0 = p0(1 −τ) and M′ = PΓ⊥M.
Since Γ ∼Ber(ρ0), Theorem 2.6 gives ∥PT −
0 PT PΓPT ∥≤1/2 with high probability. Further, because ∥PΓPT M′∥F = ∥PΓPT ⊥M′∥F , we
∥PΓPT M′∥F ≤∥PT ⊥M′∥F .
In the other direction,
0 ∥PΓPT M′∥2
0 ⟨PT M′, PT PΓPT M′)
= ⟨PT M′, PT M′⟩+ ⟨PT M′, (ρ−1
0 PT PΓPT −PT )M′)
In conclusion, ∥PT ⊥M′∥F ≥∥PΓPT M′∥F ≥ρ0
2 ∥PT M′∥F , and the claim follows since ρ0
Thus far, our analysis shows that to establish our theorem, it suﬃces to construct a pair
(Y L, W S) obeying
∥PT ⊥Y L∥< 1/4,
∥PT Y L −UV ∗∥F ≤n−2,
PΓ⊥Y L = 0,
∥PΓY L∥∞< λ/4,
PT W S = 0,
∥W S∥≤1/4,
PΩW S = λsgn(S′
obsW S = 0,
∥PΓW S∥∞≤λ/4.
Indeed, by deﬁnition, Y L + W S obeys
Y L + W S = λ(sgn(S′
where F is as in Lemma 7.2, and it can also be expressed as
Y L + W S = UV ∗+ W + PT D,
where W and PT D are as in this lemma as well.
Construction of the dual certiﬁcate Y L.
We use the golﬁng scheme to construct Y L. Think
of Γ ∼Ber(ρ0) with ρ0 = p0(1 −τ) as ∪1≤j≤j0Γj, where the sets Γj ∼Ber(q) are independent, and
q obeys ρ0 = 1−(1−q)j0. Here, we take j0 = ⌈3 log n⌉, and observe that q ≥ρ0/j0 as before. Then
starting with Y0 = 0, inductively deﬁne
Yj = Yj−1 + q−1PΓjPT (UV ∗−Yj−1),
Y L = Yj0 = q−1 X
Zj = (PT −q−1PT PΓjPT )Zj−1.
By construction, PΓ⊥Y L = 0. Now just as in Section (3.2), because q is suﬃciently large, ∥Zj∥≤
e−j∥UV ∗∥∞and ∥Zj∥F ≤e−j√r, both inequality holding with large probability. The proof is now
identical to that in (2.5). First, the same steps show that
∥PT ⊥Y L∥≤C
∥UV ∗∥∞= C′
µr(log n)2
Whenever ρ0 ≥C0
µr(log n)2
for a suﬃciently large value of the constant C0 (which is possible
provided that ρr in (1.6) is suﬃciently small), this terms obeys ∥PT ⊥Y L∥≤1/4 as required.
∥PT Y L −UV ∗∥F = ∥Zj0∥F ≤e−3 log n√r ≤n−2.
And third, the same steps give
∥Y L∥∞≤q−1∥UV ∗∥∞
e−j ≤3(1 −e−1)
µr(log n)2
Now it suﬃces to bound the right-hand side by
This is automatic when ρ0 ≥
µr(log n)2
whenever C0 is suﬃciently large and, thus, the situation is as before. In conclusion, we
have established that Y L obeys (7.3) with high probability.
Construction of the dual certiﬁcate W S.
We ﬁrst establish that with high probability,
τ ′ = τ + τ0,
where τ0(τ) is a continuous function of τ approaching zero when τ approaches zero. In other words,
the parameter τ ′ may become arbitrary small constant by selecting τ small enough. This claim is
a straight application of Corollary 2.7. We also have
obs)PΩ∥≤2τ ′.
with high probability. This second claim uses the identity
obs)PΩ= PΩPT (PT PΩobsPT )−1PT PΩ.
This is well deﬁned since the restriction of PT PΩobsPT to T is invertible. Indeed, Theorem 2.6 gives
PT PΩobsPT ≥p0
2 PT and, therefore, ∥(PT PΩobsPT )−1∥≤2p−1
0 . Hence,
obs)PΩ∥≤2p−1
0 ∥PΩPT ∥2,
and (7.6) follows from (7.5).
Setting E = sgn(S′
0), this allows to deﬁne W S via
W S = λ(I −P(T+Ω⊥
obs))(PΩ−PΩP(T+Ω⊥
obs)PΩ)−1E
:= (I −P(T+Ω⊥
0 = λE, and W S
1 = RE with R = P
k≥1(PΩP(T+Ω⊥
obs)PΩ)k. The operator R is selfadjoint and obeys ∥R∥≤
1−2τ ′ with high probability. By construction, PT W S = PΩ⊥
obsW S = 0
and PΩW S = λsgn(S′
0). It remains to check that both events ∥W S∥≤1/4 and ∥PΓW S∥∞≤λ/4
hold with high probability.
Control of ∥W S∥. For the ﬁrst term, we have ∥(I −P(T+Ω⊥
0 ∥= λ∥E∥. Because
the entries of E are i.i.d. and take the value ±1 each with probability p0τ/2, and the value 0 with
probability 1 −p0τ, standard arguments give
np0(τ + τ0)
with large probability. Since λ = 1/√p0n, ∥W S
0 ∥≤4√τ + τ0 < 1/8 with high probability, provided
τ is small enough.
For the second term, ∥(I −P(T+Ω⊥
1 ∥≤λ∥RE∥, and the same covering argument as before
P(λ∥R(E)∥> t) ≤2 × 62n exp
+ P(∥R∥≥σ).
Since λ = 1/√np0 this shows that ∥W S∥≤1/4 with high probability, since one can always choose
σ, or equivalently τ ′ = τ + τ0, suﬃciently small.
Control of ∥PΓW S∥∞. For (i, j) ∈Γ, we have
ij = ⟨eie∗
j, W S⟩= λ⟨X(i, j), E⟩,
X(i, j) = (PΩ−PΩP(T+Ω⊥
obs)PΩ)−1PΩP(T+Ω⊥
The same strategy as before gives
∥X(i, j)∥F > σ
It remains to control the Frobenius norm of X(i, j). To do this, we use the identity
j = PΩPT (PT PΩobsPT )−1PT eie∗
which gives
with high probability. This follows from the fact that ∥(PT PΩobsPT )−1∥≤2p−1
and ∥PΩPT ∥≤
√p0τ ′ as we have already seen. Since we also have ∥(PΩ−PΩP(T+Ω⊥
obs)PΩ)−1∥≤
1−2τ ′ with high
probability,
∥X(i, j)∥F ≤
This shows that ∥PΓW S∥∞≤λ/4 if τ ′, or equivalently τ, is suﬃciently small.
Acknowledgements
E. C. is supported by ONR grants N00014-09-1-0469 and N00014-08-1-0749 and by the Waterman
Award from NSF. Y. M. is partially supported by the grants NSF IIS 08-49292, NSF ECCS 07-
01676, and ONR N00014-09-1-0230. E. C. would like to thank Deanna Needell for comments on an
earlier version of this manuscript. We would also like to thank Zhouchen Lin (MSRA) for his help
with the ALM algorithm, and Hossein Mobahi (UIUC) for his help with some of the simulations.