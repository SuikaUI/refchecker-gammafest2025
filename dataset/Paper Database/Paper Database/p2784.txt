DISEÑO ÓPTIMO DE UN MECANISMO
PARALELO ENFOCADO EN MANUFACTURA
Tesis para obtener el título de Doctor en Ciencias Aplicadas
DIEGO ALEJANDRO NÚÑEZ VALLEJOS
DISEÑO ÓPTIMO DE UN MECANISMO
PARALELO ENFOCADO EN MANUFACTURA
Tesis para obtener el título de Doctor en Ciencias Aplicadas
DIEGO ALEJANDRO NÚÑEZ VALLEJOS
Ing. Mauricio Felipe Mauledoux Monroy Ph.D.
Ing. Oscar Fernando Avilés Sánchez Ph.D.
Grupo de Investigación DAVINCI
Universidad Militar Nueva Granada
Bogotá, Colombia
Dedicado a mi adorada Adriana y a la luz de mis ojos, Verónica.
“Todo llega, todo pasa”
AGRADECIMIENTOS
Agradezco a todas aquellas personas que ayudaron a hacer posible esta tesis, a los doctores Mauricio
Mauledoux y Oscar Avilés porque su paciencia, empatía, asesoría y apoyo fue mucho más que académico.
Igualmente, a los jurados Dr. Jaime Gallardo, Dr.Efrén Mezura y Dr. Carlos Rodriguez por sus minuciosas
evaluaciones, valiosos comentarios y sugerencias. Adicionalmte, doy gracias a todos los profesores que me
guiaron y fueron parte en mi desarrollo académico y profesional.
Agradezco a mi esposa Adriana porque siempre mostró un apoyo incondicional y permanente, aunque
estas palabras no hacen justicia a todo el esfuerzo y sacrificio que mostró en estos años. También agradezco
a mis padres Esther Vallejos y Alberto Nuñez por su confianza inquebrantable y su soporte en los momentos
más dificiles.
Gracias a la Dra. Paola Niño del Instituto Politecnico Nacional por su guía en la estancia doctoral y a la
Universidad Militar Nueva Granada por permitirme realizar los estudios de doctorado.
La manufactura aditiva es una técnica cuyo principio técnico es la adición de capas de material para
fabricar piezas. Aunque se han hecho estudios en pro de su mejora en aspectos de deposición, control de
temperatura, flujos y movimientos, estas últimas aún presentan retos a superar. Las máquinas
convencionales tienen movimientos cartesianos que genera dificultades relacionados con el acabado, con
los requerimientos isotrópicos, con la unión de capas, con el uso de material de soporte, con las bajas
velocidades de impresión y con la imposibilidad de imprimir alrededor de obstáculos. Con el fin de mejorar
estos aspectos, algunos desarrollos han usado mecanismos paralelos como mecanismo base de movimiento;
sin embargo, las técnicas convencionales de diseño estos mecanismos se han concentrado en dividir esta
etapa en fases. Usualmente, se concentran los primeros esfuerzos en los requerimientos estructurales y
geométricos, para luego pasar a la fase de control. El resultado de esto son mecanismos sobredimensionados
con altos requerimientos energéticos y costos elevados. Por tal motivo es necesario desarrollar un
mecanismo paralelo enfocado en manufactura aditiva que incremente la multidireccionalidad del sistema y
optimice los requerimientos volumétricos, con movimientos suaves, demanda energética pequeña y buena
precisión de movimientos.
En búsqueda de lo anterior, se planteó una estrategia de diseño considerando siete aspectos. Primero, se
analizaron estudios previos propios y de terceros. Segundo, se hizo el análisis cinemático y dinámico del
mecanismo considerando estrategias computacionalmente viables. Tercero, se halló el espacio de trabajo
computacionalmente eficiente debido a sus características discretas y técnicas de búsqueda. Cuarto, se
planteó un nuevo índice de manipulabilidad debido a las características de movimiento de los actuadores.
Quinto, como el mecanismo debe tener movimientos suaves, se consideraron estrategias de control robustas
y se examinaron sus errores y esfuerzos de control implementando un nuevo controlador híbrido, que
contempla planitud diferencial y modos deslizantes. Sexto, de la estrategia de control, se obtuvieron
indicadores de desempeño energético y de eficiencia de control. Septimo, los indicadores de desempeño
anteriormente mencionados sirvieron para el planteamiento de funciones objetivo que junto con sus
restricciones fueron evaluadas paralelamente en algoritmos metaheurísticos de optimización.
Esta estrategia de diseño no solo logró obtener un mecanismo paralelo con seis grados de libertad,
llamado HEXA, para su implementación en manufactura aditiva que suple las necesidades anteriormente
descritas, sino que, presentó nuevas formas de análisis y control de mecanismos de cinemática paralela que
involucran análisis y desarrollos geométrico, de movimiento y de control.
Finalmente, la metodología empleada puede ser la base para el análisis, diseño y optimización otros
mecanismos paralelos que consideren el WS, la manipulabilidad, y el control robusto cuyos indicadores
sean el error de control y el esfuerzo de control. Lo anterior hace que ésta forma de diseño tenga el potencial
de crear nuevas investigaciones, profesiones, industrias y empleos; impactando la academia y la industria.
Additive manufacturing is a technique whose technical principle is the addition of layers of material to
manufacture parts. Although studies have been conducted to improve deposition, temperature control,
flows, and movements, the latter still present challenges. Conventional machines have Cartesian directions
that generate difficulties related to finishing, isotropic requirements, layer bonding, use of support material,
low printing speeds, and the inability to print around obstacles. In order to improve these aspects, some
developments have used parallel manipulators as the base mechanism for movement. However,
conventional techniques for designing these manipulators have focused on dividing this stage into phases.
Typically, the initial efforts are concentrated on the structural and geometric requirements, followed by the
control phase. This results in oversized mechanisms with high energy requirements and high costs. For this
reason, it is necessary to develop a parallel mechanism focused on additive manufacturing that increases
the multi-directionality of the system and optimizes volumetric requirements with smooth movements, low
energy demand, and good movement accuracy.
In pursuit of the above, a design strategy was proposed considering seven aspects. First, previous studies
were analyzed, both proprietary and third-party. Second, the kinematic and dynamic analysis of the
mechanism was carried out, considering computationally viable strategies. Third, the computationally
efficient working volume was found due to its discrete characteristics and search techniques. Fourth, a new
manipulability index was proposed due to the movement characteristics of the actuators. Fifth, since the
mechanism must have smooth movements, robust control strategies were considered, and their control
errors and efforts were examined by implementing a new hybrid controller that includes differential flatness
and sliding modes. Sixth, energy performance, and control efficiency indicators were obtained from the
control strategy. Seventh, the aforementioned performance indicators were used to propose objective
functions that, together with their constraints, were evaluated in parallel in metaheuristic optimization
algorithms.
This design strategy not only achieved a parallel manipulator with six degrees of freedom, named
HEXA, for implementation in additive manufacturing that meets the previously described, but also
introduced novel methods for analyzing and controlling parallel kinematic mechanisms that encompass
geometric, kinematics, and control analysis.
Finally, the methodology can serve as the foundation for the analysis, design, and optimization of other
parallel mechanisms, that considers workspace, manipulability, and robust control with control error and
control effort as their indicators. This design approach has the potential to generate new research,
professions, industries, and jobs, thereby impacting academia and industry.
INTRODUCCIÓN ............................................................................................................................ 1
Descripción general................................................................................................................... 1
Objetivos ................................................................................................................................... 2
Objetivo general ................................................................................................................ 2
Objetivos específicos ........................................................................................................ 3
Metodología .............................................................................................................................. 3
Alcance del trabajo.................................................................................................................... 4
Contribuciones .......................................................................................................................... 5
Organización de la tesis ............................................................................................................ 6
MARCO TEÓRICO .......................................................................................................................... 7
Mecanismo paralelo .................................................................................................................. 7
Cinemática inversa .................................................................................................................... 9
Cinemática diferencial ............................................................................................................ 10
Generalidades .................................................................................................................. 10
Matriz Jacobiana ............................................................................................................. 10
Formulaciones para la obtención de la dinámica del mecanismo ........................................... 11
Formulación de Newton Euler ........................................................................................ 11
Formulación de Euler Laplace ........................................................................................ 11
Principio del trabajo virtual ............................................................................................. 12
Espacio de trabajo ................................................................................................................... 12
Enfoque geométrico ........................................................................................................ 13
Máximo volumen inscrito con CAD ............................................................................... 13
Método discreto............................................................................................................... 14
Análisis de límites por restricciones ............................................................................... 14
Manipulabilidad ...................................................................................................................... 14
Estrategia de control................................................................................................................ 15
Modos deslizantes ........................................................................................................... 15
Planitud diferencial ......................................................................................................... 21
Error y esfuerzo de control ...................................................................................................... 23
Optimización ........................................................................................................................... 24
Métodos de optimización clásicos .................................................................................. 24
Métodos de optimización no tradicionales ...................................................................... 25
Planteamiento de un problema de optimización ............................................................. 25
Concepto de dominancia ................................................................................................. 26
Frente de Pareto .............................................................................................................. 26
Métodos implementados ................................................................................................. 27
ESTADO DEL ARTE ..................................................................................................................... 29
Configuraciones mecánicas de los MPs .................................................................................. 29
Investigaciones en cinemática y dinámica .............................................................................. 38
Avances en estudio de cinemática inversa ...................................................................... 38
Progresos en modelación de la dinámica ........................................................................ 39
Tendencias en espacio de trabajo ............................................................................................ 41
Estrategias de control en MPs ................................................................................................. 44
Avances en la optimización de MPs ....................................................................................... 45
Conclusión del análisis del estado del arte .............................................................................. 46
DESCRIPCIÓN DEL MECANISMO ............................................................................................ 47
Selección del mecanismo ........................................................................................................ 47
Mecanismos analizados ................................................................................................... 47
Metodología de selección ................................................................................................ 47
Definición de criterios ..................................................................................................... 49
Especificaciones del mecanismo ............................................................................................. 51
Determinación de la cinemática inversa ................................................................................. 55
Vértices de las plataformas ............................................................................................. 55
Modelo matemático para la cinemática inversa .............................................................. 56
Desarrollo de la modelación dinámica .................................................................................... 60
Análisis de velocidad ...................................................................................................... 60
Análisis de aceleración .................................................................................................... 61
Matriz Jacobiana de velocidades ..................................................................................... 62
Matriz Jacobiana de aceleraciones .................................................................................. 63
Matrices Jacobianas de los eslabones ............................................................................. 63
Modelo dinámico por el principio de trabajo virtual....................................................... 64
DETERMINACIÓN DE LAS FUNCIONES OBJETIVO ............................................................. 70
Cálculo del espacio de trabajo ................................................................................................ 70
Evaluación de posición ................................................................................................... 70
Generación de nube de puntos ........................................................................................ 72
Cálculo del volumen ....................................................................................................... 74
Identificación de la manipulabilidad ....................................................................................... 75
Implementación de la estrategia de control ............................................................................. 76
Control equivalente por planitud diferencial ................................................................... 77
Control atractivo ............................................................................................................. 78
Esfuerzo de control ................................................................................................................. 81
Error de control ....................................................................................................................... 81
OPTIMIZACIÓN DEL SISTEMA ................................................................................................. 84
Variables de diseño ................................................................................................................. 84
Funciones objetivo .................................................................................................................. 84
Funciones objetivo geométricas ...................................................................................... 84
Funciones objetivo de control ......................................................................................... 85
Restricciones ........................................................................................................................... 87
Problema de optimización ....................................................................................................... 88
Análisis de dominancia ........................................................................................................... 89
Clasificación de hacinamiento ................................................................................................ 89
Evaluación del algoritmo ........................................................................................................ 90
Método de toma de decisión y espaciado ................................................................................ 91
. Implementación ..................................................................................................................... 92
RESULTADOS Y DISCUSIÓN .................................................................................................... 96
Producto del análisis de cinemática inversa ............................................................................ 96
Solución del WS...................................................................................................................... 99
Análisis de manipulabilidad .................................................................................................. 102
Efecto de la implementación de la estrategia de control ....................................................... 103
Indicador del esfuerzo de control .......................................................................................... 112
Ejecución de la optimización ................................................................................................ 113
Prototipo del HEXA 6 RUS .................................................................................................. 120
CONCLUSIONES ........................................................................................................................ 123
REFERENCIAS ........................................................................................................................................ 125
ANEXOS .................................................................................................................................................. 136
Anexo A ........................................................................................................................................... 137
Anexo B ........................................................................................................................................... 138
Anexo C ........................................................................................................................................... 140
Anexo D ........................................................................................................................................... 232
Anexo E ........................................................................................................................................... 236
Anexo F ........................................................................................................................................... 238
Anexo G ........................................................................................................................................... 246
Anexo H ........................................................................................................................................... 253
LISTA DE FIGURAS
Fig. 1-1. Esquemático de la metodología usada en el diseño más competitivo de un mecanismo paralelo. 4
Fig. 2-1. Esquemático de un A) MP serial y un B) MP paralelo ........................................................... 7
Fig. 2-2.A) MP rígido . B) MP guiado por cables. ................................................................................ 8
Fig. 2-3. Esquemático del MP 5R . ........................................................................................................ 9
Fig. 2-4. Esquemático del método de máximo volumen inscrito con CAD de un MP tipo Delta. A) Concepto
de intersección del volumen de los eslabones a una altura puntual. B) Máximo volumen inscrito . .. 13
Fig. 2-5.Esquemático del comportamiento del control discontinuo sobre la superficie . ..................... 17
Fig. 2-6. Capa límite . ........................................................................................................................... 17
Fig. 2-7. Variación de 𝑓𝑋, 𝑡, 𝜏 sobre el plano tangente . ...................................................................... 18
Fig. 2-8. Esquemático de difeomorfismo . ........................................................................................... 21
Fig. 2-9. Esquemático del error y esfuerzo de control. ............................................................................... 24
Fig. 2-10. Esquemático de un FP. ............................................................................................................... 26
Fig. 2-11. Ubicación de los puntos en una búsqueda por sección dorada ........................................... 27
Fig. 3-1. MP de 6 DOFs. A) Isométrico. B) Detalles del sistema rotacional superior . ....................... 30
Fig. 3-2. MP configurable . .................................................................................................................. 31
Fig. 3-3. 6 DOFs RSS . ......................................................................................................................... 31
Fig. 3-4. Esquemático del mecanismo y ensamble de un MP tipo Stewart de bajo costo . .................... 32
Fig. 3-6. Mecanismo tipo Hunt 6 RUS. A) Esquemático del MP. B) Vista superior de la configuración. .
.................................................................................................................................................................... 33
Fig. 3-7. Robot tipo Hexa . ................................................................................................................... 33
Fig. 3-8. MP de 4 DOFs libre de singularidades . ................................................................................ 34
Fig. 3-9. MP de 6 DOFs. A. Modelo virtual. B. Esquemático de las fuerzas en la plataforma móvil . 34
Fig. 3-10. MP de 6 DOFs. A) Esquemático del mecanismo. B) Configuración mecánica de la articulación
cilíndrica . ............................................................................................................................................. 35
Fig. 3-11. MP de 6 DOFs. A) Descripción de movimientos. B) Modelo fabricado . ........................... 35
Fig. 3-12. Prototipo virtual de un mecanismo con 5 DOFs . ................................................................ 36
Fig. 3-13. Descripción de mecanismo híbrido ..................................................................................... 37
Fig. 3-14. Hexapteron. A. Esquemático. B. Diseño mecánico . ........................................................... 37
Fig. 3-15. Arquitectura del mecanismo de múltiples rieles . ................................................................ 37
Fig. 3-16. MP configurable . ................................................................................................................ 38
Fig. 3-17. WS alcanzado por 3 diferentes MP. A) Tipo Hexa. B) Tipo Hunt. C) Tipo Zamanov . .. 42
Fig. 3-18. Posicionamiento del WS en un MP con análisis cilíndrico de espacio requerido de trabajo .
.................................................................................................................................................................... 44
Fig. 4-1. MPS preliminarmente seleccionados. .......................................................................................... 48
Fig. 4-2. Esquema de asociación de criterios .............................................................................................. 49
Fig. 4-3. Representación gráfica de la selección. ........................................................................................ 51
Fig. 4-4. Esquemático de la configuración del HEXA 6RUS. .................................................................... 52
Fig. 4-5. Esquemático de la configuración de un brazo del HEXA 6RUS. ................................................ 52
Fig. 4-6. Esquemático de la configuración de la plataforma fija superior HEXA 6RUS. .......................... 53
Fig. 4-7. Esquemático de la configuración de la plataforma móvil del HEXA 6RUS. ............................... 53
Fig. 4-8. Esquemático de la distribución de fuerzas de un brazo. ............................................................... 54
Fig. 4-9. Ubicación de los planos de referencia A) ℘ y B) ℏ. ................................................................... 59
Fig. 5-1. Esquemático de búsqueda sección dorada. ................................................................................... 71
Fig. 5-2. Puntos más bajos y altos del WS .................................................................................................. 72
Fig. 5-3. Puntos más bajos y altos del WS .................................................................................................. 74
Fig. 5-4. Esquemático de la creación de pirámides para calcular el ES. ..................................................... 74
Fig. 5-5. Esquemático de la discretización del WS para el análisis de manipulabilidad. ........................... 76
Fig. 5-6. Esquemático del control híbrido propuesto. ................................................................................. 76
Fig. 5-7. Esquemático del control equivalente por planitud diferencial. .................................................... 79
Fig. 5-8. Esquemático del controlador 𝜏𝑐𝑜𝑛. .............................................................................................. 81
Fig. 5-9. Esquemático de la obtención de EC. ............................................................................................ 82
Fig. 5-10. Esquemático del área bajo la curva del torque de un motor. ...................................................... 82
Fig. 6-1. Ejemplo de desplazamiento de prueba dentro del WS. Configuración 𝑙𝑏= 0.3 m y 𝑙𝑟= 0.3 m. ... 87
Fig. 6-2. Esquemático de la clasificación por hacinamiento . .............................................................. 90
Fig. 6-3. Comparación de FP del MOP, EDMER y GA de expresión de Binh .......................................... 91
Fig. 6-4. Comparación de FP del MOP, EDMER y GA de expresión de Viennet. .................................... 93
Fig. 6-5. Método de LINMAP de selección de punto más competitivo ............................................. 93
Fig. 7-1. Esquemático de la primera validación de la cinemática inversa. ................................................. 97
Fig. 7-2. Esquemático de la segunda validación de la cinemática inversa. ................................................. 97
Fig. 7-3. Esquemático de la tercera validación de la cinemática inversa. ................................................... 98
Fig. 7-4. Esquemático de la cuarta validación de la cinemática inversa. .................................................... 99
Fig. 7-5. Esquemático de la quinta validación de la cinemática inversa. .................................................... 99
Fig. 7-6. WS con una configuración de 𝑙𝑏= 0.07 m y 𝑙𝑟= 0.18 m. ...................................................... 100
Fig. 7-7. WS con una configuración de 𝑙𝑏= 0.5 m y 𝑙𝑟= 0.5 m. ........................................................... 101
Fig. 7-8. WS de diferentes configuraciones de 𝑙𝑏 y 𝑙𝑟. ............................................................................ 102
Fig. 7-9. WS con respecto a 𝑙𝑏/𝑙𝑟 del HEXA 6RUS ................................................................................ 102
Fig. 7-10. Número condicional de diferentes configuraciones de 𝑙𝑏 y 𝑙𝑟. ................................................ 103
Fig. 7-11. Controlador del HEXA 6RUS en Simulink® .......................................................................... 104
Fig. 7-12. Control equivalente en Simulink® ........................................................................................... 105
Fig. 7-13. Control atractivo en Simulink® ............................................................................................... 105
Fig. 7-14. Comparación de la posición deseada en X vs la generada controlada. .................................... 106
Fig. 7-15. Comparación de la posición deseada en Y vs la generada controlada. .................................... 106
Fig. 7-16. Comparación de la posición deseada en Z vs la generada controlada. ..................................... 107
Fig. 7-17. Comparación de la velocidad deseada en X vs la generada controlada. .................................. 107
Fig. 7-18. Comparación de la velocidad deseada en Y vs la generada controlada. .................................. 107
Fig. 7-19. Comparación de la velocidad deseada en Z vs la generada controlada. ................................... 108
Fig. 7-20. Comparación de la aceleración deseada en X vs la generada controlada. ................................ 108
Fig. 7-21. Comparación de la aceleración deseada en Y vs la generada controlada. ................................ 108
Fig. 7-22. Comparación de la aceleración deseada en Z vs la generada controlada. ................................ 109
Fig. 7-23. Comparación de 𝜃 vs la generada controlada. .......................................................................... 109
Fig. 7-24. Comparación de 𝜑 vs la generada controlada. ......................................................................... 109
Fig. 7-25. Comparación de 𝜓 vs la generada controlada. ......................................................................... 110
Fig. 7-26. Comparación de la velocidad 𝜃 vs la generada controlada. ..................................................... 110
Fig. 7-27. Comparación de la velocidad 𝜑 vs la generada controlada. ..................................................... 110
Fig. 7-28. Comparación de la velocidad 𝜓 vs la generada controlada. ..................................................... 111
Fig. 7-29. Comparación de la aceleración 𝜃 vs la generada controlada. ................................................... 111
Fig. 7-30. Comparación de la aceleración 𝜑 vs la generada controlada. .................................................. 111
Fig. 7-31. Comparación de la aceleración 𝜓 vs la generada controlada. .................................................. 112
Fig. 7-32. ECV de diferentes configuraciones de 𝑙𝑏 y 𝑙𝑟 con una señal sinoidal en solo Z. .................... 112
Fig. 7-33. ECV teniendo en cuenta la relación 𝑙𝑏𝑙𝑟. ................................................................................. 113
Fig. 7-34. FP A) normalizado y B) dimensionado de 𝜂 y 𝑊𝑆. ................................................................ 114
Fig. 7-35. FP A) normalizado y B) dimensionado de 𝐸𝐶 y 𝑊𝑆. .............................................................. 115
Fig. 7-36. FP A) normalizado y B) dimensionado 𝐸𝐶𝑉 y 𝜂. .................................................................... 116
Fig. 7-37. FP A) ECV y ec adimensional. B) ECV y ec, dimensionado. C) EC y ec. ................................. 117
Fig. 7-38. Convergencia en linea del espaciamiento. npop=1024, numGen=512. ................................... 118
Fig. 7-39. Convergencia en linea del 𝛬. npop=1024, numGen=512. ....................................................... 118
Fig. 7-40. Comportamiento del espaciado a diferentes ejecuciones. ........................................................ 119
Fig. 7-41. Comportamiento del 𝛬 a diferentes ejecuciones. ..................................................................... 119
Fig. 7-42. Valor de 𝛬 según la variación de npop. .................................................................................... 120
Fig. 7-43. Esquemático del modelo CAD del HEXA 6 RUS ................................................................... 121
Fig. 7-44. Modelo físico del HEXA 6 RUS.. ............................................................................................ 122
LISTA DE TABLAS
Tabla 2-1. Clasificación de los problemas de optimización . ............................................................... 24
Tabla 2-2. Clasificación de métodos clásicos de optimización . .......................................................... 25
Tabla 4-1. Escala fundamental de valoración. ............................................................................................ 49
Tabla 4-2. Descripción de criterios. ............................................................................................................ 50
Tabla 4-3. Comparación entre criterios. ...................................................................................................... 50
Tabla 4-4. Análisis de alternativas. ............................................................................................................. 50
Tabla 4-5. Dimensiones de las plataformas. ............................................................................................... 53
Tabla 4-6. Algunas propiedades del Aluminio 7075 T6 y de los eslabones. .................................... 55
Tabla 6-1. Tabla de parámetros de calibración. .......................................................................................... 94
Tabla 7-1. Datos de entrada de la validación 1. .......................................................................................... 96
Tabla 7-2. Datos de entrada de la validación 2 ........................................................................................... 97
Tabla 7-3. Datos de entrada de la validación 3. .......................................................................................... 98
Tabla 7-4. Datos de entrada de la validación 3. .......................................................................................... 98
Tabla 7-5. Datos de entrada de la validación 3. .......................................................................................... 99
Tabla 7-6. Valores de los eslabones para el estudio de WS. ..................................................................... 101
Tabla 7-7. Señales correspondientes por número de entrada. ................................................................... 105
Tabla 7-8. Resultado del análisis de sensibilidad de 𝐶𝑟y 𝐹 en Λ .............................................................. 113
Tabla 7-9. Resultados estadísticos del espaciado y 𝛬 en 12 muestras. ..................................................... 119
Tabla 7-10. Valores de configuración seleccionado ................................................................................. 120
Tabla 7-11. Tabla de partes del HEXA 6 RUS ......................................................................................... 122
GLOSARIO DE SIGLAS
Algoritmo evolutivo.
Metodología de proceso de análisis jerárquico o Analytic Hierarchy Process.
Diseño asistido por computador.
Cinemática inversa.
Grado de libertad o degree of freedom.
Error de control.
Esfuerzo de control.
Evolución diferencial.
Evolución diferencial multiobjetivo elitista restringido.
Fabricación por filamento fundido.
Función objetivo.
Frente de Pareto.
Manipulador paralelo con distribución hexagonal en la plataforma fija y 6 grados
de libertad generado por articulaciones rotacionales, universales y esféricas.
Métrica que para encontrar el punto más competitivo en un frente de Pareto.
Manufactura aditiva.
Manipulador paralelo.
Tamaño de población.
Non-dominated Sorting Genetic Algorithm.
Número de generaciones.
Pareto Front Distance Error.
Raiz del error medio cuadrático o Root mean square error.
Trabajo virtual o virtual work.
Espacio de trabajo o Workspace.
1 INTRODUCCIÓN
1.1 Descripción general
Como parte de la tecnología de fabricación digital, ha surgido una nueva industria basada en la
tecnología de manufactura aditiva (MA), también conocida como impresión tridimensional (i3D), la
tecnología MA según la ASTM es capaz de unir materiales para hacer objetos a partir de datos de modelos
3D, generalmente capa sobre capa, a diferencia de las metodologías de fabricación sustractiva. Existen
variantes de proceso dentro de MA, estos sistemas difieren en términos de la materia prima utilizada y el
principio técnico empleado para depositar las capas, construyendo así una geometría tridimensional sin
herramientas, moldes o implementos de corte . Los observadores tecnológicos aseguran que la MA tendrá
un profundo impacto económico en el sector manufacturero y, de hecho, en la sociedad en general, ya que
el crecimiento de su implementación en todos los sectores productivos no se ha detenido, lo que ha forzado
a aunar esfuerzos en la investigación y desarrollo de ésta temática . Casi todos los procesos de MA se
basan en la construcción de componentes en forma de capas, por lo que los datos topológicos
tridimensionales se dividen en una serie de cortes a través de la dirección Z, y cada capa del componente
se consolida secuencialmente a partir de estos datos. Si bien existe variedad de metodologías de MA, la
mayoría se puede dividir en dos categorías en función de cómo llega el material de alimentación a la
plataforma de construcción para producir cada capa secuencial. El primer método implica el uso de una
tina, o baño, del material de alimentación. En estos procesos, una placa de construcción normalmente está
contenida dentro de un recipiente y una capa de material de alimentación se distribuye uniformemente en
toda el área del volumen de construcción, normalmente en estado líquido o de polvo. Luego, cada capa se
solidifica selectivamente utilizando una variedad de técnicas que incluyen sinterización o fusión por láser,
deposición de un aglutinante fluido o exposición a la radiación UV, entre otras .
El segundo grupo de métodos MA el material se deposita a través de un cabezal de impresión móvil.
Por lo general, el cabezal móvil deposita el material en patrones extruidos que se unen entre sí en una
variedad de métodos según el proceso específico en uso. Los métodos de cubren una amplia gama de
materias primas. Uno de los primeros y más populares métodos se basa en la fusión y extrusión de un
filamento termoplástico a través de una boquilla. Este método se conoce como fabricación por filamento
fundido (FFF) y su bajo costo y simplicidad lo han convertido en el método de MA dominante en el
mercado. A pesar de su bajo costo, la FFF cuenta con una gama de materias primas disponibles y
recientemente, ha demostrado la capacidad de fabricar componentes de múltiples materiales. Los
componentes FFF de múltiples materiales han comenzado a demostrar una multifuncionalidad adicional en
las piezas fabricadas que son deseables para una variedad de aplicaciones .
Sin embargo, las máquinas de FFF convencionales y las piezas fabricadas en ellas presentan
inconvenientes debido a la falta de rango de movimientos rotacionales, unidireccionalidad de la adición de
material, defectos en la calidad superficial y sobredimensionamiento de mecanismos.
Las técnicas de fabricación actuales se basan en movimientos lineales de los ejes X, Y y Z que agregan
capa por capa el material. Este tipo de movimiento genera dificultades relacionados con el acabado
superficial (debido al terminado tipo escalón), con los requerimientos isotrópicos, con la unión de capas,
con el uso de material de soporte (implica tiempo extra de posprocesamiento), con las bajas velocidades de
impresión y con la imposibilidad de imprimir alrededor de obstáculos . Aunque existen técnicas
de posprocesamiento, estas no han solucionado los errores causados por la unidireccionalidad en el eje Z
de aporte de material . Dentro de las opciones de multidireccionalidad de alimentación se encuentran
los brazos robóticos industriales, los cuales han demostrado precisión y rigidez estructural; sin embargo, el
costo de estos dispositivos es muy alto y sufren de vibraciones, sobresaltos, incrementos de inercia y
respuestas lentas a perturbaciones a altas velocidades , . Adicionalmente, las técnicas convencionales
de diseño de mecanismos se han concentrado en dividir esta etapa en fases. Usualmente, se concentran los
primeros esfuerzos en los requerimientos estructurales y geométricos, para luego pasar a la fase de control.
El resultado de esto son mecanismos sobredimensionados con altos requerimientos energéticos y costos
elevados .
El diseño de un mecanismo de FFF multidireccional consta de varios retos, los cuales se concentran en:
el mecanismo multidireccional, el sistema de extrusión, el discretizador de modelos CAD y el entorno
gráfico. Con base en los problemas de movimiento anteriormente descritos, en los inconvenientes que
presentan los mecanismos seriales y luego del estudio del estado del arte, el cual se detalla en la Sección 3,
se evidencia la necesidad de un mecanismo paralelo de más de 5 grados de libertad o degrees of freedom
(DOFs) diseñado de forma óptima por medio de estrategias que considere simultáneamente no solo su
desempeño dinámico sino también el del controlador por medio de la evaluación de funciones como: el
espacio de trabajo, la manipulabilidad, la estrategia de control, el error y el esfuerzo de control. Esta
implementación impacta el proceso de MA ya que se pueden obtener no solo inclinaciones en el cabezal
que alcancen zonas que de forma convencional no se pueden conseguir por obstáculos, sino también un
mecanismo más competitivo en cuanto al desempeño dinámico, de control y espacio de trabajo 
 . Estos aspectos afectan el tiempo de fabricación y de posprocesado, la anisotropía de las piezas,
la estabilidad en los movimientos de la boquilla , las alteraciones causadas por la respuesta de los actuadores
y las aglomeraciones de material en los caminos y espesores no deseados en los cambios de dirección del
patrón .
1.2 Objetivos
Por lo anterior, el objetivo general y los objetivos específicos de este trabajo son los siguientes:
1.2.1 Objetivo general
Diseñar un mecanismo paralelo enfocado en impresión tridimensional por deposición de filamento
fundido incrementando la multidireccionalidad del sistema y optimizando los requerimientos volumétricos,
de manipulabilidad, de error de seguimiento y de torque.
1.2.2 Objetivos específicos
Proponer funciones objetivo determinando las necesidades geométricas y de control del mecanismo
paralelo para que puedan ser usadas en un algoritmo de optimización multiobjetivo.
Desarrollar un algoritmo metaheurístico que optimice el diseño mecánico y las constantes de control
buscando aumentar el espacio de trabajo y la manipulabilidad mientras que se disminuye el error y el
esfuerzo de control.
1.3 Metodología
La metodología que se utiliza para el desarrollo del proyecto consta de: revisión del estado del arte,
limitación de requerimientos, análisis de movimiento, determinación de las funciones objetivo,
optimización del proceso, fabricación del mecanismo, validación de los desarrollos obtenidos y
documentación del proceso. El esquema de esta metodología se presenta en la Fig. 1-1 y sus fases se detalla
a continuación.
Con el objetivo de profundizar las bases teóricas y analizar los desarrollos previos, se hace la revisión
del estado del arte y se ahonda en conceptos sobre configuraciones de mecanismos paralelos, cinemática,
formulaciones para el modelamiento dinámico, la determinación del espacio de trabajo, la manipulabilidad,
estrategias de control y optimización. Luego, mediante la metodología de proceso de análisis jerárquico o
Analytic Hierarchy Process (AHP) se selecciona el mecanismo paralelo y se determinan sus características.
Luego, se limitan requerimientos en cuanto a motores, dimensiones de la plataforma fija y de la
plataforma móvil, limitaciones de diámetros de los brazos y de materiales de fabricación. Esto como paso
previo al análisis de movimiento.
Del mecanismo paralelo seleccionado se determina su cinemática inversa y su modelación dinámica.
Con ayuda de la cinemática y una búsqueda de variable simple se establece el espacio de trabajo. Mientras
que con la modelación dinámica se analizan la velocidad y aceleración, al igual que las matrices jacobianas;
todos son aspectos necesarios para el estudio de la manipulabilidad y de la estrategia de control.
Tal como se describe en la Sección 3 , el control de movimiento del mecanismo paralelo es un reto para
solucionar en el diseño de un mecanismo paralelo, en este trabajo se aborda un controlador híbrido que
requiere el cálculo de las ganancias por ubicación de polos. El sistema de control es validado en un ambiente
virtual, ensamblando el mecanismo, proporcionándole características físicas y aplicando el controlador El
ensamble seguirá patrones establecidos con la respuesta de control esperada. Recalcando que la
implementación de este modelo se hará inicialmente en entornos virtuales con el fin de garantizar su
correcto funcionamiento.
Después, del sistema controlado se haya el error de control y el esfuerzo de control como indicadores
de desempeño, estos son evaluados junto con otros indicadores en una estrategia de optimización.
Por la misma relevancia que tiene las características geométricas y de respuesta ante el control, se opta
por usar una estrategia de control multiobjetivo que considere restricciones geométricas, de
comportamiento del material y respuesta del sistema controlado. Las funciones objetivo son el espacio de
trabajo, la manipulabilidad, el esfuerzo de control y el error de control; mientras que las variables de diseño
son la longitud de los eslabones y la ubicación de los polos. Para garantizar el punto más competitivo se
analizaron parámetros de mutación, tamaño de población y de generación al igual que múltiples ejecuciones
de la estrategia. La optimización tiene como resultado frentes de Pareto con sus respectivos puntos óptimos
que informan la configuración que los parámetros de diseño deben tener. Estos parámetros fueron aplicados
en la construcción del mecanismo.
Fig. 1-1. Esquemático de la metodología usada en el diseño más competitivo de un mecanismo paralelo.
1.4 Alcance del trabajo
En este trabajo se presentan retos en la investigación sobre diseño de mecanismos paralelos
considerando la configuración geométrica y la estrategia de control. Para esto, se plantea aplicar el uso de
la metodología de la Sección 1.3 en un mecanismo paralelo con escasa aplicación en MA y en su
optimización geométrica y de ganancias del controlador. Debido a las diferentes aplicaciones que poseen
los mecanismos paralelos, este trabajo considera que la MA como tecnología convergente y de industria
4.0 se beneficia de las características que aportan estos mecanismos; debido a esto, sus restricciones al igual
que sus requerimientos volumétricos y de movimiento se centran en esta aplicación. Dentro de los índices
de desempeño se consideran el espacio de trabajo, la manipulabilidad, el esfuerzo y el error de control. Los
dos primeros se impactan al incrementar los grados de libertad y plantean el comportamiento cinemático y
la facilidad con que se mueve el mecanismo paralelo; mientras que, los otros dos involucran la dinámica,
los requerimientos energéticos y la precisión de movimiento. La optimización genera frentes de Pareto de
donde es elegido la configuración para diseño. Luego del diseño se presenta la primera versión fabricada
del prototipo.
El desarrollo de este mecanismo hace parte de un macroproyecto del grupo de investigación DAVINCI
UMNG que incluye los circuitos electrónicos, la programación de microcontroladores, la interfaz
computador-mecanismo, el discretizador de geometría, y el optimizador de trayectorias de deposición entre
otros. Sin embargo, estos temas no se detallan en este escrito.
1.5 Contribuciones
Esta tesis se enfoca en los cuestionamientos que surgen acerca del propicio diseño de mecanismos
paralelos enfocados en MA, específicamente en FFF. Desde la selección del mecanismo hasta la
optimización de las constantes de control. Aunque se han documentado desarrollo de indicadores de
desempeño e implementaciones de optimización, algunos problemas presentados han contribuido a su
solución. Estos han sido documentados y detallados en el Anexo A y listados de A1 a A7.
Respecto a la MA, aunque esta ha revolucionado el diseño, la manufactura y la distribución de productos
existe poca comprensión acerca de la implementación de los mecanismos paralelos y su relación con el
diseño, el análisis dinámico y el estudio del espacio de trabajo. Es por esto que el artículo A6 sugiere el
número de grados de libertad, así como la ubicación de los actuadores para FFF; metodologías para
encontrar la cinemática inversa, los principios de modelación dinámica y del cálculo del espacio de trabajo.
Debido a que existen varios mecanismos paralelos que pueden ser usados en la FFF, se implementó la
estrategia AHP para la selección de mecanismos paralelos, en la Sección 4.1 orienta a los diseñadores a
cuantificar y clasificar estos mecanismos según sus requerimientos.
Hecha la selección, en el artículo A7 se presenta el comportamiento cinemático inverso y directo del
mecanismo HEXA y las ventajas que tiene con respecto al incremento de grados de libertad. Además, se
resalta la necesidad del análisis cinemático para el cálculo de la cinemática diferencial y el control
cinemático.
Respecto al diseño de los mecanismos paralelos, cuando se considera el controlador, existen estrategias
lineales o tradicionales de diseño con inconvenientes en la aplicación de las constantes; por esto se propuso
en el artículo A2 una metodología de un diseño basado en una optimización multiobjetivo que tiene en
cuenta el esfuerzo de control, el tiempo de establecimiento y la tasa de amortiguamiento.
Otro problema que existe en diseño es cuando se involucran parámetros de diseño geométricos, como
la longitud de los brazos y parámetros de control. Esto requiere de diseños concurrentes y algoritmos
metaheurísticos como el presentado artículo A5
La modelación dinámica es fundamental en el diseño del controlador, el problema aparece debido a las
cadenas cinemáticas cerradas de este tipo de mecanismos; si lo que se busca es el control en tiempo real y
la optimización de parámetros de control, es necesario que la obtención del modelo dinámico sea
computacionalmente eficiente, temática tratada en el artículo A1 y en la Sección 4.4. Además, debido a que
los mecanismos requieren examinar numerosos índices de desempeño que relacionan configuraciones
geométricas y de control; el artículo A1 y la Sección 6 presentan un procedimiento de diseño que involucra
un frente de Pareto de cuatro funciones objetivo y cuatro variables de diseño. En esta optimización se
implementó una técnica de evolución diferencial restringida, un nuevo método de medición de
manipulabilidad, una estrategia de control no encontrada en la literatura e indicadores de punto más
competitivo de frente de Pareto.
Finalmente, el uso de estos mecanismos en FFF presenta retos en cuanto la orientación de la pieza y los
patrones de deposición. Problemáticas que son solventadas con estrategias de optimización y de búsqueda
detallados en los artículos A3 y A4.
1.6 Organización de la tesis
Esta tesis está organizada así: el segundo capítulo resume los conceptos teóricos aplicados. El tercero,
documenta el conocimiento acumulado relacionado con estudios previos hechos en este campo. La
descripción del mecanismo se abarca en el cuarto capitulo. Luego, en el quinto capítulo se explican los
métodos usados para determinas las funciones objetivo, mientras que en el sexto capitulo se detalla la
técnica de optimización. Los resultados obtenidos se condensan en el séptimo capítulo. La discusión final
se incluye en el octavo capítulo abarcando conclusiones, trabajos futuros y los productos de generación de
nuevo conocimiento resultantes. Por último, se incluyen las referencias y los anexos.
2 MARCO TEÓRICO
2.1 Mecanismo paralelo
Dentro de las opciones de multidireccionalidad se encuentran los brazos robóticos industriales y los
robots o mecanismos paralelos (MP). Los primeros han demostrado amplitud de movimiento y fácil
programación; sin embargo, el costo de estos dispositivos es muy alto y tienen mala respuesta a altas
velocidades de respuesta ya que este tipo de movimientos causa vibraciones, sobresaltos, incrementos de
inercia y respuestas lentas a perturbaciones , . Los MPs que consisten en un efector final o plataforma
móvil con n DOFs y una plataforma fija, ambas unidas por al menos dos cadenas cinemáticas
independientes con por lo menos n actuadores (Fig. 2-1). Los MPs poseen las siguientes características :
1. Al menos dos cadenas cinemáticas están unidas al efector final.
2. El número de actuadores es ≥ al grado de libertad del efector final.
3. Cuando los actuadores se bloquean el MP no se mueve, lo que otorga un aspecto de seguridad
importante en ciertas aplicaciones (i.e. robots médicos).
Fig. 2-1. Esquemático de un A) MP serial y un B) MP paralelo 
Los MPs se han establecido como dispositivos de posicionamiento eficiente, debido a su dinámica,
precisión y la rigidez de su estructura. Esto debido a los siguientes factores.
1. Los mecanismos operan bajo dos tipos de fuerzas: la inercial y la de fricción. La inercial esta
relacionada con el cuadrado de la longitud de los eslabones, mientras que la fricción prácticamente no
se ve afectada por estas dimensiones. Esto implica que en un micro mecanismo en serie las fricciones
se mantienen relativamente similares, lo que permite concluir que los seriales son inapropiados para
altas cargas y precisión de posición.
2. El soporte de cargas se distribuye en todos los eslabones, lo que permite que las deformaciones se
3. No existe una acumulación de errores por una configuración serial.
Sin embargo, su análisis dinámico y control son complejos y aportan un espacio de trabajo mucho
menor que el de su contraparte.
Muchos MP sufren el inconveniente de las singularidades con influencias negativas en el espacio de
trabajo y la destreza de las plataformas móviles. Además, las singularidades de los MPs afectan el DOF, la
cinemática y la dinámica de los mecanismos e incluso pueden causar daños. Para aliviar la singularidad
cinemática, aumentar el espacio de trabajo y mejorar la destreza, a menudo se utilizan la redundancia de
actuación y los MPs cinemáticamente redundantes. Los MPs redundantes son aquellos en los que el número
de actuadores adicionales es mayor que el DOF, lo que se puede realizar agregando cadenas cinemáticas a
los MPs originales o accionando juntas pasivas. La redundancia puede reducir efectivamente las
singularidades, mejorar la rigidez y aumentar el espacio de trabajo . Sin embargo, estas pueden causar
cargas internas en las articulaciones, así como complejidad en la calibración, modelado, control y costos de
fabricación.
Adicionalmente, se pueden desarrollar MP de brazos rígidos o guiados por cables. Los MPs guiados por
cables han sido utilizados en aplicaciones que requieren grandes volúmenes de trabajo. Sin embargo, sus
limitaciones se basan en el hecho que solo trabajan cuando los cables soportan tensión y no compresión, lo
que los hace susceptibles a movimientos incontrolables de péndulo cuando hay movimiento de las
plataformas a alta velocidad o cuando se exponen a condiciones adversas por el medio en que trabajan.
Adicionalmente, un sistema guiado por cables con j DOFs del efector final, requiere al menos j + 1
cables , lo que implica j + 1 actuadores, esto presenta otra desventaja comparados con los MPs rígidos
pues normalmente utilizan el mismo número de actuadores que de DOF de la plataforma móvil . Debido
a todo lo anterior, el uso de MP rígidos no redundantes, es la mejor opción para aplicaciones la aplicación
Fig. 2-2.A) MP rígido . B) MP guiado por cables.
2.2 Cinemática inversa
En el diseño de un MP el análisis cinemático es una etapa esencial, ya que no solo ayuda a comprender el
movimiento, sino que sirve para hallar las dimensiones del robot por medio de técnicas de optimización En
el estudio de la cinemática de los robots se han expuesto varias técnicas con el fin de determinar la posición
actual de la plataforma móvil desde las articulaciones activas; esta relación tiene un interés en el control de
posición y velocidad del MP. La movilidad es uno de los parámetros principales al momento de modelar
mecanismos cinemáticos. La movilidad se define como el número necesario de sistemas coordenados
independientes que definen la configuración de una cadena cinemática. Gogu trabajó con esta relación
y con el número de brazos del MP para poder determinar el número de entradas requeridas por un
mecanismo. Se debe tener en cuenta que el análisis cinemático puede llevarse a cabo de dos formas, por la
cinemática directa y la inversa. El primero determina la posición de la plataforma móvil al determinar un
valor en las articulaciones activas; el otro, determina el movimiento de las articulaciones activas conociendo
la posición deseada de la plataforma móvil. En los MPs, la cinemática directa es compleja debido a que la
naturaleza de cadenas cinemáticas conduce a ecuaciones altamente no lineales que usualmente requieren el
uso de métodos numéricos para su resolución. Por otro lado, la cinemática inversa se aplica cuando se
necesita conocer el comportamiento de mecanismo ante una trayectoria/posición dada.
El método general de la cinemática inversa consiste en que con la suma de vectores con que se describen
los eslabones se puede hallar el movimiento de los actuadores. Por ejemplo, para el MP de 5 articulaciones
rotacionales (5R) de la Fig. 2-3 las sumas vectoriales de cada i-ésimo lado del MP que se expresan como
(2-1), donde los vectores 𝒂𝒃𝒊 que son funciones de las rotaciones 𝜃௜, son la base para que estos ángulos
puedan expresarse como función de 𝒑, tal como lo indica (2-2).
Fig. 2-3. Esquemático del MP 5R .
𝒑= 𝒂𝒊+ 𝒂𝒃𝒊+ 𝒃𝒊𝒑
𝒑−𝒂𝒊−𝒃𝒊𝒑= 𝒂𝒃𝒊
𝒑−𝒂𝒊−𝒃𝒊𝒑= 𝑓(𝜃௜, |𝑎𝑏௜|)
𝑓(𝒑, 𝒂𝒊, 𝒃𝒊𝒑, |𝑎𝑏௜|) = 𝜃௜
2.3 Cinemática diferencial
Dentro del análisis del comportamiento de un MP, la cinemática diferencial es necesaria para el análisis
de movimiento instantáneo, en los MPs los eslabones se representan como cuerpos rígidos y su movimiento
instantáneo se caracteriza por las velocidades en las articulaciones. Una evaluación adecuada del estado de
movimiento instantáneo es esencial para la manipulación de objetos o la reconfiguración del sistema para
el equilibrio y/o para evitar colisiones. Además, la cinemática diferencial también desempeña un papel
importante en el control. Los esquemas de control de retroalimentación y avance cinemático hacen uso de
los comandos de control especificados en términos de movimiento instantáneo de los eslabones finales de
interés; estos comandos de control se transforman luego en comandos de control de movimiento en las
articulaciones mediante la cinemática diferencial (inversa). La cinemática diferencial también es esencial
para derivar modelos dinámicos, en los que se consideran relaciones de primer orden (nivel de velocidad)
y de segundo orden (nivel de aceleración).
2.3.1 Generalidades
La cinemática diferencial es la relación entre las velocidades de la plataforma móvil y las velocidades
del actuador. Para el ejemplo anterior de la Fig. 2-3, la cinemática diferencial es (2-3); donde 𝑤௜ es la
velocidad angular de los actuadores 1 y 2; las cuales son funciones de las dimensiones de la estructurales y
las velocidades lineales del punto 𝑃 con respecto a 𝑂.
𝒘𝒊= 𝑓൫𝒑̇ , 𝒂ଙ̇ , 𝒃ଙ𝒑̇ , |𝑎𝑏௜|൯
Por lo anterior (2-3) se puede reescribir como (2-4), donde 𝐉 es una matriz que relaciona ambas
velocidades y se le conoce como Jacobiana.
2.3.2 Matriz Jacobiana
La matriz Jacobiana en el caso de MP no redundantes es 𝐽 ∈ℝ௡×௡, donde 𝑛 es el número de actuadores.
Esta matriz se considera como la versión vectorial de la derivada ordinaria de una función escalar. Además,
tiene relación con aspectos de la manipulabilidad, la precisión, planificación de movimientos, entre
otros .
De forma general 𝐉 se describe como (2-5), donde 𝑋̇ = [𝑥̇
𝑧̇] 𝜖 ℝଷ son las
velocidades cartesianas de la plataforma móvil, [𝜑̇
𝜓̇] 𝜖 ℝଷ son las velocidades angulares; además, 𝐉𝐯
y 𝐉𝐰 relacionan la velocidad cartesiana y la velocidad angular de la plataforma móvil con la velocidad
articular respectivamente.
2.4 Formulaciones para la obtención de la dinámica del
El análisis dinámico permite determinar las fuerzas y torques demandados relacionados con el
movimiento de la plataforma móvil, el cual es requerido para configurar la ley de control y el diseño de los
MPs. Existen algunos enfoques para analizar esas fuerzas, como Newton Euler (N-E), Euler Lagrange (E-
L) y trabajo virtual o en inglés virtual work (VW), entre otros.
2.4.1 Formulación de Newton Euler
En algunas ocasiones se necesitan conocer las fuerzas y las reacciones de las articulaciones de los MPs.
En estos casos, la formulación N-E es apropiada. Este método aísla cada plataforma, eslabón y articulación
y determina el comportamiento de inercia y fuerza de reacción de cada uno, de acuerdo con la tercera ley
de Newton (2-6); donde 𝑚 es la masa del cuerpo, 𝐈 es el tensor de inercia, 𝒗𝒃 y 𝒘𝒃 son la velocidad lineal
y angular del centro de masa respectivamente, 𝒇𝒃 y 𝝉𝒃 son las fuerzas y torques actuando en el centro de
masa. Este método es aplicable para la mayoría de los mecanismos; sin embargo, la eliminación de las
reacciones de las articulaciones genera dificultad y tiempo de procesado computacional .
𝒘̇ 𝒃൨+ ൤𝒘𝒃× 𝑚𝒗𝒃
𝒘𝒃× 𝜁𝒗𝒃൨= ൤𝒇𝒃
2.4.2 Formulación de Euler Laplace
Debido a que la formulación N-E calcula las fuerzas de reacción y los torques entre todos los
componentes móviles, la gran cantidad de ecuaciones y su complejidad disminuyen la eficiencia
computacional; por lo tanto, complejiza la implementación de una ley de control. Por otro lado, la
formulación E-L no se enfoca en las fuerzas de reacción, por lo que es computacionalmente más eficiente.
Sin embargo, la definición de las fuerzas de restricción generalizadas dentro del planteamiento dinámico
hace que se requiera multiplicadores de Lagrange para que la matriz de coeficientes sea simétrica .
La ecuación E-L se expresa como (2-7); donde 𝐿= 𝐾−𝑈, 𝐾∈ℝ y 𝑈 ∈ℝ es la energía cinética y
potencial respectivamente, 𝑚 es la cantidad de ecuaciones de restricción, 𝑛 es el número de actuadores,
𝑗=1,…,n, 𝑄௝ es la i-ésima fuerza generalizada, 𝑞 las coordenadas generalizadas, Γ௜ la i-ésima ecuación de
restricción, λ௜ el i-ésimo multiplicador Lagrangiano 
Debido a que la obtención de los multiplicadores Lagrangianos involucra derivadas parciales, esto los
hace computacionalmente complejos cuando su descripción se hace simbólica para la implementación en
estrategias de optimización.
2.4.3 Principio del trabajo virtual
El VW es una herramienta útil para adquirir las ecuaciones estáticas y dinámicas de los sistemas
multicuerpo. A diferencia del N-E, el VW no considera las fuerzas de restricción, solo las cantidades de
trabajo escalar para definir las ecuaciones dinámicas. VW tiene como objetivo derivar un conjunto mínimo
de ecuaciones de movimiento de los MPs eliminando las fuerzas de restricción. Adicionalmente, con VW
se obtienen un número de ecuaciones iguales al número de DOFs. La formulación de VW depende del
trabajo infinitesimal de las fuerzas externas, internas y de inercia, así como de los momentos del cuerpo,
como se muestra en (2-8). Donde, 𝑄𝑖 es el vector/matriz de las fuerzas y momentos generalizados, 𝑄𝑒 es el
vector/matriz de las fuerzas externas e inercias generalizadas que actúan sobre cada cuerpo, 𝛿𝑞 es el
desplazamiento infinitesimal y 𝜏 son las fuerzas/torques de los actuadores .
𝛿𝑊= 𝛿𝑊𝑒−𝛿𝑤𝑖= 0
[𝑄𝑒−𝑄𝑖]𝛿𝑞= 0
2.5 Espacio de trabajo
El espacio de trabajo o workspace (WS) es la porción alcanzable en el espacio al que la plataforma móvil
puede llegar. Los movimientos de los MPs pueden estar restringidos por diferentes factores: límites
mecánicos en las articulaciones pasivas, colisión entre los elementos del robot, limitaciones debidas a los
actuadores y variedades de singularidad que pueden dividir el WS.
El principal problema con la representación del WS de los MPs es que las limitaciones en DOF de todos
suelen estar acoplados. Por lo tanto, para robots que tengan más de 3 DOF no habrá ninguna ilustración
gráfica posible del WS del robot . Este no suele ser el caso con los robots en serie. Por ejemplo, el WS
de un robot en serie de 6 DOF con una muñeca de eje concurrente puede representarse por el volumen 3D
que puede alcanzar el centro de la muñeca; esto ilustra las traslaciones, y por la superficie que puede
alcanzar el extremo del efector final. El volumen 3D depende solo de la capacidad de movimiento de las
tres primeras articulaciones accionadas, mientras que la orientación utiliza solo las últimas tres
articulaciones. Una representación gráfica del WS de robots paralelos solo será posible para robots de 3
DOF. Para robots con DOF > 3, la representación del WS solo será posible si se fijan n − 3 parámetros de
pose. Según que tipos de parámetros se fijen o de la restricción que le impongamos al parámetro, se obtienen
diferentes tipos de WS.
En múltiples estudios , se han agrupado dos tipos de WS. El primero se define como WS de
orientación constante, en el cual la plataforma móvil se traslada con una orientación fija. El segundo es el
WS donde se varían los ángulos de rotación de la plataforma móvil. En términos de multidireccionalidad y
de procesos, es relevante determinar la capacidad de campo de acción del MP con el fin determinar las
geometrías de la pieza a fabricar.
Algunos enfoques para para calcular el WS son: el geométrico, máximo volumen inscrito, el discreto y
el análisis de límites por restricciones.
2.5.1 Enfoque geométrico
El propósito de este método es determinar geométricamente el límite del WS. El principio es deducir
todas las posibles ubicaciones de los eslabones que cumplan con sus restricciones de movimiento generando
un volumen por cada eslabón, luego se hace la intersección de todos los volúmenes para determinar el WS.
Este procedimiento es rápido y preciso para robots con menos de 3DOF; sin embargo, para MP con más
eslabones, el cálculo de intersección de volúmenes es complejo ya que se requiere el análisis de todas y
cada una de las restricciones .
2.5.2 Máximo volumen inscrito con CAD
De forma similar al enfoque geométrico de la sección anterior, este método genera el volumen de
movimiento de cada brazo del MP; sin embargo este volumen se hace con un software CAD. Luego, se
hacen operaciones booleanas de intersección de cada volumen y esta intersección es el WS del MP .
Fig. 2-4. Esquemático del método de máximo volumen inscrito con CAD de un MP tipo Delta. A) Concepto de
intersección del volumen de los eslabones a una altura puntual. B) Máximo volumen inscrito .
2.5.3 Método discreto
Este método considera la discretización de las posiciones de la plataforma móvil. El WS se crea por
medio de una malla regular compuesta por nodos, donde cada nodo es evaluado para determinar si tiene o
no restricciones. El límite del WS se constituye por el grupo de nodos validos que más cerca están a los que
tienen alguna restricción. La ventaja de este método es que considera las restricciones; sin embargo, la
precisión depende de la red de discretización, la cual afecta el costo computacional .
2.5.4 Análisis de límites por restricciones
Este análisis se hace considerando la cinemática inversa (CI) del MP y las restricciones de movimiento
que tienen los brazos cuando los actuadores están en sus puntos máximos y mínimos; lo que va
construyendo la superficie frontera del WS. Este método requiere la discretización de solo los puntos límite
y su costo computacional depende del número de puntos a analizar y del método de búsqueda donde la
posición es permitida . Este enfoque es el utilizado en esta tesis y es detallado en la Sección 5.
2.6 Manipulabilidad
Según Merlet , es realista asumir que los errores de las articulaciones generan errores de
posicionamiento. Por tal motivo, la precisión del MP está relacionado con la matriz Jacobiana. Esta relación
caracteriza la destreza o manipulabilidad del MP y es usado como indicador de desempeño. A partir de
(2-5) y de las propiedades de la norma ‖∙‖ se obtiene la relación (2-9); donde 𝑋̇ ∈ℝ௡, 𝛿𝑋̇ es una magnitud
pequeña adicional al movimiento esperado, de tal forma que el error de velocidades de desplazamiento es
Por lo anterior, la relación de errores de los actuadores 𝑒௤̇ y de 𝑒௑ se definen en (2-10), donde 𝜅௃ es el
número condicional.
‖Jିଵ‖‖J‖ ‖𝑒௑̇‖
El 𝜅(𝐽) se puede calcular como (2-11) si 𝐉 no es cuadrada o como (2-12) si 𝐉 es cuadrada .
Donde, 𝜆௘(max) y 𝜆௘(min) son los eigenvalores máximos y mínimos de 𝐉 respectivamente.
Si el MP tiene una mezcla de actuadores prismáticos y rotacionales o si la plataforma móvil genera
movimientos traslacionales y rotacionales, 𝐉 es usualmente no homogénea en términos de unidades. Por lo
tanto, los índices de manipulabilidad deben evaluarse en términos traslacionales y rotacionales.
Considerando que 𝑋̇ = [𝑣
𝑤]் y que la relación de 𝑋̇ respecto a 𝑞̇ es.(2-13), donde 𝑃∈ℝ௡×௡, 𝑣∈
ℝ௠×ଵ, 𝑤∈ℝ௡ି௠ ×ଵ, 𝑄∈ℝ௡×௡ y 𝑞̇ ∈ℝ௡×ଵ.
Las matrices de relación traslacional y rotacional son ൫𝐉𝐏ష𝟏𝐐൯௩ y ൫𝐉𝐏ష𝟏𝐐൯௪ respectivamente y están
organizadas de acuerdo con (2-14). Estas matrices ya no tienen combinación de unidades y conforme con
(2-12) los índices de manipulabilidad traslacional y rotacional son 𝜅ቀ൫𝐽௉షభொ൯௩ቁ y 𝜅ቀ൫𝐽௉షభொ൯௪ቁ
respectivamente.
2.7 Estrategia de control
La estrategia de control de un MP permite que por medio de una señal de torque de entrada de los
motores, la plataforma móvil llegue a un punto deseado. Existen varias estrategias de control como el
proporcional integral derivativo (PID) , el proporcional derivativo (PD) , los modos deslizantes
 , planitud diferencial entre otros. Adicionalmente, como se requiere un buen desempeño del
controlador, se usan indicadores como el de energía de desempeño, error de control, el esfuerzo de control
entre otros . En este desarrollo se enfocaron esfuerzos en la estrategia de modos deslizantes, planitud
diferencial con los indicadores error de control y esfuerzo de control.
2.7.1 Modos deslizantes
El control por modos deslizantes es un sistema estructura variable que conmuta en cualquier instante de
un conjunto de funciones de estado a otro. Este sirve para plantas dinámicas complejas de alto orden
operadas bajo condiciones de incertidumbre, debido a su propiedad de reducción de orden y su baja
sensibilidad a las perturbaciones y variaciones de los parámetros de la planta . El modo deslizante es
inducido en sistemas dinámicos por un control discontinuo en función del estado del sistema. El control
cambia a alta frecuencia asegurando un movimiento en un espacio de estados. Una descripción de este
comportamiento se detalla de (2-15) a (2-29) .
Formalmente los sistemas dinámicos discontinuos se describen como(2-15); donde, 𝑋∈ℝ௡ es el vector
de estados del sistema, 𝑛 es la dimensión del espacio de estados, 𝑡 es el tiempo y 𝑓(𝑋, 𝑡) tiene
discontinuidades dentro del espacio (𝑋, 𝑡).
𝑋̇ = 𝑓(𝑋, 𝑡, 𝑢)
Se considera que en aquellos casos cuando un conjunto de discontinuidades forma una superficie
variante en el tiempo de dimensión 𝑛, se denomine a esta superficie de conmutación (𝜎) (2-16).
Por ejemplo, en un mecanismo con fricción de Coulomb 𝑃൫𝑋̇൯ donde 𝑚 es la masa, 𝑋 es el
desplazamiento y 𝑘 es la rigidez del resorte; la discontinuidad ocurre cuando 𝑋̇ = 0 (2-17) .Por lo
anterior, las superficies de conmutación son concebidas para que la respuesta del sistema sea 𝜎= 𝑋̇ = 0 y
genere el comportamiento, características de estabilidad y seguimiento deseados.
𝑚𝑋̈ + 𝑃൫𝑋̇൯+ 𝑘𝑋= 0
𝑃൫𝑋̇, 𝑡൯= ൜𝑃௢
Una característica de las ecuaciones diferenciales que describe cualquier estrategia de control (2-18) es
la presencia del vector de control, que para los MPs controlados por torque, es 𝜏 ∈ℝ௡.
𝑋̇ = 𝑓(𝑋, 𝑡, 𝜏)
Ahora, si se considera una estrategia de control con la presencia de un vector de entrada 𝜏(𝑋, 𝑡), la clase
general del control discontinuo se define con la relación de (2-19); donde 𝜏௜
ା(𝑋, 𝑡) y 𝜏௜
ି(𝑋, 𝑡)𝑠on continuas;
de la definición de la superficie de conmutación, es importante garantizar la existencia del modo deslizante,
la cual se basa en que los vectores tangente de estados siempre apunten a la superficie 𝜎 como en la Fig.
𝜏(𝑋, 𝑡) = ൜𝜏௜
𝑖= 1, … , 𝑚
El problema de existencia se parece a un problema de generalizado de estabilidad, considerando que un
MP es estable si pierde energía a través del tiempo y si en la aplicación de la estrategia de control sus polos
se ubican en la región negativa. La estabilidad de la superficie de conmutación requiere seleccionar una
función de Lyapunov 𝑉(𝑋, 𝑡) que sea positiva definida y que tenga una derivada en el tiempo negativa en
la región de atracción. Si se cumple esta condición, entonces la trayectoria de estados converge a la
superficie de conmutación y permanece en ella para todo tiempo posterior , como pasaría si 𝑉(𝑋, 𝑡) =
0.5𝜎ଶ la cual es globalmente positiva y 𝜎
ௗ௧< 0. De acuerdo con esto, un modo deslizante es alcanzable
si el dominio de atracción es el espacio de estados. Por lo anterior, la existencia implica (2-20) .
Fig. 2-5.Esquemático del comportamiento del control discontinuo sobre la superficie .
Por lo anterior, un modo deslizante ideal existe cuando la trayectoria de estados satisface 𝜎(𝑋) = 0, lo
que requiere una infinita conmutación generando un fenómeno indeseable de oscilaciones con frecuencia y
amplitud finitas denominada chattering . Con el fin de mejorar esto, se utilizan funciones que
disminuyen la ambigüedad (Fig. 2-6) y se conocen como capas límites. Un ejemplo es la función signo
(𝑠𝑖𝑔𝑛), la cual amplía las fronteras de conmutación a valores entre −𝜀 y 𝜀 , .
Fig. 2-6. Capa límite .
La ley de control es (2-21); donde 𝜏௘௤ y 𝜏ே corresponden al control equivalente y al atractivo
respectivamente. El primero restringe el movimiento del sistema a la superficie deslizante y el segundo
lidia con las perturbaciones.
𝜏= 𝜏௘௤+ 𝜏ே
Referente a 𝜏௘௤, suponiendo que en 𝑡଴ la trayectoria de estados intercepta la superficie deslizante, un
modo deslizante existe para 𝑡≥𝑡଴. Considerando que el modo deslizante existe (2-20) y asumiendo que la
solución de (2-18) existe, ahora (2-18) se puede definir como la ecuación del modo deslizante que describe
el movimiento sobre la intersección de las superficies de conmutación (2-22)
𝑋̇ = 𝑓൫𝑋, 𝑡, 𝜏௘௤൯
Desde un punto de vista geométrico, el 𝜏௘௤ implica un reemplazo de un control discontinuo indefinido
sobre un límite discontinuo con un control continuo el cual direcciona el vector de velocidad en el espacio
de estados a lo largo de una intersección de superficies discontinuas. De la Fig. 2-7 𝜏௜
ା(𝑋, 𝑡) y 𝜏௜
actúan hasta intersectarse con el plano tangente de 𝜎(𝑋, 𝑡), el punto de intersección es el 𝜏௘௤ y el
componente derecho de (2-22).
Fig. 2-7. Variación de 𝑓(𝑋, 𝑡, 𝜏) sobre el plano tangente .
Si ahora el sistema controlado se representa de la forma (2-23); donde 𝑓(𝑋, 𝑡) y 𝐵(𝑋, 𝑡) son argumentos
continuos de dimensión 𝑛 × 1 y 𝑛 × 𝑚 respectivamente y 𝜏௘௤ cumple con (2-19).
𝑋̇ = 𝑓(𝑋, 𝑡) + 𝐵(𝑋, 𝑡)𝜏௘௤
Un control continuo que cumpla con (2-20) se expresa como (2-24); donde 𝐺= 𝜕𝜎𝜕𝑋
𝜎̇ = 𝐺𝑓(𝑋, 𝑡, 𝜏) = 0
La ecuación (2-24) puede escribirse como (2-25) si se considera 𝜏௘௤.
𝜎̇ = 𝐺𝑓(𝑋, 𝑡) + 𝐺𝐵(𝑋, 𝑡)𝜏௘௤= 0
Asumiendo que 𝐺𝐵 es no singular, el 𝜏௘௤ se define como (2-26).
𝜏௘௤= −൫𝐺𝐵(𝑋, 𝑡)൯
ିଵ𝐺𝑓(𝑋, 𝑡)
Sustituyendo (2-26) en (2-23) se obtiene (2-27), la cual describe el movimiento del modo deslizante
sobre el requerimiento 𝜎(𝑋) =0.
𝑋̇ = 𝑓−𝐵(𝐺𝐵)ିଵ𝐺𝑓
El control 𝜏௘௤ es aplicado cuando el sistema está dentro de las capas límites de la superficie de
conmutación. En consecuencia, es necesaria la existencia de un controlador que atraiga a la trayectoria de
estados hacia la superficie deslizante, este papel lo hace el control atractivo 𝜏ே (2-21) y se comporta como
un componente discontinuo y conmutado (2-19). Para implementar 𝜏ே en toda la estrategia de control se
sigue (2-28) con base en (2-25), en donde ahora la señal de control es ൫𝜏௘௤+ 𝜏ே൯.
𝐺ൣ𝑓+ 𝐵൫𝜏௘௤+ 𝜏ே൯൧
𝐺൫𝑓+ 𝐵𝜏௘௤൯+ 𝐺𝐵𝜏ே
Cuando los estados no están sobre la superficie de conmutación 𝜎̇ ≠0 y solo actúa 𝜏ே lo que genera
𝜎̇ = 𝐺𝑋̇ = 𝐺𝐵𝜏ே
Si se asume que 𝐵= 𝐼; entonces 𝜎̇ = 𝜏ே. Esta condición es suficiente para la alcanzabilidad y existencia
de un modo deslizante ya que cumple con 𝜎
ௗ௧< 0 cuando 𝜎≠0. Una de las estructuras de selección de
𝜏ே es la realimentación continua como muestra (2-30), donde 𝛼< 0 para que haya la condición de
existencia (2-31)
𝜎𝜎̇ = 𝛼𝜎ଶ< 0
De esta forma, 𝜏ே puede expresarse como (2-32); donde, 𝐿 representa el torque máximo permitido por
los actuadores.
𝜏ே= ቄ−𝐿𝑠𝑖𝑔𝑛(𝜎)
Se puede definir 𝜏 en función de 𝑋, tal como lo hace (2-33), donde 𝑋(௜) y ℏ(௜) es la i-ésima derivada de
𝑋 y el i-ésimo factor del sistema respectivamente, estos valores dependen del 𝑚 orden del sistema.
𝜏= ℏ௠ାଵ𝑋(௠) + ℏ௠𝑋(௠ିଵ) + ⋯+ ℏଶ𝑋̇ + ℏଵ𝑋
La superficie 𝜎 se expresa como (2-34), donde la i-ésima derivada del error 𝑒(௜) = (𝑋ௗ−𝑋)(௜) se
presenta como la i-ésima derivada de la diferencia de estados deseados contra los actuales y ∫(௠)
𝑚 reconstructores integrales.
𝜎= 𝑋(௠ିଵ) + 𝐾(௠ାଵ)𝑒(௠ିଶ) + ⋯+ 𝐾(ଵ) න𝑒
Luego se deriva (2-34) obteniendo (2-35).
𝜎̇ = 𝑋(௠) + 𝐾(௠ାଵ)𝑒(௠ିଵ) + ⋯+ 𝐾(ଵ)
Al despejar 𝑋(௠) de (2-33) y reemplazarlo en (2-35), 𝜎̇ se define como (2-36).
𝑋(௠ିଵ) −⋯−
𝑋൰+ 𝐾(௠ାଵ)𝑒(௠ିଵ) + ⋯+ 𝐾(ଵ)
Cuando la señal de control se encuentra sobre la superficie deseada 𝜎̇ = 0, 𝜏௘௤ está accionado tal como
(2-37) lo indica.
𝑋(௠ିଵ) −⋯−
𝑋൰+ 𝐾(௠ାଵ)𝑒(௠ିଵ) + ⋯+ 𝐾(ଵ)
Al despejar 𝜏௘௤ se genera (2-38).
𝜏௘௤= ℏ௠𝑋(௠ିଵ) + ⋯+ ℏଶ𝑋̇ + ℏଵ𝑋−ℏ௠ାଵቌ𝐾(௠ାଵ)𝑒(௠ିଵ) + ⋯+ 𝐾(ଵ)
Por otro lado; en caso de que 𝜎̇ ≠0, 𝜏௘௤ y 𝜏ே se accionan. La señal 𝜏ே se iguala a −𝐿 sign(𝜎) según
𝜏ே= −𝐿𝑠𝑖𝑔𝑛(𝜎)
Considerando (2-35) y teniendo en cuenta la activación de las dos señales 𝜏௘௤ y 𝜏ே, se calcula(2-40).
−𝐿𝑠𝑔𝑛(𝜎) = ൬
𝑋(௠ିଵ) −⋯−
𝑋൰+ 𝐾(௠ାଵ)𝑒(௠ିଵ) + ⋯+ 𝐾(ଵ)
Reemplazando (2-37), (2-39) y (2-40) se obtiene (2-41), donde 𝜎.se define en
−𝐿sign(𝜎) =
−ℏ(௠ାଵ)𝐿sign(𝜎) =
Los valores de 𝐾(௜) se determinan derivando 𝑚 veces la superficie 𝜎, luego se hace la transformada de
Laplace y se igualan los parámetros a los que tienen la dinámica del error que considera la ubicación de los
polos según la tasa de amortiguación 𝜉, la frecuencia natural no amortiguada 𝑤௡ y los parámetros de
estabilidad de Routh-Hurwitz , tal como lo muestra (2-42). Donde 𝛽 y 𝜅 dependen del valor de 𝑚.
𝑒(௠) + 𝐾(௠ାଵ)𝑒(௠ିଵ) + 𝐾(௠)𝑒(௠ିଶ) + … + 𝐾(ଶ)𝑒̇ + 𝐾(ଵ)𝑒
𝑠(௠) + 𝐾(௠ାଵ)𝑠(௠ିଵ) + 𝐾(௠)𝑠(௠ିଶ) + … + 𝐾(ଶ)𝑠+ 𝐾(ଵ)
= (𝑠ଶ+ 2𝜉𝑤௡+ 𝑤௡ଶ)ఉ(𝑠+ 𝛼)఑
2.7.2 Planitud diferencial
La estrategia de planitud diferencial aplicada en MP involucra una salida diferencialmente independiente
que permite parametrizar los estados, entradas y salidas del sistema en función de la salida y un número
finito de sus derivadas en el tiempo; además, esta función es invertible con el fin de obtener una solución
en las variables originales . El pasar de un espacio de estados y de entradas usualmente no lineales a un
espacio de salidas planas representable como un tren de integradores se denomina difeomorfismo,
usualmente representado con Φ.
Por lo tanto, un sistema de orden 𝑛 de una entrada y una salida representado por (2-43); donde los
estados 𝑥∈ℝ௡ y la entrada 𝜏∈ℝ௠, es diferencialmente plano si existe una salida ficticia 𝐹= Φ(𝑋) que
permite la parametrización de los estados y la entrada conforme a (2-44); donde Φ௫ yΦఛ representan el
difeomorfismo de los estados y la entrada respectivamente, siendo estas funciones de clase 𝐶ஶ o
infinitamente derivables. La Fig. 2-8 representa esquemáticamente este concepto.
𝑋̇ = 𝑓(𝑋, 𝜏)
ିଵ൫𝐹, 𝐹̇ , … , 𝐹௡ିଵ൯
ିଵ൫𝐹, 𝐹̇, … , 𝐹௡ିଵ൯
Fig. 2-8. Esquemático de difeomorfismo .
En la planitud, todo el conjunto de soluciones del sistema están en correspondencia uno a uno con las
trayectorias pertenecientes al espacio de salidas planas; como resultado, el comportamiento deseado que se
especifica en la salida plana determina las trayectorias de estado y de las entradas de control. Por tal motivo
la estrategia de control se centra en la superficie plana y en su controlabilidad.
Si se considera el MP como una representación de estados de la forma (2-45) donde 𝐴 y 𝐵 son matrices
de dimensiones 𝑛 𝑋 𝑛 y 𝑛 𝑋 𝑚 respectivamente.
𝑋̇ = 𝐴𝑋+ 𝐵𝜏
Siguiendo el criterio de controlabilidad de Kalman , una condición necesaria y suficiente para que el
sistema (2-45) sea controlable es que el rango de la matriz de controlabilidad 𝐾௖ expresada en (2-46) sea
igual a 𝑛.
Si este requisito se cumple, la salida plana está dada por un módulo de factor constante y una
combinación de los estados obtenidos de la última fila de la matriz inversa de 𝐾௖, tal como lo indica (2-47).
Por otro lado, 𝐹 puede expresarse como (2-48); donde 𝜆 es un vector de dimensión 1 × 𝑛 y la salida
plana se concentra en encontrar los valores de 𝜆. Para esto, lo primero es hallar las 𝑛−1 derivadas de 𝐹 y
sustituir valores con (2-45) .
𝜆𝐴(௡ିଵ)𝑋+ ⋯+ 𝜆𝐵𝜏(௡ିଶ)
Debido a que se busca que 𝑋 solo se exprese en términos de 𝐹 y sus derivadas, la entrada 𝜏 y sus
derivadas deben ser anuladas, para ello, 𝜆 debe satisfacer (2-49) .
En consecuencia, todas las 𝑋 se parametrizan en términos de 𝐹 y sus derivadas. Luego, de la expresión
(2-45) se puede definir 𝜏 como una representación de 𝐹, como lo describe (2-50); donde 𝐹(௜) y ℏ(௜) es la i-
ésima derivada de 𝐹 y el i-ésimo factor del sistema respectivamente.
𝜏= ℏ௡ାଵ𝐹(௡) + ℏ௡𝐹(௡ିଵ) + ⋯+ ℏଶ𝐹̇ + ℏଵ𝐹
Con el fin de garantizar el seguimiento suave de 𝐹, se plantea un controlador auxiliar con una acción
integral que proporcione robustez al sistema, el cual se denomina 𝑣௔௨௫ (2-51); donde 𝐹௜ௗ y 𝛾௡ son la i-
ésima derivada deseada de la planitud y el i-ésimo coeficiente respectivamente.
𝑣௔௨௫= 𝐹(௡)
ௗ+ 𝛾(௡ାଵ)ൣ𝐹(௡ିଵ)
ௗ−𝐹(௡ିଵ)൧+ 𝛾(௡)ൣ𝐹(௡ିଶ)
ௗ−𝐹(௡ିଶ)൧+ … + 𝛾(ଶ)[𝐹ௗ−𝐹] + 𝛾ଵන[𝐹ௗ−𝐹] 𝑑𝑡
A partir de (2-50) se sustituye la derivada 𝐹(௡) por 𝑣௔௨௫ como lo presenta (2-52).
𝜏= ℏ(௡ାଵ)𝑣௔௨௫+ ℏ௡𝐹(௡ିଵ) + ⋯+ ℏଶ𝐹̇ + ℏଵ𝐹
Luego, se igualan (2-50) y (2-52) y se genera la dinámica del error (2-53). Con el fin de eliminar las
integrales se deriva con respecto al tiempo (2-54); donde 𝑒௜ி= 𝐹(௜)
ௗ−𝐹(௜) y 𝑒ி= 𝐹ௗ−𝐹.
ி+ 𝛾(௡ାଵ)𝑒(௡ିଵ)
ி+ 𝛾௡𝑒(௡ିଶ)
ி+ … + 𝛾(ଶ)𝑒̇ி+ 𝛾(ଵ) න𝑒𝐹𝑑𝑡
𝐹(௡ାଵ) = 𝑣௔௨௫̇
0 = 𝐹(௡ାଵ)
ௗ+ 𝛾(௡ାଵ)𝑒(௡)
ி+ 𝛾௡𝑒(௡ିଵ)
ி+ … + 𝛾(ଶ)𝑒̇ி+ 𝛾ଵ𝑒ி−𝐹(௡ାଵ)
0 = 𝑒(௡ାଵ)
ி+ 𝛾(௡ାଵ)𝑒(௡)
ி+ 𝛾௡𝑒(௡ିଵ)
ி+ … + 𝛾(ଶ)𝑒̇ி+ 𝛾ଵ𝑒ி
Los valores de 𝛾௜ se consiguen al hacer la transformada de Laplace de (2-54) e igualarlos a los
parámetros de estabilizad de Routh-Hurwitz (2-55) .
𝑠(௡ାଵ) + 𝛾(௡ାଵ)𝑠(௡) + 𝛾௡𝑠(௡ିଵ) + … + 𝛾(ଶ)𝑠+ 𝛾ଵ= (𝑠ଶ+ 2𝜉𝑤௡+ 𝑤௡ଶ)ఉ(𝑠+ 𝛼)఑
2.8 Error y esfuerzo de control
La Fig. 2-9 muestra el esquemático de la configuración del sistema de control aplicado a un MP, donde
𝑋̈ௗ, 𝑋̇ௗ, 𝑋ௗ son las aceleraciones, velocidades y posiciones deseadas de la plataforma móvil y 𝑋̈, 𝑋̇, 𝑋 son
las aceleraciones, velocidades y posiciones en un instante de tiempo de la plataforma móvil. La sumatoria
de la norma Euclediana de discretización de la diferencia entre los estados deseados y los actuales se
denomina error de control 𝑒௖ (2-56) .
𝑒௖௑̈ = ෍ฮ𝑋̈ௗ௜−𝑋̈௜ฮ
𝑒௖௑̇ = ෍ฮ𝑋̇ௗ௜−𝑋̇௜ฮ
𝑒௖௑= ෍‖𝑋ௗ௜−𝑋௜‖
El esfuerzo de control (𝐸𝐶) de la Fig. 2-9 cuantifica el torque (𝜏) por unidad de tiempo o el área bajo
la curva que se requiere para llegar a las condiciones deseadas, lo que está relacionado con la energía de la
estrategia de control. Para calcular 𝐸𝐶 se requiere de la sumatoria de la norma Euclediana de la
discretización de 𝜏 (2-57).
2.9 Optimización
En ingeniería la optimización consiste en encontrar los mejores resultados bajo ciertas condiciones; por
ejemplo, encontrar el mejor desempeño de un proceso ante una mínima inversión. Respecto a MPs, la
optimización se enfoca en encontrar las condiciones o parámetros de diseño (estructurales, control, etc) que
generan un mejor comportamiento usualmente representado matemáticamente como funciones objetivo
(FOs) .
El desempeño de un MP depende de más de una función objetivo y tiene más de una solución válida,
por tal motivo se han desarrollado métodos estructurados para la búsqueda de estas soluciones, las cuales
se resumen en la Tabla 2-1.
Fig. 2-9. Esquemático del error y esfuerzo de control.
Tabla 2-1. Clasificación de los problemas de optimización .
Característica del problema
Tipo de función objetivo
Existencia de restricciones
Con restricciones
Sin restricciones
Tipo de variables
Número de FOs
Mono objetivo
Multi objetivo
Una vez el problema ha sido caracterizado, el siguiente paso es escoger el método de optimización, el
cual puede ser método clásico o no tradicional.
2.9.1 Métodos de optimización clásicos
Estos métodos son usados para encontrar los máximos y mínimos de una función que sea doblemente
diferenciable continua con respecto a los parámetros de diseño. La Tabla 2-2 indica la clasificación de estas
Tabla 2-2. Clasificación de métodos clásicos de optimización .
Clasificación de métodos clásicos
Variable simple
Métodos directos
Métodos de gradiente
Multivariable
Métodos directos
Métodos de gradiente
Restricciones
Con restricciones
Sin restricciones
Especializadas
Problemas particulares (i.e.
programación entera).
Debido a que en los MPs existen FOs no lineales con variables mixtas y restricciones no lineales; esta
metodología clásica es poco eficiente y compleja de implementar. Por lo que se utilizan métodos
metaheurísticos basados en búsqueda por entornos y bioinspirados, los cuales se agrupan en métodos no
tradicionales de optimización 
2.9.2 Métodos de optimización no tradicionales
Estos métodos fueron desarrollados debido a que los problemas en ingeniería no suelen cumplir con los
requisitos que requiere una optimización tradicional. Una de las técnicas más usadas en optimización de
MPs son los algoritmos evolutivos (AE), los cuales emulan los principios evolutivos de la naturaleza
(bioinspirados) para llevar a cabo la búsqueda en las configuraciones óptimas. Una de las diferencias más
críticas con respecto a los métodos clásicos es que los AE utilizan una población de soluciones en cada
iteración, lo que genera múltiples respuestas optimizadas en caso de que la naturaleza de este lo requiera.
Existen varios métodos de AE como: algoritmos genéticos, evolución diferencial, ente otros.
2.9.3 Planteamiento de un problema de optimización
En el diseño de un MP se pueden tener varias soluciones válidas dependiendo de la forma en que se
halla planteado el problema considerando criterios adicionales que ayuden a la elección, por lo que este
diseño se maneja como un problema de optimización. Por ello, se requiere encontrar las condiciones que
dan los valores máximos y mínimos de una función objetivo .
El problema de optimización se plantea como (2-58) ; donde 𝐗 es el vector de diseño de 𝑛
dimensiones, 𝑓(𝐗) es la función objetivo y 𝑔௜(𝐗) y ℎ௝(𝐗) son las restricciones de desigualdad e igualdad
respectivamente. Las restricciones representan las relaciones entre las variables de diseño y demás
parámetros que satisfacen y limitan ciertos fenómenos físicos propios del MP. El espacio de búsqueda o de
diseño está definido por 𝐗. Mientras que 𝑔௜(𝐗) fijan el comportamiento el MP, ℎ௝(𝐗) están ligadas a las
respuestas del sistema o a las variables de diseño.
Encontrar 𝐗= 𝑥ଵ
𝑥௡ que minimice 𝑓(𝐗) sujeto a:
𝑖= 1,2,3, … , 𝑚
𝑗= 1,2,3, … , 𝑝
2.9.4 Concepto de dominancia
Muchos algoritmos de optimización usan el concepto de dominancia. En estos algoritmos, dos
soluciones son comparadas con base en si una domina o no a la otra solución. Para explicar esto, Deb 
asume que si hay 𝑀 funciones objetivo, una configuración 𝐗ଵ domina a una configuración 𝐗ଶ si se
cumplen dos condiciones:
1. La solución *𝑓௝൫𝐗ଵ൯ no es peor que una solución de 𝑓௝൫𝐗ଶ൯ para todas las 𝑗= 1,2, … , 𝑀.
2. La solución 𝑓௝൫𝐗ଵ൯ es estrictamente mejor que 𝑓௝൫𝐗ଶ൯ en al menos una 𝑗= 1,2, … , 𝑀.
Este método establece un orden entre las soluciones y determina las deseables para continuar con el
proceso de optimización y generación del Frente de Pareto.
2.9.5 Frente de Pareto
En un problema con varias funciones objetivo, la noción de óptimo cambia porque la meta es encontrar
un conjunto de soluciones en lugar de una única como se hace en la optimización global. La noción de
óptimo adoptada más comúnmente es la propuesta originalmente por Francis Ysidro Edgeworth y
posteriormente generalizada por Vilfredo Pareto; donde, una solución 𝐗∈Ω es un óptimo de Pareto con
respecto a Ω si y solo si no existe un 𝐗ᇱ∈Ω en la cual 𝐕= 𝐹(𝐗ᇱ) = 𝑓ଵ(𝐗ᇱ), 𝑓ଶ(𝐗ᇱ), … , 𝑓௞(𝐗ᇱ) domine a
𝐔= 𝐹(𝐗) = 𝑓ଵ(𝐗), 𝑓ଶ(𝐗), … , 𝑓௞(𝐗) , teniendo en cuenta el concepto de dominancia descrito en la
Sección 2.9.4.
Las soluciones 𝐗 pueden no tener una relación aparente más allá de su pertenencia al conjunto óptimo
de Pareto. Ellas conforman el conjunto de todas las soluciones cuyos vectores asociados no están
dominados; las soluciones óptimas de Pareto se clasifican como tales con base a sus valores funcionales
evaluados y cuando son graficados en el espacio objetivo las 𝐔 forman un Frente de Pareto (FP) . El
procedimiento para generar el FP es calcular muchos puntos 𝐗 en Ω y sus correspondientes 𝐔, ya que no es
fácil encontrar una expresión analítica de la línea o superficie que contiene estos puntos . Cuando hay
un número suficiente de estos es posible determinar los puntos no dominados y graficar su distribución
como en Fig. 2-10.
Fig. 2-10. Esquemático de un FP.
2.9.6 Métodos implementados
En el desarrollo de este trabajo se aplicaron dos técnicas de optimización: 1) una clásica de variable
simple y búsqueda directa llamada Sección dorada y 2) el método no tradicional bioinspirado multiobjetivo
restringido basado en la evolución diferencial (ED).
2.9.6.1 Sección dorada
Esta técnica encuentra una solución de 𝐗 tal que 𝑓(𝐗) tenga el mínimo valor. Este método se basa en la
eliminación de regiones que depende de los valores de 𝑓(𝐗) evaluada en dos puntos y asumiendo que 𝑓(𝐗)
es unimodal en el espacio de búsqueda. Estas técnicas de eliminación de regiones consideran dos puntos
𝐗𝟏 y 𝐗𝟐 dentro de un intervalo (𝑎, 𝑏) y siguen el criterio de selección mostrado en (2-59) .
𝑓(𝐗)௠௜௡ no se encuentra en la zona (𝑎, 𝐗ଵ)
𝑓(𝐗)௠௜௡ no se encuentra en la zona (𝐗ଶ, 𝑏)
𝑓(𝐗)௠௜௡no se encuentra en la zona (𝑎, 𝐗ଵ) ni en (𝐗ଶ, 𝑏)
Las iteraciones de búsqueda dentro del WS se hacen normalizando el espacio de búsqueda (𝑎, 𝑏) a (0,1)
y tomando dos puntos de cada extremo de la zona de búsqueda que abarcan una zona 𝑇= 0.618 (número
dorado). Con las dos nuevas funciones se evalúa cual zona debe ser eliminada hasta que el espacio de
búsqueda sea menor a un límite establecido, tal como lo indica la Fig. 2-11.
Fig. 2-11. Ubicación de los puntos en una búsqueda por sección dorada 
2.9.6.2 Evolución diferencial multiobjetivo elitista restringido
Evolución diferencial (ED) es un algoritmo que simula la evolución combinada para generar una serie
de direcciones de búsqueda basadas en la distribución de la población actual. Cada i-ésimo vector de la
población, es capaz de generar un descendiente llamado vector de prueba (𝑣௛). Estos vectores contienen
las variables de diseño (𝐗) y sus respectivas 𝑛 FOs 𝑓(𝐗)௡. La creación de un nuevo vector o vector hijo 𝑟௛
se describe en los siguientes pasos .
De un tamaño de población de 𝑘 vectores, se calcula la diferencia entre un par de vectores 𝑟ଵ y 𝑟ଶ
elegidos arbitrariamente y diferentes entre sí y del que se trata en ese momento, llamado objetivo o
padre,para definir una dirección de búsqueda.
De la diferencia se genera un vector el cual es escalado usando un parámetro multiplicativo llamado
Factor de mutación 0 < 𝐹< 2 .
Se determina un vector de mutación 𝑟ସ el cual es obtenido de la suma de un tercer vector 𝑟ଷ con el
vector escalado del paso 2. 𝑟ଷ es diferente a 𝑟ଵ, 𝑟ଶ y al vector objetivo.
El vector 𝑟ସ se combina con el vector objetivo (𝑟௣) por cruzado binomial y bajo el control de un
factor de cruza 0 < 𝐶𝑟< 1 el cual determina la similitud entre 𝑟ସ y 𝑟௣. De esta cruza resulta 𝑟௛.
Se agrupan todos los 𝑟௣ y 𝑟௛ y se seleccionan los vectores no dominados. Un vector no dominado
es aquel que genera la mejor solución en al menos una 𝑓(𝐗) y no es peor que todas las demás (Sección
2.9.4). El análisis de dominancia organiza los vectores en varios niveles de frentes.
Si por no dominancia se escoge un número de vectores que excede el tamaño fijo de la población,
se realiza una selección por torneo de hacinamiento. En esta comparación entre las 𝑓(𝐗) de cada nivel de
frente se escogen aquellos que tengan mayor distancia con sus vecinos y se seleccionan los 𝑘 mejores
vectores, que serán los nuevos 𝑟௣.
Aunque existen variantes del ED, en este trabajo se implementó el Ed/rand/1/bin, donde cada vector se
le agrega una penalización en caso de que este incurra en violaciones de las restricciones, se consideran los
𝑟௣ y 𝑟௛, es multiobjetivo, los vectores 𝑟ଵ, 𝑟ଶ y 𝑟ଷ se eligen al azar, solo se usan un par de vectores
diferenciales y existe un cruce binomial.
3 ESTADO DEL ARTE
Durante la última década, más de 200 diferentes MPs se han desarrollado y muchas de esos se han
enfocado en el campo de la automatización, manipulación de material y ensamblaje entre otras, debido a
que se requieren maquinas con alta velocidad y aceleración. Desde 1965 con el trabajo de Stewart , se
ha probado que los MPs son complementarios a los robots seriales. Sin embargo, a pesar de los grandes
esfuerzos en investigación y de anteriores reivindicaciones aún la industria no responde a los MPs y la gran
mayoría de estos mecanismos solo han sido aplicados en laboratorios .
Los retos tecnológicos alrededor de los MPs en cuanto a generación de movimiento están relacionados
con: el diseño mecánico, el análisis cinemático y dinámico, el espacio de trabajo de trabajo y la optimización
entre otros. Por todo lo anterior, se requiere un panorama de los desarrollos e investigaciones en MP y las
particularidades que se deben tener en cuenta al momento de aplicar este tipo de mecanismos en la MA.
3.1 Configuraciones mecánicas de los MPs
Se han desarrollado multitud de MPs, desde los desarrollos de tipo hexápodos como el de Stewart los
cuales al inicio fueron rechazados debido a la dificultad de su control, hasta los diseños más populares como
el tipo Delta. Anteriormente, se destacó la importancia que los MPs tuvieran brazos rígidos, así que, a
continuación, se destacan algunos de estos, los cuales se han aplicado o son aplicables a MA y en donde la
ubicación de los dosificadores o sistemas de cura del material está prevista en la plataforma móvil.
Una forma de describir los MPs es de acuerdo con el tipo de articulación que tienen. Las articulaciones
mas usadas son las prismáticas (P), esféricas (S), rotacional (R), universal (U), helicoidal (H), cilíndrico
(C). Es así, que si un MP posee 6 brazos iguales cada uno con una articulación rotacional, una universal y
una esférica este se describe como un 6 RUS. Por ejemplo, la plataforma Gough Stewart posee 6 brazos
iguales cada uno compuesto por una articulación esférica, una prismática y otra esférica, lo que se resume
como 6 SPS. A lo largo de este texto se describe ejemplos de MPs siguiendo este tipo de abreviación.
Fu et.al. presentaron un robot que consta de 6 DOFs con tres brazos, el cual tiene una estructura
cinemática con tres brazos idénticos conectados de la plataforma base fija hasta la plataforma móvil. Cada
brazo tiene una articulación R activa, dos articulaciones R pasivas, una articulación P activa y una de tipo
U. Las seis articulaciones activas son accionadas por servomotores y sensadas por potenciómetros lineales
(Fig. 3-1). La ventaja de este robot es que las traslaciones y las rotaciones están desacopladas, la posición
final de la plataforma móvil depende únicamente de los actuadores prismáticos, mientras que la rotación
final si depende de los seis actuadores. La reconfiguración de la estructura se simplifica debido a la
estructura modular.
Fig. 3-1. MP de 6 DOFs. A) Isométrico. B) Detalles del sistema rotacional superior .
En algunas circunstancias, cuando el dosificador o boquilla poseen un peso considerable, los MPs con
6 DOFs, en los cuales sus brazos soportan uno o más motores, no son recomendados. Esto se debe a que la
ubicación de los motores en las extremidades incrementa la inercia del sistema, afectando la precisión y la
rigidez. Por tal motivo, hay prototipos de MP con los motores en la base. Wei Ye et.al. expusieron un
MP reconfigurable o reconfigurable parallel mechanism (RPM) enfocado en el proceso de extrusión de
material fundido, buscando que este tuviera la habilidad de reconfigurar su estructura de acuerdo con las
diferentes entradas de trabajo; para esto, crearon un mecanismo paralelo con la habilidad de trasladar su
plataforma móvil en los ejes X, Y y Z y rotarla en el eje X y Y (3T2R); permitiendo agregar material sobre
superficies planas, cilíndricas, circulares y de forma libre. Debido a que requerían mínimo 3 DOFs, fue
necesario hacer que en el diseño la plataforma móvil se uniera a la base fija por medio de 3 brazos. Dos de
los brazos son idénticos y poseen una característica cinemática de tipo PMM- URR. El uso de forma
metamórfica planar da a los brazos la característica de ser reconfigurables híbridos. Este tipo de brazo por
sí solo aporta 6 DOFs, pero la configuración propuesta en este diseño, debido al uso del tercer brazo de tipo
RRUR restringe un DOF; pero, permite configurar el robot a cuatro modos de operación. i.e. 3 traslaciones,
3 traslaciones y solo rotación en X, 3 traslaciones y solo rotación en Y y 3 traslaciones y rotaciones
permitidas en X y Y (Fig. 3-2).
Fig. 3-2. MP configurable .
Por otro lado, Dutta et al. presentaron un robot paralelo RSS de 6 DOFs (Fig. 3-3) con un nuevo
método de detección de fuerzas externas aplicada en la plataforma móvil, evitando sensores de fuerza
externos. Este desarrollo reduce costos, genera MP más compactos y los hace más versátiles. Sin embargo,
el WS es restringido.
Fig. 3-3. 6 DOFs RSS .
Debido a las complejidades y costos que infiere la fabricación de un MP, Song et.al. diseñaron y
fabricaron un robot de bajo costo para trabajar en FFF, las razones para seleccionar esta técnica fueron las
bajas vibraciones y cargas axiales que involucran ese proceso de MA en comparación a otros procesos
como el arranque de viruta. La máquina se basó en un MP tipo Gough Stewart. Este MP usualmente consta
de 6 brazos con dos eslabones; el primer eslabón se une en una esquina por un actuadores pasivo U y por
la otra esquina por un actuador activo tipo P; el otro eslabón se conecta por un lado con el actuador P y por
el otro con la plataforma móvil gracias a una articulación S . Sin embargo, en busca de mayor precisión,
Song et.al. , propusieron que el movimiento de los actuadores lineales fuera generado con una adaptación
de los motores a tornillos de bolas y guiados por ejes lisos. Se utilizaron 6 motores con sus respectivas
adaptaciones. Cada motor fue unido a la base con una articulación de tipo universal (Fig. 3-4). El control
de la altura de la deposición de material fue sensado por medio de un láser y una cámara. La cámara registra
el punto rojo del láser y con la relación de la lejanía de este punto al centro de la cámara se determinó la
distancia entre la boquilla y la superficie.
Fig. 3-4. Esquemático del mecanismo y ensamble de un MP tipo Stewart de bajo costo .
Otro mecanismo 6 RUS probado en varias aplicaciones industriales es el tipo Zamanov . En este
mecanismo los puntos en la base generan un movimiento circular de extremidades tipo R unidas por
articulaciones U. Cada par de extremidades se une en un mismo punto tipo S en la plataforma móvil. Una
ventaja de este MP es su capacidad de movimiento sin sobresaltos mecánicos por la configuración RUS;
sin embargo su WS comparado con otros MP es restringido. La Fig. 3-5 muestra un esquemático de este
Por otra parte, un MP similar al Zamanov 6 RUS es el mecanismo Hunt 6RUS . Este se compone
de dos plataformas triangulares una de ellas fija en el suelo. En la plataforma fija hay 6 actuadores R activos
localizados en cada vértice del triángulo. Cada actuador esta unido a la plataforma móvil a través de un
eslabón. Cada eslabón se une al actuador por medio de una articulación U y la otra esquina está conectada
a la plataforma móvil por una articulación S, como se describe la Fig. 3-5. Este MP tiene la desventaja que,
al no involucrar mecanismos complejos, esto impacta negativamente el WS.
En ocasiones se requieren máquinas capaces de generar mayores velocidades y aceleraciones, debido a
esto Filho y Cabral trabajaron en un robot paralelo con una configuración tipo HEXA, en donde una
plataforma fija es conectada a una plataforma móvil por medio de brazos iguales con articulaciones de tipo
6 RUS (HEXA 6 RUS). Los brazos cumplen un patrón circular centrado en el centro de la plataforma base
y hacen que el robot tenga 6 DOFs (Fig. 3-6), este MP adiciona amplio movimiento en el eje vertical y los
actuadores activos se encuentran en la base de la estructura. El adicionar dosificadores de material en la
plataforma móvil, lo hace una elección apta para MA.
Fig. 3-5. Mecanismo tipo Hunt 6 RUS. A) Esquemático del MP. B) Vista superior de la configuración. .
Fig. 3-6. Robot tipo Hexa .
Algunos MP admiten solo un rango de movimiento rotacional en ciertos puntos debido a las
singularidades mecánicas, algunos autores han solucionado esto con un brazo extra que una la base con la
plataforma móvil pero, Gosselin et al. y Schreiber Gosselin propusieron un MP de 4 DOFs
compuesto por 4 brazos prismáticos activos en donde 2 brazos en un extremo tienen una articulación
rotacional unida a la base fija y en el otro extremo de cada uno hay una articulación rotacional unida a la
plataforma móvil. Los otros 2 brazos en un extremo cada uno está unido a la base fija, en el otro extremo
ambos brazos están unidos con una articulación esférica. Entre la articulación esférica y la plataforma móvil
hay un brazo, la unión entre este brazo y la plataforma móvil es por medio de una articulación rotacional
(Fig. 3-7). Esta configuración permitió el giro libre de la plataforma móvil sin ningún tipo de restricción,
pero se produjo redundancia, fuerzas antagónicas y un incremento en la dificultad de control de
movimiento.
En otras ocasiones se requiere mayor torque en las extremidades, por lo que se deben activar más
articulaciones. El trabajo de Gayral et.al. se enfoca en un MP compuesto de tres brazos con un
incremento de actividad en las articulaciones de rotacionales. Los investigadores propusieron un robot
paralelo de 6 DOFs, basado en tres brazos articulados tipo RRP con dos articulaciones activas y una
articulación prismática transversal en donde puede deslizarse una barra que conecta los brazos móviles con
el actuador triangular final. Las barras están unidas al actuador final por medio de articulaciones universales
ubicadas en los vértices (Fig. 3-8). El valor agregado del diseño es que los actuadores se encuentran en la
base del robot. La ubicación de los actuadores se debe al uso de un sistema de poleas planetario de dos
DOFs, lo que ayuda a transmitir la potencia del motor de la base a la articulación rotacional activa. Debido
a que los motores se encuentran en la base del robot, la masa y la inercia de las extremidades se reduce,
generando un mecanismo liviano. El robot requiere de seis motores para su funcionamiento.
Fig. 3-7. MP de 4 DOFs libre de singularidades .
Fig. 3-8. MP de 6 DOFs. A. Modelo virtual. B. Esquemático de las fuerzas en la plataforma móvil .
Anteriormente se había señalado, que uno de los MPs más utilizados ha sido el tipo Delta, el cual solo
ofrece 3 DOFs en una estructura ligera. Sin embargo, a partir de su estructura se han hecho prototipos
incrementando sus DOFs y WS. Li y Angeles propusieron un robot basado en la distribución de un
robot Delta, con tres brazos que unen la plataforma móvil a la base. Los brazos tienen una distribución
cinemática de tipo CPS donde en la articulación cilíndrica está el actuador. El actuador cilíndrico consta en
su interior de un mecanismo tipo RHHR, en el cual dos tornillos con roscas contrarias, uno frente al otro,
alineados axialmente y paralelos a la base, se encuentran unidos por la articulación helicoidal (Fig. 3-9).
Esto hace que dependa de la dirección y velocidad de giro, la articulación cilíndrica gire o se traslade,
determinando que el robot tenga 6 DOFs y que los actuadores de encuentren cerca a la base, evitando
inercias y aumentando el WS con respecto al robot tipo Delta.
Fig. 3-9. MP de 6 DOFs. A) Esquemático del mecanismo. B) Configuración mecánica de la articulación
cilíndrica .
Otra modificación de un robot tipo Delta es la propuesta por Azulay et.al. , quienes crearon un robot
paralelo que ofrece 6 DOFs soportados en una estructura en donde la plataforma móvil se une a la base por
medio de 3 brazos. Cada uno de los brazos posee las siguientes características evidenciadas en la Fig. 3-10.
En la unión entre el brazo y la base hay un actuador de tipo prismático que se desplaza de forma circular
con respecto al eje Z. Sobre este actuador existe un segundo actuador prismático que se desplaza en
dirección normal con respecto al eje Z. Encima del último actuador hay una tercera articulación cilíndrica
que se une al brazo y permite su rotación. Al otro extremo del brazo hay una articulación esférica unida a
la plataforma móvil. El movimiento normal de los actuadores prismáticos de la base, incremental el WS en
los ejes X y Y, por lo que este mecanismo es propuesto para maquinado de alta precisión y MA.
Fig. 3-10. MP de 6 DOFs. A) Descripción de movimientos. B) Modelo fabricado .
También se han trabajado en mecanismos con cinemáticas desacopladas, un ejemplo es el desarrollo de
Song et.al. quienes propusieron una estrategia de diseño para robots con 4 -6 DOFs, para esto,
proporcionan la traslación en X y Y por medio de una plataforma con articulaciones prismáticas. Sobre esa
plataforma inicialmente proponen una plataforma actuadora sostenida por tres cadenas cinemáticas tipo
UPS y en el centro una de tipo UP. La plataforma actuadora está girada 90° con respecto al eje Y (Fig.
3-11). Dentro de la metodología propuesta se explica la configuración para aumentar o disminuir DOFs. La
rigidez de este MP y bajas inercias sirve tanto procesos de MA como de arranque de viruta.
Fig. 3-11. Prototipo virtual de un mecanismo con 5 DOFs .
Otro trabajo en mecanismos con cinemáticas desacopladas es el de Zhang et.al. . En su trabajo, el
MP se fundamenta en un robot plano con 5 DOFs. La estructura se basa en un mecanismo plano alineado
verticalmente y con todos sus movimientos sobre ese plano. El mecanismo planar tiene 4 brazos idénticos
de tipo PRR, un brazo intermedio y una plataforma móvil. A un extremo de dos brazos se encuentra unida
la plataforma móvil por medio de uniones rotacionales. Al otro extremo cada una las uniones rotacionales
de cada brazo se encuentran unidas a una articulación prismática las cuales son colineales. Al otro extremo
de la estructura, los extremos de los dos brazos restantes se encuentran unidos rotacionalmente al brazo
intermedio, el cual en su otro extremo se une rotacionalmente a la plataforma móvil. Al igual que los
anteriores dos brazos, en el otro extremo hay una unión rotacional entre el brazo y articulaciones prismáticas
colineales. Este mecanismo paralelo aporta movimientos traslacionales verticales y rotacionales en el eje
X. Al anterior robot paralelo se le agrego una base rotacional en el eje Z y la cual también puede deslizarse
por medio de articulaciones prismáticas en el eje X (Fig. 3-12).
Seward y Bonev presentaron un MP de 6 DOFs llamado Hexapteron, que hace parte de la llamada
familia Multipteron, el cual consta de un WS amplio; este MP consiste en 6 brazos cada uno CRS, todos en
una configuración ortogonal como lo indica laFig. 3-13.
Debido al tipo de estructura de los MPs, su WS es reducido en comparación a los robots seriales, Viegas
et.al. propusieron un MP que se basa en soportes de tipo prismático unidos a los brazos por medio de
articulaciones rotacionales. Crearon una estructura basada en 5 rieles que forman una red donde los
actuadores prismáticos pueden desplazarse, aumentando el WS (Fig. 3-14), basándose en la transición entre
rieles; lo que puede generar 8 configuraciones de ensamblaje modular. Se determinó del análisis de
movilidad del mecanismo basado en la sumatoria del número de articulaciones, la espacialidad de cada
brazo y de la plataforma móvil.
Fig. 3-12. Descripción de mecanismo híbrido .
Fig. 3-13. Hexapteron. A. Esquemático. B. Diseño mecánico .
Fig. 3-14. Arquitectura del mecanismo de múltiples rieles .
Entre otros recientes e interesantes MPs – , el mecanismo presentado por Rong et al. se
destaca ya que los autores propusieron un MP configurable (Fig. 3-15) que puede adaptarse a 32
configuraciones diferentes debido a su modo de bloqueo del motor, lo que permite muchos usos con
diferentes grados de libertad.
Fig. 3-15. MP configurable .
En el diseño de un MP, el análisis dinámico es una etapa crucial. Ayuda a comprender el rendimiento y
sirve para encontrar las dimensiones del robot mediante técnicas de optimización.
3.2 Investigaciones en cinemática y dinámica
En el diseño de un MP el análisis CI es una etapa esencial ya que permite conocer la relación de
posicionamiento de la plataforma móvil respecto a los actuadores (Sección 2.2). Por otra parte, como se
mencionó en la Sección 2.4, el análisis dinámico permite determinar las fuerzas y torques relacionados con
el movimiento de la plataforma móvil. A continuación, se describen trabajos realizados con estos enfoques.
3.2.1 Avances en estudio de cinemática inversa
Pedrammehr et al. evaluaron la CI de un MP tipo Hexarot, donde los modelos cinemáticos del
mecanismo se simularon para un escenario de movimiento dado utilizando MATLAB® y ADAMS®, los
cuales tuvieron concordancia con los del modelo ADAMS. De igual forma, Dharmalingum et al. 
presentaron el diseño y análisis de un MP 5 DOF para manipulación de piezas; donde, la CI fue una
extensión del método geométrico con el análisis de cadenas cinemáticas internas y externas; el análisis
cinemático directo se resolvió utilizando el método de Newton-Raphson y los resultados de los análisis
cinemáticos directo e inverso también se validaron con simulaciones de MATLAB® y SolidWorks®.
Adicionalmente, Sheng y Li también validaron la CI de un MP 3RRR con SimMechanics de
De forma complementaria, Russo et al. analizaron la CI de un MP 3-UPR con fines de diseño para
una aplicación de pierna robótica. Ruiz et al. verificaron experimentalmente el impacto de las
redundancias con análisis inverso cinemático y el consumo energético de un MP.
El análisis cinemático inverso también es usado para diseñar MP multioperación o MP de dos
extremidades. De los primeros se estudian las restricciones que definen los . De los segundos, que
pueden tener ventajas, en términos de evasión de colisiones, arquitectura simple, transformación de
configuración rápida y gran WS, el análisis cinemático inverso proporciona una herramienta para encontrar
su configuración óptima .
Asimismo, se pueden encontrar en las bases de datos desarrollos como los de: Shen et al. con un
MP 3 DOFs; Vallés et al. con un MP enfocado en rehabilitación de miembros inferiores; Ren et al.
 con 2 MP 6 DOFs para un robot bípedo; Altuzarra et al. analizaron un MP considerando la
deformación de eslabones; entre otros.
Respecto al análisis de MPs con más DOFs, se encuentra el estudio de CI en un Hunt 6 RUS hecho por
Gil y Aginaga et. al. quienes además trabajaron en las mejoras de la rigidez estática de este
mecanismo usando las singularidades inversas. De forma similar Hesselbach et al. y Dehghani et al.
 determinaron una metodología de calibración para estos mecanismos basados en la CI.
Adicionalmente, existen implementaciones en la planificación de trayectorias; tal como lo hicieron Chen et
al con adición de curvas B spline para manipular un MP 6UPU al igual que Li et al. quienes también
trabajaron con una trayectoria de movimiento libre de singularidad del efector final mediante una curva Bspline de quinto orden.
Otros ejemplos de CI son los de: Antonov y Glazunov quienes estudiaron un MP 6 ODF de tres
cadenas cinemáticas, estableciendo el análisis de movilidad basado en la teoría del tornillo; Kausar et al.
 con su propuesta de un banco de mecanizado configurado como un MP 6 DOFs; Fomin et al. 
quienes se centraron en el análisis cinemático inverso y directo de un MP 6 DOFs con guía circular; Wang
et al que se inspiraron en la manipulación de los brazos para proponer un MP 6 DOFs con dos
extremidades giratorias universales esféricas; Liwei et al. y su estudio de un MP 6 DOFs utilizando el
método de geometría analítica espacial para CI; Thomas et al. quienes plantearon un modelo
cinemático para un MP 3-PPSS usando el algoritmo de Levenberg-Marquardt y de predicción.
Asimismo se encuentran los trabajos de: Anirudh et al. MP 6 DOFs 3-RRRS donde implementaron
su control cinemático a través de Arduino basado en el modelo de cinemática inversa. Liang y Takeda 
quienes presentaron un método iterativo para resolver la CI de mecanismos paralelos de baja movilidad
(LMPM) y Han et al. que estudiaron un MP 6-P-RR-R-RR que debido a las juntas RR, la CI se calculó
iterativamente mediante Newton-Raphson y la validación se hizo utilizando MATLAB®, ADAMS® y un
prototipo físico.
3.2.2 Progresos en modelación de la dinámica
Como se mencionó en la Sección 2.4 existen tres principales enfoques para la determinación de la
dinámica inversa de los MPs: la formulación de N-E, la formulación de E-L y el principio del VW; cada
uno de estos enfoques utiliza diferentes principios físicos y matemáticos para resolver el problema de la
dinámica inversa y algunas implementaciones son descritas a continuación.
3.2.2.1 Aplicación de Newton Euler
En ocasiones, el análisis dinámico de los MPs es trabajado por el método analítico de la mecánica clásica
y N-E. Por ejemplo, Bi y Kang investigaron las características dinámicas de un MP bajo esta
formulación teniendo en cuenta la rigidez de los eslabones y considerando las ecuaciones de fuerza y
momento. Arian et.al. también analizaron la dinámica de un MP de 3 DOFs con el método N-E
presentando las fuerzas y torques de todas las articulaciones. Con el fin de validar los modelos dinámicos
y antes de implementarlos en mecanismos físicos, se sugiere utilizar software multifísico como lo son
ADAMS® y SIMSCAPE ®. Como muestra de esto, Hraiech et al. trabajaron en el comportamiento
dinámico de un mecanismo paralelo de 3 DOFs considerando las incertidumbres de sus parámetros de
diseño, lo cual fue determinado por el formalismo N-E y un algoritmo basado en el operador Krawczyk y
finalmente validado con ADAMS®. Por otra parte, Zhang, Bing, et al. modelaron un mecanismo
accionado hidráulicamente de 3 DOFs por el método N-E, y su verificación fue desarrollada también por
ADAMS®. Otros ejemplos de implementación N-E con ADAMS® son los trabajos hechos por
Pedrammehr et al. quienes analizaron un Hexarot, Li, Jianfeng, et al. , Wang et al. , Zhao et
al. , Arian et al. y Cheng et al. con un análisis de un MP redundante, entre otros. De estas
publicaciones se determina que, aunque N-E es independiente del sistema coordenado, este requiere largos
tiempos computacionales para determinar las reacciones internas, las cuales en muchas aplicaciones no se
requieren.
3.2.2.2 Soluciones con Euler Laplace
Debido a los problemas de eficiencia computacional y de información adicional que a veces no se
requiere se considera la formulación E-L que no se enfoca en las fuerzas de reacción. Sin embargo, el
análisis de MP usando el E-L puede ser exigente debido a que las derivaciones de la cadena cinemática
consideran todas las coordenadas generalizadas independientes lo que ocasiona expresiones largas ,
especialmente si se quiere trabajar cálculo simbólico como lo requieren los problemas de optimización. A
pesar de estos inconvenientes, hay estudios basados en E-L y algunos ejemplos se describen a continuación.
Tomás et al. evaluaron modelo dinámico de un mecanismo 3 PRUS con E-L y multiplicadores de
Lagrange y al igual que en anteriores estudios nombrados, ellos contrastaron sus resultados con ADAMS®.
Kuo y Tang propusieron un control de aceleración apicando tratamiento de imagenes, cuyo objetivo
era adquirir la posición del efector final de un MP de 3 DOFs y reducir los cálculos relacionados con el
modelado E-L. La implementación del sistema visual ayudó a regular las aceleraciones de la posición y el
ángulo de orientación del efector final al imponer un enfoque de servo visual que mejoró el rendimiento
dinámico y el cálculo del tiempo. Sin embargo, la adición de un sistema servo visual al controlador
incrementa la dificultad de implementación. Otros autores que trabajaron con E-L fueron: Muralidharan et
al. con la dinámica directa e inversa de una plataforma Gough-Stewart; Bernal et al. estudiaron
la dinámica de un MP 6-3 PUS con validación en MATLAB® y SOLIDWORKS®; Zhu et al. con
un MP 3 TPT; Geng et al. con la simplificación de la distribución de inercias de los cuerpos y Tsai
and Stamper con un MP translacional 3 DOFs, entre otros. En los anteriores trabajos se reportan
buenos resultados con la modelación E-L; sin embargo, al momento de implementar esta metodología en
problemas de optimización se requieren expresar de forma simbólica lo que la hace larga, compleja,
propensa a errores y costosa computacionalmente debido a las derivadas parciales y al número de
elementos.
3.2.2.3 Empleo del trabajo virtual
Por otro lado, el comportamiento dinámico de los MPs también puede establecerse por medio del VW
(Sección 2.4.3), existen varios ejemplos, como el de Danaei et.al. donde especificaron el modelo
dinámico de un MP tipo Cuadripteron y el de Li et.al. cuyo trabajo se centró en analizar un MP de 5
DOFs enfocado en aplicaciones de manufactura. Debido a las múltiples aplicaciones de los métodos de la
teoría de tornillos y el VW, Gallardo et.al. aplicaron ambas técnicas en la determinación de la
cinemática y dinámica de un MP de 4 DOFs e introduciendo el concepto de vector de primer orden para
computar las fuerzas asociadas a cualquier parte del MP y reduciendo el número de parámetros para
describir la dinámica del robot. Al igual que en N-E y E-L, el VW puede ser validado con software de
simulación mecánica. Como lo hicieron Chai et al. quienes diseñaron, fabricaron y modelaron un MP
3 DOFs 2PRU-UPR y del cual su validación fue por medio de ADAMS® software, al igual que lo hicieron
Yang et al. con un MP híbrido. De forma similar, lo hicieron Dongyi et al. quienes analizaron
dinámicamente un MP con una técnica combinada N-E y VW y validaron esta propuesta por medio de
ADAMS®. Otros ejemplos son los trabajos de Li et al. , Han et al. con un MP 4 DOFs pickand-place. Xie et al. con un MP 3DOF redundante, y Arian et al. con un MP 4 DOFs basado en
movimiento tipo Schӧnflies.
En ocasiones, los modelos dinámicos son desarrollados con software matemático y aplicados en
simuladores de estrategias de control. Uno de esto simuladores es SIMULINK®. Por ejemplo, Ghasemi et
al. derivaron la dinámica con VW, propusieron un sistema de identificación de posición para
evitar el modelo cinemático directo y simplificar la expresión que fue introducida a SIMULINK®.
Otros desarrollos con VW y SIMULINK®. Fueron los presentados por Song et al. y Arian et al.
 . El valor agregado que tiene usar este software es que ayuda a realizar las deducciones
dinámicas ayuda a validar e implementar la estrategia de control; sin necesidad de exportación,
traducción de formatos y versiones; adicionalmente los cambios se pueden hacer en tiempo real y
la implementación física se puede realizar conectando los puertos del computador a los drivers del
mecanismo.
3.3 Tendencias en espacio de trabajo
Como se mencionó anteriormente, lo MP tienen un limitado WS y esto se debe a aquellas
configuraciones en donde el movimiento continuo instantáneo no se pude determinar, estas configuraciones
se conocen como singularidades y muchos estudios se han concentrado en la forma de evitar estas
posiciones críticas .
Cuando se desea diseñar un MP también es necesario entender la naturaleza intrínseca de las
singularidades y su relación con la cinemática y la configuración del MP. Actualmente existen diferentes
puntos de vista de las singularidades en los MPs. Uno de los primeros estudios lo hizo Hunt donde se
definió las singularidades en configuraciones estacionarias y en las no definidas. Merlet propuso
aplicar la teoría de geometría de Grassmann en el estudio de configuraciones particulares. Más adelante,
Gosselin y Angeles definieron 3 tipos de singularidades en términos del rango de la matriz. En
general, una posición singular en un MP se alcanza cuando el determinante de la matriz jacobiana es igual
a cero. Con base en esto, existen las singularidades de cinemática directa y las de CI y más recientemente
se han hecho estudios de singularidades utilizando la teoría de tornillos. Debido a que la capacidad de
movimiento de la plataforma móvil depende de las singularidades mecánicas del mecanismo, se puede
evidenciar la relación directa entre estas y el WS.
Entre las variadas formas de hallar un WS existen enfoques analíticos como los de Gosselin y
Bonev y los basados en discretización. El primero puede ser potencialmente más rápido y preciso,
pero aunque el segundo es de mayor consumo computacional (lo que depende del refinamiento del
muestreo) y con menor precisión, el análisis solo se hace una vez, puede hacerse offline y es más sencillo
de implementar.
Por ejemplo, Ye et.al. estudiaron el WS obteniendo los ángulos limites en el que el mecanismo no
tuviera singularidades; después, se determinaron capas sucesivas con separación constante entre ellas y por
cada capa se hizo un barrido con la condición de que al analizar la cinemática inversa, los ángulos
resultantes no cumplieran con los valores límite de singularidades. De forma similar trabajaron Azulay et.al.
 y An et.al. cuyos esfuerzos se concentraron en la determinación de singularidades de la
discretización del espacio para así determinar la frontera del WS. Mirshekari et.al. compararon el WS
discretizado de 3 MP cada uno compuesto de 6 brazos con articulaciones rotacionales, universales y
esféricas, concluyendo que el MP tipo Hexa ofrece el mayor WS (Fig. 3-16.). La Mura et.al. no solo
analizaron un WS discreto; además, generaron un algoritmo para que los movimientos dentro del WS fueran
suaves y así disminuir errores por inercia.
Fig. 3-16. WS alcanzado por 3 diferentes MP. A) Tipo Hexa. B) Tipo Hunt. C) Tipo Zamanov .
Otro método para determinar el WS es resolviendo la CI utilizando un análisis de intervalos. El análisis
de intervalos se enfoca en el análisis continuo de una serie de puntos en vez de puntos discretos, lo cual
evita la omisión de zonas relacionadas con la resolución o muestreo. El análisis de intervalos provee una
herramienta para evaluar limites superiores e inferiores de una función en la cual los intervalos son
desconocidos .
Por otra parte, Song et.al. validaron el movimiento de su prototipo MP definiendo el valor de cada
articulación al indicar una la ubicación requerida, luego transformaron ese valor a Código G. Este código
G pasó por un verificador de restricciones mecánicas y finalmente se hizo la transformación a cuaterniones
para entrar al controlador de movimiento. El WS en las plataformas tipo Stewart está restringido por dos
variables de diseño. El rango de movimiento de los actuadores lineales y el ángulo de las articulaciones.
Otro análisis de WS se ha hecho con base en el estudio de las singularidades cuando el MP posee varios
modos de ensamble o configuración. Viegas et.al aplicaron la dependencia de las singularidades con
respecto a la nulidad de los determinante de las matrices Jacobianas seriales y paralelas. En el desarrollo de
su MP, describieron que, al haber nulidad en el determinante, se genera una pérdida de un DOFs en la
plataforma móvil y el sistema se vuelve incontrolable. La fundamentación de esto fue el trabajo de Gosselin
y Angeles .
En algunas ocasiones, el analizar la posición de la plataforma móvil en coordenadas no cartesianas
facilita el trabajo, tal como lo hicieron Filho y Cabral , quienes determinaron el WS describiendo la
posición de la plataforma móvil en coordenadas esféricas y en una función que determina si hay o no
restricciones corroborando el estado de las articulaciones. Para tal fin, desarrollaron un algoritmo de
búsqueda semejante a un Fibonacci. Al final, describieron el WS con una orientación fija de la plataforma
móvil y la relación con la orientación total.
A veces, se planea la fabricación del MP para una tarea específica, en donde se sabe el WS esperado,
así como lo planteó Fiore et.al. , quienes definieron el volumen total de trabajo de su prototipo MP, en
donde existían mayores restricciones en el plano X y Y que en el Z, restricciones parecidas a un robot tipo
Delta. Por tal motivo se enfocaron en determinar un WS específico de forma cúbica, forzando el diseño a
acaparar la mayor área posible en X y Y sin ser afectado por las restricciones geométricas del robot. Para
esto, aplicaron algoritmos genéticos para encontrar la dimensión óptima de las articulaciones.
Abeywaderna y Chen también trabajaron con volúmenes predeterminados de trabajo. Describieron
las condiciones en las que su MP podría trabajar. Determinaron un volumen esperado de trabajo de forma
cilíndrica (Fig. 3-17) y a partir de ahí definieron las dimensiones del robot. Por costo computacional debido
a la discretización y a la simetría axial del WS esperado, se analizó solo una sección de restricciones
volumétricas para después realizar un patrón circular de este espacio.
En otras ocasiones se requiere concentrar esfuerzos es en la destreza de movimientos del MP, tal como
lo hicieron Li y Angeles quienes relacionaron las características geométricas del robot con un índice
de destreza, evidenciando la relación entre las dimensiones de la plataforma, dimensiones de la base y la
altura de la plataforma móvil de su prototipo.
Fig. 3-17. Posicionamiento del WS en un MP con análisis cilíndrico de espacio requerido de trabajo .
Para el análisis espacial de MP también se ha propuesto utilizar parámetros adimensionales para evaluar
que tan lejos de una singularidad se encuentra la configuración . Esto puede ser de utilidad en un
proceso de MA en donde se comparten espacios de trabajo entre varios MP .
En el estudio de los WS también es relevante analizar otros parámetros, por ejemplo, Miller 
investigó la forma de diseñar MP en la que los WS tuvieran relación con la manipulabilidad y la utilización
del espacio, con el fin de optimizar el campo de trabajo.
Desde otra perspectiva está el estudio de Zhang et.al. , el cual no solo determinó el WS, sino también
el numero condicional de la matriz jacobiana de velocidad. Esto lo realizaron con una orientación constante
paralela de la plataforma móvil con respecto a la base y modificando el ángulo entre la plataforma móvil y
el brazo intermedio del prototipo. Por otro lado, Song et.al. propusieron examinar el WS de su prototipo
definiendo las restricciones del mecanismo, fundamentadas en el estudio del movimiento y la
transmisibilidad de potencia virtual generalizada global, lo anterior basados en la teoría de tornillos.
Debido a que en ocasiones el movimiento de los brazos está inscrito en un volumen, usualmente una
esfera, el análisis geométrico de las intersecciones de estos volúmenes ayuda a calcular el WS de un MP,
usualmente se utilizan herramientas gráficas, de análisis de volumenes y software de diseño asistido por
computador (CAD), tal como lo hizo Schreiber y Gosselin .
3.4 Estrategias de control en MPs
En cuanto a la estrategia de control, el comportamiento no lineal de la mayoría de los PR y su necesidad
de controlar la relación entre posiciones, velocidades y aceleraciones con los torques del motor, han sido
relevantes. Por lo tanto, los esquemas basados en errores y modelos son las principales estrategias de control
de los MP .
Existen implementaciones de algunos controladores para los MP. El control proporcional, integral y
derivativo (PID) y el control por modos deslizantes han sido los más implementados. Sin embargo, aunque
el primero es el más popular, no ha presentado buenos resultados debido a su incapacidad para garantizar
un buen rendimiento debido a la no linealidad de los MP . Por otra parte, el segundo, ha demostrado
mejores resultados ; sin embargo, el chattering del control atractivo a veces requiere energía adicional
debido a las incertidumbres y las perturbaciones externas.
Todos los controladores requieren sintonizar sus ganancias. Por lo general, es un procedimiento
empírico que no garantiza la mejor precisión y buen rendimiento ya que su implementación ocurre después
del diseño y la fabricación . Por lo tanto, es necesario incluir la sintonización a través del proceso de
diseño en paralelo.
El comportamiento de control también tiene índices de rendimiento. En algunos casos, la energía
relacionada con el movimiento es crítica y se refiere a los requisitos de torque. Debido a esto, el esfuerzo
de control, que involucre los requisitos de torque a través del tiempo, es un indicador adecuado del
desempeño del MP .
3.5 Avances en la optimización de MPs
Otro enfoque relacionado con el estudio de los MPs es su optimización. Como se mencionó
anteriormente existen optimizaciones mono-objetivo y multi-objetivo. Respecto al primero, una función
común en el análisis de los MPs es el comportamiento dinámico. Por ejemplo, Lu et al. optimizaron
un MP 3DOF 3 PPU minimizando la carga angular de las articulaciones con un análisis de VW y validación
con MATLAB®. Por otra parte, Yu et al. diseñaron un MP 3 DOFs enfocado en la aspersion de pintura
pero que puede ser modificable para otras tareas; este sistema se optimizó utilizando CI y rendimiento
dinámico, la contraparte dinámica fue determinada por la teoría VW. Otros estudios han considerado los
MPs y el WS como los de Zhang et al. , Rong et al. , Zhang et al. , Wu et al. y Zhao
Desde otro ángulo, se han desarrollado estrategias de optimización más complejas de MPs trabajando
con más parámetros de diseño e indicadores. Por ejemplo Canran et al. optimizaron y estudiaron 4
mecanismos paralelos planares analizando aspectos cinemáticos, mecánicos y de transmisión como
parámetros de entrada y como afectan estos el WS, para esto dieron pesos a esos parámetros y evaluaron
los resultados del WS analizando las combinatorias de los factores de peso. De forma similar, Russo et al.
 consiguieron una optimización que se hizo con una función mono-objetivo de algoritmos genéticos y
la técnica de sumatoria normalizada de pesos de funciones, donde a cada función objetivo se le asignó un
peso. Este peso fue variado en un algoritmo. Del mismo modo, Yu et al. se enfocaron en un MP 5
DOFs para pintar. Analizaron el WS, la manipulabilidad, la precisión de desempeño y el comportamiento
dinámico. Luego, definieron 3 parametros de diseño relacionado con las longitudes de los brazos y
optimizaron agregando peso a las funciones para analizarlo con algoritmos genéticos mono-objetivo.
Tambien existen desarrollos con tendencia multi-objetivo, algunos ejemplos son el de Huang et al. 
quienes presentaron un MP 3 DOFs de estructura modificable enfocada en procesos de manufactura;
utilizaron una optimización de algoritmos genéticos y generaron un frente de Pareto; analizaron cuatro
parámetros de diseño y 3 FOs; al final, presentaron un indicador de selección de la mejor opción del FP
llamada a comprehensive index que se basa en la sumatoria de las FOs. Además, Li et al. diseñaron
un MP 6 DOFs tipo Stewart considerando cuatro FOs, cuatro variables de diseño y una trayectoria
sinosoidal en las tres dimensiones usando dos estrategias, la primera una de tipo mono-objetivo con
modificación de pesos a las FOs y luego una optimización con Non-dominated Sorting Genetic Algorithm
(NSGA II). Al final, analizaron el FP y escogieron bajo sus requerimientos la mejor opción. Asimismo, Shi
et al. diseñaron una MP de 3 DOFs considerando el largo de los brazos y dos ángulos de configuración
como variables de diseño y el WS y un indice de destreza como FOs, luego generaron un FP usando
NSGA II de MATLAB®.
Adicionalmente, Zhou et al. trabajaron con un MP 3DOF que consta de acuadores lineales fijos
en la base y una estructura con paralelogramos para mejorar la estabilidad. Aunque evaluaron 4 indicadores,
se enfocaron en el WS y un indicador de carga para su diseño. La longitud de los brazos la determinaron
con algoritmos genéticos. Igualmente, Sun and Lian optimizaron un MP con un enfoque multiobjetivo generando un FP entre la rigidez y la masa. finalmente, Enferadi et al. presentaron la
optimización de un MP 3UPS -S usando 3 parámetros de diseño y 4 FOs; los cuales fueron implementados
en un NSGA-II de MATLAB®.
3.6 Conclusión del análisis del estado del arte
En conclusión,aunque existe una variedad de MPs, aquellos con 5 y 6 DOFs permiten los movimientos
que se esperan en MA de la plataforma móvil y disminuyen las imprecisiones causadas por los mecanismos
lineales; sin embargo, ofrecen un WS reducido. En los casos en que se desacoplaron movimientos lineales
y rotacionales, la ubicación de motores a un extremo de los brazos incrementa las inercias y los
requerimientos de control, para disminuir estos efectos se ubican los actuadores en la plataforma fija del
La fabricación, ensamblaje y mantenimiento del MP también es un aspecto a considerar, debido a que
como la MA cobra cada vez más fuerza, los componentes relacionados con el proceso, ensamblaje y
tolerancias de manufactura deben ser viables. Por ejemplo aunque actuadores roscados presentan
resultados, la fabricación y puesta a punto de éstos es compleja por las tolerancias.
Debido a que el MP necesita ser controlado, es indispensable determinar su comportamiento dinámico,
esto se hace por medio de la modelación dinámica. De las tres metodologías más usadas el VW es
computacionalmente más eficiente y puede aplicarse con software matemático para ser implementado en
el controlador en tiempo real. Esto ocurre porque no se requieren derivadas parciales, análisis simbólico ni
estudio de reacciones en las articulaciones. Cabe resaltar que los MPs simétricos favorecen la modelación
por la reducción de escenarios a analizar.
Por otra parte, las optimizaciones implementadas en los MPs se han concentrado en las longitudes de
los brazos y en indicadores como WS y la cinemática; además, al incrementar el número de FOs hay
tendencia a trabajar estas optimizaciones de forma mono-objetivo con valores de peso a las funciones.
Por lo anterior, esta tesis desarrolla una metodología de diseño para un MP enfocado en MA que
considere 5 o 6 DOFs; que analice lo siguiente: el WS, un apropiado índice de manipulabilidad, indicadores
de esfuerzo y error de control, así como las ganancias del controlador; y que se determinen simultaneamente
a través de una estrategia de optimización multi-objetivo como lo es por ejemplo la ED.
4 DESCRIPCIÓN DEL MECANISMO
En esta sección se profundiza la descripción del MP a diseñar entre varios candidatos para luego mostrar
sus características más relevantes. Por esto, se abordan temas como metodologías de comparación, criterios
de selección, configuraciones de las plataformas fijas y móviles y resistencia de los eslabones, entre otros
aspectos. Luego, se analiza el comportamiento cinemático inverso del MP seleccionado y finalmente se
determina su modelo dinámico inverso.
4.1 Selección del mecanismo
La selección del MP se hace considerando los siguientes pasos: Primero, se preseleccionan 6 MPs de
acuerdo con su posible aplicación en MA y a la cantidad de información de estos publicada. Segundo, se
determina la metodología de selección basada en escalas de importancia de criterios relevantes para su
construcción y aplicación en MA. Tercero, se definen los criterios de selección para finalmente implementar
la metodología y seleccionar bajo sumatoria de resultado de evaluación y comparación de criterios el MP a
desarrollar.
4.1.1 Mecanismos analizados
Con base en los MPs más estudiados y con proyección a ser implementados en MA, se eligieron
preliminarmente los seis mecanismos de la Fig. 4-1, detallados en la Sección 3.1, como alternativas a ser
escogidas.
4.1.2 Metodología de selección
La metodología utilizada es AHP. Esta metodología es utilizada para la toma de decisiones y la
resolución de problemas complejos de criterios múltiples. Fue desarrollada por Thomas L. Saaty y se basa
en la comparación de las características de varias opciones con el fin de jerarquizarlas , . La
ventaja de este método es que se pueden incluir datos cuantitativos y cualitativos que por su análisis muchas
veces no son considerados, pero pueden ser relevantes para la toma de decisiones. El método se basa en un
sistema de cotejo por pares donde se comparan 2 criterios bajo el esquema de medición descrita en la Tabla
4-1 y luego se analizan cada una de las alternativas con base en los mismos criterios. La Fig. 4-2 describe
gráficamente este cotejo.
HEXA 6 RUS 
Zamanov 6RUS 
Hunt 6 RUS 
Stewart 
Hexapteron 
Fig. 4-1. MPS preliminarmente seleccionados.
Tabla 4-1. Escala fundamental de valoración.
Intensidad de importancia en una
escala absoluta
Definición
Igual importancia.
Moderada importancia de uno sobre otro.
Esencial o fuerte importancia.
Muy fuerte importancia.
Extrema importancia.
2, 4, 6 y 8
Valores intermedios
Fig. 4-2. Esquema de asociación de criterios
4.1.3 Definición de criterios
Se definen los criterios de evaluación para los seis MPs alternativos descritos anteriormente. Estos
criterios son: movimiento continuo, precisión, robustez, simplicidad de fabricación y WS y su relevancia
se basa en estudios anteriores .
Las características de los MPs se fueron tomadas de las investigaciones de: , , , ,
 , respectivamente y la descripción de cada uno de estos criterios se resume en la Tabla 4-2.
El cotejo por pares de todos los criterios descrito en la Tabla 4-2 y valorado como en la Tabla 4-1 da
como resultado la Tabla 4-3; la cual, describe entre otras cosas que es moderadamente más importante
(valor 4) el movimiento continuo que la Robustez, entre otras relaciones. Una vez analizadas estas
comparaciones, el análisis de todo el conjunto de criterios determinó en su comparación paritaria que el
criterio más relevante es el de movimiento continuo, seguido por la precisión, el WS, la robustez y
finalmente la simplicidad de fabricación.
La Tabla 4-3 describe los resultados del análisis y los valores normalizados de la matriz de pesos; de los
cuales, la mejor opción es la cual se acerca a uno punto cero (1.0). En este caso, la mejor alternativa es el
robot paralelo HEXA 6RUS, seguido por el Hunt 6 RUS. En la Fig. 4-3 se visualiza la sumatoria de los
criterios justificando la elección.
Tabla 4-2. Descripción de criterios.
Descripción
Movimiento continuo
Se relaciona con la capacidad de generar movimientos continuos
sin escalones o sobresaltos. Tiene relación con el tipo de actuador.
Los actuadores de movimientos discretos disminuyen esta
capacidad.
La mínima diferencia que existe entre la posición final de la
plataforma móvil con respecto a la posición que fue enviada desde
el punto de control.
Capacidad física de la estructura para evitar distorsiones del
movimiento debido a las vibraciones del ensamblaje.
Simplicidad de la
fabricación
Las piezas geométricamente complejas, involucran mayor tiempo
de fabricación, más material e incremento en el costo.
Cada mecanismo posee un volumen en el cual pueden moverse,
este volumen tiene restricciones relacionadas con la geometría de
los actuadores y la cinemática conjunta del paralelismo de estos.
Tabla 4-3. Comparación entre criterios.
Movimiento
Simplicidad
Fabricación
Comparación
Movimiento
Simplicidad
Fabricación
Tabla 4-4. Análisis de alternativas.
Movimiento
Precisión Robustez
Simplicidad
Resultado de AHP
HEXA 6 RUS
Hunt 6 RUS
Zamarov 6 RUS
Hexapteron
Fig. 4-3. Representación gráfica de la selección.
4.2 Especificaciones del mecanismo
La Fig. 4-4 muestra el esquemático del MP tipo HEXA 6RUS. Este consta de seis brazos con tres tipos
de articulaciones: rotacional, universal y esférica o RUS (Fig. 4-5). Cada brazo está fijo a una plataforma
fija superior (Fig. 4-6) por su articulación rotacional y por el otro extremo la articulación esférica está unida
a una plataforma móvil (Fig. 4-7). La articulación rotacional es la activa debido a que en esta se fijan los
motores. Los motores son DC de 48V y 60 W, con un sistema planetario que ofrece 4.5 Nm, todo de marca
MAXON® y detallado en el Anexo B
Además, cada brazo consta de dos eslabones: el superior y el inferior: El primero va desde el punto 𝐴
hasta el punto 𝐵 con una longitud 𝑙௕, el segundo va desde el punto 𝐵 hasta el punto 𝐶 con una longitud 𝑙௥;
los seis brazos tienen el mismo valor de 𝑙௕ y 𝑙௥.
El dimensionamiento de la estructura tiene en cuenta varias consideraciones como las dimensiones de
las plataformas, los materiales, las dimensiones de los eslabones y el comportamiento mecánico de los
brazos, las cuales se detallan a a continuación.
Los materiales de fabricación inciden en la resistencia, rigidez, masa y confiabilidad del MP. Existe una
amplia gama de materiales poliméricos y metálicos usados para estos mecanismos. Sin embargo, los
primeros no poseen límites de fatiga que obligan a descartarlos. Las aleaciones metálicas en cambio tienen
ventajas en cuanto a la resistencia a la fluencia, a la fatiga, facilidad de mecanizado y de stock, por lo que
fueron usadas en el MP HEXA 6RUS.
La dimensión 𝐷 de la plataforma fija (Fig. 4-6) está relacionada directamente con el torque del motor,
entre más grande esta dimensión, mayores requerimientos, esta es una plataforma mecanizada en un Acero
AISI 1045 y sus dimensiones se detallan en la Tabla 4-5. Por otra parte, los requerimientos de torques
obligan a que la plataforma móvil sea lo más pequeña y liviana posible. Esta plataforma está fabricada en
6RUS Zamarov
Hexapteron
Robots opcionales
Mov-Continuo
Simplicidad
Volumen de trabajo
Aluminio 7075 T6 y fue dimensionada para que las articulaciones esféricas y el extrusor estuvieran
organizados de forma compacta (Tabla 4-5).
Adicionalmente, los eslabones de los brazos fueron diseñados en Aluminio 7075 T6 con un perfil
cilíndrico de 8 y 6 mm de diámetro para los eslabones superiores e inferiores respectivamente.
Las consideraciones estructurales buscan garantizar criterios de resistencia y estabilidad. Las piezas que
más requerimientos mecánicos necesita son los brazos. El diseño de estos brazos debe considerar la
resistencia, rigidez y la vida útil de los eslabones. Para esto, se toma como base la posición más crítica del
eslabón superior, la cual es cuando este actúa como una barra empotrada paralela a la plataforma fija, tal
como lo indica la Fig. 4-8, donde 𝐹௠ es una sexta parte de la masa de la plataforma móvil, 𝐹ଶ es la fuerza a
la tracción del eslabón inferior, 𝐹ଵy 𝑀் son la carga que soporta y el momento flector del eslabón superior.
Por otra parte, el eslabón inferior está sometido a una tensión por las fuerzas 𝐹ଶ.
Fig. 4-4. Esquemático de la configuración del HEXA 6RUS.
Fig. 4-5. Esquemático de la configuración de un brazo del HEXA 6RUS.
Fig. 4-6. Esquemático de la configuración de la plataforma fija superior HEXA 6RUS.
Fig. 4-7. Esquemático de la configuración de la plataforma móvil del HEXA 6RUS.
Tabla 4-5. Dimensiones de las plataformas.
Descripción
Con respecto al eslabón superior, este se encuentra en un estado combinado de flexión-torsión-carga por
lo que su análisis utiliza la teoría de Von Mises combinada con análisis de fatiga. Para este diseño se
contempla el criterio de Goodman modificado (4-1) y los parámetros del material (Tabla 4-6) donde:
𝑛௙ es el factor de seguridad (Tabla 4-6).
𝑆௬ es la resistencia a la fluencia (Tabla 4-6).
𝑆௔ es la resistencia alternante 𝑆௔= 𝑆௬−𝑆௠.
𝑆௘ límite de resistencia a la fatiga (4-2).
𝑆௠ resistencia media (4-5).
𝑆௨௧ resistencia a la tensión (Tabla 4-6).
𝐷௕ Diámetro del eslabón (Tabla 4-6).
𝐹ଶ fuerza a la tracción del eslabón inferior 𝐹ଶ= 𝐹௠ 𝑡𝑎𝑛 (𝛼).
Fig. 4-8. Esquemático de la distribución de fuerzas de un brazo.
𝑆௘= ඥ𝜎௘ଶ+ 3𝜏௘ଶ
𝜎௘: Esfuerzo máximo en flexión para una viga circular (4-3).
𝜏௘: Esfuerzo máximo cortante para una viga circular (4-4).
2𝐼+ 4 𝐹ଶcos (𝛼)
𝑆௠= ൫𝑆௬−𝑆௘൯𝑆௨௧
Respecto al eslabón inferior, este está principalmente sometido a tensión y debe cumplir con (4-6),
donde 𝑆௧ es el esfuerzo a la tensión en el eslabón y 𝐷௥ es el diámetro del eslabón (Tabla 4-6).
Tabla 4-6. Algunas propiedades del Aluminio 7075 T6 y de los eslabones.
En conclusión, se eligió el HEXA 6 RUS como MP a trabajar llevando a cabo lo siguiente: En primer
lugar, se preseleccionaron seis posibles MP según su aplicabilidad en MA y la cantidad de información
publicada sobre ellos. En segundo lugar, se implementó la metodología AHP que se basa en escalas de
importancia para los criterios: movimiento continuo, precisión, robustez, simplicidad de fabricación y WS.
Una vez analizados los MPs, la suma de los resultados de evaluación y la comparación de criterios presentó
el elegido. Luego, se detalló la configuración mecánica del HEXA 6 RUS y algunas consideraciones
estructurales de los eslabones: para que los eslabones garanticen estabilidad dimensional y una vida útil,
deben contemplar las condiciones de resistencia a la fatiga y a la fluencia las cuales son obligatorias de
cumplir. En el resto de este trabajo se concentran esfuerzos en el diseño del HEXA 6 RUS.
4.3 Determinación de la cinemática inversa
Como se nombró en la Sección 2.2, la CI consiste en determinar las coordenadas generalizadas del
actuador según la posición y orientación de la plataforma móvil respecto, para ello, inicialmente se
describen los vértices de las plataformas y luego de desarrolla el modelo matemático de la relación
plataforma móvil – actuador (Fig. 4-4).
En este trabajo la CI toma particular interés debido a que el MP va a ser aplicado en MA, donde las
posiciones y velocidades de la plataforma móvil deben seguirse según el software discretizador; además,
los ángulos y posiciones determinados en la CI luego son usados en el modelamiento dinámico
(Sección 4.4), que a su vez ayuda a determinar indicadores de desempeño (i.e. manipulabilidad (Sección
5.2)); adicionalmente, la CI se usa en el cálculo del WS (Sección 5.1). Sin embargo, para mayor información
acerca del desarrollo de la cinemática directa del HEXA 6 RUS puede consultarse el trabajo de
Valencia et al. .
4.3.1 Vértices de las plataformas
Las i-ésimas coordenadas de los vértices de la plataforma fija superior (𝒃𝒂𝒊) se describen según
(4-8) a (4-13), mientras que los i-ésimos vértices de la plataforma móvil (𝑝𝑙௜) se describen de (4-14) a
(4-19), todo con base en la Fig. 4-4. Donde 𝐚𝒊 y 𝐜𝒊 son vectores del centro de la plataforma fija y móvil
respectivamente al i-ésimo vértice, mientras 𝐷 y 𝑑 son la magnitud de media arista de las plataformas fija
𝒃𝒂𝟏= ൣa 𝑐𝑜𝑠൫𝑎𝑠𝑖𝑛(𝐷/a)൯
𝒃𝒂𝟐= ൣa 𝑐𝑜𝑠൫𝑎𝑠𝑖𝑛(𝐷/a)൯
𝒃𝒂𝟑= 𝑹𝒛(120) 𝑏𝑎ଵ
𝒃𝒂𝟒= 𝐑𝐳(120) 𝑏𝑎ଶ
𝒃𝒂𝟓= 𝐑𝐳(120) 𝑏𝑎ଷ
𝒃𝒂𝟔= 𝐑𝐳(120) 𝑏𝑎ସ
𝒑𝒍𝟏= ൣc 𝑐𝑜𝑠൫𝑎𝑠𝑖𝑛(𝑑/c)൯
𝒑𝒍𝟐= ൣc 𝑐𝑜𝑠൫𝑎𝑠𝑖𝑛(𝑑/c)൯
𝒑𝒍𝟑= 𝐑𝐳(120௢) 𝒑𝒍𝟏
𝒑𝒍𝟒= 𝐑𝐳(120௢) 𝒑𝒍𝟐
𝒑𝒍𝟓= 𝐑𝐳(120௢) 𝒑𝒍𝟑
𝒑𝒍𝟔= 𝐑𝐳(120௢) 𝒑𝒍𝟒
La matriz de rotación de la referencia absoluta 𝐹 a la referencia que se encuentra en el centro de la
plataforma móvil (ℑ) se determina con (4-20). Donde 𝜑 , 𝜃 y 𝜓 son los ángulos de rotación respecto a la
referencia 𝐹.
𝕴= 𝐑𝐲(𝜃)𝐑𝐱(𝜑) 𝐑𝐳(𝜓)
4.3.2 Modelo matemático para la cinemática inversa
Inicialmente, se halla una referencia relacionada con cada vértice de la plataforma fija (𝐹𝑖) y con cada
vértice de la plataforma móvil (ℱ𝑖). Las matrices de rotación de F a 𝐹𝑖 y de ℑ a ℱ𝑖 se representan con 𝐑𝐅𝐢
(4-21) respectivamente y las cuales dependen del ángulo de rotación 𝛼௜ (4-22), considerando que
𝑖 =1, …, 6.
Luego, la traslación de la referencia 𝐹𝑖 y ℱ𝑖 a los vértices de la plataforma fija (𝐴௜) y móvil (𝐶௜)
son(4-23) y (4-24) respectivamente.
De este modo, el vector que describe la posición de 𝐴௜ respecto a 𝐹 es (4-25).
En la Fig. 4-4, el marco de referencia 𝑓௜= ൣ𝑥௙௜, 𝑦௙௜, 𝑧௙௜൧ está configurado para que 𝑧௙௜ coincida con el
eje de rotación y que 𝑦௙௜ esté perpendicular hacia arriba con respecto a la plataforma fija. Como resultado,
la rotación del marco 𝑓௜ con respecto a 𝐹𝑖 es (4-26).
= 𝐑𝒛(180௢)𝐑𝒙(90௢)
El vector 𝒍𝒃 que describe el i-ésimo eslabón superior es (4-27), el cual inicia en 𝐴௜ y termina en 𝐵௜.
Donde 𝜁 es el ángulo de rotación de la articulación activa según Fig. 4-4.
|𝑙௕|[𝑐𝑜𝑠𝜁, 𝑠𝑖𝑛𝜁, 0]்
La posición de la articulación universal 𝐵௜ con respecto a la referencia 𝐹 es (4-28).
𝒑𝒃௜= 𝒍𝒃𝒊+ 𝒑𝒂𝒊
Teniendo en cuenta que la posición deseada de la plataforma móvil es (4-29).
La posición de la articulación esférica 𝐶௜ con respecto a la referencia 𝐹 es (4-30).
Si 𝐵௜= [𝐵௫௜
𝐵௭௜]் y 𝐶௜= [𝐶௫௜
𝐶௭௜]், la longitud al cuadrado del eslabón 𝑙௥
ଶ es(4-31).
ଶ= (𝐶௫௜−𝐵௫௜)ଶ+ ൫𝐶௬௜−𝐵௬௜൯
ଶ+ (𝐶௭௜−𝐵௭௜)ଶ
0 = (𝐶௫௜−𝐵௫௜)ଶ+ ൫𝐶௬௜−𝐵௬௜൯
ଶ+ (𝐶௭௜−𝐵௭௜)ଶ−𝑙௥௜
La ecuación (4-31) puede ser expresada como la multiplicación de 2 vectores igualada a cero, tal como
lo indica(4-32).
ðହ௜][𝑠𝑖𝑛ଶ𝜁௜
Por lo tanto, 𝜁௜ es (4-33).
𝜁௜= arctan(𝑛𝑢𝑚/𝑑𝑒𝑛)
ðଵହ௜= ðଵ௜+ ðହ௜
𝑛𝑢𝑚= ቆðଵହ௜ðଶ௜
ଶ−ðସ௜ට−ðଶ௜
ଶ൯ቇ/ ቀðଶ௜൫ðସ௜
𝑑𝑒𝑛= ቆðଵହ௜ðସ௜
En el punto 𝐴௜ del marco de referencia 𝑁௜= [𝑥ே௜, 𝑦ே௜, 𝑧ே௜] de la Fig. 4-4, el eje 𝑧ே௜ coincide con 𝑧௙௜ y
𝑥ே௜ con 𝐴𝐵௜; como resultado, la rotación del marco 𝑁௜ con respecto a 𝑓௜ es(4-34).
La rotación del marco de referencia 𝑁௜ con respecto a 𝐹 teniendo en cuenta (4-21), (4-26) y (4-34) es
Ahora, es necesario determinar el vector unitario 𝒒௜ que tiene la misma dirección del eslabón que apunta
a 𝐶௜ desde 𝐵௜. Para esto, lo primero es determinar la ecuación de la cadena cerrada de cada extremidad
según (4-36).
𝒑𝒂௜+ |𝑙௕|𝒔௜+ |𝑙௥|𝒒௜= 𝒑+ 𝒄௜
Donde 𝒔𝒊 es el vector unitario expresado en(4-37) y que apunta a 𝐵௜ desde 𝐴௜, 𝒄௜ (4-38) es el vector que
une el centro de la plataforma móvil a la articulación esférica, tal como lo indica la Fig. 4-4. Para hallar 𝒔௜
se requieren expresar el vector del eslabón superior desde la referencia 𝑁𝑖 :
Por lo tanto, 𝒒𝒊 es (4-39).
𝒒௜= (𝒑+ 𝒄௜−𝒑𝒂௜−|𝑙௕|𝒔௜)/|𝑙௥|
Ahora, se requiere saber la matriz de transformación del marco de referencia ℏ௜= [𝑥ℏ௜, 𝑦ℏ௜, 𝑧ℏ௜] con
respecto a la referencia 𝐹. Para lo anterior se requieren dos marcos de referencia, el ℘ y el ℏ como lo
muestra la Fig. 4-9. Primero, el eje 𝑥ℏ௜ esta alineado con el eslabón inferior y su eje 𝑧ℏ௜ con el eje de giro
de la articulación universal. Para esto, lo primero que se necesita es rotar 90௢ con respecto a 𝑥ே௜ en el
marco de referencia 𝑁௜ (Fig. 4-9. A), esto genera un nuevo marco de referencia ℘𝑖 definido en (4-40).
Luego, la matriz de rotación de la referencia ℏ௜ con respecto a ℘௜=ൣ𝑥℘௜, 𝑦℘௜, 𝑧℘௜൧ puede ser calculada.
Inicialmente, el eje 𝑥℘௜ está alineado con 𝒍𝒃௜; así que se debe hacer una primera rotación ℧ଵ௜ respecto al eje
𝑦℘௜; luego, se rota en el eje z de la nueva referencia un ángulo de ℧ଶ௜(4-41).
Fig. 4-9. Ubicación de los planos de referencia A) ℘ y B) ℏ.
= 𝐑𝒙(90௢)𝐑𝒚(℧ଵ௜)𝐑𝒛(℧ଶ௜)
Por lo anterior, la matriz de rotación para expresar el marco de referencia ℏ௜ con respecto a 𝐹 es (4-42)
, tal como lo indica la Fig. 4-9 B.
Los ángulos ℧ଵ௜ y ℧ଶ௜ se determinan de la siguiente forma. Si el vector 𝒒௜ con respecto a ℏ𝑖 es(4-43) y
𝒒௜ respecto a 𝐹 es (4-39) entonces 𝒒௜ es (4-44); donde ℚ es una matriz de transformación.
𝑐𝑜𝑠(℧ଶ௜)𝑠𝑖𝑛(℧ଵ௜)
𝑐𝑜𝑠(℧ଶ௜)𝑐𝑜𝑠(℧ଵ௜)
Invirtiendo la matriz ℚ y multiplicándola por 𝑞௜ ya se puede determinar ℧ଵ௜ y ℧ଶ௜ según (4-45), teniendo
en cuenta que ℋ= [ℋଵ, ℋଶ, ℋଷ]்.
[ℚ]ିଵ𝑞௜= ℋ
℧ଵ௜= atan (ℋଶ௜/ℋଷ௜)
℧ଶ௜= arcsin (ℋଵ௜)
Finalmente, considerando la Fig. 4-4, el vector que describe al i-ésimo eslabón inferior (𝒍𝒓௜), el cual
inicia en la articulación universal 𝐵௜ y termina en la esférica 𝐶௜ es(4-46).
𝒍𝒓௜= 𝒄௜+ 𝒑்−൫𝒍𝒃௜+ 𝒑𝒂௜൯
4.4 Desarrollo de la modelación dinámica
Como se mencionó anteriormente, existen distintas formas de obtener el modelo matemático de la
dinámica de un robot paralelo como lo son N-E, E-L y VW. Este último se basa en adoptar el principio de
D’Alembert en el cual la suma de las fuerzas a través de un desplazamiento virtual del mecanismo es igual
a cero y ha demostrado ser uno de los menos exigentes a nivel computacional , por lo que se
aplica en el análisis del HEXA 6RUS. Este análisis consta del análisis de velocidad y aceleración, la
evaluación de las matrices jacobianas de velocidades, aceleraciones y de los eslabones y finalmente la
determinación del modelo dinámico.
4.4.1 Análisis de velocidad
Una vez determinada la CI (Sección 4.3), se necesita analizar es la velocidad de los componentes.
Inicialmente, la velocidad lineal deseada de la plataforma móvil según el plano 𝐹 es (4-47).
𝒗𝒑= [𝑥̇, 𝑦̇, 𝑧̇]
La velocidad angular de la plataforma móvil según el marco 𝐹 se indica en (4-48).
𝒘𝒑= ൣ𝜃̇, 𝜑̇, 𝜓̇൧
Si la rotación del i-ésimo eslabón superior con respecto a 𝑓𝑖 es 𝜁௜, entonces la velocidad de rotación
respecto a 𝑓𝑖 se describe como 𝜁ప̇ ; con respecto al plano de referencia 𝐹, la velocidad angular de la
articulación es ℨ̇ (4-49) .
La velocidad lineal del centro de masa del eslabón superior es (4-50).
𝐯𝒃𝒊= ℨప̇ × ൫𝒍𝒃௜/2൯
La velocidad de la articulación esférica 𝒑𝒄ଙ̇ es (4-51).
= 𝒗௣+ 𝒘௣× 𝒄௜
Por otro lado, 𝒑𝒄ప̇ también puede expresarse como (4-52); donde, 𝒑𝒃ప̇ es la velocidad de 𝐵௜ y 𝒘௥௜ es la
velocidad angular del i-ésimo eslabón inferior.
+ 𝒘௥௜× 𝒍𝒓௜
Adicionalmente, la velocidad 𝒑𝒃ప̇ según (4-52) es (4-53).
= 𝒑𝒄ప̇ −𝒘௥௜× 𝒍𝒓௜
La cual también puede plantearse como (4-54).
= 𝖅ప̇ × 𝒍𝒃௜
Reemplazando (4-51), (4-52), (4-53) y (4-54) se obtiene (4-55).
𝒘௥௜× 𝒍𝒓௜= 𝒗௣+ 𝒘௣× 𝒄௜−𝖅ప̇ × 𝒍𝒃௜
Con el fin de obtener 𝒘௥௜, se opera ambos lados de (4-55) por el producto cruz de 𝒍𝒓௜ y se divide por la
norma al cuadrado negativa de 𝒍𝒓௜, así como lo indica (4-63) .
൫𝒗𝒑+ 𝒘𝒑× 𝒄௜−𝖅ప̇ × 𝒍𝒃௜൯× 𝒍𝒓௜
4.4.2 Análisis de aceleración
La aceleración lineal deseada de la plataforma móvil según el plano 𝐹 es (4-57) y la aceleración angular
de la misma se expresa en (4-58).
La aceleración de la plataforma móvil está relacionada con la aceleración angular de la articulación
cilíndrica activa. Por tal motivo, derivando (4-49) se obtiene la expresión (4-59); donde 𝜁̈୧ es la aceleración
angular de la articulación activa y ൣℨ̈ ௫௜
ℨ̈ ௭௜൧ son las tres componentes del vector resultante de las
rotaciones con respecto al marco de referencia 𝐹.
𝜁̈୧]்= ൣℨ̈ ௫௜
La aceleración lineal del centro de masa del eslabón superior se calcula derivando (4-50), generando
𝐯̇𝒃𝒊= 𝖅̈ ௜× ൫𝒍𝒃௜/2൯+ 𝖅̇ ௜× ቀℨ̇ ௜× ൫𝒍𝒃௜/2൯ቁ
Al derivar (4-55) y considerando (4-59), la aceleración del mecanismo se puede describir como (4-61).
Donde la aceleración angular del i-ésimo eslabón inferior es 𝒘̇ ௥௜.
× 𝒍𝒓௜= 𝒘̇ ௥ଵ௜+ 𝒘̇ ௥ଶ௜+ 𝒘̇ ௥ଷ௜
𝒘̇ ௥ଵ௜= 𝒗௣̇ + 𝒘௣̇ × 𝒄௜
𝒘̇ ௥ଶ௜= 𝒘𝒑× ൫𝒘𝒑× 𝒄௜൯−𝖅ଙ̈ × 𝒍𝒃௜− 𝒘௥௜× ൫𝒘௥௜× 𝒍𝒓௜൯
𝒘̇ ௥ଷ௜= 𝖅ଙ̇ × ൫𝖅ଙ̇ × 𝒍𝒃௜൯
4.4.3 Matriz Jacobiana de velocidades
Un paso crítico en la formulación de las ecuaciones de movimiento es la determinación de las matrices
Jacobianas (𝐉𝒑), quienes expresan la relación de la velocidad de las articulaciones (𝜱̇ ) con respecto de la
velocidad de la plataforma móvil 𝑿̇ ; donde 𝑿̇ = [𝑥̇
𝜓̇], tal como lo describe (4-62).
Respecto al mecanismo, (4-55) describe la velocidad del sistema. Con el fin de obtener la matriz
Jacobiana es necesario despejar la velocidad angular de cada i-ésima articulación rotacional 𝜁̇୧; para esto,
se elimina la expresión de la izquierda de la igualdad (𝒘௥௜× 𝒍𝒓௜) de (4-55) utilizando el operador punto, tal
como lo muestra (4-63). De esta forma solo 𝜁̇୧ es incógnita.
൫𝒘௥௜× 𝒍𝒓௜൯∙𝒍𝒓௜
൫𝒗𝒑+ 𝒘𝒑× 𝒄௜−𝖅ଙ̇ × 𝒍𝒃௜൯∙𝒍𝒓௜
൫𝒗𝒑+ 𝒘𝒑× 𝒄௜−𝖅ଙ̇ × 𝒍𝒃௜൯∙𝒍𝒓௜
Al calcular el lado derecho de (4-63), esta expresión puede factorizarse en términos de ൫𝜁̇୧
y el vector (𝓐𝒊)ଵ୶଻, tal como lo señala (4-64).
Al despejar 𝜁̇୧ de (4-64) se obtiene (4-65), donde ൫𝐉𝐩𝐢൯ଵ୶଺ es la i-ésima fila de la matriz Jacobiana de
velocidades.
4.4.4 Matriz Jacobiana de aceleraciones
Otro paso fundamental es la determinación de la transformación de la aceleración de la plataforma móvil
(Ẍ) a las aceleraciones de las articulaciones activas (Φ̈ ) , tal como lo describe (4-66); donde, 𝐉𝒂𝟏es una
matriz de 6 X 6 y 𝐉𝒂𝟐 es un vector de 6 X 1.
𝚽̈ = 𝐉𝒂𝟏Ẍ + 𝐉𝒂𝟐
La base de esta transformación es (4-61); para trabajar con el lado derecho de la expresión se opera por
el producto punto, obteniendo como resultado (4-67).
× 𝒍𝒓௜൯∙𝒍𝒓௜= (𝒘̇ ௥ଵ௜+ 𝒘̇ ௥ଶ௜+ 𝒘̇ ௥ଷ௜) ∙𝒍𝒓௜= 0
El lado derecho de (4-67) puede escribirse como la multiplicación de dos vectores: 𝛃𝐢𝟏𝐱𝟖 y
1൧ଵ୶଼ (4-68).
De esta forma 𝜁ప̈ puede formularse como (4-66), donde 𝐉𝒂𝟏𝒊 y 𝐉𝒂𝟐𝒊 corresponden a la i-ésima fila de la
transformación que ilustra (4-69).
𝜁̈୧= 𝐉𝐚𝟏𝒊[𝒗𝒑̇
𝒘𝒑̇ ]்+ 𝑱𝒂𝟐𝒊
4.4.5 Matrices Jacobianas de los eslabones
Siguiendo la descripción de la velocidad angular de la articulación rotacional ℨ̇ (4-49) y la deducción
de 𝜁̇௜ en (4-65); la ℨ̇ ௜ es (4-70).
La velocidad del centro de masa del i-ésimo eslabón superior con respecto a la referencia 𝐹 (Fig. 4-4),
𝐑̇ 𝒃𝒊 , se formula como (4-71) .
𝐑̇ 𝒃𝒊= 𝖅ଙ̇ × 𝒍𝒃௜/2
Por lo tanto, de (4-71) se puede factorizar 𝑿̇ , lo que da como resultado la matriz Jacobiana de velocidades
del i-ésimo eslabón superior 𝐉𝑹𝒃𝒊 (4-72).
Ahora, teniendo en cuenta que 𝖅ଙ̇ se expresa como (4-70), la velocidad angular del i-ésimo eslabón
inferior 𝒘𝒓𝒊 según (4-56) se puede escribir como (4-73). Esto determina que 𝒘𝒓𝒊 es función de 𝑋̇.
൫𝒗𝒑+ 𝒘𝒑× 𝒄௜−( 𝐑ி௜
𝐉𝐩𝐢𝑋̇ ்൧) × 𝒍𝒃௜൯× 𝒍𝒓௜
Luego, las velocidades del centro de masa del i-ésimo eslabón inferior (𝑹̇ 𝒓𝒊); considera 𝒘𝒓𝒊 (4-73) y la
longitud del eslabón, se describe como (4-74).
𝑹̇ 𝒓𝒊= 𝒘௥௜×
De forma similar que (4-72) se factorizan los términos 𝑋̇ de 𝖅ଙ̇ (4-70), de 𝒘𝒓𝒊 (4-73) y 𝑹̇ 𝒓𝒊 (4-74)
generando las matrices Jacobianas relacionadas en (4-75) (4-76) y (4-77) respectivamente.
𝖅ଙ̇ = 𝐉𝝎𝒃𝒊𝑋̇
𝒘𝒓𝒊= 𝐉𝝎𝒓𝒊𝑋̇
𝑹̇ 𝒓𝒊= 𝐉𝑹𝒓𝒊𝑋̇ = ቎
4.4.6 Modelo dinámico por el principio de trabajo virtual
Con el fin de analizar la dinámica inversa, se requiere una trayectoria deseada de la plataforma móvil
para determinar el torque requerido para producir ese movimiento; el cual depende de los parámetros
estructurales, la posición, la cinemática, la gravedad, las fuerzas externas y el momento ejercido en la
plataforma móvil. Por lo anterior, la ecuación explicita de la dinámica del mecanismo es (4-78), donde 𝜏 es
el vector de torque de las articulaciones activas, 𝑀 es la matriz de inercia, 𝐶 relaciona el vector de Coriolis
y de los términos centrifugales y 𝐺 es el vector de las fuerzas gravitacionales
𝜏= 𝑀𝑋̈ + 𝐶+ 𝐺
Las ecuaciones dinámicas de movimiento son formuladas bajo los principios de D’Alembert y del VW
debido a las ventajas computacionales anteriormente mencionadas. Estas ecuaciones se plantean usando el
concepto de sistemas de fuerzas equipolentes que consisten en una fuerza y un momento que reemplazan
todas las fuerzas y momentos incluyendo las de reacción que actúan sobre el mecanismo .
El VW del mecanismo relaciona el trabajo ejercido por los momentos y por las fuerzas. El VW que
ejerce el momento se define como el producto entre la suma de los momentos del centro de masa
൫𝑀௜−𝐽௜𝜃̈ ௜൯, donde 𝑀 son los momentos aplicados, 𝐽 son los momentos de inercia, 𝜃̈ las aceleraciones
angulares y los cambios virtuales en la orientación angular del cuerpo ൫𝛿𝜃௜൯. El VW que ejercen las fuerzas
es el producto de las fuerzas resultantes aplicadas en el centro de masa ൫𝐹௜−𝑚௜𝑎௜൯ donde 𝐹 son las fuerzas
aplicadas en el centro de masa, 𝑚 es la masa del sistema y 𝑎 las aceleraciones, por los cambios virtuales de
desplazamiento ൫𝛿𝑅௜൯ , tal como lo relaciona (4-79).
൫𝑀௜−𝐽௜𝜃̈ ௜൯𝛿𝜃௜= 0
Adicionando las dos ecuaciones de (4-79) se obtiene (4-80) la cual expresa y clasifica el VW en dos
aspectos: el generado por las fuerzas externas (𝛿𝑊௘) y el ocasionado por las fuerzas internas y las inercias
𝛿𝑊௘= 𝐹௜𝛿𝑅௜+ 𝑀௜𝛿𝜃௜
𝛿𝑊௜= 𝑚௜𝑎௜𝛿𝑅௜+ 𝐽௜𝜃̈ ௜𝛿𝜃௜
Como se mencionó, 𝛿𝑊௘ se relaciona con las fuerzas externas (𝐹௘) y 𝛿𝑊௜ con las fuerzas internas (𝐹௜),
ambas asociadas a un sistema independiente de coordenadas (𝛿𝑞) según , por lo que (4-80) puede
expresarse como (4-81).
Debido a que 𝛿𝑞≠0, entonces (4-82).
De acuerdo con lo anterior, la aplicación del principio de VW en el mecanismo puede enfocarse en las
fuerzas externas y las fuerzas inerciales.
4.4.6.1 Determinación del trabajo virtual de las fuerzas externas
El VW que las fuerzas externas ejercen sobre el sistema lo describe (4-83); donde 𝛿𝜁 es la rotación
virtual del actuador activo, δ𝑏௭ es el desplazamiento virtual en z del eslabón superior, m௕ masa del eslabón
superior, 𝑔 gravedad, δ𝑟௭ es el desplazamiento virtual en z del eslabón inferior, m௕ masa del eslabón
superior, m௥ masa del eslabón inferior, 𝛿𝑧 es el desplazamiento virtual en z de la plataforma móvil y m௣
es la masa de la plataforma móvil.
δ𝜁𝜏+ δ𝑏௭(−m௕𝑔) + δ𝑟௭(−m௥𝑔) + 𝛿𝑧൫−m௣𝑔൯
Considerando (4-65), (4-72) y (4-77), se puede reescribir (4-83) como (4-84).
൫J௣δ𝑋൯𝜏+ (Jோ௕௭δ𝑋)(−m௕𝑔) + (Jோ௥௭δ𝑋)(−m௥𝑔) + 𝛿𝑧൫−m௣𝑔൯
Reorganizando (4-84) respecto a 𝛿𝑋 se obtiene (4-85).
்(−m௕𝑔) + 𝐉𝑹𝒓𝒛
Debido a que 𝛿𝑋≠0, se despeja 𝜏 y se plantea (4-86).
்(m௕𝑔) + 𝐉𝑹𝒓𝒛
Por lo anterior, la totalidad de las fuerzas externas 𝐹௘ equivalen a la sumatoria de las fuerzas involucradas
en el VW de cada una de las seis extremidades más las relacionadas con la plataforma móvil, reescribiendo
esto se tiene (4-87).
𝑸𝒆= ෍ቀ𝐉𝑹𝒃𝒛𝒊
𝑻(m௕𝑔) + 𝐉𝑹𝒓𝒛𝒊
4.4.6.2 Análisis del trabajo virtual de las fuerzas internas e inerciales
El VW de las fuerzas inerciales se puede analizar por cada uno de los componentes del sistema; de este
modo F௕, F௥ y F௣ relaciona las fuerzas de los eslabones superiores, inferiores y las relacionadas con la
plataforma móvil respectivamente, tal como (4-88).
δ𝑋F௕+ δ𝑋F௥+ δ𝑋F௣
δ𝑋൫F௕+ F௥+F௣൯
Por lo anterior, el primer paso es analizar las fuerzas internas de la plataforma móvil (𝐹௣). El tensor de
inercia de este componente respecto a 𝐹 es (4-89); donde 𝐈𝒑𝒄 es el tensor de inercia de la plataforma, el cual
es calculado en el software CAD donde fue diseñada la plataforma.
La representación de 𝐹௣ es (4-90).
𝐅𝒑= 𝐅𝒑𝑴𝑋̈ + 𝐅𝒑𝑪
𝑚௣ es la masa de la plataforma.
𝑰𝒏 𝐗 𝒎 es la matriz identidad de n X m.
El siguiente paso es analizar las fuerzas internas del i-ésimo eslabón superior (𝑭𝒃𝒊). El tensor de inercia
del i-ésimo eslabón superior respecto a 𝐹 es (4-91); donde 𝑚௕ es la masa del eslabón superior
Considerando la descripción de fuerzas internas de y los desplazamientos virtuales, el VW del i-
ésimo eslabón superior relacionado con las fuerzas internas es (4-92).
δ𝑅𝑏𝑖𝑚௕𝒗̇ 𝒃𝒊+ δ𝜛௕𝐈௕௜𝖅̈ 𝒊+ δ𝜛௕௜ቀ𝖅̇ 𝒊× ൫𝐈𝒃𝒊𝖅̇ 𝒊൯ቁ
Considerando (4-72) y (4-75), se puede reescribir (4-92) como (4-93).
(𝐉𝑹𝒃𝒊δX) 𝑚௕𝒗̇ 𝒃𝒊+ (𝐉𝝎𝒃𝒊δX) 𝐈௕௜𝖅̈ 𝒊+ (Jఠ௕௜δX) ቀ𝖅̇ 𝒊× ൫𝐈𝒃𝒊𝖅̇ 𝒊൯ቁ
Teniendo en cuenta (4-60) y reorganizando (4-93) respecto a 𝛿𝑋 se obtiene (4-94).
𝐉𝑹𝒃𝒊𝑚௕ቀ𝖅̈ 𝒊× ൫𝒍𝒃௜/2൯ቁ+ 𝐉𝝎𝒃𝒊𝐈𝒃𝒊𝖅̈ 𝒊
+𝐉𝑹𝒃𝒊𝑚௕൬𝖅̇ 𝒊× ቀ𝖅̇ 𝒊× ൫𝒍𝒃௜/2൯ቁ൰+ 𝐉𝝎𝒃𝒊ቀ𝖅̇ 𝒊× ൫𝐈𝒃𝒊𝖅̇ 𝒊൯ቁ
Se factoriza 𝖅̈ 𝒊 de modo tal que (4-94) quede como (4-95), donde 𝚼𝒊 es una matriz de 6X3 que resulta de
la factorización.
+𝐉𝑹𝒃𝒊𝑚௕൬𝖅̇ 𝒊× ቀ𝖅̇ 𝒊× ൫𝒍𝒃௜/2൯ቁ൰+ 𝐉𝝎𝒃𝒊ቀ𝖅̇ ௜× ൫𝐈𝒃𝒊𝖅̇ 𝒊൯ቁ
𝝁𝒊 es una matriz de 6X3 donde cada columna puede representarse de la siguiente forma 𝜇௜=
𝜇ଷ௜], 𝐹௕௜ puede declararse como (4-96).
𝐉𝒂𝟏𝒊 𝑋̈ + 𝐉𝒂𝟐𝒊
+𝐉𝑹𝒃𝒊𝑚௕൬𝖅̇ 𝒊× ቀ𝖅̇ 𝒊× ൫𝒍𝒃௜/2൯ቁ൰+ 𝐉𝝎𝒃𝒊ቀ𝖅̇ 𝒊× ൫𝐈𝒃𝒊𝖅̇ 𝒊൯ቁ
𝝁𝒊= 𝚼𝒊𝐑ி௜௝
La representación de 𝐹௕ es (4-97).
𝐅𝒃= 𝐅𝒃𝑴𝑋+𝐅𝒃𝑪
𝐅𝒃𝑴= ෍𝜇ଷ௜𝐉𝒂𝟏𝒊
𝐅𝒃𝑪= ෍𝜇ଷ௜𝐉𝒂𝟐𝒊
+ ෍𝐉ோ௕௜𝑚௕൬𝖅̇ 𝒊× ቀ 𝖅̇ 𝒊× ൫𝒍𝒃௜/2൯ቁ൰+ 𝐉𝝎𝒃𝒊ቀ𝖅̇ 𝒊× ൫𝐈𝒃𝒊 𝖅̇ 𝒊൯ቁ
Lo siguiente es analizar las fuerzas internas del i-ésimo eslabón inferior (𝐹௥௜). El tensor de inercia del
eslabón inferior respecto a 𝐹 es (4-98); donde 𝑚௥ es la masa del eslabón inferior
El VW del i-ésimo eslabón inferior relacionado con las fuerzas internas es (4-99); donde, 𝛅𝑹𝒓 es el
desplazamiento virtual del eslabón inferior y δ𝜛௥ es la rotación virtual del eslabón inferior.
𝛅𝑹𝒓𝑚௥𝒗̇ 𝒓+ 𝛅𝝕𝒓𝐈𝒓𝒘̇ 𝒓+ 𝛅𝝕𝒓൫𝒘𝒓𝒊× (𝐈𝒓𝒊𝒘𝒓𝒊)൯
Considerando (4-76) y (4-77), se puede reescribir (4-99) como (4-100).
(𝐉𝑹𝒓𝒊𝛅𝑿)𝑚௥𝒗̇ 𝒓+ (𝐉𝝎𝒓𝒊𝛅𝑿)𝐈𝒓𝒘̇ 𝒓+ (𝐉𝝎𝒓𝒊𝛅𝑿)൫𝒘𝒓𝒊× (𝐈𝒓𝒊𝒘𝒓𝒊)൯
Reorganizando (4-100) respecto a 𝜹𝑿 se obtiene 𝐅𝒓𝒊 según (4-101). Donde, 𝝈 corresponde a una matriz
de 6X3, que representa la factorización de (𝐉𝑹𝒓𝒊 𝑚௥) ቀ𝒘̇ 𝒓𝒊× ൫𝒍𝒓௜/2൯ቁ+ (𝐉𝝎𝒓𝒊 𝐈𝒓𝒊) con respecto 𝒘̇ 𝒓𝒊.
𝐅𝒓𝒊= 𝝈𝒘̇ 𝒓𝒊+ 𝐉𝝎𝒓𝒊
𝑻(𝒘𝒓𝒊× 𝐈𝒓𝒊𝒘𝒓𝒊)
Adicionalmente, (4-101) puede expresarse como (4-102); donde 𝜌௜ es una matriz de 6X3 que denota
𝝆𝒊= 𝝈𝒊𝐑𝑭𝒊𝒋
y cada columna puede expresarse de la siguiente forma 𝝆𝒊= [𝜌ଵ௜
𝐽௔ଵ௜𝑋̈ + 𝐽௔ଶ௜
൩+ 𝝈(𝒘̇ 𝒓𝟏𝒊+ 𝒘̇ 𝒓𝟐𝒊) + 𝐉𝝎𝒓𝒊
்(𝒘𝒓𝒊× 𝐈𝒓𝒊𝒘𝒓𝒊)
Por lo anterior, las fuerzas relacionadas con el eslabón inferior son (4-103).
𝐅𝒓= 𝐅𝒓𝑴𝑿̈ + 𝐅𝒓𝑴
𝐅𝒓𝑴= 𝝆𝟑𝒊𝐉𝒂𝟏𝒊
𝑖= 1, … ,6.
𝐅𝒓𝑪= 𝝆𝟑𝒊𝐉𝒂𝟐𝒊+ 𝝈(𝒘̇ 𝒓𝟏𝒊+ 𝒘̇ 𝒓𝟐𝒊) + 𝐉𝝎𝒓𝒊(𝒘𝒓𝒊× 𝐈𝒓𝒊𝒘𝒓𝒊)
𝑖= 1, … ,6.
Teniendo en cuenta (4-82), (4-87), (4-97) y (4-103) se determina 𝝉 como (4-104).
்ିଵ𝑸𝒆−𝐅𝒓𝑴𝑿̈ −𝐅𝒃𝑴𝑿̈ −𝐅𝒃𝑪−𝐅𝒓𝑴
Finalmente, ya se pueden plantear las expresiones 𝐌 (4-105), 𝐂 (4-106)y 𝐆 (4-107) de (4-78).
்/൫𝐅𝒑𝑴+ 𝐅𝒃𝑴+ 𝐅𝒓𝑴൯
்/൫𝐅𝒑𝑪+ 𝐅𝒃𝑪+ 𝐅𝒓𝑪൯
En conclusión, por el método AHP y criterios de movimiento continuo, precisión, robustez, simplicidad
de fabricación y WS, se seleccionó el MP HEXA 6 RUS. Su análisis de CI requiere las dimensiones de la
distribución hexagonal de los actuadores, así como las matrices de rotación que modifican los planos de
trabajo según el eje de rotación, las dimensiones de los brazos y de las plataformas. Adicionalmente, se
desarrolló la modelación de la dinámica inversa del MP, esto requiere de un análisis de velocidad y de
aceleración en las cuales hay un enfoque en el comportamiento de la articulación activa rotacional. Debido
a quien rige el movimiento es la plataforma móvil, es necesario relacionar el movimiento de esta plataforma
con respecto a las articulaciones; para esto, se determinan las matrices Jacobianas de velocidad, aceleración
y de los centros de masa de los eslabones. Una vez determinado dichos análisis y matrices, el MP se puede
modelar bajo el principio de VW que considera el VW de las fuerzas externas, internas e inerciales y los
movimientos virtuales. El desarrollo de la CI y de la dinámica se hicieron en MATLAB® se puede
nencontrar en el Anexo C.
5 DETERMINACIÓN DE LAS FUNCIONES
Con el fin de optimizar el diseño del HEXA 6 RUS es necesario determinar las FOs: el WS (Sección 2.5),
la manipulabilidad (Sección 2.6), el EC y el 𝑒௖ (Sección 2.8). Las dos primeras dependen de la CI y de las
matrices Jacobianas; mientras que las dos últimas, dependen de la respuesta de la estrategia de control.
5.1 Cálculo del espacio de trabajo
Los MPs poseen ventajas en cuanto a rigidez, momentos e inercias comparados con los mecanismos
seriales; sin embargo, tiene desventajas entre otras cosas por su reducido WS y su manipulabilidad, ambas
ocasionadas por las cadenas cinemáticas cerradas. Por tal motivo, dichas características se hacen
indispensables al momento del diseño del HEXA 6RUS. En términos de multidireccionalidad y
procesamiento el WS es relevante para determinar el volumen de la pieza que se puede fabricar.
El estudio del WS del HEXA 6RUS se enfoca en un método de orientación fija de forma discreta
configurable (Sección 2.5). Para esto se deben considerar tres fases: la evaluación de posición, la generación
de nube de puntos y el cálculo del volumen.
5.1.1 Evaluación de posición
Con el fin de evaluar las posiciones límites del WS se utiliza una función que evalúa y encuentra una
posición no restringida considerando el punto inicial y la dirección de un vector. Esta función se aplica a
cada posición a evaluar y tiene dos aspectos importantes: el estudio de las restricciones y la implementación
algorítmica.
La función de evaluación tiene como entrada la posición de la plataforma móvil y retorna un dato
booleano de uno (1) si todas las restricciones se respetan o cero (0) si al menos una restricción no se cumple.
Se considera que las posiciones no restringidas más alejadas del centro crean el límite del WS. La
Fig. 5-1 esquematiza la búsqueda del límite del WS que consta de cinco pasos.
1. La búsqueda inicia creando un vector 𝑣௟ entre el punto inicial 𝑃௖ y el punto a estudiar.
2. Se define una tolerancia ε.
3. La búsqueda empieza a una magnitud |𝑣௟|.
4. El algoritmo alterna la magnitud del vector 𝑣௟ aumentándola o disminuyéndola, dependiendo si no
existen o existen restricciones respectivamente.
5. La magnitud se va modificando según el número dorado 0.618 (Sección 2.9.6.1) hasta que esté
dentro de la zona ε.
Por lo anterior es necesario definir las restricciones e implementarlas en un algoritmo de búsqueda de
sección dorada.
Fig. 5-1. Esquemático de búsqueda sección dorada.
5.1.1.1 Restricciones
Las restricciones que se tienen en cuenta son los ángulos entre las plataformas y los eslabones. El ángulo
entre la plataforma fija y el eslabón superior 𝜁௜ ilustrado en Fig. 4-4 y descrito en la CI (4-33) debe ser real
y positivo (5-1) .𝜌
El ángulo 𝜂௜ (Fig. 4-8) entre el eslabón superior (𝐴𝐵𝑖) y el eslabón inferior (𝐵𝐶𝑖) debe ser real y mayor
a 90º (5-2). Este ángulo es calculado siguiendo el producto punto tal como lo muestra (5-3).
𝜂௜= arccos ቆ−
ห𝑙௕௜หห𝑙௥௜หቇ
El ángulo 𝜆௜ entre el eslabón inferior y la plataforma móvil (𝒄𝒊) de la Fig. 4-8 debe ser real y mayor a
90º (5-4). Este ángulo es calculado siguiendo el producto punto tal como lo muestra (5-5).
𝜆௜= arccosቆ−
ห𝑙௥௜ห|𝑐௜|ቇ
Al final, una posición no restringida es aquella en donde cada uno de los i-ésimos brazos cumple las
condiciones anteriormente descritas.
5.1.1.2 Algoritmo
El Pseudocódigo 5-1 detalla la búsqueda con sección dorada implementada en la determinación de
posiciones no restringidas, donde el vector que inicia en X=0 y Y=0 tiene un origen  y un punto final ψ,
tal como lo muestra
Fig. 5-1. La búsqueda va alternando su zona de enfoque un rango de 0.618 y analiza
si hay restricciones de movimiento con la subfunción EVAL POS.
5.1.2 Generación de nube de puntos
El objetivo es crear puntos coordenados en el espacio que luego serán evaluados para crear la superficie
externa del WS. Como el HEXA 6RUS es simétrico solo se calcula un tercio de su volumen y luego se
replica, así que solo se genera una porción de la nube de puntos. Para esto se requieren hallar los puntos
críticos o límites y la determinación de puntos no restringidos que generan el límite del WS.
5.1.2.1 Puntos críticos
El punto inicial 𝑃௖ siempre se encuentra sobre el eje Z así que X=0 y Y=0.
Para la creación de nube de puntos, se recorre la distancia di desde el punto más alto alcanzable 𝑃௧௢ hasta
el punto más bajo alcanzable 𝑃௕௢ con un cierto paso 𝑝௪௦ , tal como lo muestra la Fig. 5-2.
Con el fin de calcular el 𝑃௧௢, el vector 𝑣௟ inicia en la plataforma fija superior alineado con el centro de
esta y apuntando hacia abajo; luego su magnitud empieza a manipularse según la Sección 5.1.1.2 hasta
encontrar el primer punto no restringido.
Luego, para hallar el 𝑃௕௢ el vector 𝑣௟ inicia en la plataforma fija superior alineado con el centro de esta
y apuntando hacia abajo; luego se configura |𝑣௟| = 2(𝑙௕+ 𝑙௥), esta magnitud también se manipula según
Sección 5.1.1.2. y se considera que este punto no debe estar más abajo que la base de la estructura.
Una vez determinado di y seleccionado el paso con que se recorre esta distancia, lo siguiente es crear el
punto medio 𝑃௠, el cual es el promedio entre el límite superior y el límite inferior.
Fig. 5-2. Puntos más bajos y altos del WS
Pseudocódigo 5-1. Búsqueda con sección dorada
Valor del error
Magnitud de 𝜕
𝑣𝑢𝑝= 𝑢ො(𝜕)
Vector unitario de 𝜕
𝑎= 0; 𝑏= 𝑚𝑉
Inicializar: 𝑎𝑤= 0; 𝑏𝑤= 1; 𝐿𝑤= 𝑏𝑤−𝑎𝑤; 𝑘= 0
if |𝐿𝑤(𝑏−𝑎)| > 𝑒𝑟𝑟𝑜𝑟
while |𝐿𝑤(𝑏−𝑎)| > 𝑒𝑟𝑟𝑜𝑟
𝑤1 = 𝑎𝑤+ 0.618 𝐿𝑤
𝑤2 = 𝑏𝑤−0.618 𝐿𝑤
𝑋1 = 𝑤1(𝑏−𝑎) + 𝑎
𝑃𝑋1 = [𝑋1𝑣𝑢𝑝+ 𝜌, 0,0,0]
El vector va modificando su magnitud,
manteniendo su origen y dirección.
EVAL POS 𝑖𝑛(𝑃𝑋1, 𝐿௕, 𝐿௥) = 𝑓𝑎𝑙𝑠𝑒
Si al menos hay una restricción en 𝑃𝑋1
considerando los valores de 𝐿௕ y 𝐿௥.
𝐶𝑜𝑜𝑟𝑑𝑒𝑛𝑎𝑑𝑎= 𝑃𝑋1
El algoritmo retorna la coordenada no
restringida
𝑤1 = 𝑎𝑤+ 0.618 𝐿𝑤
𝑤2 = 𝑏𝑤−0.618 𝐿𝑤
𝑃𝑋1 = [𝜌, 0,0,0]
if 𝐸𝑣𝑎𝑙𝑃𝑜𝑠𝑖𝑛(𝑃𝑋1, 𝐿௔௥௠, 𝐿௥௢ௗ) = 𝑓𝑎𝑙𝑠𝑒
𝐶𝑜𝑜𝑟𝑑𝑒𝑛𝑎𝑑𝑎= 𝑃𝑋1
5.1.2.2 Determinación de puntos
Por cada 𝑝௪௦ se generan puntos uniformemente distribuidos a un ángulo 𝑎௛ en el plano X-Y en un
barrido total de 120º, tal como lo ilustra Fig. 5-3. Cada punto se ubica en la zona límite de restricciones
aplicando la función de evaluación de posición anteriormente descrita.
Fig. 5-3. Vista superior de la sección analizada.
5.1.3 Cálculo del volumen
Una vez generados todos los puntos no restringidos, se considera 𝑃௠ como el centro del volumen,
entonces, se seleccionan tres puntos de la nube de puntos y junto con 𝑃௠ se crea un tetraedro y se calcula
su volumen. La sumatoria de todos los volúmenes es el WS del HEXA 6RUS.
Fig. 5-4. Esquemático de la creación de tetraedros para calcular el WS.
5.2 Identificación de la manipulabilidad
Según la Sección 2.6, la destreza o manipulabilidad del HEXA 6RUS puede cuantificarse mediante el
número condicional de las Jacobianas traslacionales y rotacionales. Considerando las submatrices ൫𝐉𝑷ష𝟏𝑸൯௩
y ൫𝐉𝑷ష𝟏𝑸൯௪ de (2-14) y el comportamiento en velocidad del MP (4-65), la Jacobiana traslacional se define
como (5-6) y la Jacobiana rotacional es (5-7); donde 𝐉𝒗 son las tres primeras filas de 𝐉𝒑
ିଵ y 𝐉𝒘 son las tres
últimas filas de 𝐉𝒑
൫𝑱𝑷ష𝟏𝑸൯௩𝜻̇
൫𝐉𝑷ష𝟏𝑸൯௪𝜻̇
Con el fin de medir la relación de errores entre los motores y la plataforma móvil, se aplica el concepto
de (2-9) y (2-11), teniendo en cuenta que las submatrices 𝐉𝒗 y 𝐉𝒘 no son cuadradas, el número condicional
de cada una de estas es (5-8) y (5-9).
Una vez se tienen los indicadores del comportamiento lineal y rotacional de los errores, se promedian
(5-10) para identificar la relación del error en velocidad 𝜅(J௩௪).
𝜅(J௩௪) = 𝜅(J௩) + 𝜅(J௪)
Cabe resaltar que esta relación es para una sola posición de la plataforma móvil. Como se requiere
analizar el comportamiento general del HEXA 6RUS, hay que evaluar 𝜅(J௩௪) en cada posición del WS tal
como lo muestra (5-11), donde 𝜂 es la manipulabilidad general del MP.
Debido al costo computacional que requiere (5-11), esta se aproxima con una suma de puntos discretos
del WS, donde 𝜅(J௩௪)௜ corresponde a una i-ésima posición y 𝑁 son el número de puntos analizados del
A causa de que ya estan determinados los límites del WS definidos por la nube de puntos (Sección 5.1.2)
y el centro del volumen 𝑃௠ de la Fig. 5-4, el modo de calcular la manipulabilidad del HEXA 6RUS se
realiza con los siguiente cuatro pasos.
1. Se crea un vector entre un punto de la nube de puntos y 𝑃௠.
2. La magnitud de ese vector es dividida en 𝑛௠ partes (Fig. 5-5).
3. Cada nuevo vector es una posición del WS, a la cual se le analiza 𝜅(𝐽௩௪) (5-10).
4. Se realiza el proceso con cada punto de la nube de puntos y se determina 𝜂 (5-11).
Fig. 5-5. Esquemático de la discretización del WS para el análisis de manipulabilidad.
5.3 Implementación de la estrategia de control
Inicialmente y luego de estudios previos , se escogió una estrategia de control híbrida que considera
la estrategia de planitud diferencial por su eficacia a la hora de seguir trayectorias junto con la propiedad
de conmutación de los modos deslizantes. Por tal motivo, la señal de control 𝜏௖௢௡ (5-13) está compuesta
por dos componentes: la señal de control equivalente 𝜏௘௤ y la señal de control atractivo 𝜏ே, tal como lo
indica Fig. 5-6.
𝜏௖௢௡= 𝜏௘௤+ 𝜏ே
Fig. 5-6. Esquemático del control híbrido propuesto.
5.3.1 Control equivalente por planitud diferencial
Respecto a la consecución del control equivalente basado en planitud diferencial (Sección 2.7.1), el
primer paso es hacer una representación de estados (2-45) del MP de acuerdo con (4-78), lo que genera
La matriz de controlabilidad es (5-15), su rango es 12 y su determinante es ≠0, por lo que se considera
un sistema controlable.
Debido a que es controlable se puede determinar 𝐹 (2-47), la cual es (5-16).
Por lo que 𝑀 no infringe la propiedad de planitud diferencial para calcular la parametrización porque 𝐹
puede ser representada por cualquier escalar multiplicado 𝐹 , entonces 𝐹 se considera 𝐹= 𝑋ଵ= 𝑋.
Según (2-48), 𝐹 puede presentarse como (5-17) y 𝐹̇ como (5-18); donde 𝜆= [1
0] cumple con la
anulación de 𝜏 y sus derivadas siguiendo los requisitos de (2-49),evidenciado en (5-27).
𝐹̇ = 𝜆𝐴𝑋+ 𝜆𝐵𝜏= [1
1/𝑀൨= 1/𝑀≠0
Luego por (2-52) y (5-14): 𝐹= 𝑋ଵ= 𝑋, 𝐹̇ = 𝑋ଶ= 𝑋̇, por lo que 𝐹̈ = 𝑋̈; lo que implica que (4-78) se
puede expresar como(5-20).
𝜏= 𝑀𝐹̈ + 𝐶+ 𝐺
Con el fin de garantizar un movimiento suave de 𝐹 se plantea 𝑣௔௨௫ según (2-51) obteniendo (5-21).
𝑣௔௨௫= 𝐹̈ௗ+ 𝛾(ଷ)ൣ𝐹̇ௗ−𝐹̇൧+ 𝛾(ଶ)[𝐹ௗ−𝐹] + 𝛾(ଵ) න[𝐹ௗ−𝐹]𝑑𝑡
A partir de (5-20) se sustituye la derivada 𝐹̈ por 𝑣௔௨௫ como lo presenta (5-22)
𝜏= 𝑀𝑣௔௨௫+ 𝐶+ 𝐺
Luego, se genera la dinámica del error (5-23), con base en (2-53), donde (𝑒= 𝐹ௗ−𝐹).
𝑒̈ + 𝛾(ଷ)𝑒̇ + 𝛾(ଶ)𝑒+ 𝛾(ଵ) න𝑒𝑑𝑡= 0
Para calcular los parámetros 𝛾(௜) se deriva (5-23) y se consideran la ubicación de los polos según la tasa
de amortiguación 𝜉 y la frecuencia natural no amortiguada 𝑤௡=
𝜉 𝑡𝑠 , tal como lo muestra (5-24).
𝑒⃛+ 𝛾(3)𝑒̈ + 𝛾(2)𝑒̇ + 𝛾(1)𝑒= 0
𝑠ଷ+ 𝛾(3)𝑠ଶ+ 𝛾(2)𝑠+ 𝛾(1) = (𝑠ଶ+ 2𝜉𝑤௡𝑠+ 𝑤௡
ଶ)(𝑠+ 5𝜉𝑤௡)
Finalmente, los valores de los parámetros son (5-25). Se recalca que los valores de 𝜉 y 𝑡௦ son variables
de diseño para optimizar, tema que será profundizado en la Sección 6.1.
(10𝜉ଶ+ 1)𝑤௡
La implementación de esta estrategia se hace reemplazando 𝐹 por 𝑋 de (5-23)en (5-22), de donde se
obtiene (5-26). La Fig. 5-7 muestra el esquemático de la configuración de 𝜏௘௤.
𝑋̈ = 𝑋̈ௗ+ 𝛾(ଷ)ൣ𝑋̇ௗ−𝑋̇൧+ 𝛾(ଶ)[𝑋ௗ−𝑋] + 𝛾(ଵ) න[𝑋ௗ−𝑋] 𝑑𝑡
𝜏௘௤= 𝑀൬𝑋̈ௗ+ 𝛾(ଷ)ൣ𝑋̇ௗ−𝑋̇൧+ 𝛾(ଶ)[𝑋ௗ−𝑋] + 𝛾(ଵ) න[𝑋ௗ−𝑋] 𝑑𝑡൰+ 𝐶+ 𝐺
Sin embargo, como lo menciona Craig , la implementación de solo este controlador es inalcanzable
en la práctica debido a la discretización involucrada por el uso de computadores y por las inexactitudes
causadas por las simplificaciones en la modelación dinámica. Por tal motivo, se sugiere el uso de un control
atractivo que reencauce la señal de control en caso de que se desvíe de la superficie deseada de respuesta.
Por lo anterior, se debe contemplar que la ley de control es discontinua a través de la superficie.
5.3.2 Control atractivo
El diseño de este controlador atractivo 𝜏ே se hace bajo el concepto de modos deslizantes, el cual se basa
en el uso de una señal de conmutación para confinar el comportamiento a la señal de control equivalente
descrito en la Sección 2.7.1. Para tal fin, se considera que cuando las trayectorias de vector de estado del
sistema siguen la superficie 𝜎 lo cual se refleja en que 𝜎̇ = 0, el control equivalente no se activa; en caso
contrario, el controlador conmuta con la función 𝑠𝑖𝑔𝑛 y una ganancia 𝐿 que limita el movimiento a las
especificaciones de torque del motor. Al considerar que la implementación se hace en MATLAB® y que
en la práctica la función 𝑠𝑖𝑔𝑛 genera chattering al ser tan estricta, 𝑠𝑖𝑔𝑛 es reemplazada por una saturación
(𝑠𝑎𝑡). Esta nueva función produce una señal de salida correspondiente a un valor de entrada limitada por
valores de saturación máximos y mínimos; estos límites son especificados por el valor de 𝐿. De esta forma
(2-32) se reescribe como lo indica (5-27).
𝜏ே= ቄ−𝐿sat(𝜎)
Fig. 5-7. Esquemático del control equivalente por planitud diferencial.
Con base en desarrollos anteriores y en la Sección 2.7.1, el primer paso es despejar 𝑋(௠) del
sistema descrito de la forma de (2-33) que para este MP es (4-78) por un controlador de seguimiento de
trayectoria (5-28).
𝑋̈ = (𝜏/𝑀) −(𝐶/𝑀) −(𝐺/𝑀)
Debido a que el comportamiento es de segundo orden, la superficie deslizante 𝜎 debe ser de un orden
inferior según (2-34) y se debe considerar un reconstructor integral de segundo orden, tal como lo muestra
𝜎= 𝑋̇ + 𝐾(ଷ)𝑒+ 𝐾(ଶ) න𝑒𝑑𝑡+ 𝐾(ଵ) නන𝑒𝑑𝑡𝑑𝑡
Tomando la derivada de la superficie (5-29) se obtiene (5-30).
𝜎̇ = 𝑋̈ + 𝐾(ଷ)𝑒̇ + 𝐾(ଶ)𝑒+ 𝐾(ଵ) න𝑒𝑑𝑡
La expresión 𝜎̇ se puede plantear según (5-31) teniendo en cuenta (5-28) y (5-30).
𝜎̇ = ൫(𝜏/𝑀) −(𝐶/𝑀) −(𝐺/𝑀)൯+ 𝐾(ଷ)𝑒̇ + 𝐾(ଶ)𝑒+ 𝐾(ଵ) න𝑒𝑑𝑡
Cuando la señal de control se encuentra sobre la superficie deseada 𝜎̇ = 0, un torque 𝜏௢௣௖ se acciona,
tal como (5-32) lo indica.
𝜎̇ = 0 = ൫𝜏௢௣௖/𝑀൯−൬𝐶
𝑀൰+ 𝐾(ଷ)𝑒̇ + 𝐾(ଶ)𝑒+ 𝐾(ଵ) න𝑒𝑑𝑡
Despejando 𝜏௢௣௖ de (5-32) se obtiene (5-33).
𝜏௢௣௖= 𝐶+ 𝐺−𝑀൬𝐾(ଷ)𝑒̇ + 𝐾(ଶ)𝑒+ 𝐾(ଵ) න𝑒𝑑𝑡൰
Por otro lado; en caso de que 𝜎̇ ≠0, 𝜏௢௣௖ (5-33) y 𝜏௔௖ se accionan. La señal 𝜏௔௖ se iguala a −𝐿 sat(𝜎)
según (5-34).
𝜏௔௖= −𝐿sat(𝜎)
Considerando (5-31) y teniendo en cuenta la activación de las dos señales 𝜏௢௣௖ y 𝜏ே se calcula (5-35).
𝜎̇ = 𝜏௔௖= −𝐿sat(𝜎) = ቆ൫𝜏௢௣௖+ 𝜏ே൯
𝑀൰+ 𝐾(3)𝑒̇ + 𝐾(2)𝑒+ 𝐾(1) න𝑒𝑑𝑡
Reemplazando (5-33), (5-34) y (5-35) se obtiene (5-36).
−𝐿sat(𝜎) =
ቆ𝐶+ 𝐺−𝑀൫𝐾(ଷ)𝑒̇ + 𝐾(ଶ)𝑒+ 𝐾(ଵ) ∫𝑒൯+ 𝜏ே
𝑀൰+ 𝐾(ଷ)𝑒̇ + 𝐾(ଶ)𝑒+ 𝐾(ଵ) න𝑒𝑑𝑡
−𝐿sat(𝜎) =
−𝑀𝐿sat(𝜎) =
Los valores de 𝐾(௜) se obtiene de la dinámica del error (2-42) como se indica en (5-37).
𝑒⃛+ 𝐾(3)𝑒̈ + 𝐾(2)𝑒̇ + 𝐾(1)𝑒= 0
𝑠ଷ+ 𝐾(3)𝑠ଶ+ 𝐾(2)𝑠+ 𝐾(1) = (𝑠ଶ+ 2𝜉𝑤௡𝑠+ 𝑤௡
ଶ)(𝑠+ 5𝜉𝑤௡)
Los valores de los parámetros son (5-38).
(10𝜉ଶ+ 1)𝑤௡
Ahora, considerando, 𝜏௘௤ (5-26) y 𝜏ே (5-36) se calcula 𝜏௖௢௡ (5-13) y se obtiene (5-39); donde 𝜎 es de la
forma de (5-29). La Fig. 5-8 muestra el esquemático del controlador, donde las líneas punteadas encierran
la sección del 𝜏ே.
𝜏௖௢௡= 𝑀൬𝑋̈ௗ+ 𝛾(ଷ)ൣ𝑋̇ௗ−𝑋̇൧+ 𝛾(ଶ)[𝑋ௗ−𝑋] + 𝛾(ଵ) න[𝑋ௗ−𝑋] 𝑑𝑡൰+ 𝐶+ 𝐺−𝑀𝐿sat(𝜎)
Fig. 5-8. Esquemático del controlador 𝜏௖௢௡.
5.4 Esfuerzo de control
El esfuerzo de control (𝐸𝐶) cuantifica el torque (𝜏) por unidad de tiempo que se requiere para llegar a
las condiciones deseadas. Con base en la Fig. 2-9 y (2-57) y considerando que el HEXA 6RUS tiene seis
actuadores, la señal es obtenida como indica la Fig. 5-9 y calculada según (5-40), donde 𝐴௧௜ es la i-ésima
área bajo la curva de la señal de j-ésimo motor, para esto, la señal es discretizada en 𝑚 secciones y el área
es aproximada con trapecios. Las amplitudes de las trayectorias dependen del WS y entre mayor la
trayectoria mayor la energía requerida; sin embargo, es de interés saber si ese EC relacionado con el WS es
viable. Este cálculo sirve como indicador de desempeño al concentrarse en la energía requerida por los
eslabones. La Fig. 5-10 presenta el esquemático de la discretización de la señal de torque del j-ésimo motor.
Este indicador está relacionado con la energía necesaria que la estrategia de control y el MP requieren para
generar una trayectoria.
5.5 Error de control
El error de control (𝑒௖) cuantifica la eficiencia del controlador, tal como se detalla en (2-56), en donde
se tienen en cuenta los errores de posición, velocidad y aceleración lineales y angulares de la plataforma
móvil. Tanto los errores lineales como los angulares poseen componentes relacionados con los ejes
cartesianos y varían con respecto al tiempo.
El cálculo del error considera una discretización en 𝑚 partes y su correspondiente norma; en
consecuencia, para la cuantificación del error inicialmente se determinan los 𝑒௖ parciales de cada tipo de
movimiento según (5-41) a (5-46); donde 𝑒௖௑௟ es 𝑒௖ de la traslación, 𝑒௖௑̇௟ es 𝑒௖ de la velocidad lineal, 𝑒௖௑̈௟
es 𝑒௖ de la aceleración lineal, 𝑒௖௑௔ es 𝑒௖ de la rotación, 𝑒௖௑̇௔ es 𝑒௖ de la velocidad angular y 𝑒௖௑̈௔ es 𝑒௖ de
la aceleración angular. Luego se promedian todos para hallar un 𝑒௖் que considere todos los movimientos
de la plataforma móvil (5-47).
Fig. 5-9. Esquemático de la obtención de EC.
Fig. 5-10. Esquemático del área bajo la curva del torque de un motor.
𝑚෍ට(𝑋ௗ௫௜−𝑋௫௜)ଶ+ ൫𝑋ௗ௬௜−𝑋௬௜൯
ଶ+ (𝑋ௗ௭௜−𝑋௭௜)ଶ
𝑚෍ට൫𝑋̇ௗ௫௜−𝑋̇௫௜൯
ଶ+ ൫𝑋̇ௗ௬௜−𝑋̇௬௜൯
ଶ+ ൫𝑋̇ௗ௭௜−𝑋̇௭௜൯
𝑚෍ට൫𝑋̈ௗ௫௜−𝑋̈௫௜൯
ଶ+ ൫𝑋̈ௗ௬௜−𝑋̈௬௜൯
ଶ+ ൫𝑋̈ௗ௭௜−𝑋̈௭௜൯
𝑚෍ට൫𝑋ௗఝ௜−𝑋ఝ௜൯
ଶ+ (𝑋ௗఏ௜−𝑋ఏ௜)ଶ+ ൫𝑋ௗట௜−𝑋ట௜൯
𝑚෍ට൫𝑋̇ௗఝ௜−𝑋̇ఝ௜൯
ଶ+ ൫𝑋̇ௗఏ௜−𝑋̇ఏ௜൯
ଶ+ ൫𝑋̇ௗట௜−𝑋̇ట௜൯
𝑚෍ට൫𝑋̇ௗఝ௜−𝑋̇ఝ௜൯
ଶ+ ൫𝑋̇ௗఏ௜−𝑋̇ఏ௜൯
ଶ+ ൫𝑋̇ௗట௜−𝑋̇ట௜൯
6 (𝑒௖௑௟+ 𝑒௖௑̇௟+ 𝑒௖௑̈௟+ 𝑒௖௑௔+ 𝑒௖௑̇௔+ 𝑒௖௑̈௔)
En conclusión, para la determinación de WS del MP se considera: el análisis de límites por restricciones
y discretización; la evaluación de posición de la plataforma móvil acerca de la existencia de restricciones
teniendo en cuenta la cinemática inversa; la generación de una nube de puntos basada en las posiciones
límites permisibles y el cálculo del volumen a partir de los tetraedros formados por tres puntos de la nube
de puntos y el punto central. Adicionalmente, la manipulabilidad del MP considera una discretización del
WS y el número condicional de las matrices Jacobianas de velocidad lineal y angular del MP. En cuanto a
la implementación del controlador, este tiene en cuenta una estrategia híbrida que integra una planitud
diferencial junto con un control atractivo. Ambas partes tienen presente las ganancias de la estrategia de
control analizando la ubicación de los polos según 𝜉 y 𝑡௦. Los valores de 𝜉 y 𝑡௦ son variables de diseño
para optimizar. La sección de planitud diferencial examina: 𝑋̈ௗ, 𝑒̇, 𝑒 y ∫𝑒 junto con M, C, G y las ganancias
𝛾(ଵ), 𝛾(ଶ) y 𝛾(ଷ). La sección atractiva procura que la señal de control se mantenga en la superficie 𝜎 para
que 𝜎̇ = 0, para esto conmuta con la función 𝑠𝑎𝑡. La implementación de la parte atractiva usa: 𝑋̇, 𝑒, ∫𝑒 y
∫∫𝑒 junto con M, un límite físico de torque L, las ganancias 𝐾(ଵ), 𝐾(ଶ) y 𝐾(ଷ) y la función sat en reemplazo
de 𝑠𝑖𝑔𝑛. Finalmente, el 𝐸𝐶 se relaciona con la energía necesaria para que el sistema sea controlado y es un
indicador de desempeño a ser optimizado; mientras que, el 𝑒௖ determina la eficiencia del controlador al
comparar las condiciones deseadas contra las realizadas y agruparlas en una expresión que también es
candidata para optimizar. Todos estos cálculos son implementados en MATLAB®. El WS y 𝜂 se
encuentran en el Anexo D, mientras que, la estrategia de control, 𝐸𝐶 y 𝑒௖ se encuentran en Anexo E
6 OPTIMIZACIÓN DEL SISTEMA
Como se mencionó anteriormente, la optimización considera aspectos dimensionales y estructurales de
los brazos, así como los parámetros de la estrategia de control. Estos parámetros tienen influencia en la
altura del mecanismo, el consumo energético, la robustez de movimiento y en los costos.
La optimización del HEXA 6RUS en este trabajo considera las variables de diseño, las FOs, las
restricciones, el problema de optimización, el análisis de dominancia, la clasificación de hacinamiento, la
evaluación del algoritmo, la toma de decisión y la implementación.
6.1 Variables de diseño
Se consideran las variables de diseño la longitud de los eslabones, la tasa de amortiguación y el tiempo
de establecimiento tal como lo indica el vector ℘ௗ (6-1).
6.2 Funciones objetivo
La optimización se enfoca en cuatro FOs: el WS (Sección5.1), la 𝜂 (Sección 5.2), el EC (Sección 5.4) y
el 𝑒௖ (Sección 5.5); las cuales pueden ser reescritas como 𝑓ଵ, 𝑓ଶ, 𝑓ଷ y 𝑓ସ respectivamente. Estas FOs se
consideran de igual importancia, así que son evaluadas simultáneamente y unificadas en dimensión y escala
para crear un FP (Sección 2.9.4). Por tal motivo, las FO se adimensionan y se escalan entre . Para esto,
se usa el enfoque lineal de adimensionamiento el cual depende de la evaluación de cada valor de FO y de
los valores máximos y mínimos . Con el fin de conocer los valores extremos de cada FO, se hace una
combinación sin repetición con las variables de diseño en sus dimensiones permisibles. El WS y 𝜂 dependen
de la cinemática y dinámica del HEXA 6RUS respectivamente, mientras que EC y 𝑒௖ además requiere una
señal de entrada deseada.
6.2.1 Funciones objetivo geométricas
Entonces, para 𝜂 y 𝐸𝐶 el escalamiento es 𝑊𝑆௜௝
௡ (6-2) y 𝜂௜௝
௡ (6-3) respectivamente. Sin embargo, para el
cálculo de EC y 𝑒௖ se requiere un trabajo adicional ya que requieren de una señal de entrada para aplicar la
ley de control.
𝑚𝑎𝑥(𝑊𝑆) −𝑊𝑆௜௝
𝑚𝑎𝑥(𝑊𝑆) −𝑚𝑖𝑛(𝑊𝑆)
𝜂௜௝−𝑚𝑖𝑛(𝜂)
𝑚𝑎𝑥(𝜂) −𝑚𝑖𝑛(𝜂)
6.2.2 Funciones objetivo de control
Debido a que se requiere implementar la estrategia de control para calcular EC y 𝑒௖, en consecuencia,
para este trabajo, se plantea una trayectoria deseada descrita a continuación.
El primer paso es definir la señal de entrada 𝑆ௗ= [𝑋̈ௗ
𝑋ௗ] que busca evaluar el comportamiento
del controlador cuando el movimiento de la plataforma móvil 𝑆௜= [𝑋̈௜
𝑋௜] abarca el WS. Como el
WS varía por la modificación de 𝑙௕ y 𝑙௥, 𝑆ௗ es función de éstas tal como se expresan de (6-4) a (6-12) para
los movimientos translacionales y (6-13) a (6-21) para los movimientos rotacionales; donde, 𝐴௫ es el
mínimo valor en x del límite del WS, 𝑡௙௜௡ es el tiempo total de recorrido, 𝐴௬ es el mínimo valor en y del
límite del WS, 𝑑௜ es la mitad de la altura máxima que tiene el WS (Sección 5.1.2.1), 𝑓௭= 2𝜋𝑡௙௜௡
frecuencia del movimiento en z, 𝑃௠ es el punto medio de WS (Sección 5.1.2.1) y 𝐴௥ es la amplitud del
movimiento rotacional
𝑧ௗ= 𝑑௜𝑠𝑖𝑛(𝑓௭𝑡) + 𝑃௠
𝑥̇ௗ= 2 ∗𝐴௫
𝑦̇ௗ= 3 ∗𝐴௬
𝑧̇ௗ= 𝑑௜𝑓௭𝑐𝑜𝑠(𝑓௭𝑡)
𝑥̈ௗ= 2 ∗𝐴௫
𝑦̈ = 6 ∗𝐴௬
𝑧̈ = −𝑑௜𝑓௭
𝜃= 𝐴௥𝑠𝑖𝑛(𝑓௭𝑡)
𝜃̇ = 𝐴௥𝑓௭𝑐𝑜𝑠(𝑓௭𝑡)
𝜃̈ = −𝐴௥𝑓௭
Las anteriores expresiones generan una trayectoria dentro del WS de la forma como se representa en la
Fig. 6-1. Las amplitudes de las trayectorias dependen del WS y entre mayor la trayectoria mayor la energía
requerida; sin embargo, es de interés saber si ese EC relacionado con el WS es viable. Es por eso que se
define un esfuerzo de control volumétrico (𝐸𝐶𝑉) basándose en (5-40), lo que resulta en (6-22).
6 WS ෍෍𝐴௧௜
Ahora, el adimensionamiento de ECV es (6-23).
𝐸𝐶𝑉௜௝−𝑚𝑖𝑛(𝐸𝐶𝑉)
𝑚𝑎𝑥(𝐸𝐶𝑉) −𝑚𝑖𝑛(𝐸𝐶𝑉)
El adimensionamiento de 𝑒𝑐 considera el promedio entre cada componente de 𝑆ௗ y 𝑆௜, por ejemplo, para
(5-41) su adimensionamiento es (6-24). Teniendo en cuenta los errores en velocidad y aceleración
traslacional (5-41) a (5-43) el 𝑒𝑐௜௝
௡ es (6-25).
𝑚෍ඨ൬𝑋ௗ௫௜−𝑋௫௜
+ ൬𝑋ௗ௭௜−𝑋௭௜
Fig. 6-1. Ejemplo de desplazamiento de prueba dentro del WS. Configuración 𝑙௕= 0.3 m y 𝑙௥= 0.3 m.
6.3 Restricciones
Las restricciones dividen el WS en dos regiones, la factible y la no factible , en un desarrollo de FP,
las soluciones deben ser factibles. Existen dos tipos de restricciones, las fuertes y la suaves. Las primeras
deben satisfacerse para que la solución sea factible, las segundas poseen algo de flexibilidad debido a la
naturaleza del problema.
Las restricciones fuertes en este trabajo se relacionan con la resistencia y rigidez de los eslabones. Por
lo tanto, se contemplan la teoría de Von Mises, el criterio de Goodman modificado y los parámetros del
material (Sección 4), los cuales deben cumplirse para no tener problemas de deformaciones permanentes o
fallas (6-26) y (6-27).
Por otro lado, las restricciones flexibles se concentran en el adimensionamiento de las FOs.
6.4 Problema de optimización
La optimización se enfoca en minimizar cada i-ésima FO (6-32).
𝐹𝑂௜(℘ௗ) + 𝑅௠Ω(℘ௗ)
Se tiene en cuenta un parámetro de penalidad 𝑅௠ y una función de penalización Ω(℘ௗ). El 𝑅௠ se usa
para mantener las configuraciones que violan las restricciones flexibles en la región factible, pero con una
penalidad. La Ω(℘ௗ) agrupa todas las violaciones de restricciones (6-33) y (6-34), donde las restricciones
𝑔௜(℘ௗ) se expresan como (6-35) y (6-36).
Ω(℘ௗ) = ෍𝜔௜(℘ௗ)
𝜔௜(℘ௗ) = ൜|𝑔௜(℘ௗ)|,
si 𝑔௜(℘ௗ) < 0,
en otro caso
𝑔௜(℘ௗ) = 1 −𝑓௜≥0
𝑔௜(℘ௗ) = 𝑓௜≥0
Los límites de las variables de diseño se describen de (6-37) a (6-40).
6.5 Análisis de dominancia
Debido a que en una optimización multi-objetivo se hace un análisis del espacio generado por las FOs,
las opciones óptimas que construyen el FP deben garantizar que no existen mejores que ellas. Para
garantizar esto la mayoría de los algoritmos de optimización multi-objetivo usan el concepto de dominancia,
donde dos soluciones son comparadas bajo estas condiciones :
La solución ℘ௗ
ଵ no es peor que una solución de ℘ௗ
ଶ en todas las FOs.
La solución ℘ௗ
ଵ es estrictamente mejor en al menos una FO generada por ℘ௗ
Si cualquiera de las dos condiciones se viola, ℘ௗ
ଵ no domina a ℘ௗ
Debido a que se debe hacer un análisis de dominancia de todas las FOs, en este trabajo se aplica el
enfoque Naive and Slow el cual identifica los ℘ௗ que no son dominados. El Pseudocódigo 6-1 describe
el paso a paso para encontrar el conjunto de soluciones no dominadas en un vector 𝑃 de tamaño 𝑁.
6.6 Clasificación de hacinamiento
El método implementado en este trabajo considera el conjunto de las soluciones generadas por los padres
(𝐹𝑂௣) y los hijos (𝐹𝑂ீାଵ) por lo que la población ൫𝑅௧= 𝐹𝑂௣∪𝐹𝑂ீାଵ൯ luego de una generación es de
tamaño 2N . Una forma de clasificar estas soluciones es con un análisis de cercanía de soluciones o de
hacinamiento. Con este enfoque, primero se hace una clasificación por dominancia de 𝑅௧, la nueva
población consta de diferentes frentes no dominados. Por lo tanto, las mejores soluciones consideran los
mejores frentes, si el primer frente no tiene las N soluciones requeridas, se pasa al segundo frente, luego al
tercero y así sucesivamente. Las soluciones restantes son eliminadas. Este escenario se ilustra en Fig. 6-2.
En vez de descartar arbitrariamente miembros de los últimos frentes, se seleccionan aquellos que se
encuentran en las zonas menos hacinadas, esto genera que el FP abarque una mayor región de soluciones.
Pseudocódigo 6-1. Identificación de soluciones no dominadas por el enfoque Naive and Slow
i=1 y crear un vector no dominado 𝑃′
if 𝑗 domina la solución 𝑖
Para una solución 𝑗∈𝑃 donde 𝑗≠𝑖
if hay más soluciones en 𝑃
𝑃′ = 𝑃′ ∪{𝑖}
El Pseudocódigo 6-2 describe el paso a paso de este proceso. Inicialmente la población 𝑅௧ es creada;
luego, es organizada en diferentes niveles de no dominancia y a cada solución se le asigna el nivel ese peso
(donde 1 es el mejor nivel). Después, se hace un torneo de hacinamiento que finalmente hace que las
soluciones con menos “vecinos” tengan prioridad para crear la siguiente generación 𝐹𝑂ீାଵ.
6.7 Evaluación del algoritmo
En este trabajo se desarrolla una estrategia metaheurística denominada Evolución diferencial
multiobjetivo elitista restringido (EDMER) que se introduce en la Sección 2.9.6. Con el fin de evaluar la
exactitud de EDMER se seleccionan funciones numéricas con problemas multiobjetivo o multiobjective
problems (MOP) definidos y se contrastan con los Frentes de Pareto del algoritmo de optimización. Estas
MOP son utilizadas a menudo ya que examinan la capacidad de un algoritmo para "manejar" varias
características del dominio del problema debido a que incorporan características relevantes del espacio de
búsqueda que deben ser abordadas por alguna instancia particular del algoritmo. La métrica para definir el
error es el Pareto Front Distance Error (PFDE) (6-41); donde, 𝑛 es el número de puntos evaluados y 𝑑 es
la distancia entre el i-ésimo punto del FP y el i-ésimo punto de MOP .
Con el fin de evaluar el EDMER se eligen dos MOP: la expresión de Binh (6-42) y la de Viennet (6-43),
las cuales cuentan con dos y tres FOs respectivamente. Para ambos casos las MOP definen las funciones a
optimizar y las restricciones que deben cumplirse. Los FP de estas expresiones se contrastan con los puntos
ya definidos de ambas expresiones que pueden descargarse en . En ambos casos las soluciones del
EDMER con respecto a las MOP presentan FPDE < 1%. Adicionalmente, se generan FPs con el módulo
de algoritmos genéticos o genetic algorithms (GA) ya programado de MATLAB®. La distribución de los
FP del MOP, EDMER y GA se ilustran en Fig. 6-3 y Fig. 6-4.
Fig. 6-2. Esquemático de la clasificación por hacinamiento .
Definición
Restricciones
𝑓ଵ(𝑥, 𝑦) =
𝑓ଶ(𝑥, 𝑦) =
(𝑥−5)ଶ+ (𝑦−5)ଶ
0 ≥(𝑥−5)ଶ+ 𝑦ଶ−25
0 ≥−(𝑥−8)ଶ−(𝑦+ 3)ଶ+ 7.7
Definición
Restricciones
𝑓ଵ(𝑥, 𝑦) =
𝑓ଶ(𝑥, 𝑦) =
𝑓ଷ(𝑥, 𝑦) =
(3𝑥−2𝑦+ 4)ଶ
+ (𝑥−𝑦+ 1)ଶ
Fig. 6-3. Comparación de FP del MOP, EDMER y GA de expresión de Binh
6.8 Método de toma de decisión y espaciado
Debido a que el FP consta de varias soluciones óptimas, se requiere saber el mejor punto de ese frente
con ayuda de estrategias de toma de decisiones. Numerosos enfoques han sido presentados en la literatura
 . El presente estudio usa la métrica LINMAP que consta en computar la distancia Euclidiana de cada
punto del FP (𝛬) con respecto al punto ideal, que en este trabajo es la coordenada [0
0]. La Fig.
6-5 es un ejemplo de la representación gráfica del análisis LINMAP de un FP de 3 FOs. Se resalta que el
cálculo de LINMAP se hace en el FP con las FOs adimensionadas.
La evaluación del desempeño de AEs ha venido desarrollandose de forma cuantitativa, este trabajo
considera el espaciado de soluciones (ESP), el cual mide qué tan diversas o bien distribuidas están las
soluciones en un FP . La métrica se describe con (6-44); donde 𝑑௜ es la distancia euclidiana entre una
solución 𝑥௜ y su solución más cercana, 𝑛 es el número de soluciones en el FP y 𝑑̅ es la distancia euclidiana
promedio entre soluciones, se resalta que valores pequeños de ESP indican una mejor distribución de las
soluciones .
Pseudocódigo 6-2. Clasificación de hacinamiento.
Ordenar las soluciones no dominadas de 𝑅௧ en diferentes Frentes ℱ௜
Establecer la siguiente generación de padres en cero.
while ห𝐹𝑂௣
ீାଵห+ |ℱ௜| ≤𝑁
Nombre el número de soluciones de ℱ௜ como 𝑙
while 𝑚≤número de FO
Por cada 𝐹𝑂௠→𝑚= 1,2,3,4. Organizar cada 𝐹𝑂௠ de menor a
Asignar un valor de distancia 𝑑௠௜= ∞ a la primera y última 𝐹𝑂௠
Calcular la distancia 𝑑௠௜ para el resto de las soluciones que van de
𝑗= 2 hasta 𝑙−1
𝑑௠௜= 𝑑௠௜+ 𝐹𝑂௠
𝐹𝑂௠௠௔௫−𝐹𝑂௠௠௜௡
Asignar 𝑑௠௜ a cada 𝐹𝑂
Ordenar 𝐹𝑂௣
ீାଵ según el valor de 𝑑௠௜ de mayor a menor
Escoger las primeras 𝑁 soluciones
6.9 . Implementación
El Pseudocódigo 6-3 describe la implementación del EDMER en el HEXA 6RUS. Sin embargo, varios
autores remarcan que los valores de 𝐶௥, 𝐹 y el número de generaciones (numGen) varía de acuerdo con el
problema . Por esta razón, la configuración más competitiva relacionada con Λ fue inicialmente
analizada con cuatro configuraciones de 𝐶௥, 𝐹 quienes son evaluadas en ocho condiciones de numGen
diferentes con un tamaño de población (npop) de 64. Los valores de 𝐶௥ y 𝐹 se toman de y y este
primer estudio se resume con la Tabla 6-1. Luego de determinar los valores de 𝐶௥ y 𝐹 con tendencia a tener
un Λ menor, se escoge la mejor solución de entre tres estudios en donde npop tiene un valor de 2௜,
𝑖= 5, 6, … 9 y esta solución es en conclusión la opción más competitiva de este trabajo.
Fig. 6-4. Comparación de FP del MOP, EDMER y GA de expresión de Viennet.
Fig. 6-5. Método de LINMAP de selección de punto más competitivo 
Pseudocódigo 6-3. EDMER para HEXA 6RUS
Determinación de ℘ௗ y 𝑛𝑝𝑎𝑟𝑎
𝑡௦], 𝑛𝑝𝑎𝑟𝑎= 4
Valores de tamaño de población 𝑛𝑝𝑜𝑝
𝑛𝑝𝑜𝑝= 2 × 2௡௣௔௥௔
Valores de 𝐶௥ y 𝐹
0.5], 𝐹= ൥
Crear un vector con la combinatoria de ℘ௗ basado
en los valores extremos.
℘ௗ௘= ቀ2௡௣௔௥௔
Determinar resto de población
℘ௗ௥= 𝑟𝑎𝑛𝑑(℘ௗ
𝐹𝑂௣ padres con ℘ௗ௘y ℘ௗ௥
𝐹𝑂௣= [𝐹𝑂𝑒௜
→൜𝐹𝑂𝑒௜= 𝑓௜(℘ௗ௘) + 𝑅௠Ω(℘ௗ௘)
𝐹𝑂𝑒௝= 𝑓௜(℘ௗ௥) + 𝑅௠Ω(℘ௗ௥)
while G < numGen
Selección de D, A, B y C.
𝐷= 1, … , 𝑛𝑝𝑜𝑝
𝐴= 1, … , 𝑛𝑝𝑜𝑝
𝐵= 1, … , 𝑛𝑝𝑜𝑝
𝐶= 1, … , 𝑛𝑝𝑜𝑝
if 𝑟௞,௠≤𝐶௥⋁𝑚= 𝐷௞
Generación de un hijo
ீାଵ= 𝐹𝑂஼ೖ,௠
+ 𝐹൫𝐹𝑂஺ೖ,௠
𝑘= 1, … , 𝑛𝑝𝑜𝑝
𝑚= 1, … , 𝑛𝑝𝑎𝑟𝑎
La nueva generación es el mismo padre
ீାଵ= 𝐹𝑂௞,௠
Unir la población de padres e hijos.
Análisis de dominancia
Pseudocódigo 6-1
Clasificación por hacinamiento
Escoger los mejores sujetos como nuevos
Evaluación de LINMAP
Tabla 6-1. Tabla de parámetros de calibración.
Configuración
Número de generaciones
En conclusión, la aplicación de la estrategia de optimización para el diseño del HEXA 6 RUS tuvo en
cuenta lo siguiente: Se consideraron como variables de diseño la longitud de los eslabones, la tasa de
amortiguación y el tiempo de establecimiento. Las FOs fueron 𝑊𝑆௜௝
௡. Se definieron las
restricciones del problema relacionadas con la resistencia a la fatiga de los eslabones y el
adimensionamiento de las FOs. El algoritmo metaheurístico elegido fue el EDMER del que se detalló entre
otros su análisis de dominancia, clasificación de hacinamiento y su PFDE. Se eligió el LINMAP como
método de toma de decisión y se tomaron parámetros de calibración relacionados con 𝐶௥, 𝐹 y número de
generaciones Todo esto fue implementado en MATLAB® y detallado en el Anexo F.
7 RESULTADOS Y DISCUSIÓN
En esta sección se presenta los resultados obtenidos al hacer el análisis de la cinemática inversa y algunos
ejemplos. Adicionalmente, se ilustra la solución del WS y el análisis de η. Luego se expone los efectos de
la estrategia de control y los resultados de los índices de EC y 𝑒௖. Además, se exhibe la ejecución del
EDMER, los FPs. Finalmente, se describe el prototipo resultante del proceso de diseño.
7.1 Producto del análisis de cinemática inversa
Se analizaron cinco posiciones con el fin de validar el cálculo de la cinemática inversa. Para lo cual, se
tomaron las siguientes consideraciones. Para todas las posiciones analizadas la plataforma fija y la
plataforma móvil mantuvieron las mismas dimensiones descritas en la Tabla 4-5. Las dimensiones de 𝑙௕ y
𝑙௥ variaron. Las posiciones cartesianas de la plataforma móvil se describieron con 𝑝 considerando el
punto de origen el marco de referencia 𝐹 el cual se ubicó en la cara inferior de la plataforma fija. Las
posiciones angulares de la plataforma móvil se describieron con el vector 𝑝௔௡௚. Los ángulos obtenidos 𝜁௜
(4-33) se validaron con ayuda del software CAD Autodesk Power Shape®. Estos ángulos se renombraron
௖௔௟ mientras que los del modelo CAD como 𝜁௜
஼஺஽. Además, se halló el error de la raíz cuadrática
media (RMSE) de cada validación y se presentan dos vistas de la posición analizada. La Tabla 7-1 muestra
los valores de la primera validación los cuales se ilustran en la Fig. 7-1. El RMSE es igual a 0.009°.
Tabla 7-1. Datos de entrada de la validación 1.
La Tabla 7-2 muestra los valores del segundo análisis, mientras que Fig. 7-2 indica el esquemático de la
configuración en CAD. El RMSE es igual a 0.136°. La Tabla 7-3 muestra los valores de la tercera validación
los cuales se resumen en la Fig. 7-3. El RMSE es igual a 0.09º. La Tabla 7-4 muestra los valores del segundo
análisis, mientras que la Tabla 7-4 indica el esquemático de la configuración en CAD. El RMSE es igual a
0º. LaTabla 7-5 muestra los valores de la tercera validación los cuales se resumen en la Fig. 7-5. El RMSE
es igual a 0º.
Fig. 7-1. Esquemático de la primera validación de la cinemática inversa.
Tabla 7-2. Datos de entrada de la validación 2
Fig. 7-2. Esquemático de la segunda validación de la cinemática inversa.
Tabla 7-3. Datos de entrada de la validación 3.
Fig. 7-3. Esquemático de la tercera validación de la cinemática inversa.
Tabla 7-4. Datos de entrada de la validación 3.
452.90 mm.
Fig. 7-4. Esquemático de la cuarta validación de la cinemática inversa.
Tabla 7-5. Datos de entrada de la validación 3.
397.26 mm.
Fig. 7-5. Esquemático de la quinta validación de la cinemática inversa.
7.2 Solución del espacio de trabajo
Con el fin de demostrar los resultados de la metodología para el cálculo de WS, se computaron dos WS
modificando la longitud de los eslabones. Cada WS se calculó siguiendo el Pseudocódigo 5-1. Se hizo una
discretización en el eje Z (𝑝௪௦) como lo indica la Fig. 5-2 de diecinueve partes y en cada capa discretizada
se evaluaron veinticinco vecindades de singularidades. Como el mecanismo es simétrico con estas
vecindades se hicieron dos patrones circulares de 120° cada una y se hizo el cálculo de cada tetraedro según
la Sección 5.1.3. Con el fin de evitar sobreimpulsos en los torques, el limite inferior alcanzable 𝑃௕௢ del WS
se configuro como un 90% del total alcanzable, 𝑃௕௢= 0.9𝑃௕௢. Para evitar colisiones entre los eslabones
inferiores y la pieza impresa, el límite 𝑃௧௢ debe estar por debajo de la articulación universal. Esto implica
que la longitud de los eslabones, determinan la altura máxima del HEXA 6RUS.
La Fig. 7-6 expone el WS obtenido con un 𝑙௕= 0.07 m y 𝑙௥= 0.18 m, esta configuración genera un
WS=8.49 𝑒ିହ 𝑐𝑚ଷ y una altura máxima del HEXA 6RUS de 0.77m.
Por otra parte, al igualar los valores de los eslabones a 0.5 m el valor de WS es de 1200 𝑐𝑚ଷ, lo que
implica una altura del dispositivo de 0.49 m. La Fig. 7-7 esquematiza estos valores.
Debido al impacto de las variaciones sobre el tamaño del HEXA 6RUS y a que WS es una función
objetivo que debe ser adimensionada según la Sección 6.2.1. Se evaluaron 121 configuraciones de eslabones
los cuales sus dimensiones variaron según la Tabla 7-6.
Los WS obtenidos fueron graficados y sus valores máximos y mínimos determinados según se ve en la
Fig. 7-8. El WS máximo equivale a 0.118 m3 aproximadamente cuando los valores de 𝑙௕y 𝑙௥ son de 0.414
y 0.5 m respectivamente. Por otro lado, El WS mínimo es de 1.48 10-6 m3 cuando los valores de 𝑙௕y 𝑙௥ son
de 0.199 y 0.180 m respectivamente.
En este punto es importante aclarar que debido a que para crear el FP las FO requieren ser normalizadas.
A cada FO se le determinan sus límites máximos y mínimos.
Fig. 7-6. WS con una configuración de 𝑙௕= 0.07 m y 𝑙௥= 0.18 m.
Fig. 7-7. WS con una configuración de |𝑙௕| = 0.5 m y |𝑙௥| = 0.5 m.
Tabla 7-6. Valores de los eslabones para el estudio de WS.
La Fig. 7-8 muestra que la en el HEXA 6RUS, existe una relación entre el incremento de los eslabones
y el WS. Esto se debe a que entre mayor sea la longitud, mayor el alcance que pueden tener.
Los mayores WS se obtuvieron cuando el eslabón superior es más corto que el eslabón superior. Por
otro lado, una relación mayor del superior con respecto al inferior impacta significativamente el WS,
específicamente cuando la relación es mayor a 1. Para el HEXA 6RUS la relación de longitud de
eslabones𝑙௕/𝑙௥ con un mayor WS es de 0.828 según lo evidencia la Fig. 7-9.
Fig. 7-8. WS de diferentes configuraciones de 𝑙௕ y 𝑙௥.
Fig. 7-9. WS con respecto a 𝑙𝑏/𝑙𝑟 del HEXA 6RUS
7.3 Análisis de manipulabilidad
Teniendo en cuenta que las matrices Jacobianas 𝐽௩ y 𝐽௪ y la manipulabilidad general 𝜂 (5-12) dependen
de la longitud de los eslabones, y del WS; y al igual que WS, 𝜂 es una función objetivo (6-3), se evaluaron
121 configuraciones de HEXA 6RUS según la Tabla 7-6 y se determinaron los valores máximos y mínimos
A medida que van aumentando el largo de los eslabones, 𝜂 tiende a ser más mayor; lo que implica que
los errores de velocidad que puedan tener los actuadores incrementan los errores de movimiento en la
plataforma móvil al aumentar el tamaño del HEXA 6RUS. Esto resalta la importancia de encontrar puntos
No. de configuración.
[0.828, 0.118]
Relación lb / lr
más competitivos por medio de desarrollo de frentes de Pareto debido a que el WS y el 𝜂 tienen una relación
Fig. 7-10. Número condicional de diferentes configuraciones de 𝑙௕ y 𝑙௥.
7.4 Efecto de la implementación de la estrategia de control
Como se enunció en la Sección 5.3, la estrategia de control la comprenden el control equivalente y el
atractivo. Luego se ser validado el modelo dinámico (Anexo G), las matrices M, C y G fueron usadas. El
HEXA 6RUS controlado fue simulado en MATLAB R2021B® utilizando el módulo Simulink® como se
ve en la Fig. 7-11 y detallado en el Anexo E. En esta simulación existen varios subsistemas que a
continuación se describen.
El módulo matrices MCG_S, coloreado en rojo y cuyas salidas son rojas, calcula las matrices M, C y G
(4-105) a (4-107), las cuales son funciones de la longitud de los eslabones (bloques verdes), la posición
(color azul claro) y la velocidad (magenta) de la plataforma móvil.
Respecto al subsistema Mecanismo (bloque y salidas naranja), por costo computacional se utilizó el
modelo dinámico (Sección 4.4.6). y la señal de torque (T) procedente del controlador. La salida del bloque
Mecanismo es la aceleración de la plataforma móvil.
La señal T proviene del bloque del controlador (azul oscuro) el cual tiene nueve entradas y que será
detallado más adelante. Adicionalmente, la simulación consta del bloque Generador de Trayectoria (bloque
gris) que provee el vector 𝑆ௗ descrito en la Sección 6.2.2. Las señales de T y 𝑆௜, para el cálculo de 𝐸𝐶 y 𝑒௖
(Secciones 0 y 5.5 ), son almacenadas en los bloques torque (verde oscuro) y en SalidaControl_Pos,
SalidaControl_Vel y SalidaControl_Acel (bloques negros).
16.80332347
Índice de destreza (1/m3)
No. configuración
Fig. 7-11. Controlador del HEXA 6RUS en Simulink®
De la Fig. 7-12, la zona en el área gris, representa la configuración en Simulink® del control equivalente.
Donde, las entradas corresponden a lo descrito en la Tabla 7-7; las ganancias Kp2, Kp3, Kp6 corresponden
a 𝛾(ଷ), 𝛾(ଶ), 𝛾(ଵ) (5-26) y el bloque Matrix Multiply hace la multiplicación con M descrita en (5-26).
Por otro lado, en la Fig. 7-13 la zona gris muestra la configuración de 𝜏ே. Las entradas y salidas
numeradas corresponden a lo descrito en la Tabla 7-7; las ganancias Kp1, Kp4 y Kp5 se relacionan con
𝐾(ଷ), 𝐾(ଶ) y 𝐾(ଵ) respectivamente; el sat esta limitado por 6 Nm que es el límite de torque máximo del
fabricante del actuador (Anexo B). Finalmente, el bloque Matrix Multiply hace la multiplicación con M
descrita en (5-39).
Como ejemplo, el sistema controlado fue simulado bajo las siguientes condiciones: 𝑙௕= 0.3 𝑚,𝑙௥=
0.3 𝑚, 𝜉= 0.7 y 𝑡௦= 0.25 s, 𝑡௙௜௡= 2 𝑠, 𝐴௬= 0.0671 𝑚, 𝑃௠= −0.40 𝑚, 𝐴௫= 0.0671 𝑚, 𝑑௜=
0.0796 𝑚, 𝑓௭= 𝜋 y 𝐴௥= 5௢. Las respuestas de la simulación se plasman en las Fig. 7-14 a Fig. 7-31, de
las cuales se puede apreciar lo siguiente. Los comportamientos de posición en los ejes X y Y presentan un
error menor al 1% (Fig. 7-14 y Fig. 7-15), en el eje z se presentó un error de seguimiento menor al 1%, lo
que se considera aceptable para la aplicación debido a que en la aplicación en MA no se exigen cambios
bruscos de posición, velocidad ni aceleración.
De forma similar, las velocidades traslacionales en x y y (Fig. 7-17 y Fig. 7-18) presentaron errores
menores al 1%, mientras que la velocidad en z (Fig. 7-19) generó un sobreimpulso. Este sobreimpulso es
el esperado debido al valor de 𝜉 y a que el sistema inicia en reposo; sin embargo, luego de 𝑡௦ el sistema
sigue la velocidad deseada.
Tabla 7-7. Señales correspondientes por número de entrada.
No. de entrada
Fig. 7-12. Control equivalente en Simulink®
Fig. 7-13. Control atractivo en Simulink®
Respecto a las aceleraciones traslacionales, se evidenció un sobreimpulso del 6% en X debido a las
condiciones iniciales de aceleración de la simulación (Fig. 7-20), respecto al eje Y (Fig. 7-21), el
seguimiento presenta errores menores al 1% salvo en el instante de 0.67 s; sin embargo, el RMSE entre las
dos señales fue de 1.46×10-3 m/s2 valor aceptable para la aplicación. En el eje Z, el seguimiento tuvo el
comportamiento esperado del sobreimpulso y posterior establecimiento (Fig. 7-22), el sobreimpulso
considera las condiciones iniciales de aceleración de la simulación.
El seguimiento de θ, φ ψ presenta errores menores al 1% luego de 𝑡௦ (Fig. 7-23 a Fig. 7-25), los valores
de RMSE fueron de 5×10-4 rad, 6.9×10-5 rad, y 3.21×10-5 rad, respectivamente, valores que se consideran
aceptables para la aplicación en MA. Con relación a 𝜃,̇ 𝜑,̇ las Fig. 7-26 y Fig. 7-27 evidencian el
sobreimpulso debido a las condiciones iniciales; al igual que en las otras señales, luego de 𝑡௦, el seguimiento
presenta errores por debajo del 1%. Al 𝜓̇ iniciar en cero al igual que la señal de referencia, no existe
sobreimpulso (Fig. 7-28)y el valor de RMSE es de 3.65×10-5 rad/m.
Finalmente, 𝜃̈, 𝜑̈ y 𝜓̈ fueron las señales sensibles a los cambios. 𝜃̈ presentó sobreimpulsos entre
2.25 ×10-5 rad/m2 y 9×10-3 rad/m2 en los cambios de dirección (Fig. 7-29). Referente a 𝜑̈ (Fig. 7-30), se
presentó sobreimpulsos al inicio del control de un valor de 0.05×10-2 rad/m2, luego la señal se mantuvo por
debajo del 1%. En consideración a 𝜓̈, ésta presentó un RMSE 9.84 ×10-2 rad/m2.
Fig. 7-14. Comparación de la posición deseada en X vs la generada controlada.
Fig. 7-15. Comparación de la posición deseada en Y vs la generada controlada.
tiempo (s)
X Controlada
tiempo (s)
Y Controlada
Fig. 7-16. Comparación de la posición deseada en Z vs la generada controlada.
Fig. 7-17. Comparación de la velocidad deseada en X vs la generada controlada.
Fig. 7-18. Comparación de la velocidad deseada en Y vs la generada controlada.
Vel Y (m/s)
tiempo (s)
Y Controlada
Fig. 7-19. Comparación de la velocidad deseada en Z vs la generada controlada.
Fig. 7-20. Comparación de la aceleración deseada en X vs la generada controlada.
Fig. 7-21. Comparación de la aceleración deseada en Y vs la generada controlada.
Acel X (m/s2)
tiempo (s)
X Controlado
Acel Y (m/s2)
tiempo (s)
X Controlado
Fig. 7-22. Comparación de la aceleración deseada en Z vs la generada controlada.
Fig. 7-23. Comparación de 𝜃 vs la generada controlada.
Fig. 7-24. Comparación de 𝜑 vs la generada controlada.
tiempo (s)
θ Controlada
tiempo (s)
φ Controlada
Fig. 7-25. Comparación de 𝜓 vs la generada controlada.
Fig. 7-26. Comparación de la velocidad 𝜃 vs la generada controlada.
Fig. 7-27. Comparación de la velocidad 𝜑 vs la generada controlada.
tiempo (s)
ψ Controlada
Vel θ (rad/s)
tiempo (s)
θ Controlada
Vel φ /rad/s)
tiempo (s)
φ Controlada
Fig. 7-28. Comparación de la velocidad 𝜓 vs la generada controlada.
Fig. 7-29. Comparación de la aceleración 𝜃 vs la generada controlada.
Fig. 7-30. Comparación de la aceleración 𝜑 vs la generada controlada.
Vel ψ (rad/s)
tiempo (s)
ψ Controlada
Acel θ (rad/s2)
tiempo (s)
θ Controlada
Acel φ (rad/s2)
tiempo (s)
φ Controlada
Fig. 7-31. Comparación de la aceleración 𝜓 vs la generada controlada.
7.5 Indicador del esfuerzo de control
De acuerdo con la Sección 2.8, el 𝐸𝐶 cuantifica el 𝜏 por unidad de tiempo que se requiere para llegar a
las condiciones deseadas. Al igual que lo que se hizo con WS, se simularon 121 configuraciones de
eslabones según la Tabla 7-6 del sistema de la Fig. 7-11; la trayectoria fue la planteada según las ecuaciones
de (6-4) a (6-21) considerando un 𝜉= 0.7, 𝑡௦= 0.25 s y 𝑡௙௜௡= 2 𝑠. La Fig. 7-32 indica los valores
corresponden
𝑙௕= 0.457,
𝑙௕= 0.371,
𝑙௥= 0.18 respectivamente, los que luego fueron utilizados en el adimensionamiento. La Fig. 7-33 eviencia
la relación de los eslabones con la energía requerida, donde se aclara que el ECV en relaciones específicas
es hasta siete veces mayor, acentuando la relevancia de ésta relación en el desempeño energético del HEXA
Fig. 7-32. ECV de diferentes configuraciones de 𝑙௕ y 𝑙௥ con una señal sinoidal en solo Z.
Acel ψ (rad/s2)
tiempo (s)
ψ Controlada
110, 2.051923788
78, 716.7247049
No. Configuración.
Fig. 7-33. ECV teniendo en cuenta la relación 𝑙௕𝑙௥
7.6 Ejecución de la optimización
De acuerdo con lo mencionado en la Sección 6.1y 6.2, la optimización del HEXA 6RUS consideró el
vector de diseño ℘ௗ (6-1) y las FOs normalizadas 𝑓ଵ, 𝑓ଶ, 𝑓ଷ y 𝑓ସ, (6-2), (6-3), (6-23) y (6-25)
respectivamente. El algoritmo trabajo con las cuatro FOs al tiempo generando un FP de cuatro dimensiones.
Se analizó la sensibilidad de los parámetros 𝐶௥ y 𝐹, para evaluar su efecto en el valor de LINMAP (𝛬)
(Sección 6.8), según la Tabla 6-1. Este análisis especificó que en todas las numGen la mejor opción es la
configuración número 2 con numGen=512 (Tabla 7-8). Con el fin de facilitar la observación de la relación
de las FO en el FP, algunas de éstas se presentan de forma bidimensional, tanto adimensional como con sus
respectivas unidades.
Tabla 7-8. Resultado del análisis de sensibilidad de 𝐶௥y 𝐹 en Λ
Configuración
Número de generaciones (numGen)
2.06, 716.72
ECV (Kg/mss)
relación lb / lr
La Fig. 7-34 muestra 𝜂 contra 𝑊𝑆, acá se evidencia que un comportamiento logarítmico al inicio de 𝑊𝑆
y una meseta de 𝜂 a medida que este se incrementa, esto demuestra que en el HEXA 6RUS se pueden tener
𝑊𝑆 mayores que implican variaciones de 𝜂 de 2.5.
La Fig. 7-35 presenta el comportamiento de EC versus WS, en Fig. 7-35.A se indica que la relación se
mantiene casi constante hasta cuando la relación 𝑙௕𝑙௥
⁄ se acerca a 0.6 (Fig. 7-9). El 𝐸𝐶 más alto es
0.119 𝑁/𝑚 cuando 𝑊𝑆= 0.0916 𝑚ଷ, 𝐸𝐶𝑉= 3.68 𝐾𝑔/𝑚𝑠 y 𝑙௕𝑙௥
= 0.68. La grafica demuestra que no
necesariamente los 𝑊𝑆 más grandes requieren los mayores torques.
La Fig. 7-36 expone la relación de 𝐸𝐶𝑉 y 𝜂; la disminución de los torques necesarios en un 𝑊𝑆
determinado no implican la disminución en la amplificación del error de movimiento. En este frente los
𝐸𝐶𝑉 y 𝜂 máximos (𝐸𝐶𝑉= 527.39, 𝜂= 10.65) y mínimos (𝐸𝐶𝑉= 2.04, 𝜂= 2.40), valores que generan
las relaciones 𝑙௕𝑙௥
= 0.39 y 𝑙௕𝑙௥
= 1. Se destaca que este comportamiento no es directamente
proporcional y resalta la relevancia de encontrar el Λ.
Fig. 7-34. FP A) normalizado y B) dimensionado de 𝜂 y 𝑊𝑆.
La Fig. 7-37 muestra como el 𝑒௖ y 𝐸𝐶𝑉 se relacionan. Los 𝑒௖ se mantienen en un rango entre 8.18% y
12.80% en la mayoría de los casos, excepto en relaciones de 0.618, 0.632, 0.718, 0.650, 0.694, esto resalta
que existen configuraciones particulares que no solo exigen los motores, sino que amplifican el error de
forma considerable.
Fig. 7-35. FP A) normalizado y B) dimensionado de 𝐸𝐶 y 𝑊𝑆.
Fig. 7-36. FP A) normalizado y B) dimensionado 𝐸𝐶𝑉 y 𝜂.
ECV (Kg/ms)
Fig. 7-37. FP A) ECV y ec adimensional. B) ECV y ec, dimensionado. C) EC y ec.
ECV (Kg/ms)
Respecto a la convergencia del algoritmo, la Fig. 7-38 presenta el comportamiento de convergencia del
espaciamiento (Sección 6.8) ante tres ejecuciones del EDMER, donde npop=1024 y numGen=512, este
gráfico muestra que el algoritmo converge gradualmente a un mismo valor. Por otra parte, la Fig. 7-39
evidencia la convergencia en linea del 𝛬 (Sección 6.8) ante los mismos valores de npop y numGen,
mostrando la misma tendencia de convergencia que el espaciamiento.
Fig. 7-38. Convergencia en linea del espaciamiento. npop=1024, numGen=512.
Fig. 7-39. Convergencia en linea del 𝛬. npop=1024, numGen=512.
En cuanto al comportamiento estadístico, se realizaron 12 ejecuciones del EDMER y se analizaron la
media, la desviación, el coeficiente de variación y el rango, tanto del esparcimiento de las soluciones (Fig.
7-40) como del indicador de toma de desición 𝛬 (Fig. 7-41). El estudio estadístico se hizo considerando
que debido al número de muestras, la mejor opción es por medio de una T de student, los resultados se
resumen en la Tabla 7-11.
Fig. 7-40. Comportamiento del espaciado a diferentes ejecuciones.
Fig. 7-41. Comportamiento del 𝛬 a diferentes ejecuciones.
Tabla 7-9. Resultados estadísticos del espaciado y 𝛬 en 12 muestras.
Espaciamiento
Desviación
Coeficiente de variación
Luego de comprender el desempeño que puede tener HEXA 6RUS mediante el análisis de los diferentes
frentes de Pareto y de escoger los valores de C୰ y F, se realizaron los 3 estudios con estos parámetros
variando npop= 2௜, 𝑖= 5, 6, … ,9 y de cada frente se calculó el 𝛬 respectivo. La Fig. 7-42 presenta como
el incremento de npop tiende a encontrar Λ más pequeños. El resultado final de este análisis fue encontrar
la configuración óptima dentro de estos campos de búsqueda, estos valores se resumen en la Tabla 7-10 y
resultaron del Estudio 2 con un 𝑛𝑝𝑜𝑝= 1024 y un 𝛬= 0.3189.
Fig. 7-42. Valor de 𝛬 según la variación de npop.
Tabla 7-10. Valores de configuración seleccionado
adimensional.
** adimensional normalizado.
7.7 Prototipo del HEXA 6 RUS
Luego de la obtención del vector de diseño por parte de los pasos anteriormente descritos, se procede al
diseño en software CAD, en este caso se utilizó el software SolidWorks® para crear los planos de
fabricación del HEXA 6 RUS. La Fig. 7-43 exhibe el mecanismo ensamblado y la Tabla 7-11 las partes
principales; donde, se nombran las piezas numeradas. Con el fin de fabricarlo se utilizaron técnicas de
arranque de viruta, corte laser y manufactura aditiva. En el Anexo H se presentan los planos utilizados para
la fabricación y ensamble. Además, la Fig. 7-44 presenta el modelo físico resultante del HEXA 6 RUS, el
cual se encuentra en las instalaciones del Centro de Investigación DAVINCI en la sede Cajicá de la
Universidad Militar Nueva Granada.
Finalmente, algunos de los aspectos a considerar en la fabricación son los siguientes:
1. La estructura es de perfil estructural de aluminio para facilitar su ensamble yfuturas mejoras o adiciones
de dispositivos debido a su configuración con rieles.
2. En la plataforma fija se anclan los motores, cables y soportes. Ella está fabricada en AISI 1045.
3. El HEXA 6 RUS inicialmente se configura para FFF, por tal motivo se fabrica un soporte para filamento
4. La sujeción del motor tiene la forma de la cara plana del eje del motor y un tornillo prisionero para
disminuir los errores de movimiento debido a tolerancias de mecanizado.
5. La articulación S presenta una inclinación de 30 grados para incrementar el movimiento de rotación.
Además, es fabricada con AISI 304, Nylon y bronce para disminuir la fricción entre las piezas.
6. Los eslabones son fabricados en aluminio; sin embargo, las piezas roscadas se fabrican en AISI 1045
con el fin de aumentar la vida útil de las roscas; además poseen caras planas para facilitar la
implementación de contratuercas.
7. Luego de varias pruebas, la articulación U posee una configuración de dado y Y atravesado por ejes de
acero. Los rodamientos disminuyen la fricción del movimiento y sobrecargas del motor.
8. Finalmente, los motores se fijan a la plataforma fija por medio de un soporte en AISI 1045 y una
abrazadera en PLA hecha con MA.
9. La plataforma móvil se fabrica en aluminio para disminuir el peso; adicionalmente, posee un agujero
en el centro para facilitar el montaje de extrusores, ya que estos pueden ensamblarse como un
subconjunto que luego es fijado por tres tornillos a la plataforma.
Fig. 7-43. Esquemático del modelo CAD del HEXA 6 RUS
Tabla 7-11. Tabla de partes del HEXA 6 RUS
No. de Plano
Estructura
Plataforma fija
Motor del MP/ MAXON 3100009+un reductor 166169
Sujeción motor brazo
Sujeción motor
Plataforma móvil
Cama caliente
Soporte cables
Sujeción del motor MAXON
Fig. 7-44. Modelo físico del HEXA 6 RUS..
8 CONCLUSIONES
En ésta tesis se plantea una metodología para el diseño de un MP enfocado en MA que considera
aspectos como la dimensión de los brazos, los parámetros del controlador, el WS, la manipulabilidad, el
error de seguimiento y el torque requerido. Para esto se definieron dos objetivos específicos que se detallan
a continuación
El primer objetivo era proponer FOs determinando las necesidades geométricas y de control del MP
para que pudieran ser usadas en un algoritmo de optimización multiobjetivo. Para esto, el primer paso fue
seleccionar el HEXA 6 RUS como el MP a trabajar después de preseleccionar seis posibles mecanismos
del estudio del estado del arte ( Sección 3.1) y utilizar la metodología AHP para evaluar y comparar criterios
como: precisión, robustez, simplicidad de fabricación y espacio disponible, tal como se detalla en la
Sección 4.1; en este mismo análisis se determinó que los componentes más susceptibles a las cargas son
los brazos y para garantizar la precisión de movimientos, la resistencia y la rigidez; se definieron
restricciones de desempeño mecánico relacionados con la deformación plástica y la fatiga, expresiones
detalladas en la Sección 4.2. Una vez elegido el MP, el siguiente paso fue la determinación de WS como
una FO, lo cual tuvo en cuenta: el estudio del estado del arte (Sección 3.3) para considerar el análisis de
límites por restricciones y discretización (Sección 2.5.4) como técnica computacionalmente viable; la
evaluación de posición respecto a la CI (Sección 4.3); la generación de una nube de puntos basada en las
posiciones límites y el cálculo del volumen a partir de tetraedros (Sección 5). La η (Sección 2.6) se
identificó como otra FO que pudo calcularse mediante: una discretización del WS y el número condicional
de las matrices Jacobianas de velocidad lineal y angular del MP determinadas por la modelación dinámica
(Sección 4.4). Para el cálculo de la tercera y cuarta FO, 𝐸𝐶 y 𝑒௖ respectivamente, se propuso una estrategia
de control híbrida (Sección 5.3) que se basó en las matrices de la modelación dinámica (Sección 4.4).
El segundo objetivo de esta tesis era desarrollar un algoritmo metaheurístico que optimice el diseño
mecánico del MP y las constantes de control buscando aumentar el WS y la manipulabilidad, mientras que
se disminuye el error y el esfuerzo de control. Para esto, según el estado del arte (3.5), se desarrolló un
algoritmo basado en EDMER (2.9.6) y se determinaron cinco aspectos claves. El primer aspecto fue que en
las pruebas de PFDE, EDMER proporcionó errores menores al 1% lo que resalta el algoritmo como una
buena opción de diseño para este tipo de problemas (Sección 6.7). Segundo, en la aplicación del diseño del
HEXA 6 RUS, EDMER consideró las cuatro FO simultáneamente (Secciones 5 y 5.3), junto con el análisis
de dominancia, la clasificación de hacinamiento y las restricciones para generar FPs Tercero, se eligió el
LINMAP (Sección 6.8) como método de toma de decisión y se tomaron parámetros de calibración
relacionados con 𝐶௥, 𝐹 y número de generaciones. Cuarto, se hicieron varias corridas del algoritmo con
diferentes números de población con el fin de encontrar la mejor configuración dentro de la superficie de
respuesta (Sección 7.6), de estas corridas se evaluó el comportamiento en línea del espaciamiento y del
LINMAP, asi como, el análisis estadístico y la convergencia. Quinto, debido al costo computacional, el
comportamiento del MP se basó en el modelo dinámico hallado en la Sección 4.4.
En la búsqueda de estos objetivos se hicieron varios desarrollos y hallazgos. Por ejemplo, la estrategia de
control seleccionada fue una híbrida que consideró la planitud diferencial por su eficacia de seguimiento de
trayectoria junto con la propiedad de conmutación de los modos deslizantes (Secciones 2.7 y 5.3). Esto
generó un controlador robusto que en validaciones in silico presentó una buena respuesta a las
perturbaciones y a los juegos mecánicos producto de las tolerancias de fabricación (Sección 7.4). Con esta
implementación el 𝐸𝐶 se relacionó con la energía necesaria para que el sistema sea controlado mientras
que el 𝑒௖ determinó la eficiencia del controlador al comparar las condiciones deseadas contra las realizadas.
Otra conclusión fue que el análisis dinámico con el principio de D’Alembert y de trabajo virtual demostró
ser eficaz y computacionalmente eficiente. El hecho que no se requiera calcular derivadas parciales permite
que el cálculo para la obtención de las matrices se pueda hacer en la estrategia de control, evitando la
expresión simbólica de estas matrices, que en mecanismos de cinemática paralela son largas, y disminuye
el costo de cómputo al momento de usar las respuestas de controlador como FOs.
Además, la determinación del WS discretizado en mecanismos axisimétricos basándose en la creación de
la superficie límite es una estrategia también con un bajo costo computacional apta para su implementación
en optimización y que permite con la variación de la cantidad de puntos analizados modificar su precisión
(Sección 7.2).
Adicionalmente, las consideraciones geométricas y de control durante el proceso de diseño permitieron
evaluar el funcionamiento del MP y sintonizar el controlador por medio de herramientas computacionales
(Sección 7.6). Esto disminuye los ajustes iterativos a los prototipos físicos como se hace en la metodología
de diseño secuencial. Lo anterior indica que los diseños concurrentes disminuyen tiempo, amplían
búsquedas y combinaciones no contempladas mientras que reducen costos de prueba, ejecución e
implementación.
Se recalca que no se encontró evidencia en la literatura acerca del diseño de algún MP con seis grados
de libertad que considere cuatro FOs; además, tampoco hay demostraciones de optimizaciones
multiobjetivo en donde sus FOs relacionen la configuración mecánica como con las ganancias del
controlador. Por otra parte, tampoco se halló una estrategia de control híbrida, como la presentada en este
documento, en la literatura. Todos estos aspectos aportan el estado de arte relacionado con el diseño óptimo
Como trabajos futuros se proponen: utilizar la teoría de tornillos tanto para el análisis cinemático
infinitesimal del MP, como para la deducción de las matrices Jacobianas y así poder comprobar si este
enfoque simplifica los cálculos, tal como algunos autores aseguran. Además, se considera que el cálculo de
la cinemática directa infinitesimal permitiría detallar la relación de velocidades de la placa móvil según la
velocidad de los actuadores. Adicionalmente, se exalta el estudio de la manipulabilidad separando los
comportamientos rotacionales y traslacionales, lo que genera una función objetivo adicional. Asimismo, se
insta a analizar el balanceo dinámico del mecanismo. Por otra parte, se requiere el ajuste fino del
controlador con el modelo físico del HEXA 6 RUS (Sección 7.7) debido a que las tolerancias de mecanizado
y ensamble difieren de los modelos en CAD. Además, aunque los motores poseen sensores de movimiento,
la incorporación de sensores o cámaras que retornen la posición real del centro de la plataforma móvil
disminuye errores de seguimiento. Finalmente, en el Anexo A se listan los productos de nuevo
conocimiento derivados de esta tesis.
REFERENCIAS
M. Baumers, P. Dickens, C. Tuck, and R. Hague, “The cost of additive manufacturing: Machine
productivity, economies of scale and technology-push,” Technol. Forecast. Soc. Change, vol. 102,
2016, doi: 10.1016/j.techfore.2015.02.015.
W. Gao et al., “The status, challenges, and future of additive manufacturing in engineering,” CAD
Comput. Aided Des., vol. 69, pp. 65–89, 2015, doi: 10.1016/j.cad.2015.04.001.
Y. Jin, J. Du, Y. He, and G. Fu, “Modeling and process planning for curved layer fused deposition,”
Int. J. Adv. Manuf. Technol., vol. 91, no. 1–4, pp. 273–285, 2017, doi: 10.1007/s00170-016-9743-
R. J. A. Allen and R. S. Trask, “An experimental demonstration of effective Curved Layer Fused
Filament Fabrication utilising a parallel deposition robot,” Addit. Manuf., vol. 8, pp. 78–87, 2015,
doi: 10.1016/j.addma.2015.09.001.
W. Gao, Y. Zhang, D. C. Nazzetta, K. Ramani, R. J. Cipra, and W. Lafayette, “RevoMaker :
Enabling Multi-directional and Functionally-embedded 3D Printing using a Rotational Cuboidal
Platform,” Proc. 28th Annu. ACM Symp. User Interface Softw. Technol. - UIST ’15, pp. 437–446,
2015, doi: 10.1145/2807442.2807476.
X. Song, Y. Pan, and Y. Chen, “Development of a Low-Cost Parallel Kinematic Machine for
Multidirectional Additive Manufacturing,” J. Manuf. Sci. Eng., vol. 137, no. April, pp. 1–13, 2015,
doi: 10.1115/1.4028897.
D. Bourell, B. Stucker, Y. Chen, C. Zhou, and J. Lao, “A layerless additive manufacturing process
based on CNC accumulation,” Rapid Prototyp. J., vol. 17, no. 3, pp. 218–227, 2011.
Z.-F. Shao, X. Tang, X. Chen, and L.-P. Wang, “Research on the inertia matching of the Stewart
parallel manipulator,” Robot. Comput. Integr. Manuf., vol. 28, no. 6, pp. 649–659, 2012, doi:
10.1016/j.rcim.2012.04.001.
P. Ogbobe, Z. Ye, H. Jiang, and J. Han, “Analytical Formulation of Coupling Effects Matrix
Between Degrees of Freedom Motion of Parallel Robots,” in Intelligent Computation Technology
and Automation (ICICTA), 2010 International Conference on, 2010, vol. 1, pp. 711–714, doi:
10.1109/ICICTA.2010.368.
K. Deb, Optimization for Engineering Design, 2nd ed. New Delhi: PHI Learning Private Limited,
J. Ruan, K. Eiamsa-ard, and F. W. Liou, “Automatic process planning and toolpath generation of a
multiaxis hybrid manufacturing system,” J. Manuf. Process., vol. 7, no. 1, pp. 57–68, 2005.
K. Gupta, N. K. Jain, and R. F. Laubscher, Hybrid machining processes: perspectives on machining
and finishing. Springer, 2016.
A. El Khalick, M. N. Uchiyama, and S. Sano, “Sliding mode contouring control design using
nonlinear sliding surface for three-dimensional machining,” Int. J. Mach. TOOLS Manuf., vol. 65,
pp. 8–14, Feb. 2013, doi: 10.1016/j.ijmachtools.2012.07.004.
S.-H. Chen and L.-C. Fu, “Observer-based backstepping control of a 6-dof parallel hydraulic
manipulator,”
10.1016/j.conengprac.2014.11.011.
J. P. Merlet, Parallel robots, 2nd ed., vol. 128. Dordrecht: Springer Science & Business Media,
Z. Pandilov and V. Dukovski, “Comparison of the Characteristics Between Serial and Parallel
Robots,” Acta Tech. Corviniensis-Bulletin Eng., vol. 7, no. 1, pp. 2067–3809, 2014, [Online].
Available: 
W. Lei, F. Qian, C. Jia, and S. Liye, “Control Method of Parallel Robot Based on Adaptive Neural
Fuzzy Inference Combined with PID Control,” Agro Food Ind. Hi. Tech., vol. 28, no. 3, pp. 3169–
3174, 2017.
D. Zhang, Y. Xu, J. Yao, B. Hu, and Y. Zhao, “Kinematics, dynamics and stiffness analysis of a
novel 3-DOFkinematically/actuation redundant planar parallel mechanism,” Mech. Mach.
THEORY, vol. 116, pp. 203–219, Oct. 2017, doi: 10.1016/j.mechmachtheory.2017.04.011.
M. Ming, A., Kajitani, “On the design of wire parallel mechanism,” Int. J. Jpn Soc. Precis. Eng, vol.
4, no. 29, pp. 337–242, 1995.
C. Viegas, M. Tavakoli, and A. T. de Almeida, “A novel grid-based reconfigurable spatial parallel
mechanism with large workspace,” Mech. Mach. Theory, vol. 115, no. September, pp. 149–167,
2017, doi: 10.1016/j.mechmachtheory.2017.05.008.
G. Gogu, “Mobility of mechanisms: a critical review,” Mech. Mach. Theory, vol. 40, no. 9, pp.
1068–1097, Sep. 2005, doi: 10.1016/J.MECHMACHTHEORY.2004.12.014.
W. J. Liu, Xin-Jun, parallel Kinematics: Type, Kinematics, and Optimal Design, 1st ed. London:
Springer London, 2014.
J. P. Merlet, “Jacobian, manipulability, condition number and accuracy of parallel robots,” Springer
Tracts Adv. Robot., vol. 28, 2007, doi: 10.1007/978-3-540-48113-3_16.
B. Dasgupta and P. Choudhury, “General strategy based on the Newton-Euler approach for the
dynamic formulation of parallel manipulators,” Mech. Mach. Theory, vol. 34, no. 6, pp. 801–824,
1999, doi: 10.1016/S0094-114X(98)00081-0.
X. Wang and Y. Tian, “Inverse dynamics of hexa parallel robot based on the lagrangian equations
of first type,” 2010 Int. Conf. Mech. Autom. Control Eng. MACE2010, no. 2008, pp. 3712–3716,
2010, doi: 10.1109/MACE.2010.5535969.
A. A. Shabana, Computational Dynamics, 3rd ed. John Wiley & Sons, 2010.
M. DANESHMAND, M. M. TALE, and M. H. SAADATZI, “Optimization of the Kinematic
Sensitivity and the Greatest Continuous Circle in the Constant-orientation Workspace of Planar
Parallel Mechanisms,” 2015.
Y. Liu, H. Wu, Y. Yang, S. Zou, X. Zhang, and Y. Wang, “Symmetrical Workspace of 6-UPS
Parallel Robot Using Tilt and Torsion Angles,” vol. 2018, 2018.
X. J. Liu, J. Wang, K. K. Oh, and J. Kim, “A new approach to the design of a DELTA robot with a
desired workspace,” J. Intell. Robot. Syst. Theory Appl., vol. 39, no. 2, pp. 209–225, 2004, doi:
10.1023/B:JINT.0000015403.67717.68.
S. T. Filho and E. Cabral, “Kinematics and workspace analysis of a parallel architecture robot: the
Hexa,” 18th Int. Congr. Mech. Eng. Novemb. 6-11, Ouro Preto, MG, vol. 2, no. August, pp. 158–
Available:
 
J.-P. Merlet, “Jacobian, manipulability, condition number and accuracy of parallel robots.”
J. D. Orozco-Muñiz, J. J. Cervantes-Sánchez, and J. M. Rico-Martínez, “Dexterity indices for planar
parallel manipulators,” Robot. Comput. Integr. Manuf., vol. 46, pp. 144–155, Aug. 2017, doi:
10.1016/J.RCIM.2016.12.011.
A. Koszewnik, K. Troc, and M. Słowik, “PID controllers design applied to positioning of ball on
the stewart platform,” Acta Mech. Autom., vol. 8, no. 4, pp. 214–218, 2014, doi: 10.2478/ama-2014-
F. Inel and L. Khochmane, “Comparison performance between PID and PD controllers for three and
four cable-based robots,” World J. Eng., vol. 11, no. 6, pp. 543–556, 2014, doi: 10.1260/1708-
5284.11.6.543.
S. Keshtkar, A. S. Poznyak, E. Hernandez, and A. Oropeza, “Adaptive Sliding-Mode Controller
Based on the ``Super-Twist’’ State Observer for Control of the Stewart Platform,” Autom. Remote
Control, vol. 78, no. 7, pp. 1218–1233, Jul. 2017, doi: 10.1134/S0005117917070049.
H. Sira-Ramirez and S. K. Agrawal, Differentially Flat Systems, 2nd ed. Boca Raton: CRC Press,
K. Ogata, Modern Control Engineering, 5th ed. New Jersey: Prentice Hall, 2010.
J. Liu, “Basic sliding mode control principle and design,” in Sliding Mode Control Using MATLAB,
Academic Press, 2017, pp. 1–29.
V. I. Utkin, Sliding Modes in Control and Optimization, 2nd ed. Berlin, Heidelberg: Springer Berlin
Heidelberg, 1992.
J. Slotine and W. Li, Applied Nonlinear Control. 1990.
H. Lee and V. I. Utkin, “Chattering suppression methods in sliding mode control systems,” Annu.
Rev. Control, vol. 31, no. 2, pp. 179–188, Jan. 2007, doi: 10.1016/J.ARCONTROL.2007.08.001.
A. M. Piña, “Trajectory generation of differentially flat systems,” Rev. Técnologica Ingieneria Univ.
Zulia, vol. 24, no. 2, pp. 99–106, 2001.
A. Morillo, “Trajectory generation of differentially flat systems,” Rev. técnica la Fac. Ing. del Zulia.,
vol. 24, no. 2, pp. 99–106, 2001.
S. Rao, Engineering Optimization. Theory and Practice, 4th ed. John Wiley & Sons, Ltd, 2009.
K. Deb, Multi Objective Optimization using Evolutionary Algorithms, 1st ed. West Sussex: Wiley,
V. D. Coello, Carlos, Lamont Gary, Evolutionary Algorithms for Solving Multi-Objective Problems,
2nd ed. 2007.
J. Price, K.; Storn, R.; Lampinen, Differential Evolution. Berlin: Springer, 2005.
J. Lampinen and I. Zelinka, “Mixed Variable Non-linear Optimization by Difeerential Evolution,”
Proccedings of Nostradamus, vol. 99, no. 2, pp. 1–10, 1999.
M. Weck and D. Staimer, “Parallel kinematic machine tools - Current state and future potentials,”
CIRP Ann. - Manuf. Technol., vol. 51, no. 2, pp. 671–683, 2002, doi: 10.1016/S0007-
8506(07)61706-5.
D. Stewart, “A Platform with Six Degrees of Freedom,” Proc. Inst. Mech. Eng., vol. 180, no. 1, pp.
371–386, Jun. 1965, doi: 10.1243/PIME_PROC_1965_180_029_02.
Y. Jiang, T. Li, L. Wang, and F. Chen, “Improving tracking accuracy of a novel 3-DOF redundant
planar parallel kinematic machine,” Mech. Mach. Theory, vol. 119, pp. 198–218, 2018, doi:
10.1016/j.mechmachtheory.2017.09.012.
J. Fu, F. Gao, Y. Pan, and H. Du, “Forward kinematics solutions of a special six-degree-of-freedom
parallel manipulator with three limbs,” Adv. Mech. Eng., vol. 7, no. 5, pp. 1–11, 2015, doi:
10.1177/1687814015582118.
W. Ye, Y. Fang, and S. Guo, “Design and analysis of a reconfigurable parallel mechanism for
multidirectional additive manufacturing,” Mech. Mach. Theory, vol. 112, pp. 307–326, Jun. 2017,
doi: 10.1016/J.MECHMACHTHEORY.2016.02.011.
A. Dutta, D. H. Salunkhe, S. Kumar, A. D. Udai, and S. V. Shah, “Sensorless full body active
compliance in a 6 DOF parallel manipulator,” Robot. Comput. Integr. Manuf., vol. 59, no. May, pp.
278–290, 2019, doi: 10.1016/j.rcim.2019.04.010.
K. H. Hunt, “Structural kinematics of in-parallel-actuated robot-arms,” J. Mech. Transm. Autom.
Des., vol. 105, no. 4, pp. 705–712, 1983.
C. Gosselin, T. Laliberte, and A. Veillette, “Singularity-Free Kinematically Redundant Planar
Parallel Mechanisms With Unlimited Rotational Capability,” IEEE Trans. Robot., vol. 31, no. 2, pp.
457–467, Apr. 2015, doi: 10.1109/TRO.2015.2409433.
L.-T. Schreiber and C. Gosselin, “Kinematically redundant planar parallel mechanisms: Kinematics,
workspace and trajectory planning,” Mech. Mach. Theory, vol. 119, pp. 91–105, 2018, doi:
10.1016/j.mechmachtheory.2017.08.022.
C. Chen, T. Gayral, S. Caro, D. Chablat, G. Moroz, and S. Abeywardena, “A Six Degree of Freedom
Epicyclic-Parallel Manipulator,” J. Mech. Robot., vol. 4, no. 4, p. 041011, 2012, doi:
10.1115/1.4007489.
W. Li and J. Angeles, “The design of a 3-CPS parallel robot for maximum dexterity,” Mech. Mach.
Theory, vol. 122, pp. 279–291, 2018, doi: 10.1016/j.mechmachtheory.2018.01.003.
H. Azulay, M. Mahmoodi, R. Zhao, J. K. Mills, and B. Benhabib, “Comparative analysis of a new
3× PPRS parallel kinematic mechanism,” Robot. Comput. Integr. Manuf., vol. 30, no. 4, pp. 369-
378o, 2014, doi: 10.1016/j.rcim.2013.12.003.
Y. Song, B. Lian, T. Sun, G. Dong, Y. Qi, and H. Gao, “A novel five-degree-of-freedom parallel
manipulator and its kinematic optimization,” J. Mech. Robot., vol. 6, no. 4, 2014, doi:
10.1115/1.4027742.
N. Seward and I. A. Bonev, “A new 6-DOF parallel robot with simple kinematic model,” Proc. -
IEEE Int. Conf. Robot. Autom., pp. 4061–4066, 2014, doi: 10.1109/ICRA.2014.6907449.
C. Viegas, M. Tavakoli, and A. T. d. Almeida, “A novel grid-based reconfigurable spatial parallel
mechanism with large workspace,” Mech. Mach. Theory, vol. 115, pp. 149–167, 2017, doi:
10.1016/j.mechmachtheory.2017.05.008.
G. Yu, J. Wu, L. Wang, and Y. Gao, “Optimal Design of the Three-Degree-of-Freedom Parallel
Manipulator in a Spray-Painting Equipment,” Robotica, vol. 38, no. 6, pp. 1064–1081, 2020.
H. Zhang, H. Fang, Q. Zou, and D. Zhang, “Dynamic modeling and adaptive robust synchronous
control of parallel robotic manipulator for industrial application,” Complexity, vol. 2020, 2020.
A. Arian, M. Isaksson, and C. Gosselin, “Kinematic and dynamic analysis of a novel parallel
kinematic Schönflies motion generator,” Mech. Mach. Theory, vol. 147, p. 103629, 2020.
S. Lu, B. Ding, and Y. Li, “Minimum-jerk trajectory planning pertaining to a translational 3-degreeof-freedom parallel manipulator through piecewise quintic polynomials interpolation,” Adv. Mech.
Eng., vol. 12, no. 3, p. 1687814020913667, 2020.
X. Chai, M. Wang, L. Xu, and W. Ye, “Dynamic modeling and analysis of a 2PRU-UPR parallel
robot based on screw theory,” Ieee Access, vol. 8, pp. 78868–78878, 2020.
S. Xie, K. Hu, H. Liu, and Y. Wan, “Dynamic modeling and performance analysis of a new
redundant parallel rehabilitation robot,” IEEE Access, vol. 8, pp. 222211–222225, 2020.
H. Zhang, H. Fang, D. Zhang, Q. Zou, and X. Luo, “Trajectory tracking control study of a new
parallel mechanism with redundant actuation,” Int. J. Aerosp. Eng., vol. 2020, 2020.
Y. Rong, X. C. Zhang, and M. K. Qu, “Unified inverse dynamics for a novel class of metamorphic
mechanisms,”
10.1016/j.apm.2019.04.051.
S. Pedrammehr, B. Danaei, H. Abdi, M. T. Masouleh, and S. Nahavandi, “Dynamic analysis of
Hexarot: Axis-symmetric parallel manipulator,” Robotica, vol. 36, no. 2, pp. 225–240, 2018, doi:
10.1017/S0263574717000315.
W. E. Dharmalingum, J. Padayachee, and G. Bright, “SYNTHESIS OF A NOVEL FIVE-
DEGREES–OF-FREEDOM PARALLEL KINEMATIC MANIPULATOR,” South African J. Ind.
Eng., vol. 32, no. 1, pp. 131–143, May 2021, doi: 10.7166/32-1-2382.
L. Sheng and W. Li, “Optimization design by genetic algorithm controller for trajectory control of
a 3-RRR parallel robot,” Algorithms, vol. 11, no. 1, 2018, doi: 10.3390/a11010007.
M. Russo, S. Herrero, O. Altuzarra, and M. Ceccarelli, “Kinematic analysis and multi-objective
optimization of a 3-UPR parallel mechanism for a robotic leg,” Mech. Mach. Theory, vol. 120, pp.
192–202, Feb. 2018, doi: 10.1016/J.MECHMACHTHEORY.2017.10.004.
A. G. Ruiz, J. C. Santos, J. Croes, W. Desmet, and M. M. Da Silva, “On redundancy resolution and
energy consumption of kinematically redundant planar parallel manipulators,” Robotica, vol. 36,
no. 6, pp. 809–821, Jun. 2018, doi: 10.1017/S026357471800005X.
D. Chablat, X. Kong, and C. Zhang, “Kinematics, workspace, and singularity analysis of a parallel
robot with five operation modes,” J. Mech. Robot., vol. 10, no. 3, Jun. 2018, doi:
10.1115/1.4039400/377469.
H. Shen, Y. Tang, G. Wu, J. Li, T. Li, and T. Yang, “Design and analysis of a class of two-limb
non-parasitic 2T1R parallel mechanism with decoupled motion and symbolic forward position
solution - influence of optimal arrangement of limbs onto the kinematics, dynamics and stiffness,”
10.1016/J.MECHMACHTHEORY.2022.104815.
H. Shen, D. Chablat, B. Zeng, J. Li, G. Wu, and T. L. Yang, “A Translational Three-Degrees-of-
Freedom Parallel Mechanism with Partial Motion Decoupling and Analytic Direct Kinematics,” J.
Mech. Robot., vol. 12, no. 2, Jan. 2020, doi: 10.1115/1.4045972/1072539.
M. Vallés et al., “Mechatronic design, experimental setup, and control architecture design of a novel
4 DoF parallel manipulator,” Mech. Based Des. Struct. Mach., vol. 46, no. 4, pp. 425–439, 2018,
doi: 10.1080/15397734.2017.1355249.
O. Altuzarra, D. Caballero, F. J. Campa, and C. Pinto, “Position analysis in planar parallel
continuum mechanisms,” Mech. Mach. Theory, vol. 132, pp. 13–29, Feb. 2019, doi:
10.1016/J.MECHMACHTHEORY.2018.10.014.
J. J. Gil, I. Zabalza, J. Ros, J. M. Pintor, and J. M. Jiménez, “Kinematics and dynamics of a 6-RUS
hunt-type parallel manipulator by using natural coordinates,” in On Advances in Robot Kinematics,
Springer, 2004, pp. 329–335.
J. Aginaga, I. Zabalza, O. Altuzarra, and J. Nájera, “Improving static stiffness of the 6-RUS parallel
manipulator using inverse singularities,” Robot. Comput. Integr. Manuf., vol. 28, no. 4, pp. 458–
471, 2012, doi: 10.1016/j.rcim.2012.02.003.
J. Hesselbach, C. Bier, A. Campos, and H. Lowe, “Direct kinematic singularity detection of a hexa
parallel robot,” in Robotics and Automation, 2005. ICRA 2005. Proceedings of the 2005 IEEE
International Conference on, 2005, pp. 3238–3243.
M. Dehghani, M. Ahmadi, A. Khayatian, M. Eghtesad, and M. Yazdi, “Vision-based calibration of
a Hexa parallel robot,” Ind. Robot An Int. J., vol. 41, no. 3, pp. 296–310, 2014.
D. Chen, S. Li, J. F. Wang, Y. Feng, and Y. Liu, “A multi-objective trajectory planning method
based on the improved immune clonal selection algorithm,” Robot. Comput. Integr. Manuf., vol. 59,
pp. 431–442, Oct. 2019, doi: 10.1016/J.RCIM.2019.04.016.
S. Li, D. Chen, and J. Wang, “An optimal singularity-free motion planning method for a 6-DOF
parallel manipulator,” Ind. Rob., vol. 48, no. 2, pp. 290–299, 2020, doi: 10.1108/IR-04-2020-
0079/FULL/XML.
A. Antonov and V. Glazunov, “Position, velocity, and workspace analysis of a novel 6-DOF parallel
manipulator with ‘piercing’ rods,” Mech. Mach. Theory, vol. 161, p. 104300, Jul. 2021, doi:
10.1016/J.MECHMACHTHEORY.2021.104300.
M. F. Shah, Z. Kausar, M. U. Farooq, L. A. Khan, and S. S. Farooq, “Accuracy Analysis of
Machining Trajectory Contemplating Workpiece Dislocation on a Six Degree of Freedom
Machining Bed:,” vol. 235, no. 19,
pp. 4037–4048, Dec. 2020, doi: 10.1177/0954406220974049.
A. Fomin, A. Antonov, V. Glazunov, and Y. Rodionov, “Inverse and Forward Kinematic Analysis
of a 6-DOF Parallel Manipulator Utilizing a Circular Guide,” Robot. 2021, Vol. 10, Page 31, vol.
10, no. 1, p. 31, Feb. 2021, doi: 10.3390/ROBOTICS10010031.
K. Wang, X. Wu, Y. Wang, J. Ding, and S. Bai, “Kinematics of a 6-DOF parallel manipulator with
generators:,”
 
10.1177/09544062211032998.
Y. Liwei, F. Yanchao, C. Fangmao, P. Xinyuan, and D. deyi, “Parameter calibration of 6-degreeof-freedom parallel mechanism based on orthogonal displacement measuring system,” Optik
(Stuttg)., vol. 226, p. 165806, Jan. 2021, doi: 10.1016/J.IJLEO.2020.165806.
M. J. Thomas, M. M. Sanjeev, A. P. Sudheer, and J. M.L, “Comparative study of various machine
learning algorithms and Denavit–Hartenberg approach for the inverse kinematic solutions in a 3-
PPSS parallel manipulator,” Ind. Rob., vol. 47, no. 5, pp. 683–695, Aug. 2020, doi: 10.1108/IR-11-
2019-0233/FULL/XML.
R. V. Anirudh, K. A. Sai, S. Kulothungan, and A. K. Dash, “An Application of a 3-RRRS 6 DOF
Parallel Manipulator,” J. Title, vol. 10, no. 1, pp. 501–509, 2020, doi: 10.5875/AUSMT.V10I1.2048.
X. Liang and Y. Takeda, “An iterative method for the inverse kinematics of lower-mobility parallel
mechanism with three RS or SR chains based on kinematically equivalent mechanism,” Mech.
10.1016/J.MECHMACHTHEORY.2019.06.033.
H. S. A. Q. E. Han, C. Y. Han, Z. B. Xu, M. C. Zhu, Y. Yu, and Q. W. Wu, “Kinematics analysis
and testing of novel 6-P-RR-R-RR parallel platform with offset RR-joints:,” vol. 233, no. 10, pp. 3512–3530, Dec. 2018,
doi: 10.1177/0954406218817001.
Z. M. Bi and B. Kang, “An Inverse Dynamic Model of Over-Constrained Parallel Kinematic
Machine Based on Newton–Euler Formulation,” J. Dyn. Syst. Meas. Control, vol. 136, no. 4, p.
041001, Mar. 2014, doi: 10.1115/1.4026533.
A. Arian, B. Danaei, and M. Tale Masouleh, “Kinematic and Dynamic Analysis of Tripteron, an
Over-constrained 3-DOF Translational Parallel Manipulator, Through Newton-Euler Approach,”
AUT J. Model. Simul., vol. 50, no. 1, pp. 61–70, Jun. 2018, doi: 10.22060/MISCJ.2018.13020.5055.
B. Zhang, S. Jiang, Z. Jiang, J. Li, K. Zhou, and F. Liu, “Dynamic Analysis and Control Research
of a 3-DOF Hydraulic Driven Parallel Mechanism,” Recent Patents Mech. Eng., vol. 13, no. 2, pp.
156–170, 2020, doi: 10.2174/2212797613666200210113800.
 J. Li et al., “Mechanical design and performance analysis of a novel parallel robot for ankle
rehabilitation,” J. Mech. Robot., vol. 12, no. 5, p. 51007, 2020, doi: 10.1115/1.4046511.
 Z. Wang, N. Zhang, X. Chai, and Q. Li, “Kinematic/dynamic analysis and optimization of a 2-URR-
RRU parallel manipulator,” NONLINEAR Dyn., vol. 88, no. 1, pp. 503–519, 2017, doi:
10.1007/s11071-016-3256-5.
 Y. Zhao, H. Yu, J. Zhang, J. Yang, and T. Zhao, “Kinematics, dynamics and control of a stabilized
platform with a 6-RUS parallel mechanism,” Int. J. Robot. Autom., vol. 32, no. 3, pp. 283–290,
 A. Arian, B. Danaei, and M. T. Masouleh, “Kinematics and dynamics analysis of a 2-dof spherical
parallel robot,” in 2016 4th international conference on robotics and mechatronics (ICROM), 2016,
pp. 154–159, doi: 10.1109/ICRoM.2016.7886838.
 C. Xiulong, L. Yuewen, and J. Yonghao, “Dynamic response and nonlinear characteristics of spatial
parallel mechanism with spherical clearance joint,” J. Comput. Nonlinear Dyn., vol. 14, no. 4, 2019,
doi: 10.1115/1.4042636.
 J. Brinker, B. Corves, and M. Wahle, “A comparative study of inverse dynamics based on Clavel’s
delta robot,” 2015 IFToMM World Congr. Proceedings, IFToMM 2015, 2015, doi:
10.6567/IFToMM.14TH.WC.OS13.026.
 M. J. Thomas, M. L. Joy, and A. P. Sudheer, “Kinematic and Dynamic Analysis of a 3-PRUS Spatial
Parallel Manipulator,” Chinese J. Mech. Eng. 90041-V.
 Lung-Wen Tsai, G. C. Walsh, and R. E. Stamper, “Kinematics of a novel three DOF translational
platform,” in Proceedings of IEEE International Conference on Robotics and Automation, vol. 4,
pp. 3446–3451, doi: 10.1109/ROBOT.1996.509237.
 B. Danaei, A. Arian, M. T. Masouleh, and A. Kalhor, “Kinematic and Dynamic Modeling and Base
Inertial Parameters Determination of the Quadrupteron Parallel Manipulator,” 2018, pp. 249–256.
 R. Li, S. Wang, D. Fan, Y. Du, and S. Bai, “Dynamic modeling of a 2-RPU+2-UPS hybrid
manipulator for machining application,” Model. Identif. Control, vol. 38, no. 4, pp. 169–184, 2017,
doi: 10.4173/mic.2017.4.2.
 J. Gallardo-Alvarado, R. Rodríguez-Castro, and P. J. Delossantos-Lara, “Kinematics and dynamics
of a 4-PRUR Schönflies parallel manipulator by means of screw theory and the principle of virtual
10.1016/j.mechmachtheory.2017.12.022.
 H. Yang, H. Fang, Y. Fang, and H. Qu, “Kinematics performance and dynamics analysis of a novel
parallel perfusion manipulator with passive link,” Math. Probl. Eng., vol. 2018, 2018, doi:
10.1155/2018/6768947.
 D. Li et al., “Dynamic analysis of multi-functional maintenance platform based on Newton-Euler
method and improved virtual work principle,” Nucl. Eng. Technol., vol. 52, no. 11, pp. 2630–2637,
2020, doi: 10.1016/j.net.2020.04.017.
 R. Li, S. Wang, D. Fan, Y. Du, and S. Bai, “Dynamic Modeling of a 2-RPU+2-UPS Hybrid
Manipulator for Machining Application,” Model. Identif. Control A Nor. Res. Bull., vol. 38, no. 4,
pp. 169–184, 2017, doi: 10.4173/mic.2017.4.2.
 G. Han, F. Xie, and X.-J. Liu, “Evaluation of the power consumption of a high-speed parallel robot,”
Front. Mech. Eng., vol. 13, no. 2, pp. 167–178, 2018, doi: 10.1007/s11465-017-0456-8.
 A. Arian, M. Isaksson, and C. Gosselin, “Kinematic and dynamic analysis of a novel parallel
kinematic Schönflies motion generator,” Mech. Mach. Theory, vol. 147, p. 103629, May 2020, doi:
10.1016/J.MECHMACHTHEORY.2019.103629.
 P. Li, A. Ghasemi, W. Xie, and W. Tian, “Visual Closed-Loop Dynamic Model Identification of
Parallel Robots Based on Optical CMM Sensor,” Electron. 2019, Vol. 8, Page 836, vol. 8, no. 8, p.
836, Jul. 2019, doi: 10.3390/ELECTRONICS8080836.
 X. Song, Y. Zhao, L. Jin, P. Zhang, and C. Chen, “Dynamic feedforward control in decoupling space
for a four-degree-of-freedom parallel robot:,” vol. 16,
no. 1, Jan. 2019, doi: 10.1177/1729881418820451.
 A. Arian, B. Danaei, H. Abdi, and S. Nahavandi, “Kinematic and dynamic analysis of the Gantry-
Tau, a 3-DoF translational parallel manipulator,” Appl. Math. Model., vol. 51, pp. 217–231, 2017,
doi: 10.1016/j.apm.2017.06.012.
 S. S. Parsa, R. Boudreau, and J. A. Carretero, “Reconfigurable mass parameters to cross direct
kinematic singularities in parallel manipulators,” Mech. Mach. Theory, vol. 85, pp. 53–63, Mar.
2015, doi: 10.1016/J.MECHMACHTHEORY.2014.10.008.
 J.-H. Choi, T. Seo, and J. W. Lee, “Singularity analysis of a planar parallel mechanism with revolute
joints based on a geometric approach,” Int. J. Precis. Eng. Manuf., vol. 14, no. 8, pp. 1369–1375,
Aug. 2013, doi: 10.1007/s12541-013-0185-9.
 C. Gosselin and J. Angeles, “Singularity analysis of closed-loop kinematic chains,” IEEE Trans.
Robot. Autom., vol. 6, no. 3, pp. 281–290, Jun. 1990, doi: 10.1109/70.56660.
 C. Gosselin, “Determination of the workspace of 6-DOF parallel manipulators,” J. Mech. Des., vol.
112, no. 3, pp. 331–336, 1990, doi: 10.1115/1.2912612.
 I. A. Bonev and J. Ryu, “A geometrical method for computing the constant-orientation workspace
of 6-PRRS parallel manipulators,” Mech. Mach. theory, vol. 36, no. 1, pp. 1–13, 2001, doi:
10.1016/S0094-114X(00)00031-8.
 H. An, B. Li, S. Wang, and W. Ge, “Kinematics and Transmission Performance Analyses of a 2T2R
Type 4-DOF Spatial Parallel Manipulator,” J. Robot., vol. 2018, 2018, doi: 10.1155/2018/4750627.
 E. Mirshekari, A. Ghanbarzadeh, and K. H. Shirazi, “Structure comparison and optimal design of
6-rus parallel manipulator based on kinematic and dynamic performances,” Lat. Am. J. Solids
Struct., vol. 13, no. 13, pp. 2414–2438, 2016, doi: 10.1590/1679-78252937.
 F. La Mura, P. Romanó, E. Fiore, and H. Giberti, “Workspace limiting strategy for 6 DOF force
controlled PKMs manipulating high inertia objects,” Robotics, vol. 7, no. 1, 2018, doi:
10.3390/robotics7010010.
 E. Mirshekari, A. Ghanbarzadeh, K. H. Shirazia, E. Mirshekari, A. Ghanbarzadeh, and K. H.
Shirazia, “Structure comparison and optimal design of 6-RUS parallel manipulator based on
kinematic and dynamic performances,” Lat. Am. J. Solids Struct., vol. 13, no. 13, pp. 2414–2438,
Dec. 2016, doi: 10.1590/1679-78252937.
 M. J.P., “Interval analysis and reliability in robotics,” Int. J. Reliab. Saf., vol. 3, no. 1–3, pp. 104–
130, 2009.
 E. Fiore, H. Giberti, and L. Sbaglia, “Dimensional synthesis of a 5-DOF parallel kinematic
manipulator for a 3d printer,” 16th Int. Conf. Res. Educ. Mechatronics, REM 2015 - Proc., pp. 41–
52, 2016, doi: 10.1109/REM.2015.7380372.
 S. Abeywardena and C. Chen, “Implementation and evaluation of a three-legged six-degrees-offreedom parallel mechanism as an impedance-type haptic device,” IEEE/ASME Trans.
Mechatronics, vol. 22, no. 3, pp. 1412–1422, 2017, doi: 10.1109/TMECH.2017.2682930.
 P. Grosch, R. Di Gregorio, J. Lopez, and F. Thomas, “Motion Planning for a Novel Reconﬁgurable
Parallel Manipulatorwith Lockable Revolute Joints,” IEEE Int. Conf. Robot. Autom., pp. 4697–
4702, 2010, doi: 10.1109/ROBOT.2010.5509305.
 K. Miller, “Optimal design and modeling of spatial parallel manipulators,” Int. J. Rob. Res., vol. 23,
no. 2, pp. 127–140, 2004, doi: 10.1177/0278364904041322.
 S. Pedrammehr, M. R. C. Qazani, H. Asadi, M. M. Ettefagh, and S. Nahavandi, “Model-based
control of axisymmetric hexarot parallel manipulators,” Results Control Optim., vol. 7, Feb. 2023,
doi: 10.1016/J.RICO.2022.100135.
 A. Valencia, M. Mauledoux, and C. Castañeda, “Design of Dynamic Controllers for Continuous
Paths on Parallel Platforms (Slide Modes and PD+),” MATEC Web Conf., vol. 306, no. 20 20, p.
03005, 2020, doi: 10.1051/matecconf/202030603005.
 V. Prada-Jimenez, P. A. Nino-Suarez, E. A. Portilla-Flores, and M. F. Mauledoux-Monroy, “Tuning
a PD+ controller by means of dynamic optimization in a mobile manipulator with coupled
dynamics,” IEEE Access, vol. 7, pp. 124712–124726, 2019, doi: 10.1109/ACCESS.2019.2936309.
 D. . Nunez, M. Mauledoux, O. Aviles, J. Guacheta, and S. Gonzalez, “Optimal Design of Kinematics
Parallel Manipulator Considering Workspace and Control,” Int. J. Mech. Eng. Robot. Res., vol. 11,
no. 4, 2022.
 H. Q. Zhang, H. R. Fang, B. S. Jiang, and S. G. Wang, “Dynamic Performance Evaluation of a
Redundantly Actuated and Over-constrained Parallel Manipulator,” Int. J. Autom. Comput. 2018
163, vol. 16, no. 3, pp. 274–285, Oct. 2018, doi: 10.1007/S11633-018-1147-6.
 J. Wu, Y. Gao, B. Zhang, and L. Wang, “Workspace and dynamic performance evaluation of the
parallel manipulators in a spray-painting equipment,” Robot. Comput. Integr. Manuf., vol. 44, pp.
199–207, 2017, doi: 10.1016/j.rcim.2016.09.002.
 Y. Zhao, Z. Zhang, and G. Cheng, “Inverse rigid-body dynamic analysis for a 3UPS-PRU parallel
robot,” Adv. Mech. Eng., vol. 9, no. 2, Feb. 2017, doi: 10.1177/1687814017693194.
 C. Li, N. Wang, K. Chen, and X. Zhang, “Prescribed flexible orientation workspace and
performance comparison of non-redundant 3-DOF planar parallel mechanisms,” Mech. Mach.
Theory, vol. 168, p. 104602, 2022, doi: 10.1016/j.mechmachtheory.2021.104602.
 G. Yu, J. Wu, L. Wang, and Y. Gao, “Optimal Design of the Three-Degree-of-Freedom Parallel
Manipulator in a Spray-Painting Equipment,” Robotica, vol. 38, no. 6, pp. 1064–1081, Jun. 2020,
doi: 10.1017/S0263574719001255.
 G. Huang, S. Guo, D. Zhang, H. Qu, and H. Tang, “Kinematic analysis and multi-objective
optimization of a new reconfigurable parallel mechanism with high stiffness,” Robotica, vol. 36, no.
2, pp. 187–203, 2018, doi: 10.1017/S0263574717000236.
 C. Li, H. Wu, and H. Eskelinen, “Design and Multi-Objective Optimization of a Dexterous Mobile
Parallel Mechanism for Fusion Reactor Vacuum Vessel Assembly,” IEEE Access, vol. 9, pp.
153796–153810, 2021, doi: 10.1109/ACCESS.2021.3127947.
 B. Shi and H. Wu, “Designation and Multiobjective Optimization of a New Six-DOF Haptic Device
Based on Genetic Algorithm,” Wirel. Commun. Mob. Comput., vol. 2021, 2021, doi:
10.1155/2021/5551585.
 Q. Zou, D. Zhang, X. Luo, G. Huang, L. Li, and H. Zhang, “Enumeration and optimum design of a
class of translational parallel mechanisms with prismatic and parallelogram joints,” Mech. Mach.
Theory, vol. 150, p. 103846, Aug. 2020, doi: 10.1016/J.MECHMACHTHEORY.2020.103846.
 T. Sun and B. Lian, “Stiffness and mass optimization of parallel kinematic machine,” Mech. Mach.
Theory, vol. 120, pp. 73–88, 2018, doi: 10.1016/j.mechmachtheory.2017.09.014.
 J. Enferadi and R. Nikrooz, “The Performance Indices Optimization of a Symmetrical Fully
Spherical Parallel Mechanism for Dimensional Synthesis,” J. Intell. Robot. Syst. Theory Appl., vol.
90, no. 3–4, pp. 305–321, 2018, doi: 10.1007/s10846-017-0675-6.
 T. L. Saaty, “Decision making with the analytic hierarchy process,” Int. J. Serv. Sci., vol. 1, no. 1,
p. 83, 2008, doi: 10.1504/IJSSCI.2008.017590.
 G. Improta, M. A. Russo, M. Triassi, G. Converso, T. Murino, and L. C. Santillo, “Use of the AHP
methodology in system dynamics: Modelling and simulation for health technology assessments to
determine the correct prosthesis choice for hernia diseases,” Math. Biosci., vol. 299, no. June 2017,
pp. 19–27, 2018, doi: 10.1016/j.mbs.2018.03.004.
 A. V. Nguyen, B. C. Bouzgarrou, K. Charlet, and A. Béakou, “Static and dynamic characterization
of the 6-Dofs parallel robot 3CRS,” Mech. Mach. theory, vol. 93, pp. 65–82, 2015.
 F. Pierrot, “A new design of a 6-DOF parallel robot,” J. Robot. Mechatronics, vol. 2, no. 4, pp. 308–
315, 1990.
 A. Şumnu, İ. H. Güzelbey, M. V Çakir, A. Sumnu, I. H. Guzelbey, and M. V. Cakir, “Simulation
and PID control of a Stewart platform with linear motor,” J. Mech. Sci. Technol., vol. 31, no. 1, pp.
345–356, 2017, doi: 10.1007/s12206-016-1238-7.
 R. G. Budynas, R. G. Budynas, and J. K. Nisbett, Shigley’s Mechanical Engineering Design.
McGraw-Hill Education, 2014.
 A. J. Valencia, M. Mauledoux, and D. A. Nunez, “Inverse and Direct Kinematics of Hexa Parallel
Robot of Six Degrees of Freedom,” Int. J. Mech. Eng. Robot. Res., vol. 8, no. 5, 2019, doi:
10.18178/ijmerr.8.5.748-752.
 Y. Zhao and F. Gao, “Inverse dynamics of the 6-dof out-parallel manipulator by means of the
principle of virtual work,” Robotica, vol. 27, no. 2, pp. 259–268, Mar. 2009, doi:
10.1017/S0263574708004657.
 J. Wu, X. Chen, and L. Wang, “Design and Dynamics of a Novel Solar Tracker with Parallel
Mechanism,” IEEE/ASME Trans. Mechatronics, vol. 21, no. 1, pp. 88–97, Feb. 2016, doi:
10.1109/TMECH.2015.2446994.
 J. J. Craig, Introduction to robotics: mechanics and control, vol. 3. Pearson/Prentice Hall Upper
Saddle River, NJ, USA:, 2005.
 R. Silva-Ortigoza, H. Sira-Ramírez, and V. M. Hernández-Guzmán, “Control of the DC/DC boost
converter using sliding modes and differential flatness: Experimental results,” RIAI - Rev. Iberoam.
Autom. e Inform. Ind., vol. 5, no. 4, pp. 77–82, 2008, doi: 10.1016/s1697-7912(08)70180-8.
 R. Kumar, S. C. Kaushik, R. Kumar, and R. Hans, “Multi-objective thermodynamic optimization of
an irreversible regenerative Brayton cycle using evolutionary algorithm and decision making,” Ain
Shams Eng. J., vol. 7, no. 2, pp. 741–753, 2016, doi: 10.1016/j.asej.2015.06.007.
Veldhuizen,
“Emoobook,”
 .
 G. G. Yen and Z. He, “Performance metric ensemble for multiobjective evolutionary algorithms,”
10.1109/TEVC.2013.2240687.
 G.-A. Vargas-Hákim, E. Mezura-Montes, and E. Galván, “Evolutionary Multi-Objective Energy
Production Optimization: An Empirical Comparison,” Math. Comput. Appl., vol. 25, no. 2, p. 32,
2020, doi: 10.3390/mca25020032.
 A. K. Qin, V. L. Huang, and P. N. Suganthan, “Differential evolution algorithm with strategy
adaptation for global numerical optimization,” IEEE Trans. Evol. Comput., vol. 13, no. 2, pp. 398–
417, 2009, doi: 10.1109/TEVC.2008.927706.
 D. Nunez, M. Mauricio, and A. Oscar, “Optimal Design of the HEXA RUS Mechanism,” 2022.
Lista de los productos de nuevo conocimiento
Artículos en revistas indexadas.
A1. Nunez, D. A., Gonzalez, S., Mauledoux, M., & Aviles, O, “Design of Six Degrees of Freedom Parallel
Manipulator by Means of Multi-objective Optimization”, Mechanics Based Design of Structures and
Machines. Sometido. 2023.
A2. Gonzalez, S., Guacheta, J. C., Nunez, D. A., Mauledoux, M., & Aviles, O. F, “Multi-objective
optimization of dynamic controllers on parallel platforms”. Journal of Engineering Research, 11(1),
100025, 2023, doi: 10.1016/j.jer.2023.100025.
A3. Alba, J. C. G., Garzon, S. G., Nunez, D. A., Mauledoux, M., & Aviles, O. F, “3D printing part
orientation optimization: discrete approximation of support volume”, International Journal of
Electrical & Computer Engineering, 12(6), 2022, doi: 10.11591/ijece.v12i6.pp5958-5966.
A4. Alba, J. C. G., Nunez, D. A., Mauledoux, M., & Aviles, O. F, “Deposition Toolpath Pattern
Comparison: Contour-Parallel and Hilbert Curve Application”, International Journal of Mechanical
Engineering and Robotics Research, 11(7), 2022, doi: 10.18178/ijmerr.11.7.542-548.
A5. Nunez, D. A., Mauledoux, M., Aviles, O., Guacheta, J., & Gonzalez, S, “Optimal Design of Kinematics
Parallel Manipulator Considering Workspace and Control Effort”, International Journal of Mechanical
Engineering and Robotics Research, 11(4), 2022, doi: 10.18178/ijmerr.11.4.234-240.
A6. Nunez, D. A., Gonzalez, S., Guacheta, J., Mauledoux, M., & Aviles, O, “Kinematics Parallel
Mechanisms Design Particularities Focused on Additive Manufacturing”, Journal of Engineering
Science & Technology Review, 14(4), 2021, doi: 10.25103/jestr.144.25.
A7. Valencia A, Mauledoux, M., & Nunez, D. A, “Inverse and Direct Kinematics of Hexa Parallel Robot
of Six Degrees of Freedom”, International Journal of Mechanical Engineering and Robotics
Research, 8(5), 748-752, 2019, doi: 10.18178/ijmerr.8.5.748-752.
Congresos internacionales
Nunez, D. A., Mauledoux, M., Aviles, O., Guacheta, J., & Gonzalez, S. , Optimal Design of
Kinematics Parallel Manipulator Considering Workspace and Control Effort. 6th International
Conference on Mechanical Engineering and Robotics Research , 11th to 13th December
2021, Krakow, Poland
Descripción de los motores usados
Código de la modelación dinámica
La función matrices MCG(x) retorna las matrices descritas en (4-105) - (4-107).
function [M2,C2,G2,Parar] = matricesMCG(x)
AB=zeros(6,3); vc=zeros(6,3); BC=zeros(6,3);
FrM=zeros(6,6); FrC=zeros(6,1); QeG=zeros(6,1);
FbM=zeros(6,6); FbC=zeros(6,1); Fij_r_A=zeros(6,3);
c=zeros(6,3); s=zeros(6,3); q=zeros(6,3);
fcurij_r_C=zeros(6,3); fk_R_N=zeros(3,3,6);
F_R_N=zeros(3,3,6); a=zeros(6,3);
Pk_R_h=zeros(3,3,6); F_R_h=zeros(3,3,6);
ba=zeros(3,6); pl=zeros(3,6);
alarm=0; Zeta=0; yk1=0;
yk2=0; errorYK=0; Jp=zeros(6,6);
JpV2=zeros(6,6); Parar=0;
x=[250/1000, 300/1000, 0/1000, 0/1000, -349.5/1000, 0.001, 0.001, 0.001,
0.0001,0.0001,0.0001,0,0,0];
L_brazo=x(1); L_rod=x(2);
px= x(3); pye= x(4); pz= x(5); teta=x(6); fii=x(7);
psii=x(8);
px_dot=x(9); pye_dot=x(10); pz_dot=x(11); fii_dot=x(12);
teta_dot=x(13); psii_dot= x(14);
px_dotdot=x(15); pye_dotdot=x(16); pz_dotdot=x(17); fii_dotdot= x(18);
teta_dotdot=x(19); psii_dotdot=x(20);
densidad= 2700;
Area= (16/1000)^2*pi/4; %m2
VolumenB= Area*L_brazo;
Area= (12/1000)^2*pi/4; %m2
VolumenR= Area*L_rod;
m_brazo= densidad*VolumenB; % kilogramos
m_rod = densidad*VolumenR; % kilogramos del rod
p=[px,pye,pz]; % posición deseada de la plataforma movil
X_dot= [px_dot pye_dot pz_dot fii_dot teta_dot psii_dot];
vp= X_dot(1:3); % velocidad deseada de la plataforma movil
%Algoritmo Principal
% Base Vertices
H = 230/1000;
D=89/1000;
h = 82.6/1000;
d=60/1000;
% masa de la plataforma movil
mp=m_p*eye(3);
% masa del brazo
M_brazo=m_brazo*eye(3);
% masa del rod
M_rod=m_rod*eye(3);
% Base Vertices
ba(:,1)=[H*cos(asin(D/H)), -D, 0];
ba(:,2)=[H*cos(asin(D/H)), D, 0];
ba(:,3)=(rotz(120)*ba(:,1));
ba(:,4)=(rotz(120)*ba(:,2));
ba(:,5)=(rotz(120)*ba(:,3));
ba(:,6)=(rotz(120)*ba(:,4));
% Plataforma Vertices
pl(:,1)=rotz(0)*[h*cos(asin(d/h)); -d; 0];
pl(:,2)=rotz(0)*[h*cos(asin(d/h)); d; 0];
pl(:,3)=(rotz(120)*pl(:,1));
pl(:,4)=(rotz(120)*pl(:,2));
pl(:,5)=(rotz(120)*pl(:,3));
pl(:,6)=(rotz(120)*pl(:,4));
F_R_fcur= roty(fii)*rotx(teta)*rotz(psii);
%Velocidad angular de la plataforma movil (wp)
wp=[teta_dot;fii_dot;psii_dot];
% Rotacion de la referencia Fij y fcurij (ij=12,34,56) con respecto a F. La rotación
es de alfa_ij
alfa_ij=[0, 0, 2*pi/3, 2*pi/3, 4*pi/3, 4*pi/3];
F_R_Fij=zeros(3,3,6);
F_R_Fij(:,:,i)=rotz(rad2deg(alfa_ij(i)));
fcur_R_fcurij= F_R_Fij;
% Traslación de la referencia Fij y fcurij a los extremos de las plataformas Ak y Ck
(k=1,...,6)
Fij_r_A(1,:) = ba(:,1);
Fij_r_A(2,:) = ba(:,2);
Fij_r_A(3,:) = Fij_r_A(1,:);
Fij_r_A(4,:) = Fij_r_A(2,:);
Fij_r_A(5,:) = Fij_r_A(1,:);
Fij_r_A(6,:) = Fij_r_A(2,:);
fcurij_r_C(1,:)=pl(:,1);
fcurij_r_C(2,:)=pl(:,2);
fcurij_r_C(3,:)=fcurij_r_C(1,:);
fcurij_r_C(4,:)=fcurij_r_C(2,:);
fcurij_r_C(5,:)=fcurij_r_C(1,:);
fcurij_r_C(6,:)=fcurij_r_C(2,:);
% Rotacion de la referencia Fij teniendo en cuenta que la rotacion se haga sobre el
eje Z y que el eje Y sea perpendicular a la plataforma base
Fij_R_fk=rotz(180)*rotx(90);
% Rotacion de la referencia fk para que el eje X este alineado con el brazo y el eje
Z se mantenga alineado con el eje de rotación una vez se haya definido el angulo de
rotacion del brazo (zeta), donde el valor de z debe ser negativo.
%Zeta = CinematicaInversa(L_brazo, L_rod, p, ba, pl, fii, teta, psii)'-pi
% retorna Zeta en grados
[Zeta,alarm]=CinematicaInversa3(L_brazo, L_rod,[px,pye,pz,teta,fii,psii]);
Zeta=deg2rad(-Zeta);
z1= Zeta(1); z2= Zeta(2); z3= Zeta(3);
z4= Zeta(4); z5= Zeta(5); z6= Zeta(6);
fk_R_N(:,:,i)=rotz(rad2deg(Zeta(i)));
F_R_N(:,:,i)=F_R_Fij(:,:,i)*Fij_R_fk*fk_R_N(:,:,i);
% Determinación del vector unitario del rod qk
coord_brazo=[L_brazo;0;0];
a(i,:)=F_R_Fij(:,:,i)*Fij_r_A(i,:)';
% Vector del centro de la plataforma movil a la articulación esférica
c(i,:) = double(F_R_fcur*fcur_R_fcurij(:,:,i)*fcurij_r_C(i,:)');
% Vector unitario de A a B
s(i,:) = F_R_N(:,:,i) * (coord_brazo/norm(coord_brazo));
% Rotacion de Nk a Pk, es necesario rotar Nk 90°(pi/2)en el eje X
Nk_R_Pk= rotx(90);
% Vector unitario del punto B al punto C
q(i,:)=(p + c(i,:) - a(i,:) - (L_brazo*s(i,:)))/L_rod;
% Rotacion de la referencia Pk para que el eje X del rod este alineado con la
barra y el eje Z este alineado con la rotacion
[yk1,yk2,errorYK]=YK(alfa_ij(i), Zeta(i), q(i,1), q(i,2), q(i,3));
Pk_R_h(:,:,i)=rotx(90)*roty(rad2deg(yk1))*rotz(rad2deg(yk2));
% Las matrices de rotacion necesarias para determinar la referencia Nk y hk
respecto a la referencia estatica inicial fija F son
F_R_h(:,:,i)=F_R_N(:,:,i)*Nk_R_Pk*Pk_R_h(:,:,i);
% Vector de AB con respecto al punto F
AB(i,:) = F_R_Fij(:,:,i)*Fij_R_fk * [L_brazo*cos(Zeta(i)); L_brazo*sin(Zeta(i));
% Vector que inicia en Bk y termina en Ck de cada k-ésimo rod
BC(i,:)= c(i,:) + [px,pye,pz] - (AB(i,:) + a(i,:));
%% Evaluacion de Jacobiana y Jacobiana de la aceleración
% Velocidad la plataforma movil
[Jp,JpV2,AA]=JP(L_brazo, px, pye, pz, fii, teta, psii, z1, z2, z3, z4, z5, z6);
Zetah_dot= JpV2*X_dot';
Jp1=JP1(L_brazo, px, pye, pz, fii, teta, psii, z1, z2, z3, z4, z5, z6);
Jp2=JP2(L_brazo, px, pye, pz, fii, teta, psii, z1, z2, z3, z4, z5, z6,...
fii_dot, teta_dot, psii_dot, px_dot, pye_dot, pz_dot,Zetah_dot(1),...
Zetah_dot(2),Zetah_dot(3),Zetah_dot(4),Zetah_dot(5),Zetah_dot(6));
% Velocidad angular en i de L_brazo
fk_w_k= [zeros(6,2), Zetah_dot];
% Velocidad lineal del punto Ck
vc(i,:)= vp + cross(wp,c(i,:));
[Jrbrazo,Jwbrazo,Jwrod,Jrrod]= jacobianasLinks(JpV2,AB,BC,c);
%% TRABAJO VIRTUAL
% QE MATRIX
% Principio de D'Alembert
% Plataforma movil
Ip_plataforma_movil=[4721.54,0,0;0,5953.13,0;0,0,10606.68]*(1/(100^2))*(1/1000);
% Los valores los momentos de inercia (Ip) de la plataforma movil de Solidworks
gr*cm^2->Kg/m^2
Ip=F_R_fcur*Ip_plataforma_movil*F_R_fcur';
QeG= QeG - Jrbrazo(3,:,i)'*m_brazo - Jrrod(3,:,i)'*m_rod;
zeta_dot= F_R_Fij(:,:,i)*Fij_R_fk *[0;0;Zetah_dot(i)']; % REVISAR
wr= (-1/(norm(BC(i,:))^2) * cross(vp + cross(wp,c(i,:)) -
cross(zeta_dot,AB(i,:)),BC(i,:)));
% Tensor de Inercia de cada brazo con referencia al marco F
Ib=fk_R_N(:,:,i)*((m_brazo*L_brazo^2)/3*[0,0,0;0,1,0;0,0,1])*fk_R_N(:,:,i)';
M1= Jrbrazo(:,:,i)'*M_brazo;
m101=M1(1,1); m102=M1(1,2);m103=M1(1,3);
m104=M1(2,1); m105=M1(2,2);m106=M1(2,3);
m107=M1(3,1); m108=M1(3,2);m109=M1(3,3);
m110=M1(4,1); m111=M1(4,2);m112=M1(4,3);
m113=M1(5,1); m114=M1(5,2);m115=M1(5,3);
m116=M1(6,1); m117=M1(6,2);m118=M1(6,3);
ab1=AB(i,1);ab2=AB(i,2);ab3=AB(i,3);
% las matrices son generadas en C:\Users\danvm\Documents\hexa2\prueba.mlx
AA =[[ (ab2*m103)/2 - (ab3*m102)/2, (ab3*m101)/2 - (ab1*m103)/2, (ab1*m102)/2 –
ab2*m101)/2];...
[ (ab2*m106)/2 - (ab3*m105)/2, (ab3*m104)/2 - (ab1*m106)/2, (ab1*m105)/2 –
(ab2*m104)/2];...
[ (ab2*m109)/2 - (ab3*m108)/2, (ab3*m107)/2 - (ab1*m109)/2, (ab1*m108)/2 –
(ab2*m107)/2];...
[ (ab2*m112)/2 - (ab3*m111)/2, (ab3*m110)/2 - (ab1*m112)/2, (ab1*m111)/2 –
(ab2*m110)/2];...
[ (ab2*m115)/2 - (ab3*m114)/2, (ab3*m113)/2 - (ab1*m115)/2, (ab1*m114)/2 –
(ab2*m113)/2];...
[ (ab2*m118)/2 - (ab3*m117)/2, (ab3*m116)/2 - (ab1*m118)/2, (ab1*m117)/2 –
(ab2*m116)/2]];
M2=Jwbrazo(:,:,i)'*Ib;
CC=BB*F_R_Fij(:,:,i)*Fij_R_fk;
FbM=FbM+CC(:,3)*Jp1(i,:);
FbC=FbC+CC(:,3)*Jp2(i,1) + Jwbrazo(:,:,i)'* cross(zeta_dot,Ib*zeta_dot);
% ROD O SEGUNDO ESLABÓN
Ir = F_R_h(:,:,i)*((m_rod*L_rod^2)/3*[0,0,0;0,1,0;0,0,1])*F_R_h(:,:,i)';
M3=Jrrod(:,:,i)'*M_rod;
m301=M3(1,1); m302=M3(1,2);m303=M3(1,3);
m304=M3(2,1); m305=M3(2,2);m306=M3(2,3);
m307=M3(3,1); m308=M3(3,2);m309=M3(3,3);
m310=M3(4,1); m311=M3(4,2);m312=M3(4,3);
m313=M3(5,1); m314=M3(5,2);m315=M3(5,3);
m316=M3(6,1); m317=M3(6,2);m318=M3(6,3);
bc1=BC(i,1);bc2=BC(i,2);bc3=BC(i,3);
[ (bc2*m303)/2 - (bc3*m302)/2, (bc3*m301)/2 - (bc1*m303)/2, (bc1*m302)/2 –
(bc2*m301)/2];...
[ (bc2*m306)/2 - (bc3*m305)/2, (bc3*m304)/2 - (bc1*m306)/2, (bc1*m305)/2 -
(bc2*m304)/2];...
[ (bc2*m309)/2 - (bc3*m308)/2, (bc3*m307)/2 - (bc1*m309)/2, (bc1*m308)/2 –
(bc2*m307)/2];...
[ (bc2*m312)/2 - (bc3*m311)/2, (bc3*m310)/2 - (bc1*m312)/2, (bc1*m311)/2 –
(bc2*m310)/2];...
[ (bc2*m315)/2 - (bc3*m314)/2, (bc3*m313)/2 - (bc1*m315)/2, (bc1*m314)/2 –
(bc2*m313)/2];...
[ (bc2*m318)/2 - (bc3*m317)/2, (bc3*m316)/2 - (bc1*m318)/2, (bc1*m317)/2 –
(bc2*m316)/2]];
M4=Jwrod(:,:,i)'*Ir;
n= 1/(norm(BC(i,:))^2);
c1=c(i,1);c2=c(i,2);c3=c(i,3);
[0 , -bc3*n , bc2*n, n*(bc2*c2 + bc3*c3), -bc2*c1*n, -
bc3*c1*n];...
[bc3*n , 0, -bc1*n, -bc1*c2*n , n*(bc1*c1 + bc3*c3), -
bc3*c2*n];...
[-bc2*n, bc1*n , 0, -bc1*c3*n , -bc2*c3*n, n*(bc1*c1 +
bc2*c2)]];
FF=-1/(norm(BC(i,:))^2)*cross(cross(wp,cross(wp,c(i,:)))-
cross(zeta_dot,cross(zeta_dot,AB(i,:)))-cross(wr,cross(wr,BC(i,:))),BC(i,:));
[ -n*(ab2*bc2 + ab3*bc3), ab1*bc2*n, ab1*bc3*n];...
[ ab2*bc1*n, -n*(ab1*bc1 + ab3*bc3), ab2*bc3*n];...
[ ab3*bc1*n, ab3*bc2*n, -n*(ab1*bc1 + ab2*bc2)]];
HH=EE*GG*(F_R_Fij(:,:,i)*Fij_R_fk);
FrM= FrM+ EE*KK + HH(:,3)*Jp1(i,:);
FrC= FrC+ HH(:,3)*Jp2(i,1) + EE*FF' + Jwrod(:,:,i)'*cross(wr,Ir*wr')';
QeG=QeG + m_p*[0;0;1;0;0;0];
FpM= [mp,zeros(3);zeros(3),Ip];
FpC=[zeros(3,1);cross(wp,Ip*wp)];
% CREACIÓN DE MATRICES
M2=double( -JpV2'\(FpM+FbM+FrM));
C2= double(-JpV2'\(FpC+FbC+FrC));
G2= double(JpV2'\QeG);
function [Zetah2,alarm]=CinematicaInversa3(lb,lr,POS)
% retorna Zetah2 en grados
% Base Vertices
% Longitudes Poligono
H = 230/1000; D=89/1000;
% Longitudes Plataforma móvil
h = 82.6/1000; d=60/1000;
alarma=zeros(6,1); alarm=0;
ba=zeros(3,6);
pl=zeros(3,6);
Zetah2=zeros(6,1);
ba(:,1)=[H*cos(asin(D/H)), -D, 0];
ba(:,2)=[H*cos(asin(D/H)), D, 0];
ba(:,3)=(rotz(120)*ba(:,1));
ba(:,4)=(rotz(120)*ba(:,2));
ba(:,5)=(rotz(120)*ba(:,3));
ba(:,6)=(rotz(120)*ba(:,4));
% Plataforma Vertices
pl(:,1)=[h*cos(asin(d/h)); -d; 0];
pl(:,2)=[h*cos(asin(d/h)); d; 0];
pl(:,3)=(rotz(120)*pl(:,1));
pl(:,4)=(rotz(120)*pl(:,2));
pl(:,5)=(rotz(120)*pl(:,3));
pl(:,6)=(rotz(120)*pl(:,4));
alfa_ij=[0, 0, 2*pi/3, 2*pi/3, 4*pi/3, 4*pi/3];
Fij_r_A=zeros(6,3);
Fij_r_A(1,:) = ba(:,1);
Fij_r_A(2,:) = ba(:,2);
Fij_r_A(3,:) = Fij_r_A(1,:);
Fij_r_A(4,:) = Fij_r_A(2,:);
Fij_r_A(5,:) = Fij_r_A(1,:);
Fij_r_A(6,:) = Fij_r_A(2,:);
fcurij_r_C=zeros(6,3);
fcurij_r_C(1,:)=pl(:,1);
fcurij_r_C(2,:)=pl(:,2);
fcurij_r_C(3,:)=fcurij_r_C(1,:);
fcurij_r_C(4,:)=fcurij_r_C(2,:);
fcurij_r_C(5,:)=fcurij_r_C(1,:);
fcurij_r_C(6,:)=fcurij_r_C(2,:);
alfa_ijs=alfa_ij(i); FA=Fij_r_A(i,:);
FC=fcurij_r_C(i,:);
[Zetah,alarma(i)]=CinematicaInversaII(lb, lr,POS,alfa_ijs,FA,FC);
Zetah2(i,1) = (180-rad2deg(Zetah));
if sum(alarma)>0
function [Zetah,alarma] = CinematicaInversaII(lb, lr,POS,alfa_ijs,FA,FC)
px=POS(1); pye=POS(2); pz=POS(3);
tetaX=deg2rad(POS(4)); fiiY=deg2rad(POS(5)); psiiZ=deg2rad(POS(6));
% Vertices plataforma superior A
FijrA1=FA(1); FijrA2=FA(2); FijrA3=FA(3);
% Vertices plataforma inferior C
fcurijrC1= FC(1); fcurijrC2= FC(2); fcurijrC3= FC(3);
% Analisis simbolico para la factorizacion
syms lb lr px pye pz real
syms betah gammah alfah psiiZ tetaX fiiY real
syms alfa_ijs z FijrA1 FijrA2 FijrA3 fcurijrC1 fcurijrC2 fcurijrC3 real % escalar
p=[px, pye, pz];
Fij_R_fk=rotz(180)*rotx(90);
% Matrices de rotación
Rxa = [1, 0, 0;
0, cos(alfah), -sin(alfah);
0, sin(alfah), cos(alfah)];
Ryb = [ cos(betah) 0 sin(betah);
-sin(betah) 0 cos(betah)];
Rzg = [cos(gammah) -sin(gammah) 0;
sin(gammah) cos(gammah) 0;
F_R_fcur= subs(Ryb,betah,fiiY)*...
subs(Rxa,alfah,tetaX)*...
subs(Rzg,gammah,psiiZ);
F_R_Fij = subs(Rzg,gammah,alfa_ijs);
AB = F_R_Fij*Fij_R_fk*[lb*cos(z); lb*sin(z); 0];
a =F_R_Fij*[FijrA1,FijrA2,FijrA3]';
c = F_R_fcur*F_R_Fij*[fcurijrC1, fcurijrC2,fcurijrC3]';
eq = (Pi(1)-Pa(1))^2 + (Pi(2)-Pa(2))^2 + (Pi(3)-Pa(3))^2 - lr^2;
[A,B]=coeffs(eq,[sin(z),cos(z)]);
% Producto de la factorización generados simbolicamente
A=[lb^2, -2*lb*(pz - FijrA3 - fcurijrC1*(cos(alfa_ijs)*(cos(psiiZ)*sin(fiiY) -
cos(fiiY)*sin(psiiZ)*sin(tetaX)) - sin(alfa_ijs)*(sin(fiiY)*sin(psiiZ) +
cos(fiiY)*cos(psiiZ)*sin(tetaX))) + fcurijrC2*(cos(alfa_ijs)*(sin(fiiY)*sin(psiiZ) +
cos(fiiY)*cos(psiiZ)*sin(tetaX)) + sin(alfa_ijs)*(cos(psiiZ)*sin(fiiY) -
cos(fiiY)*sin(psiiZ)*sin(tetaX))) + fcurijrC3*cos(fiiY)*cos(tetaX)), lb^2,
2*lb*cos(alfa_ijs)*(px + fcurijrC1*(cos(alfa_ijs)*(cos(fiiY)*cos(psiiZ) +
sin(fiiY)*sin(psiiZ)*sin(tetaX)) - sin(alfa_ijs)*(cos(fiiY)*sin(psiiZ) -
cos(psiiZ)*sin(fiiY)*sin(tetaX))) - fcurijrC2*(cos(alfa_ijs)*(cos(fiiY)*sin(psiiZ) -
cos(psiiZ)*sin(fiiY)*sin(tetaX)) + sin(alfa_ijs)*(cos(fiiY)*cos(psiiZ) +
sin(fiiY)*sin(psiiZ)*sin(tetaX))) - FijrA1*cos(alfa_ijs) + FijrA2*sin(alfa_ijs) +
fcurijrC3*cos(tetaX)*sin(fiiY)) + 2*lb*sin(alfa_ijs)*(pye - FijrA2*cos(alfa_ijs) -
FijrA1*sin(alfa_ijs) - fcurijrC3*sin(tetaX) +
fcurijrC1*(cos(alfa_ijs)*cos(tetaX)*sin(psiiZ) + cos(psiiZ)*sin(alfa_ijs)*cos(tetaX))
+ fcurijrC2*(cos(alfa_ijs)*cos(psiiZ)*cos(tetaX) -
sin(alfa_ijs)*cos(tetaX)*sin(psiiZ))), (px +
fcurijrC1*(cos(alfa_ijs)*(cos(fiiY)*cos(psiiZ) + sin(fiiY)*sin(psiiZ)*sin(tetaX)) -
sin(alfa_ijs)*(cos(fiiY)*sin(psiiZ) - cos(psiiZ)*sin(fiiY)*sin(tetaX))) -
fcurijrC2*(cos(alfa_ijs)*(cos(fiiY)*sin(psiiZ) - cos(psiiZ)*sin(fiiY)*sin(tetaX)) +
sin(alfa_ijs)*(cos(fiiY)*cos(psiiZ) + sin(fiiY)*sin(psiiZ)*sin(tetaX))) -
FijrA1*cos(alfa_ijs) + FijrA2*sin(alfa_ijs) + fcurijrC3*cos(tetaX)*sin(fiiY))^2 +
(pye - FijrA2*cos(alfa_ijs) - FijrA1*sin(alfa_ijs) - fcurijrC3*sin(tetaX) +
fcurijrC1*(cos(alfa_ijs)*cos(tetaX)*sin(psiiZ) + cos(psiiZ)*sin(alfa_ijs)*cos(tetaX))
+ fcurijrC2*(cos(alfa_ijs)*cos(psiiZ)*cos(tetaX) -
sin(alfa_ijs)*cos(tetaX)*sin(psiiZ)))^2 + (pz - FijrA3 -
fcurijrC1*(cos(alfa_ijs)*(cos(psiiZ)*sin(fiiY) - cos(fiiY)*sin(psiiZ)*sin(tetaX)) -
sin(alfa_ijs)*(sin(fiiY)*sin(psiiZ) + cos(fiiY)*cos(psiiZ)*sin(tetaX))) +
fcurijrC2*(cos(alfa_ijs)*(sin(fiiY)*sin(psiiZ) + cos(fiiY)*cos(psiiZ)*sin(tetaX)) +
sin(alfa_ijs)*(cos(psiiZ)*sin(fiiY) - cos(fiiY)*sin(psiiZ)*sin(tetaX))) +
fcurijrC3*cos(fiiY)*cos(tetaX))^2 - lr^2];
aa =(A(1)+A(5));
num= (aa*cc^2 - bb*sqrt(-(cc^2)*(aa^2-bb^2-cc^2)))/ (cc*(bb^2+cc^2));
den= (aa*bb + sqrt(-(cc^2)*(aa^2-bb^2-cc^2))) / (bb^2+cc^2);
Zetah=atan(num/den);
% enviar una alarma si el angulo es menor a 90 grados
if num/den<0
function [Jp,JpV2,AA]=JP(brazo, x, y, z, ang1, ang2, ang3, z1, z2, z3, z4, z5, z6)
% las expresiones de Jp son generadas simbolicamente en CinematicaDerivadaInversa3
[[-(x - 0.056769*sin(ang1)*sin(ang3) + brazo*cos(z1) + 0.06*cos(ang3)*sin(ang1) +
0.056769*cos(ang1)*cos(ang2)*cos(ang3) + 0.06*cos(ang1)*cos(ang2)*sin(ang3) -
0.21208)/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2)) - brazo*sin(z1)*(x - 0.056769*sin(ang1)*sin(ang3) +
brazo*cos(z1) + 0.06*cos(ang3)*sin(ang1) + 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) - 0.21208)), -(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) +
0.06*cos(ang2)*sin(ang1)*sin(ang3) +
0.089)/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2)) - brazo*sin(z1)*(x - 0.056769*sin(ang1)*sin(ang3) +
brazo*cos(z1) + 0.06*cos(ang3)*sin(ang1) + 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) - 0.21208)), (1.0*(0.06*sin(ang2)*sin(ang3) -
1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2)) - brazo*sin(z1)*(x -
0.056769*sin(ang1)*sin(ang3) + brazo*cos(z1) + 0.06*cos(ang3)*sin(ang1) +
0.056769*cos(ang1)*cos(ang2)*cos(ang3) + 0.06*cos(ang1)*cos(ang2)*sin(ang3) -
0.21208)), (1.0*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2))*(0.056769*cos(ang1)*sin(ang3) -
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) +
0.06*cos(ang2)*sin(ang1)*sin(ang3)) - (0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2))*(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) +
0.06*cos(ang2)*sin(ang1)*sin(ang3) +
0.089))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2)) - brazo*sin(z1)*(x - 0.056769*sin(ang1)*sin(ang3) +
brazo*cos(z1) + 0.06*cos(ang3)*sin(ang1) + 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) - 0.21208)), -(1.0*(1.0*(0.06*sin(ang2)*sin(ang3)
- 1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2))*(0.06*cos(ang3)*sin(ang1) -
0.056769*sin(ang1)*sin(ang3) + 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3)) - (0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2))*(x - 0.056769*sin(ang1)*sin(ang3) + brazo*cos(z1) +
0.06*cos(ang3)*sin(ang1) + 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) -
0.21208)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2)) - brazo*sin(z1)*(x - 0.056769*sin(ang1)*sin(ang3) +
brazo*cos(z1) + 0.06*cos(ang3)*sin(ang1) + 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) - 0.21208)), (1.0*((0.056769*cos(ang1)*sin(ang3) -
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) +
0.06*cos(ang2)*sin(ang1)*sin(ang3))*(x - 0.056769*sin(ang1)*sin(ang3) + brazo*cos(z1)
+ 0.06*cos(ang3)*sin(ang1) + 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) - 0.21208) - 1.0*(0.06*cos(ang3)*sin(ang1) -
0.056769*sin(ang1)*sin(ang3) + 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3))*(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) +
0.06*cos(ang2)*sin(ang1)*sin(ang3) +
0.089)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2)) - brazo*sin(z1)*(x - 0.056769*sin(ang1)*sin(ang3) +
brazo*cos(z1) + 0.06*cos(ang3)*sin(ang1) + 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) - 0.21208))];
[-(0.056769*sin(ang1)*sin(ang3) - 1.0*x - 1.0*brazo*cos(z2) +
0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) + 0.21208)/(1.0*brazo*cos(z2)*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2)) -
brazo*sin(z2)*(0.056769*sin(ang1)*sin(ang3) - 1.0*x - 1.0*brazo*cos(z2) +
0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) + 0.21208)), (1.0*(y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) -
0.06*cos(ang2)*sin(ang1)*sin(ang3) - 0.089))/(1.0*brazo*cos(z2)*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2)) -
brazo*sin(z2)*(0.056769*sin(ang1)*sin(ang3) - 1.0*x - 1.0*brazo*cos(z2) +
0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) + 0.21208)), (1.0*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2)))/(1.0*brazo*cos(z2)*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2)) -
brazo*sin(z2)*(0.056769*sin(ang1)*sin(ang3) - 1.0*x - 1.0*brazo*cos(z2) +
0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) + 0.21208)), -(1.0*(1.0*(0.06*sin(ang2)*sin(ang3)
- 0.056769*cos(ang3)*sin(ang2))*(y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) -
0.06*cos(ang2)*sin(ang1)*sin(ang3) - 0.089) - (0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) -
0.06*cos(ang2)*sin(ang1)*sin(ang3))*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2)
- 0.056769*cos(ang3)*sin(ang2))))/(1.0*brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2)) -
brazo*sin(z2)*(0.056769*sin(ang1)*sin(ang3) - 1.0*x - 1.0*brazo*cos(z2) +
0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) + 0.21208)), -((0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2))*(0.056769*sin(ang1)*sin(ang3) - 1.0*x -
1.0*brazo*cos(z2) + 0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3)
+ 0.06*cos(ang1)*cos(ang2)*sin(ang3) + 0.21208) - 1.0*(0.056769*sin(ang1)*sin(ang3) +
0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3))*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2)
- 0.056769*cos(ang3)*sin(ang2)))/(1.0*brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2)) -
brazo*sin(z2)*(0.056769*sin(ang1)*sin(ang3) - 1.0*x - 1.0*brazo*cos(z2) +
0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) + 0.21208)), (1.0*(0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) -
0.06*cos(ang2)*sin(ang1)*sin(ang3))*(0.056769*sin(ang1)*sin(ang3) - 1.0*x -
1.0*brazo*cos(z2) + 0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3)
+ 0.06*cos(ang1)*cos(ang2)*sin(ang3) + 0.21208) - (0.056769*sin(ang1)*sin(ang3) +
0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3))*(y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.056769*cos(ang2)*cos(ang3)*sin(ang1) -
0.06*cos(ang2)*sin(ang1)*sin(ang3) - 0.089))/(1.0*brazo*cos(z2)*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2)) -
brazo*sin(z2)*(0.056769*sin(ang1)*sin(ang3) - 1.0*x - 1.0*brazo*cos(z2) +
0.06*cos(ang3)*sin(ang1) - 0.056769*cos(ang1)*cos(ang2)*cos(ang3) +
0.06*cos(ang1)*cos(ang2)*sin(ang3) + 0.21208))];
[-(1.0*(0.023577*sin(ang1)*sin(ang3) - 1.0*x + 0.5*brazo*cos(z3) +
0.079164*cos(ang3)*sin(ang1) - 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) - 0.028965))/(brazo*cos(z3)*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2)) +
0.5*brazo*sin(z3)*(0.023577*sin(ang1)*sin(ang3) - 1.0*x + 0.5*brazo*cos(z3) +
0.079164*cos(ang3)*sin(ang1) - 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) - 0.028965) + 0.86603*brazo*sin(z3)*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) - 0.079164*cos(ang2)*sin(ang1)*sin(ang3) -
0.22817)), (y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) + 0.023577*cos(ang2)*cos(ang3)*sin(ang1) -
0.079164*cos(ang2)*sin(ang1)*sin(ang3) - 0.22817)/(brazo*cos(z3)*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2)) +
0.5*brazo*sin(z3)*(0.023577*sin(ang1)*sin(ang3) - 1.0*x + 0.5*brazo*cos(z3) +
0.079164*cos(ang3)*sin(ang1) - 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) - 0.028965) + 0.86603*brazo*sin(z3)*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) - 0.079164*cos(ang2)*sin(ang1)*sin(ang3) -
0.22817)), (z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2)) +
0.5*brazo*sin(z3)*(0.023577*sin(ang1)*sin(ang3) - 1.0*x + 0.5*brazo*cos(z3) +
0.079164*cos(ang3)*sin(ang1) - 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) - 0.028965) + 0.86603*brazo*sin(z3)*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) - 0.079164*cos(ang2)*sin(ang1)*sin(ang3) -
0.22817)), (1.0*(1.0*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) - 0.079164*cos(ang2)*sin(ang1)*sin(ang3))*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2)) -
(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) - 0.079164*cos(ang2)*sin(ang1)*sin(ang3) -
0.22817)))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2)) + 0.5*brazo*sin(z3)*(0.023577*sin(ang1)*sin(ang3) -
1.0*x + 0.5*brazo*cos(z3) + 0.079164*cos(ang3)*sin(ang1) -
0.023577*cos(ang1)*cos(ang2)*cos(ang3) + 0.079164*cos(ang1)*cos(ang2)*sin(ang3) -
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) - 0.079164*cos(ang2)*sin(ang1)*sin(ang3) -
0.22817)), (1.0*(1.0*(0.023577*sin(ang1)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1) -
0.023577*cos(ang1)*cos(ang2)*cos(ang3) + 0.079164*cos(ang1)*cos(ang2)*sin(ang3))*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2)) -
(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2))*(0.023577*sin(ang1)*sin(ang3) - 1.0*x +
0.5*brazo*cos(z3) + 0.079164*cos(ang3)*sin(ang1) -
0.023577*cos(ang1)*cos(ang2)*cos(ang3) + 0.079164*cos(ang1)*cos(ang2)*sin(ang3) -
0.028965)))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2)) + 0.5*brazo*sin(z3)*(0.023577*sin(ang1)*sin(ang3) -
1.0*x + 0.5*brazo*cos(z3) + 0.079164*cos(ang3)*sin(ang1) -
0.023577*cos(ang1)*cos(ang2)*cos(ang3) + 0.079164*cos(ang1)*cos(ang2)*sin(ang3) -
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) - 0.079164*cos(ang2)*sin(ang1)*sin(ang3) -
0.22817)), ((0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) -
0.079164*cos(ang2)*sin(ang1)*sin(ang3))*(0.023577*sin(ang1)*sin(ang3) - 1.0*x +
0.5*brazo*cos(z3) + 0.079164*cos(ang3)*sin(ang1) -
0.023577*cos(ang1)*cos(ang2)*cos(ang3) + 0.079164*cos(ang1)*cos(ang2)*sin(ang3) -
0.028965) - 1.0*(0.023577*sin(ang1)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1) -
0.023577*cos(ang1)*cos(ang2)*cos(ang3) + 0.079164*cos(ang1)*cos(ang2)*sin(ang3))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) - 0.079164*cos(ang2)*sin(ang1)*sin(ang3) -
0.22817))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2)) + 0.5*brazo*sin(z3)*(0.023577*sin(ang1)*sin(ang3) -
1.0*x + 0.5*brazo*cos(z3) + 0.079164*cos(ang3)*sin(ang1) -
0.023577*cos(ang1)*cos(ang2)*cos(ang3) + 0.079164*cos(ang1)*cos(ang2)*sin(ang3) -
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) - 0.079164*cos(ang2)*sin(ang1)*sin(ang3) -
0.22817))];
[-(1.0*(0.5*brazo*cos(z4) - 0.080346*sin(ang1)*sin(ang3) - x +
0.019164*cos(ang3)*sin(ang1) + 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) - 0.18312))/(1.0*brazo*cos(z4)*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2)) -
0.86603*brazo*sin(z4)*(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) +
0.019164*cos(ang2)*sin(ang1)*sin(ang3) + 0.13917) +
0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 0.080346*sin(ang1)*sin(ang3) - x +
0.019164*cos(ang3)*sin(ang1) + 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) - 0.18312)), -(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) + 0.019164*cos(ang2)*sin(ang1)*sin(ang3) +
0.13917)/(1.0*brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2)) - 0.86603*brazo*sin(z4)*(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) + 0.019164*cos(ang2)*sin(ang1)*sin(ang3) +
0.13917) + 0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 0.080346*sin(ang1)*sin(ang3) - x +
0.019164*cos(ang3)*sin(ang1) + 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) - 0.18312)), (1.0*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2)))/(1.0*brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2)) -
0.86603*brazo*sin(z4)*(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) +
0.019164*cos(ang2)*sin(ang1)*sin(ang3) + 0.13917) +
0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 0.080346*sin(ang1)*sin(ang3) - x +
0.019164*cos(ang3)*sin(ang1) + 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) - 0.18312)), -
(1.0*(1.0*(0.080346*cos(ang1)*sin(ang3) - 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) + 0.019164*cos(ang2)*sin(ang1)*sin(ang3))*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2)) -
(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2))*(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) +
0.019164*cos(ang2)*sin(ang1)*sin(ang3) + 0.13917)))/(1.0*brazo*cos(z4)*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2)) -
0.86603*brazo*sin(z4)*(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) +
0.019164*cos(ang2)*sin(ang1)*sin(ang3) + 0.13917) +
0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 0.080346*sin(ang1)*sin(ang3) - x +
0.019164*cos(ang3)*sin(ang1) + 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) - 0.18312)), -
(1.0*((0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2))*(0.5*brazo*cos(z4) - 0.080346*sin(ang1)*sin(ang3) - x +
0.019164*cos(ang3)*sin(ang1) + 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) - 0.18312) - 1.0*(0.019164*cos(ang3)*sin(ang1)
- 0.080346*sin(ang1)*sin(ang3) + 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3))*(z + 0.019164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2))))/(1.0*brazo*cos(z4)*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2)) -
0.86603*brazo*sin(z4)*(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) +
0.019164*cos(ang2)*sin(ang1)*sin(ang3) + 0.13917) +
0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 0.080346*sin(ang1)*sin(ang3) - x +
0.019164*cos(ang3)*sin(ang1) + 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) - 0.18312)), -
(1.0*((0.080346*cos(ang1)*sin(ang3) - 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) +
0.019164*cos(ang2)*sin(ang1)*sin(ang3))*(0.5*brazo*cos(z4) -
0.080346*sin(ang1)*sin(ang3) - x + 0.019164*cos(ang3)*sin(ang1) +
0.080346*cos(ang1)*cos(ang2)*cos(ang3) + 0.019164*cos(ang1)*cos(ang2)*sin(ang3) -
0.18312) - 1.0*(0.019164*cos(ang3)*sin(ang1) - 0.080346*sin(ang1)*sin(ang3) +
0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3))*(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) + 0.019164*cos(ang2)*sin(ang1)*sin(ang3) +
0.13917)))/(1.0*brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2)) - 0.86603*brazo*sin(z4)*(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) + 0.019164*cos(ang2)*sin(ang1)*sin(ang3) +
0.13917) + 0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 0.080346*sin(ang1)*sin(ang3) - x +
0.019164*cos(ang3)*sin(ang1) + 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) - 0.18312))];
[(x + 0.080346*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z5) +
0.019164*cos(ang3)*sin(ang1) - 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) + 0.18312)/(brazo*cos(z5)*(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) -
0.019164*cos(ang2)*sin(ang1)*sin(ang3) - 0.13917) - 0.5*brazo*sin(z5)*(x +
0.080346*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z5) + 0.019164*cos(ang3)*sin(ang1) -
0.080346*cos(ang1)*cos(ang2)*cos(ang3) + 0.019164*cos(ang1)*cos(ang2)*sin(ang3) +
0.18312)), -(1.0*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) -
0.019164*cos(ang2)*sin(ang1)*sin(ang3) - 0.13917))/(brazo*cos(z5)*(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) -
0.019164*cos(ang2)*sin(ang1)*sin(ang3) - 0.13917) - 0.5*brazo*sin(z5)*(x +
0.080346*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z5) + 0.019164*cos(ang3)*sin(ang1) -
0.080346*cos(ang1)*cos(ang2)*cos(ang3) + 0.019164*cos(ang1)*cos(ang2)*sin(ang3) +
0.18312)), (z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2))/(brazo*cos(z5)*(z - 0.019164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) -
0.019164*cos(ang2)*sin(ang1)*sin(ang3) - 0.13917) - 0.5*brazo*sin(z5)*(x +
0.080346*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z5) + 0.019164*cos(ang3)*sin(ang1) -
0.080346*cos(ang1)*cos(ang2)*cos(ang3) + 0.019164*cos(ang1)*cos(ang2)*sin(ang3) +
0.18312)), -(1.0*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) - 0.019164*cos(ang2)*sin(ang1)*sin(ang3))*(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2)) +
(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2))*(0.86603*brazo*cos(z5)
- 1.0*y + 0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) - 0.019164*cos(ang2)*sin(ang1)*sin(ang3) -
0.13917))/(brazo*cos(z5)*(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2)) + 0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y
+ 0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) - 0.019164*cos(ang2)*sin(ang1)*sin(ang3) -
0.13917) - 0.5*brazo*sin(z5)*(x + 0.080346*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z5) +
0.019164*cos(ang3)*sin(ang1) - 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) + 0.18312)), -((0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2))*(x + 0.080346*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z5) +
0.019164*cos(ang3)*sin(ang1) - 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) + 0.18312) + 1.0*(0.080346*sin(ang1)*sin(ang3)
+ 0.019164*cos(ang3)*sin(ang1) - 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3))*(z - 0.019164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2)))/(brazo*cos(z5)*(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) + 0.080346*cos(ang2)*cos(ang3)*sin(ang1) -
0.019164*cos(ang2)*sin(ang1)*sin(ang3) - 0.13917) - 0.5*brazo*sin(z5)*(x +
0.080346*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z5) + 0.019164*cos(ang3)*sin(ang1) -
0.080346*cos(ang1)*cos(ang2)*cos(ang3) + 0.019164*cos(ang1)*cos(ang2)*sin(ang3) +
0.18312)), ((0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) - 0.019164*cos(ang2)*sin(ang1)*sin(ang3))*(x +
0.080346*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z5) + 0.019164*cos(ang3)*sin(ang1) -
0.080346*cos(ang1)*cos(ang2)*cos(ang3) + 0.019164*cos(ang1)*cos(ang2)*sin(ang3) +
0.18312) - 1.0*(0.080346*sin(ang1)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1) -
0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) - 0.019164*cos(ang2)*sin(ang1)*sin(ang3) -
0.13917))/(brazo*cos(z5)*(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2)) + 0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y
+ 0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) +
0.080346*cos(ang2)*cos(ang3)*sin(ang1) - 0.019164*cos(ang2)*sin(ang1)*sin(ang3) -
0.13917) - 0.5*brazo*sin(z5)*(x + 0.080346*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z5) +
0.019164*cos(ang3)*sin(ang1) - 0.080346*cos(ang1)*cos(ang2)*cos(ang3) +
0.019164*cos(ang1)*cos(ang2)*sin(ang3) + 0.18312))];
[-(1.0*(x - 0.023577*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z6) +
0.079164*cos(ang3)*sin(ang1) + 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) +
0.028965))/(brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2)) + 0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6)
- 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3) +
0.22817) + 0.5*brazo*sin(z6)*(x - 0.023577*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z6) +
0.079164*cos(ang3)*sin(ang1) + 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) + 0.028965)), -(1.0*y - 0.86603*brazo*cos(z6)
- 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3) +
0.22817)/(brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2)) + 0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6)
- 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3) +
0.22817) + 0.5*brazo*sin(z6)*(x - 0.023577*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z6) +
0.079164*cos(ang3)*sin(ang1) + 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) + 0.028965)), (0.079164*sin(ang2)*sin(ang3) -
1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2))/(brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2)) + 0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3) +
0.22817) + 0.5*brazo*sin(z6)*(x - 0.023577*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z6) +
0.079164*cos(ang3)*sin(ang1) + 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) + 0.028965)), -
(1.0*(1.0*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2))*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3) +
0.22817) - (0.023577*cos(ang1)*sin(ang3) - 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) +
0.079164*cos(ang2)*sin(ang1)*sin(ang3))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2))))/(brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2)) + 0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3) +
0.22817) + 0.5*brazo*sin(z6)*(x - 0.023577*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z6) +
0.079164*cos(ang3)*sin(ang1) + 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) + 0.028965)), -
(1.0*(0.079164*cos(ang3)*sin(ang1) - 0.023577*sin(ang1)*sin(ang3) +
0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2)) - (0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2))*(x - 0.023577*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z6) +
0.079164*cos(ang3)*sin(ang1) + 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) +
0.028965))/(brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2)) + 0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6)
- 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3) +
0.22817) + 0.5*brazo*sin(z6)*(x - 0.023577*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z6) +
0.079164*cos(ang3)*sin(ang1) + 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) + 0.028965)), -((0.079164*cos(ang3)*sin(ang1)
- 0.023577*sin(ang1)*sin(ang3) + 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3) +
0.22817) - 1.0*(0.023577*cos(ang1)*sin(ang3) - 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3))*(x -
0.023577*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z6) + 0.079164*cos(ang3)*sin(ang1) +
0.023577*cos(ang1)*cos(ang2)*cos(ang3) + 0.079164*cos(ang1)*cos(ang2)*sin(ang3) +
0.028965))/(brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2)) + 0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6)
- 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.023577*cos(ang2)*cos(ang3)*sin(ang1) + 0.079164*cos(ang2)*sin(ang1)*sin(ang3) +
0.22817) + 0.5*brazo*sin(z6)*(x - 0.023577*sin(ang1)*sin(ang3) - 0.5*brazo*cos(z6) +
0.079164*cos(ang3)*sin(ang1) + 0.023577*cos(ang1)*cos(ang2)*cos(ang3) +
0.079164*cos(ang1)*cos(ang2)*sin(ang3) + 0.028965))]];
[-(1.0*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*brazo*sin(z1)*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), -(1.0*(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*brazo*sin(z1)*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), (1.0*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3)
- 1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*brazo*sin(z1)*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), -(1.0*((0.06*cos(ang1)*cos(ang3)
- 0.056769*cos(ang1)*sin(ang3))*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + (y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3
) - 1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*brazo*sin(z1)*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), (1.0*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208) - 1.0*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3)
- 1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*brazo*sin(z1)*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), -(1.0*((y -
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089)*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*brazo*sin(z1)*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208));
(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + brazo*sin(z2)*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), (y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + brazo*sin(z2)*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), (z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3)
- 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
brazo*sin(z2)*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), -(1.0*(1.0*(y +
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))))/(brazo*cos(z2)*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
brazo*sin(z2)*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), -
(1.0*((0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3))*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3))*(x +
brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)))/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + brazo*sin(z2)*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), (1.0*(1.0*(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)))/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + brazo*sin(z2)*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208));
(1.0*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965))/(brazo*cos(z3)*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
0.5*brazo*sin(z3)*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) + 0.86603*brazo*sin(z3)*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)), (y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817)/(brazo*cos(z3)*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
0.5*brazo*sin(z3)*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) + 0.86603*brazo*sin(z3)*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)), (z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))/(brazo*cos(z3)*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
0.5*brazo*sin(z3)*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) + 0.86603*brazo*sin(z3)*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)), (1.0*(1.0*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))*(z
+ 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 0.5*brazo*sin(z3)*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)), -
(1.0*((0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(1.0*x - 0.5*brazo*cos(z3) +
0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 0.5*brazo*sin(z3)*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)), -
(1.0*(1.0*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) - 1.0*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 0.5*brazo*sin(z3)*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817));
-(1.0*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), (1.0*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3) - 0.13917))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) -
1.0*x + 0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), (z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 1.0*x
+ 0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), (1.0*((0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3))*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), -(1.0*((0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) -
1.0*x + 0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), (1.0*((0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917));
-(1.0*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - 1.0*z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), -(1.0*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - 1.0*z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), -(1.0*(0.019164*sin(ang2)*sin(ang3) - 1.0*z
+ 1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) -
1.0*x + 0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - 1.0*z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), (1.0*(0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3))*(0.019164*sin(ang2)*sin(ang3) - 1.0*z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - 1.0*z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), (1.0*(0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(0.019164*sin(ang2)*sin(ang3) - 1.0*z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) -
1.0*x + 0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - 1.0*z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), -(1.0*((0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3))*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917)))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - 1.0*z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917));
-(1.0*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965))/(0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817) + brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), -(1.0*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) + 0.22817))/(0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817) + brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), (0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))/(0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817) + brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), -(1.0*(1.0*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
(0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))))/(0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817) + brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), -(1.0*(1.0*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1)
- 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)))/(0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), -(1.0*(1.0*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3))*(x - 0.5*brazo*cos(z6)
+ 0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)))/(0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))];
[brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*brazo*sin(z1)*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208), x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3)
- 0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208, y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) + 0.089, z -
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z1) - 0.056769*cos(ang3)*sin(ang2) -
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3),
(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3))*(0.06*sin(ang2)*sin(ang3) -
1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + (y -
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089)*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)),
(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208), (y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089)*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
- 1.0*brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*brazo*sin(z2)*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208), x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3)
+ 0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208, y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089, z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3),
(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(y
+ 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)),
(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3))*(x +
brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208) - 1.0*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3))*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)), (y +
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.5*brazo*sin(z3)*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - 1.0*brazo*cos(z3)*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817), x - 0.5*brazo*cos(z3) +
0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965, y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817, z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3),
(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817), 1.0*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(1.0*x - 0.5*brazo*cos(z3) +
0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) - (0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)),
1.0*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817) - (0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965);
- 0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
+ 0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312) - 1.0*brazo*cos(z4)*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
0.86603*brazo*sin(z4)*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3) - 0.13917), x - 0.5*brazo*cos(z4) -
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) - 0.080346*sin(ang1)*sin(ang2)*sin(ang3) +
0.18312, y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3) - 0.13917, z + 0.019164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3),
1.0*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3))*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) - 0.13917),
(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312), 1.0*(0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - (0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) - 0.13917);
1.0*brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) -
1.0*x + 0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917), x -
0.5*brazo*cos(z5) - 0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) - 0.080346*sin(ang1)*sin(ang2)*sin(ang3) +
0.18312, y - 0.86603*brazo*cos(z5) - 0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3) + 0.13917, z - 0.019164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3),
1.0*(0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - (0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917),
1.0*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - (0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(0.019164*sin(ang2)*sin(ang3) - z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)),
(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917) -
1.0*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3))*(0.5*brazo*cos(z5)
- 1.0*x + 0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965), x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965, y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817, z -
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z6) - 0.023577*cos(ang3)*sin(ang2) -
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3),
1.0*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
(0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)), (0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1)
- 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965), 1.0*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3))*(x - 0.5*brazo*cos(z6)
+ 0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)];
function Jp1= JP1(brazo, x, y, z, ang1, ang2, ang3, z1, z2, z3, z4, z5, z6)
% Es generado simbolicamente en CinematicaDerivadaInversa4
[-(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - brazo*sin(z1)*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), -(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089)/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - brazo*sin(z1)*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), (1.0*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3)
- 1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
brazo*sin(z1)*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), -((0.06*cos(ang1)*cos(ang3) -
0.056769*cos(ang1)*sin(ang3))*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + (y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3)
- 1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
brazo*sin(z1)*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), (1.0*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208) - (0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3)
- 1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
brazo*sin(z1)*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), -((y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)) + (0.06*cos(ang1)*cos(ang3) -
0.056769*cos(ang1)*sin(ang3))*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - brazo*sin(z1)*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208));
(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + brazo*sin(z2)*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), (y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + brazo*sin(z2)*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), (z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3)
- 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
brazo*sin(z2)*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), -(1.0*(y +
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3)
- 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
brazo*sin(z2)*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)), -
(1.0*((0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3))*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3))*(x +
brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)))/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + brazo*sin(z2)*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)), (1.0*(1.0*(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)))/(brazo*cos(z2)*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + brazo*sin(z2)*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208));
(1.0*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965))/(brazo*cos(z3)*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
0.5*brazo*sin(z3)*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) + 0.86603*brazo*sin(z3)*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)), (y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817)/(brazo*cos(z3)*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
0.5*brazo*sin(z3)*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) + 0.86603*brazo*sin(z3)*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)), (z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))/(brazo*cos(z3)*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
0.5*brazo*sin(z3)*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) + 0.86603*brazo*sin(z3)*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)), (1.0*(1.0*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))*(z
+ 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 0.5*brazo*sin(z3)*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)), -
((0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(1.0*x - 0.5*brazo*cos(z3) +
0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 0.5*brazo*sin(z3)*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)), -
(1.0*(1.0*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) - (0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 0.5*brazo*sin(z3)*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817));
-(1.0*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), (1.0*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3) - 0.13917))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) -
1.0*x + 0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), (z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 1.0*x
+ 0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), (1.0*((0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3))*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), -((0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - (0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) -
1.0*x + 0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)), (1.0*((0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917)))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917));
-(1.0*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), -(1.0*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), -(0.019164*sin(ang2)*sin(ang3) - z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x
+ 0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), (1.0*(0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - (0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), (1.0*(0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3))*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - (0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(0.019164*sin(ang2)*sin(ang3) - z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) -
1.0*x + 0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)), -(1.0*((0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3))*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - 1.0*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917)))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917));
-(1.0*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965))/(0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817) + brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), -(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) + 0.22817)/(0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817) + brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), (0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))/(0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817) + brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), -(1.0*(1.0*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
(0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))))/(0.86603*brazo*sin(z6)*(1.0*y -
0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817) + brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), -(1.0*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1)
- 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - (0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)), -(1.0*(1.0*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3))*(x - 0.5*brazo*cos(z6)
+ 0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)))/(0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))];
function Jp2= JP2(brazo, x, y, z, ang1, ang2, ang3, z1, z2, z3, z4, z5, z6,ang1dot,
ang2dot, ang3dot, xdot, ydot, zdot,z1p, z2p, z3p, z4p, z5p, z6p)
% Es generado simbolicamente en CinematicaDerivadaInversa4
[((1.0*ang1dot*(ang1dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2)
+ 0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3))) +
ang2dot*(1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3))) -
((1.0*(ang2dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1))*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208) - (xdot -
1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z1p*sin(z1))*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(((1.0*(ang2dot*(0.056769*cos(ang2)*cos(ang3
) + 0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1))*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208) - (xdot -
1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z1p*sin(z1))*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2) - (((y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(xdot - 1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.06*cos(ang1)*cos(ang3) -
0.056769*cos(ang1)*sin(ang3)) - 1.0*brazo*z1p*sin(z1)) - 1.0*(ydot +
ang1dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x +
brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))*(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089))/(abs(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) -
1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) + 0.089)^2)))/(abs(x
+ brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2) + 1.0*brazo*z1p^2*sin(z1) - (((((y -
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) + 0.089)*(xdot -
1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z1p*sin(z1)) - 1.0*(ydot + ang1dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2) + (((y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(ang2dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1)) - 1.0*(ydot + ang1dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2))*((y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(ang2dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1)) - 1.0*(ydot + ang1dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
1.0*(ang3dot*(ang1dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3))) +
ang2dot*(ang2dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3))) - (1.0*((((y -
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) + 0.089)*(xdot -
1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z1p*sin(z1)) - 1.0*(ydot + ang1dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2) + (((y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(ang2dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1)) - 1.0*(ydot + ang1dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2))*((y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(xdot - 1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.06*cos(ang1)*cos(ang3) -
0.056769*cos(ang1)*sin(ang3)) - 1.0*brazo*z1p*sin(z1)) - 1.0*(ydot +
ang1dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x +
brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)))/(abs(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) -
1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) + 0.089)^2) -
((1.0*(ang2dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1))*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208) - (xdot -
1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z1p*sin(z1))*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*((((y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(ang2dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1)) - 1.0*(ydot + ang1dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2) +
(1.0*(1.0*(ang2dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1))*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208) - (xdot -
1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z1p*sin(z1))*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))/(abs(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) -
1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) + 0.089)^2)))/(abs(x
+ brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2) + brazo*z1p^2*cos(z1))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208) - (y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089)*(ang1dot*(ang2dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3))) -
ang3dot*(1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3))) + (((((y -
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089)*(ang2dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1)) - 1.0*(ydot + ang1dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2) +
(1.0*(1.0*(ang2dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1))*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208) - (xdot -
1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z1p*sin(z1))*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))/(abs(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) -
1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) + 0.089)^2))*((y -
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089)*(ang2dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1)) - 1.0*(ydot + ang1dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2) -
((((1.0*(ang2dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) +
brazo*z1p*cos(z1))*(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208) - (xdot -
1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z1p*sin(z1))*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(0.06*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)^2) - (((y - 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) + 0.089)*(xdot - 1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.06*cos(ang1)*cos(ang3) -
0.056769*cos(ang1)*sin(ang3)) - 1.0*brazo*z1p*sin(z1)) - 1.0*(ydot +
ang1dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x +
brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))*(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089))/(abs(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) -
1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) + 0.089)^2))*((y -
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) + 0.089)*(xdot -
1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.06*cos(ang1)*cos(ang3) - 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z1p*sin(z1)) - 1.0*(ydot + ang1dot*(0.06*sin(ang2)*sin(ang3) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)))/(abs(x + brazo*cos(z1) + 0.056769*cos(ang2)*cos(ang3) +
0.06*cos(ang2)*sin(ang3) - 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(0.06*sin(ang2)*sin(ang3) -
1.0*z + brazo*sin(z1) + 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) - 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(y - 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) +
0.089)^2)))/(1.0*brazo*cos(z1)*(0.06*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z1) +
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) -
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - brazo*sin(z1)*(x + brazo*cos(z1) +
0.056769*cos(ang2)*cos(ang3) + 0.06*cos(ang2)*sin(ang3) -
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208));
(((((1.0*((y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)*(xdot + ang2dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*sin(z2)) - 1.0*(ydot - 1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))*(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089))/(abs(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(y +
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089)^2 + abs(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) +
((1.0*(xdot + ang2dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*sin(z2))*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - (zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2))*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2))*(1.0*(xdot +
ang2dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*sin(z2))*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - (zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2))*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) -
ang2dot*(1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
ang3dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))) -
1.0*ang1dot*(ang1dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3))) +
(1.0*((((y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089)*(xdot +
ang2dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*sin(z2)) - 1.0*(ydot - 1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) + (1.0*(1.0*(y + 0.06*cos(ang1)*cos(ang3)
+ 0.056769*cos(ang1)*sin(ang3) - 0.089)*(zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2)) - (ydot - 1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2))*(1.0*(y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) - 0.089)*(zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2)) - (ydot - 1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3))))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) + brazo*z2p^2*sin(z2))*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
(ang3dot*(ang1dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3))) -
ang2dot*(1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))) +
(1.0*((1.0*(1.0*(xdot + ang2dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3)) - 1.0*brazo*z2p*sin(z2))*(z + 0.06*sin(ang2)*sin(ang3)
- 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - (zdot
- 1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2))*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208))*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))/(abs(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(y +
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089)^2 + abs(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) -
((1.0*(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089)*(zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2)) - (ydot - 1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) - 0.089))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2))*(1.0*(xdot +
ang2dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*sin(z2))*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - (zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2))*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) + (((((y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) - 0.089)*(xdot + ang2dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3)) - 1.0*brazo*z2p*sin(z2)) - 1.0*(ydot -
1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x +
brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) + (1.0*(1.0*(y + 0.06*cos(ang1)*cos(ang3)
+ 0.056769*cos(ang1)*sin(ang3) - 0.089)*(zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2)) - (ydot - 1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2))*((y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) - 0.089)*(xdot + ang2dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3)) - 1.0*brazo*z2p*sin(z2)) - 1.0*(ydot -
1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x +
brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)))/(abs(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(y +
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089)^2 + abs(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) -
1.0*brazo*z2p^2*cos(z2))*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208) + 1.0*(y + 0.06*cos(ang1)*cos(ang3)
+ 0.056769*cos(ang1)*sin(ang3) -
0.089)*(ang1dot*(1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3)
+ 0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) -
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))) +
ang3dot*(1.0*ang2dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
ang3dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3))) -
(1.0*((1.0*(1.0*(xdot + ang2dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3)) - 1.0*brazo*z2p*sin(z2))*(z + 0.06*sin(ang2)*sin(ang3)
- 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - (zdot
- 1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2))*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208))*(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))/(abs(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(y +
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089)^2 + abs(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) -
((1.0*(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089)*(zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2)) - (ydot - 1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3)))*(y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) - 0.089))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2))*(1.0*(y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) - 0.089)*(zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2)) - (ydot - 1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3))))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) + (((1.0*((y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) - 0.089)*(xdot + ang2dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3)) - 1.0*brazo*z2p*sin(z2)) - 1.0*(ydot -
1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x +
brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208))*(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089))/(abs(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(y +
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089)^2 + abs(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2) +
((1.0*(xdot + ang2dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*sin(z2))*(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - (zdot -
1.0*ang2dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3)) -
1.0*brazo*z2p*cos(z2))*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208))*(z + 0.06*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1)
+ 0.056769*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(x + brazo*cos(z2) +
0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)^2 + abs(y + 0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) -
0.089)^2 + abs(z + 0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2))*((y + 0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3) - 0.089)*(xdot + ang2dot*(0.06*sin(ang2)*sin(ang3) -
0.056769*cos(ang3)*sin(ang2) + 0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.06*cos(ang1)*cos(ang3) +
0.056769*cos(ang1)*sin(ang3)) - 1.0*brazo*z2p*sin(z2)) - 1.0*(ydot -
1.0*ang1dot*(0.06*sin(ang2)*sin(ang3) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3)))*(x +
brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) - 0.06*cos(ang2)*sin(ang3) +
0.06*cos(ang3)*sin(ang1)*sin(ang2) + 0.056769*sin(ang1)*sin(ang2)*sin(ang3) -
0.21208)))/(abs(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208)^2 + abs(y +
0.06*cos(ang1)*cos(ang3) + 0.056769*cos(ang1)*sin(ang3) - 0.089)^2 + abs(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) +
0.056769*cos(ang2)*sin(ang1)*sin(ang3))^2)))/(brazo*cos(z2)*(z +
0.06*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z2) - 0.056769*cos(ang3)*sin(ang2) +
0.06*cos(ang2)*cos(ang3)*sin(ang1) + 0.056769*cos(ang2)*sin(ang1)*sin(ang3)) +
brazo*sin(z2)*(x + brazo*cos(z2) + 0.056769*cos(ang2)*cos(ang3) -
0.06*cos(ang2)*sin(ang3) + 0.06*cos(ang3)*sin(ang1)*sin(ang2) +
0.056769*sin(ang1)*sin(ang2)*sin(ang3) - 0.21208));
(1.0*((ang3dot*(ang1dot*(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - ang3dot*(0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3))) -
ang2dot*(ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))) +
(1.0*((((zdot - ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3)
+ 0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot +
ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(1.0*x - 0.5*brazo*cos(z3) +
0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(abs(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(0.5*brazo*cos(z3) - 1.0*x -
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) - 0.023577*sin(ang1)*sin(ang2)*sin(ang3) -
0.028965)^2 + abs(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) + (((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817) - (1.0*ydot -
ang1dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
0.86603*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817))/(abs(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2))*((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot +
ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))))/(abs(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) +
(1.0*((1.0*ydot - ang1dot*(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 0.86603*brazo*z3p*sin(z3))*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) - 1.0*(xdot + ang2dot*(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3)) + 0.5*brazo*z3p*sin(z3))*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817))*((((1.0*ydot
- ang1dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
0.86603*brazo*z3p*sin(z3))*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3)
- 0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - 1.0*(xdot +
ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z3p*sin(z3))*(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817))*(1.0*x - 0.5*brazo*cos(z3) +
0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(abs(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(0.5*brazo*cos(z3) - 1.0*x -
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) - 0.023577*sin(ang1)*sin(ang2)*sin(ang3) -
0.028965)^2 + abs(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) - (((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817) - (1.0*ydot -
ang1dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
0.86603*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2)))/(abs(z
+ 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) +
0.5*brazo*z3p^2*cos(z3))*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) -
(ang2dot*(ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))) +
ang1dot*(ang1dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
ang3dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3))) -
1.0*brazo*z3p^2*sin(z3) + (1.0*((((1.0*ydot - ang1dot*(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 0.86603*brazo*z3p*sin(z3))*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) - 1.0*(xdot + ang2dot*(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3)) + 0.5*brazo*z3p*sin(z3))*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817))*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(abs(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(0.5*brazo*cos(z3) - 1.0*x -
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) - 0.023577*sin(ang1)*sin(ang2)*sin(ang3) -
0.028965)^2 + abs(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) - (((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817) - (1.0*ydot -
ang1dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
0.86603*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2))*((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817) - (1.0*ydot -
ang1dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
0.86603*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))))/(abs(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) -
(((((1.0*ydot - ang1dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2)
+ 0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
0.86603*brazo*z3p*sin(z3))*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3)
- 0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - 1.0*(xdot +
ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z3p*sin(z3))*(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817))*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817))/(abs(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) +
(1.0*((zdot - ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot +
ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2))*((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot +
ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))))/(abs(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2))*(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
1.0*(ang3dot*(ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))) +
1.0*ang1dot*(ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3))) + (((((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot +
ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(1.0*x - 0.5*brazo*cos(z3) +
0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(abs(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(0.5*brazo*cos(z3) - 1.0*x -
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) - 0.023577*sin(ang1)*sin(ang2)*sin(ang3) -
0.028965)^2 + abs(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) + (((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817) - (1.0*ydot -
ang1dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
0.86603*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817))/(abs(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2))*((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817) - (1.0*ydot -
ang1dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
0.86603*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))))/(abs(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) -
0.86603*brazo*z3p^2*cos(z3) + (((((1.0*ydot - ang1dot*(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 0.86603*brazo*z3p*sin(z3))*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) - 1.0*(xdot + ang2dot*(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3)) + 0.5*brazo*z3p*sin(z3))*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817))/(abs(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(0.5*brazo*cos(z3) - 1.0*x -
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) - 0.023577*sin(ang1)*sin(ang2)*sin(ang3) -
0.028965)^2 + abs(y + 0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2) + (1.0*((zdot -
ang2dot*(0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) -
1.0*brazo*z3p*cos(z3))*(1.0*x - 0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot +
ang2dot*(0.079164*sin(ang2)*sin(ang3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z3p*sin(z3))*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(z + 0.079164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)^2))*((1.0*ydot - ang1dot*(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.023577*cos(ang2)*cos(ang3) -
0.079164*cos(ang2)*sin(ang3) + 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 0.86603*brazo*z3p*sin(z3))*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) - 1.0*(xdot + ang2dot*(0.079164*sin(ang2)*sin(ang3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) +
0.023577*cos(ang1)*sin(ang3)) + 0.5*brazo*z3p*sin(z3))*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)))/(abs(z +
0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) - 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) + 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(0.5*brazo*cos(z3) - 1.0*x - 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) -
0.023577*sin(ang1)*sin(ang2)*sin(ang3) - 0.028965)^2 + abs(y + 0.86603*brazo*cos(z3)
+ 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2))*(y +
0.86603*brazo*cos(z3) + 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) -
0.22817)))/(brazo*cos(z3)*(z + 0.079164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z3) -
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) +
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 0.5*brazo*sin(z3)*(1.0*x -
0.5*brazo*cos(z3) + 0.023577*cos(ang2)*cos(ang3) - 0.079164*cos(ang2)*sin(ang3) +
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) + 0.86603*brazo*sin(z3)*(y + 0.86603*brazo*cos(z3) +
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) - 0.22817));
-((1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3) -
0.13917)*(ang1dot*(1.0*ang1dot*(0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3)) + ang2dot*(0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))) +
ang3dot*(1.0*ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))) +
0.86603*brazo*z4p^2*cos(z4) - ((1.0*(1.0*zdot + ang1dot*(0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3)) + 1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*brazo*z4p*cos(z4))*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917) + (ang1dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
ydot + 1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))*((((xdot -
ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 1.0*(1.0*zdot +
ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(abs(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 + abs(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) + ((1.0*(1.0*zdot +
ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3) - 0.13917) + (ang1dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ydot +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(abs(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 + abs(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2)))/(abs(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) -
(1.0*(1.0*(xdot - ang3dot*(0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3)) + 1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*z4p*sin(z4))*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917) - (ang1dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
ydot + 1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
+ 0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*((1.0*(1.0*(xdot -
ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z4p*sin(z4))*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ang1dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ydot +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
+ 0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(abs(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 + abs(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) + (((xdot -
ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 1.0*(1.0*zdot +
ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(z + 0.019164*sin(ang2)*sin(ang3)
- 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2)))/(abs(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2))
+ (ang3dot*(ang1dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3))) +
1.0*ang2dot*(1.0*ang1dot*(0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3)) + ang2dot*(0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))) + ((((1.0*(1.0*zdot +
ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3) - 0.13917) + (ang1dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ydot +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))*(z + 0.019164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) -
((1.0*(xdot - ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z4p*sin(z4))*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ang1dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ydot +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
+ 0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(abs(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 + abs(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2))*(1.0*(xdot -
ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z4p*sin(z4))*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ang1dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ydot +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
+ 0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)))/(abs(0.080346*cos(ang1)*sin(ang3)
- 0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) +
0.5*brazo*z4p^2*cos(z4) - (((xdot - ang3dot*(0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3)) + 1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*z4p*sin(z4))*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
1.0*(1.0*zdot + ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3))
+ 1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*((((xdot -
ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 1.0*(1.0*zdot +
ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(abs(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 + abs(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) + ((1.0*(1.0*zdot +
ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3) - 0.13917) + (ang1dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ydot +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(abs(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 + abs(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2)))/(abs(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - (ang2dot*(1.0*ang3dot*(0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3)) - ang2dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))) -
ang1dot*(ang1dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3))) +
1.0*brazo*z4p^2*sin(z4) + (((xdot - ang3dot*(0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3)) + 1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*z4p*sin(z4))*(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
1.0*(1.0*zdot + ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3))
+ 1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*((1.0*(1.0*(xdot -
ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z4p*sin(z4))*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ang1dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ydot +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
+ 0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(1.0*y + 0.86603*brazo*cos(z4) +
0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(abs(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 + abs(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) + (((xdot -
ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 1.0*(1.0*zdot +
ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(z + 0.019164*sin(ang2)*sin(ang3)
- 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2)))/(abs(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) +
((((1.0*(1.0*zdot + ang1dot*(0.019164*cos(ang1)*cos(ang3) -
0.080346*cos(ang1)*sin(ang3)) + 1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*brazo*z4p*cos(z4))*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917) + (ang1dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
ydot + 1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))*(z + 0.019164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) -
((1.0*(xdot - ang3dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.019164*sin(ang2)*sin(ang3) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z4p*sin(z4))*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ang1dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ydot +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
+ 0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(abs(0.080346*cos(ang1)*sin(ang3) - 0.86603*brazo*cos(z4) -
0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 + abs(0.5*brazo*cos(z4) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2))*(1.0*(1.0*zdot +
ang1dot*(0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z4p*cos(z4))*(1.0*y + 0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3)
- 0.080346*cos(ang1)*sin(ang3) - 0.13917) + (ang1dot*(0.019164*sin(ang2)*sin(ang3) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ydot +
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z4p*sin(z4))*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))))/(abs(0.080346*cos(ang1)*sin(ang3) -
0.86603*brazo*cos(z4) - 0.019164*cos(ang1)*cos(ang3) - 1.0*y + 0.13917)^2 +
abs(0.5*brazo*cos(z4) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) +
0.019164*cos(ang2)*sin(ang3) - 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z +
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2))*(z + 0.019164*sin(ang2)*sin(ang3) -
1.0*brazo*sin(z4) + 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(0.5*brazo*sin(z4)*(0.5*brazo*cos(z4) -
1.0*x + 0.080346*cos(ang2)*cos(ang3) + 0.019164*cos(ang2)*sin(ang3) -
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) + brazo*cos(z4)*(z + 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z4) +
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) + 0.86603*brazo*sin(z4)*(1.0*y +
0.86603*brazo*cos(z4) + 0.019164*cos(ang1)*cos(ang3) - 0.080346*cos(ang1)*sin(ang3) -
0.13917));
-(1.0*((0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) -
0.13917)*(ang3dot*(ang3dot*(0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3)) - ang2dot*(0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3))) +
1.0*ang1dot*(1.0*ang1dot*(0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3)) - ang2dot*(0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))) - (1.0*((ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917))*((((ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(abs(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 + abs(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2) - 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) + (((xdot +
ang3dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(abs(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 + abs(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2) - 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2)))/(abs(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) -
(((((xdot + ang3dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.019164*sin(ang2)*sin(ang3) - z
+ 1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) +
(1.0*(1.0*(xdot + ang3dot*(0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3)) - ang2dot*(0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
- 0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(abs(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 + abs(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2) - 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2))*(1.0*(xdot +
ang3dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
- 0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)))/(abs(0.86603*brazo*cos(z5) -
1.0*y + 0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) +
0.86603*brazo*z5p^2*cos(z5)) +
1.0*(1.0*ang1dot*(ang1dot*(0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - ang3dot*(0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3))) -
1.0*ang2dot*(ang3dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3))) +
(((ydot + 1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917))*(((1.0*(xdot +
ang3dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
- 0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(abs(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 + abs(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2) - 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) - (((ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917))*(0.019164*sin(ang2)*sin(ang3) - z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2)))/(abs(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) +
1.0*brazo*z5p^2*sin(z5) - (((xdot + ang3dot*(0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3)) - ang2dot*(0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*((((xdot +
ang3dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.019164*sin(ang2)*sin(ang3) - z
+ 1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) +
(1.0*(1.0*(xdot + ang3dot*(0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3)) - ang2dot*(0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
- 0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(abs(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 + abs(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2) - 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2)))/(abs(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2))*(0.019164*sin(ang2)*sin(ang3) - z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
(ang3dot*(ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3))) +
ang2dot*(1.0*ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3))) +
(1.0*(((1.0*(xdot + ang3dot*(0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3)) - ang2dot*(0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
- 0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(abs(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 + abs(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2) - 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) - (((ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917))*(0.019164*sin(ang2)*sin(ang3) - z +
1.0*brazo*sin(z5) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2))*(1.0*(xdot +
ang3dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917) - (ydot +
1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) -
1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3)
- 0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)))/(abs(0.86603*brazo*cos(z5) -
1.0*y + 0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) +
(1.0*((((ydot + 1.0*ang1dot*(0.019164*sin(ang2)*sin(ang3) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3)
+ 0.080346*cos(ang1)*sin(ang3) - 0.13917))*(0.86603*brazo*cos(z5) - 1.0*y +
0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) -
0.13917))/(abs(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 + abs(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2) - 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) + (((xdot +
ang3dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312))*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312))/(abs(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 + abs(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)^2 + abs(z - 0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) +
0.080346*cos(ang3)*sin(ang2) - 0.019164*cos(ang2)*cos(ang3)*sin(ang1) -
0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2))*((xdot +
ang3dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) -
ang2dot*(0.019164*sin(ang2)*sin(ang3) - 0.080346*cos(ang3)*sin(ang2) +
0.019164*cos(ang2)*cos(ang3)*sin(ang1) + 0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.5*brazo*z5p*sin(z5))*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*(1.0*zdot -
ang1dot*(0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3)) +
1.0*ang2dot*(0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*brazo*z5p*cos(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)))/(abs(0.86603*brazo*cos(z5) -
1.0*y + 0.019164*cos(ang1)*cos(ang3) + 0.080346*cos(ang1)*sin(ang3) - 0.13917)^2 +
abs(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) - 0.18312)^2 + abs(z -
0.019164*sin(ang2)*sin(ang3) - 1.0*brazo*sin(z5) + 0.080346*cos(ang3)*sin(ang2) -
0.019164*cos(ang2)*cos(ang3)*sin(ang1) - 0.080346*cos(ang2)*sin(ang1)*sin(ang3))^2) -
0.5*brazo*z5p^2*cos(z5))*(0.5*brazo*cos(z5) - 1.0*x + 0.080346*cos(ang2)*cos(ang3) -
0.019164*cos(ang2)*sin(ang3) + 0.019164*cos(ang3)*sin(ang1)*sin(ang2) +
0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312)))/(0.5*brazo*sin(z5)*(0.5*brazo*cos(z5) - 1.0*x +
0.080346*cos(ang2)*cos(ang3) - 0.019164*cos(ang2)*sin(ang3) +
0.019164*cos(ang3)*sin(ang1)*sin(ang2) + 0.080346*sin(ang1)*sin(ang2)*sin(ang3) -
0.18312) - brazo*cos(z5)*(0.019164*sin(ang2)*sin(ang3) - z + 1.0*brazo*sin(z5) -
0.080346*cos(ang3)*sin(ang2) + 0.019164*cos(ang2)*cos(ang3)*sin(ang1) +
0.080346*cos(ang2)*sin(ang1)*sin(ang3)) +
0.86603*brazo*sin(z5)*(0.86603*brazo*cos(z5) - 1.0*y + 0.019164*cos(ang1)*cos(ang3) +
0.080346*cos(ang1)*sin(ang3) - 0.13917));
(1.0*(1.0*(ang2dot*(ang2dot*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3))) + ang1dot*(ang1dot*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3))) - (((ang2dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - 1.0*(xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*((((ydot +
ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2) +
(1.0*((ang2dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - 1.0*(xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1)
- 0.023577*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.86603*brazo*cos(z6) - 1.0*y +
0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 +
abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)^2)))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2) + 1.0*brazo*z6p^2*sin(z6) -
(1.0*((((ydot + ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2)
+ 0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - (ang2dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1)
- 0.023577*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.86603*brazo*cos(z6) - 1.0*y +
0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 +
abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)^2) + (((ydot + ang1dot*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) + 0.86603*brazo*z6p*sin(z6))*(x -
0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) - (xdot - 1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3)) + 0.5*brazo*z6p*sin(z6))*(1.0*y - 0.86603*brazo*cos(z6)
- 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817))*(x -
0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2))*((ydot +
ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - (ang2dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817)))/(abs(0.86603*brazo*cos(z6) - 1.0*y +
0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 +
abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)^2))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - (1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817)*(1.0*ang1dot*(ang2dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) + ang1dot*(0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3))) - ang3dot*(ang2dot*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - 1.0*ang3dot*(0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3))) + 0.86603*brazo*z6p^2*cos(z6) + (((ydot +
ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817))*((((ydot +
ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2) +
(1.0*((ang2dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - 1.0*(xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1)
- 0.023577*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.86603*brazo*cos(z6) - 1.0*y +
0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 +
abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)^2)))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2) + (((((ydot +
ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - (ang2dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2) -
(((ang2dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - 1.0*(xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2))*((ydot +
ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - (ang2dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817)))/(abs(0.86603*brazo*cos(z6) - 1.0*y +
0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 +
abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)^2)) + (1.0*ang3dot*(ang1dot*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3))) +
1.0*ang2dot*(ang2dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3))) - (((((ydot +
ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - (ang2dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z +
brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1)
- 0.023577*cos(ang2)*sin(ang1)*sin(ang3)))/(abs(0.86603*brazo*cos(z6) - 1.0*y +
0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 +
abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)^2) + (((ydot + ang1dot*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) + 0.86603*brazo*z6p*sin(z6))*(x -
0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965) - (xdot - 1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + ang3dot*(0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3)) + 0.5*brazo*z6p*sin(z6))*(1.0*y - 0.86603*brazo*cos(z6)
- 0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817))*(x -
0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2))*((ydot +
ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - (xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817)))/(abs(0.86603*brazo*cos(z6) - 1.0*y +
0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 +
abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)^2) + (((ang2dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - 1.0*(xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*((((ydot +
ang1dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) +
0.86603*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) - (ang2dot*(0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3)) - 1.0*zdot +
ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(1.0*y - 0.86603*brazo*cos(z6) - 0.079164*cos(ang1)*cos(ang3)
+ 0.023577*cos(ang1)*sin(ang3) + 0.22817))*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) +
0.22817))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2) -
(((ang2dot*(0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3)) -
1.0*zdot + ang1dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
1.0*brazo*z6p*cos(z6))*(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965) - 1.0*(xdot -
1.0*ang2dot*(0.079164*sin(ang2)*sin(ang3) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3)) +
ang3dot*(0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3)) +
0.5*brazo*z6p*sin(z6))*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)))*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))/(abs(0.86603*brazo*cos(z6) - 1.0*y + 0.079164*cos(ang1)*cos(ang3) -
0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 + abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z
+ brazo*sin(z6) + 0.023577*cos(ang3)*sin(ang2) +
0.079164*cos(ang2)*cos(ang3)*sin(ang1) - 0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 +
abs(x - 0.5*brazo*cos(z6) + 0.023577*cos(ang2)*cos(ang3) +
0.079164*cos(ang2)*sin(ang3) - 0.079164*cos(ang3)*sin(ang1)*sin(ang2) +
0.023577*sin(ang1)*sin(ang2)*sin(ang3) + 0.028965)^2)))/(abs(0.86603*brazo*cos(z6) -
1.0*y + 0.079164*cos(ang1)*cos(ang3) - 0.023577*cos(ang1)*sin(ang3) - 0.22817)^2 +
abs(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3))^2 + abs(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)^2) - 0.5*brazo*z6p^2*cos(z6))*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965)))/(0.86603*brazo*sin(z6)*(1.0*y - 0.86603*brazo*cos(z6) -
0.079164*cos(ang1)*cos(ang3) + 0.023577*cos(ang1)*sin(ang3) + 0.22817) +
brazo*cos(z6)*(0.079164*sin(ang2)*sin(ang3) - 1.0*z + brazo*sin(z6) +
0.023577*cos(ang3)*sin(ang2) + 0.079164*cos(ang2)*cos(ang3)*sin(ang1) -
0.023577*cos(ang2)*sin(ang1)*sin(ang3)) + 0.5*brazo*sin(z6)*(x - 0.5*brazo*cos(z6) +
0.023577*cos(ang2)*cos(ang3) + 0.079164*cos(ang2)*sin(ang3) -
0.079164*cos(ang3)*sin(ang1)*sin(ang2) + 0.023577*sin(ang1)*sin(ang2)*sin(ang3) +
0.028965))];
function CinematicaDerivadaInversa4
syms brazo real
syms betah gammah alfah real
syms z1 z2 z3 z4 z5 z6 real
syms z1p z2p z3p z4p z5p z6p real
syms x y z ang1 ang2 ang3 real
syms xdot ydot zdot ang1dot ang2dot ang3dot real
syms z1pp z2pp z3pp z4pp z5pp z6pp real
syms pxdotdot pyedotdot pzdotdot fiidotdot tetadotdot psiidotdot real
% Matrices de rotación
Rxa = [1, 0, 0;
0, cos(alfah), -sin(alfah);
0, sin(alfah), cos(alfah)];
Ryb = [ cos(betah) 0 sin(betah);
-sin(betah) 0 cos(betah)];
Rzg = [cos(gammah) -sin(gammah) 0;
sin(gammah) cos(gammah) 0;
% Longitudes Poligono Base 15/09/2021
H = 230/1000; D= 89/1000;
% Longitudes Plataforma móvil 15/09/2021
h = 82.6/1000; d= 60/1000;
% Base Vertices
ba(:,1)=[H*cos(asin(D/H)), -D, 0];
ba(:,2)=[H*cos(asin(D/H)), D, 0];
ba(:,3)=(rotz(120)*ba(:,1));
ba(:,4)=(rotz(120)*ba(:,2));
ba(:,5)=(rotz(120)*ba(:,3));
ba(:,6)=(rotz(120)*ba(:,4));
% Plataforma Vertices
pl(:,1)=rotz(0)*[h*cos(asin(d/h)); -d; 0];
pl(:,2)=rotz(0)*[h*cos(asin(d/h)); d; 0];
pl(:,3)=(rotz(120)*pl(:,1));
pl(:,4)=(rotz(120)*pl(:,2));
pl(:,5)=(rotz(120)*pl(:,3));
pl(:,6)=(rotz(120)*pl(:,4));
Xp= formula([x y z ang1 ang2 ang3]);
Xpdot= formula([xdot ydot zdot ang1dot ang2dot ang3dot]);
Xpdotdot= formula([pxdotdot pyedotdot pzdotdot tetadotdot fiidotdot psiidotdot]);
zetap= formula([z1p z2p z3p z4p z5p z6p]);
zetapp= formula([z1pp z2pp z3pp z4pp z5pp z6pp]);
zeta= formula([z1 z2 z3 z4 z5 z6]);
alfa_ij=[0, 0, 2*pi/3, 2*pi/3, 4*pi/3, 4*pi/3];
Fij_R_fk=rotz(180)*rotx(90);
F_R_fcur= subs(Ryb,betah,ang2)*...
subs(Rxa,alfah,ang1)*...
subs(Rzg,gammah,ang3);
fcurij_r_C(1,:)=pl(:,1);
fcurij_r_C(2,:)=pl(:,2);
fcurij_r_C(3,:)=fcurij_r_C(1,:);
fcurij_r_C(4,:)=fcurij_r_C(2,:);
fcurij_r_C(5,:)=fcurij_r_C(1,:);
fcurij_r_C(6,:)=fcurij_r_C(2,:);
Fij_r_A(1,:) = ba(:,1);
Fij_r_A(2,:) = ba(:,2);
Fij_r_A(3,:) = Fij_r_A(1,:);
Fij_r_A(4,:) = Fij_r_A(2,:);
Fij_r_A(5,:) = Fij_r_A(1,:);
Fij_r_A(6,:) = Fij_r_A(2,:);
vp= Xpdot(1:3);
wp= Xpdot(4:6);
vpp= Xpdotdot(1:3);
wpp= Xpdotdot(4:6);
% JACOBIANA PLATAFORMA
F_R_Fij=double(subs(Rzg,gammah,alfa_ij(i)));
Zetap= vpa(F_R_Fij*Fij_R_fk *[0;0;zetap(i)])
AB= F_R_Fij*Fij_R_fk *[brazo*cos(zeta(i)); brazo*sin(zeta(i)); 0];
fcur_R_fcurij= F_R_Fij;
c= F_R_fcur*fcur_R_fcurij*fcurij_r_C(i,:)';
a=F_R_Fij*Fij_r_A(i,:)';
BC= c' + Xp(1:3) - (AB+a)';
eq1=dot(vp+cross(wp,c)-cross(Zetap',AB),BC);
[A,B]=coeffs(eq1,[zetap(i), Xpdot]);
Jp(i,:)=vpa(-A(2:7)/A(1),2);
AA(i,:)=A;
% Segunda derivada para la jacobiana de aceleración
Zetapp= F_R_Fij*Fij_R_fk *[0;0;zetapp(i)'];
wr= (-1/(norm(BC)^2) * cross(vp + cross(wp,c) - cross(Zetap,AB)',BC));
eq2=dot(cross(Zetapp,AB)'+ cross(Zetap,cross(Zetap,AB))'+
cross(wr,cross(wr,BC)) –
vpp-cross(wpp,c)-cross(wp,cross(wp,c)),BC);
[C,D]=coeffs(eq2,[zetapp(i), Xpdotdot]);
Jp1(i,:)=-C(2:7)/C(1);
Jp2(i,1)=-C(8)/C(1);
function [Jrbrazo,Jwbrazo,Jwrod,Jrrod]= jacobianasLinks(Jp,AB,BC,c)
Jrbrazo=zeros(3,6,6);
Jwbrazo=zeros(3,6,6);
Jwrod=zeros(3,6,6); Jrrod=zeros(3,6,6);
% Las expresiones fueron generadas en SimbolicasJacobianasLinks.
Jrbrazo(:,:,1) =[...
[ (ab3*jp1)/2, (ab3*jp2)/2, (ab3*jp3)/2, (ab3*jp4)/2, (ab3*jp5)/2,
(ab3*jp6)/2];...
[ 0, 0, 0, 0, 0,
[ -(ab1*jp1)/2, -(ab1*jp2)/2, -(ab1*jp3)/2, -(ab1*jp4)/2, -(ab1*jp5)/2, -
(ab1*jp6)/2]];
Jrbrazo(:,:,2) =[...
[ (ab6*jp7)/2, (ab6*jp8)/2, (ab6*jp9)/2, (ab6*jp10)/2, (ab6*jp11)/2,
(ab6*jp12)/2];...
[ 0, 0, 0, 0, 0,
[ -(ab4*jp7)/2, -(ab4*jp8)/2, -(ab4*jp9)/2, -(ab4*jp10)/2, -(ab4*jp11)/2, -
(ab4*jp12)/2]];
Jrbrazo(:,:,3) =[...
[ -(ab9*jp13)/4, -(ab9*jp14)/4,
-(ab9*jp15)/4, -(ab9*jp16)/4, -
(ab9*jp17)/4, -(ab9*jp18)/4];...
[ (3^(1/2)*ab9*jp13)/4, (3^(1/2)*ab9*jp14)/4,
(3^(1/2)*ab9*jp15)/4, (3^(1/2)*ab9*jp16)/4,
(3^(1/2)*ab9*jp17)/4, (3^(1/2)*ab9*jp18)/4];...
[ (ab7*jp13)/4 - (3^(1/2)*ab8*jp13)/4, (ab7*jp14)/4 - (3^(1/2)*ab8*jp14)/4,
(ab7*jp15)/4 - (3^(1/2)*ab8*jp15)/4, (ab7*jp16)/4 - (3^(1/2)*ab8*jp16)/4,
(ab7*jp17)/4 - (3^(1/2)*ab8*jp17)/4, (ab7*jp18)/4 - (3^(1/2)*ab8*jp18)/4]];
Jrbrazo(:,:,4) =[...
[ -(ab12*jp19)/4, -(ab12*jp20)/4,
-(ab12*jp21)/4, -(ab12*jp22)/4, -
(ab12*jp23)/4, -(ab12*jp24)/4];...
[ (3^(1/2)*ab12*jp19)/4, (3^(1/2)*ab12*jp20)/4,
(3^(1/2)*ab12*jp21)/4, (3^(1/2)*ab12*jp22)/4,
(3^(1/2)*ab12*jp23)/4, (3^(1/2)*ab12*jp24)/4];...
[ (ab10*jp19)/4 - (3^(1/2)*ab11*jp19)/4, (ab10*jp20)/4 - (3^(1/2)*ab11*jp20)/4,
(ab10*jp21)/4 - (3^(1/2)*ab11*jp21)/4, (ab10*jp22)/4 - (3^(1/2)*ab11*jp22)/4,
(ab10*jp23)/4 - (3^(1/2)*ab11*jp23)/4, (ab10*jp24)/4 - (3^(1/2)*ab11*jp24)/4]];
Jrbrazo(:,:,5) =[...
[ -(ab15*jp25)/4, -(ab15*jp26)/4,
-(ab15*jp27)/4, -(ab15*jp28)/4, -
(ab15*jp29)/4, -(ab15*jp30)/4];...
[ -(3^(1/2)*ab15*jp25)/4, -(3^(1/2)*ab15*jp26)/4,
-(3^(1/2)*ab15*jp27)/4, -(3^(1/2)*ab15*jp28)/4, -
(3^(1/2)*ab15*jp29)/4, -(3^(1/2)*ab15*jp30)/4];...
[ (ab13*jp25)/4 + (3^(1/2)*ab14*jp25)/4, (ab13*jp26)/4 + (3^(1/2)*ab14*jp26)/4,
(ab13*jp27)/4 + (3^(1/2)*ab14*jp27)/4, (ab13*jp28)/4 + (3^(1/2)*ab14*jp28)/4,
(ab13*jp29)/4 + (3^(1/2)*ab14*jp29)/4, (ab13*jp30)/4 + (3^(1/2)*ab14*jp30)/4]];
Jrbrazo(:,:,6) =[...
[ -(ab18*jp31)/4, -(ab18*jp32)/4,
-(ab18*jp33)/4, -(ab18*jp34)/4, -
(ab18*jp35)/4, -(ab18*jp36)/4];...
[ -(3^(1/2)*ab18*jp31)/4, -(3^(1/2)*ab18*jp32)/4,
-(3^(1/2)*ab18*jp33)/4, -(3^(1/2)*ab18*jp34)/4, -
(3^(1/2)*a b18*jp35)/4, -(3^(1/2)*ab18*jp36)/4];...
[ (ab16*jp31)/4 + (3^(1/2)*ab17*jp31)/4, (ab16*jp32)/4 + (3^(1/2)*ab17*jp32)/4,
(ab16*jp33)/4 + (3^(1/2)*ab17*jp33)/4, (ab16*jp34)/4 + (3^(1/2)*ab17*jp34)/4,
(ab16*jp35)/4 + (3^(1/2)*ab17*jp35)/4, (ab16*jp36)/4 + (3^(1/2)*ab17*jp36)/4]];
Jwbrazo(:,:,1) =[...
 ;...
[ jp1, jp2, jp3, jp4, jp5, jp6];...
 ];
Jwbrazo(:,:,2) =[...
 ;...
[ jp7, jp8, jp9, jp10, jp11, jp12];...
 ];
Jwbrazo(:,:,3) =[...
[ -(3^(1/2)*jp13)/2, -(3^(1/2)*jp14)/2, -(3^(1/2)*jp15)/2, -(3^(1/2)*jp16)/2, -
(3^(1/2)*jp17)/2, -(3^(1/2)*jp18)/2];...
[ -jp13/2, -jp14/2, -jp15/2, -jp16/2,
-jp17/2, -jp18/2];...
[ 0, 0, 0, 0,
Jwbrazo(:,:,4) =[...
[ -(3^(1/2)*jp19)/2, -(3^(1/2)*jp20)/2, -(3^(1/2)*jp21)/2, -(3^(1/2)*jp22)/2, -
(3^(1/2)*jp23)/2, -(3^(1/2)*jp24)/2];...
[ -jp19/2, -jp20/2, -jp21/2, -jp22/2,
-jp23/2, -jp24/2];...
[ 0, 0, 0, 0,
Jwbrazo(:,:,5) =[...
[ (3^(1/2)*jp25)/2, (3^(1/2)*jp26)/2, (3^(1/2)*jp27)/2, (3^(1/2)*jp28)/2,
(3^(1/2)*jp29)/2, (3^(1/2)*jp30)/2];...
[ -jp25/2, -jp26/2, -jp27/2, -jp28/2, jp29/2, -jp30/2];...
[ 0, 0, 0, 0,
Jwbrazo(:,:,6) =[...
[ (3^(1/2)*jp31)/2, (3^(1/2)*jp32)/2, (3^(1/2)*jp33)/2, (3^(1/2)*jp34)/2,
(3^(1/2)*jp35)/2, (3^(1/2)*jp36)/2];...
-jp31/2, -jp32/2, -jp33/2, -jp34/2, -jp35/2,
-jp36/2];...
[ 0, 0, 0, 0,
Jwrod(:,:,1) =[...
[ (ab1*bc2*jp1)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2),
-(bc3 - ab1*bc2*jp2)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2),
(bc2*(ab1*jp3 + 1))/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), (bc3*c3 + bc2*(c2 +
ab1*jp4))/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), -(bc2*(c1 -
ab1*jp5))/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), -(bc3*c1 -
ab1*bc2*jp6)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)];...
[ -(bc3*(ab3*jp1 - 1) + ab1*bc1*jp1)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), -
(ab1*bc1*jp2 + ab3*bc3*jp2)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), -(bc1*(ab1*jp3 +
1) + ab3*bc3*jp3)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), -(bc1*(c2 + ab1*jp4) +
ab3*bc3*jp4)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), (bc1*(c1 - ab1*jp5) + bc3*(c3 -
ab3*jp5))/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), -(bc3*(c2 + ab3*jp6) +
ab1*bc1*jp6)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)];...
[ (bc2*(ab3*jp1 - 1))/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2),
(bc1 + ab3*bc2*jp2)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2),
(ab3*bc2*jp3)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), -(bc1*c3 -
ab3*bc2*jp4)/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), -(bc2*(c3 -
ab3*jp5))/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2), (bc1*c1 + bc2*(c2 +
ab3*jp6))/(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)]];
Jwrod(:,:,2) =[...
[ (ab4*bc5*jp7)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2),
-(bc6 - ab4*bc5*jp8)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2),
(bc5*(ab4*jp9 + 1))/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), (bc6*c6 + bc5*(c5
+ ab4*jp10))/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), -(bc5*(c4 -
ab4*jp11))/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), -(bc6*c4 -
ab4*bc5*jp12)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)];...
[ -(bc6*(ab6*jp7 - 1) + ab4*bc4*jp7)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), -
(ab4*bc4*jp8 + ab6*bc6*jp8)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), -(bc4*(ab4*jp9 +
1) + ab6*bc6*jp9)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), -(bc4*(c5 + ab4*jp10) +
ab6*bc6*jp10)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), (bc4*(c4 - ab4*jp11) + bc6*(c6
- ab6*jp11))/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), -(bc6*(c5 + ab6*jp12) +
ab4*bc4*jp12)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)];...
[ (bc5*(ab6*jp7 - 1))/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2),
(bc4 + ab6*bc5*jp8)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2),
(ab6*bc5*jp9)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), -(bc4*c6 -
ab6*bc5*jp10)/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), -(bc5*(c6
- ab6*jp11))/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2), (bc4*c4 + bc5*(c5 +
ab6*jp12))/(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)]];
Jwrod(:,:,3) =[...
[ -(bc8*((ab7*jp13)/2 - (3^(1/2)*ab8*jp13)/2) - (3^(1/2)*ab9*bc9*jp13)/2)/(abs(bc7)^2
+ abs(bc8)^2 + abs(bc9)^2), (bc9*((3^(1/2)*ab9*jp14)/2 - 1) - bc8*((ab7*jp14)/2 -
(3^(1/2)*ab8*jp14)/2))/(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2),
(bc8*((3^(1/2)*ab8*jp15)/2 - (ab7*jp15)/2 + 1) +
(3^(1/2)*ab9*bc9*jp15)/2)/(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2), (bc9*(c9 +
(3^(1/2)*ab9*jp16)/2) + bc8*(c8 - (ab7*jp16)/2 + (3^(1/2)*ab8*jp16)/2))/(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2), -(bc8*(c7 + (ab7*jp17)/2 - (3^(1/2)*ab8*jp17)/2) -
(3^(1/2)*ab9*bc9*jp17)/2)/(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2), -(bc9*(c7 -
(3^(1/2)*ab9*jp18)/2) + bc8*((ab7*jp18)/2 - (3^(1/2)*ab8*jp18)/2))/(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2)];...
[ (bc9*((ab9*jp13)/2 + 1) + bc7*((ab7*jp13)/2 - (3^(1/2)*ab8*jp13)/2))/(abs(bc7)^2
+ abs(bc8)^2 + abs(bc9)^2), (bc7*((ab7*jp14)/2 - (3^(1/2)*ab8*jp14)/2)
+ (ab9*bc9*jp14)/2)/(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2), -
(bc7*((3^(1/2)*ab8*jp15)/2 - (ab7*jp15)/2 + 1) - (ab9*bc9*jp15)/2)/(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2), -(bc7*(c8 - (ab7*jp16)/2 +
(3^(1/2)*ab8*jp16)/2) - (ab9*bc9*jp16)/2)/(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2),
(bc7*(c7 + (ab7*jp17)/2 - (3^(1/2)*ab8*jp17)/2) + bc9*(c9 +
(ab9*jp17)/2))/(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2), -(bc9*(c8 -
(ab9*jp18)/2) - bc7*((ab7*jp18)/2 - (3^(1/2)*ab8*jp18)/2))/(abs(bc7)^2 + abs(bc8)^2 +
abs(bc9)^2)];...
[ -(bc8*((ab9*jp13)/2 + 1) + (3^(1/2)*ab9*bc7*jp13)/2)/(abs(bc7)^2
+ abs(bc8)^2 + abs(bc9)^2), -(bc7*((3^(1/2)*ab9*jp14)/2 - 1)
+ (ab9*bc8*jp14)/2)/(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2),
-((ab9*bc8*jp15)/2 + (3^(1/2)*ab9*bc7*jp15)/2)/(abs(bc7)^2 + abs(bc8)^2 +
abs(bc9)^2), -(bc7*(c9 + (3^(1/2)*ab9*jp16)/2) +
(ab9*bc8*jp16)/2)/(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2), -
(bc8*(c9 + (ab9*jp17)/2) + (3^(1/2)*ab9*bc7*jp17)/2)/(abs(bc7)^2 + abs(bc8)^2 +
abs(bc9)^2), (bc7*(c7 - (3^(1/2)*ab9*jp18)/2) + bc8*(c8 -
(ab9*jp18)/2))/(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)]];
Jwrod(:,:,4) =[...
[ -(bc11*((ab10*jp19)/2 - (3^(1/2)*ab11*jp19)/2) -
(3^(1/2)*ab12*bc12*jp19)/2)/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2),
(bc12*((3^(1/2)*ab12*jp20)/2 - 1) - bc11*((ab10*jp20)/2 -
(3^(1/2)*ab11*jp20)/2))/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2),
(bc11*((3^(1/2)*ab11*jp21)/2 - (ab10*jp21)/2 + 1) +
(3^(1/2)*ab12*bc12*jp21)/2)/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2), (bc12*(c12 +
(3^(1/2)*ab12*jp22)/2) + bc11*(c11 - (ab10*jp22)/2 +
(3^(1/2)*ab11*jp22)/2))/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2), -(bc11*(c10 +
(ab10*jp23)/2 - (3^(1/2)*ab11*jp23)/2) - (3^(1/2)*ab12*bc12*jp23)/2)/(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2), -(bc12*(c10 - (3^(1/2)*ab12*jp24)/2) +
bc11*((ab10*jp24)/2 - (3^(1/2)*ab11*jp24)/2))/(abs(bc10)^2 + abs(bc11)^2 +
abs(bc12)^2)];...
[ (bc12*((ab12*jp19)/2 + 1) + bc10*((ab10*jp19)/2 -
(3^(1/2)*ab11*jp19)/2))/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2),
(bc10*((ab10*jp20)/2 - (3^(1/2)*ab11*jp20)/2) + (ab12*bc12*jp20)/2)/(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2), -(bc10*((3^(1/2)*ab11*jp21)/2 - (ab10*jp21)/2 + 1)
- (ab12*bc12*jp21)/2)/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2), -
(bc10*(c11 - (ab10*jp22)/2 + (3^(1/2)*ab11*jp22)/2) -
(ab12*bc12*jp22)/2)/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2), (bc10*(c10 +
(ab10*jp23)/2 - (3^(1/2)*ab11*jp23)/2) + bc12*(c12 + (ab12*jp23)/2))/(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2), -(bc12*(c11 - (ab12*jp24)/2) -
bc10*((ab10*jp24)/2 - (3^(1/2)*ab11*jp24)/2))/(abs(bc10)^2 + abs(bc11)^2 +
abs(bc12)^2)];...
[ -(bc11*((ab12*jp19)/2 + 1) +
(3^(1/2)*ab12*bc10*jp19)/2)/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2),
-(bc10*((3^(1/2)*ab12*jp20)/2 - 1) + (ab12*bc11*jp20)/2)/(abs(bc10)^2 + abs(bc11)^2 +
abs(bc12)^2), -((ab12*bc11*jp21)/2 +
(3^(1/2)*ab12*bc10*jp21)/2)/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2),
-(bc10*(c12 + (3^(1/2)*ab12*jp22)/2) + (ab12*bc11*jp22)/2)/(abs(bc10)^2 + abs(bc11)^2
+ abs(bc12)^2), -(bc11*(c12 + (ab12*jp23)/2) +
(3^(1/2)*ab12*bc10*jp23)/2)/(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2),
(bc10*(c10 - (3^(1/2)*ab12*jp24)/2) + bc11*(c11 - (ab12*jp24)/2))/(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2)]];
Jwrod(:,:,5) =[...
[ -(bc14*((ab13*jp25)/2 + (3^(1/2)*ab14*jp25)/2) +
(3^(1/2)*ab15*bc15*jp25)/2)/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2), -
(bc15*((3^(1/2)*ab15*jp26)/2 + 1) + bc14*((ab13*jp26)/2 +
(3^(1/2)*ab14*jp26)/2))/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2), -
(bc14*((ab13*jp27)/2 + (3^(1/2)*ab14*jp27)/2 - 1) +
(3^(1/2)*ab15*bc15*jp27)/2)/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2), (bc15*(c15 -
(3^(1/2)*ab15*jp28)/2) - bc14*((ab13*jp28)/2 - c14 +
(3^(1/2)*ab14*jp28)/2))/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2), -(bc14*(c13 +
(ab13*jp29)/2 + (3^(1/2)*ab14*jp29)/2) + (3^(1/2)*ab15*bc15*jp29)/2)/(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2), -(bc15*(c13 + (3^(1/2)*ab15*jp30)/2) +
bc14*((ab13*jp30)/2 + (3^(1/2)*ab14*jp30)/2))/(abs(bc13)^2 + abs(bc14)^2 +
abs(bc15)^2)];...
[ (bc15*((ab15*jp25)/2 + 1) + bc13*((ab13*jp25)/2 +
(3^(1/2)*ab14*jp25)/2))/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2),
(bc13*((ab13*jp26)/2 + (3^(1/2)*ab14*jp26)/2) + (ab15*bc15*jp26)/2)/(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2), (bc13*((ab13*jp27)/2 + (3^(1/2)*ab14*jp27)/2 -
1) + (ab15*bc15*jp27)/2)/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2),
(bc13*((ab13*jp28)/2 - c14 + (3^(1/2)*ab14*jp28)/2) +
(ab15*bc15*jp28)/2)/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2), (bc13*(c13 +
(ab13*jp29)/2 + (3^(1/2)*ab14*jp29)/2) + bc15*(c15 + (ab15*jp29)/2))/(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2), -(bc15*(c14 - (ab15*jp30)/2) -
bc13*((ab13*jp30)/2 + (3^(1/2)*ab14*jp30)/2))/(abs(bc13)^2 + abs(bc14)^2 +
abs(bc15)^2)];...
[ -(bc14*((ab15*jp25)/2 + 1) -
(3^(1/2)*ab15*bc13*jp25)/2)/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2),
(bc13*((3^(1/2)*ab15*jp26)/2 + 1) - (ab15*bc14*jp26)/2)/(abs(bc13)^2 + abs(bc14)^2 +
abs(bc15)^2), -((ab15*bc14*jp27)/2 -
(3^(1/2)*ab15*bc13*jp27)/2)/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2),
-(bc13*(c15 - (3^(1/2)*ab15*jp28)/2) + (ab15*bc14*jp28)/2)/(abs(bc13)^2 + abs(bc14)^2
+ abs(bc15)^2), -(bc14*(c15 + (ab15*jp29)/2) -
(3^(1/2)*ab15*bc13*jp29)/2)/(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2),
(bc13*(c13 + (3^(1/2)*ab15*jp30)/2) + bc14*(c14 - (ab15*jp30)/2))/(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2)]];
Jwrod(:,:,6) =[...
[ -(bc17*((ab16*jp31)/2 + (3^(1/2)*ab17*jp31)/2) +
(3^(1/2)*ab18*bc18*jp31)/2)/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2), -
(bc18*((3^(1/2)*ab18*jp32)/2 + 1) + bc17*((ab16*jp32)/2 +
(3^(1/2)*ab17*jp32)/2))/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2), -
(bc17*((ab16*jp33)/2 + (3^(1/2)*ab17*jp33)/2 - 1) +
(3^(1/2)*ab18*bc18*jp33)/2)/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2), (bc18*(c18 -
(3^(1/2)*ab18*jp34)/2) - bc17*((ab16*jp34)/2 - c17 +
(3^(1/2)*ab17*jp34)/2))/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2), -(bc17*(c16 +
(ab16*jp35)/2 + (3^(1/2)*ab17*jp35)/2) + (3^(1/2)*ab18*bc18*jp35)/2)/(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2), -(bc18*(c16 + (3^(1/2)*ab18*jp36)/2) +
bc17*((ab16*jp36)/2 + (3^(1/2)*ab17*jp36)/2))/(abs(bc16)^2 + abs(bc17)^2 +
abs(bc18)^2)];...
[ (bc18*((ab18*jp31)/2 + 1) + bc16*((ab16*jp31)/2 +
(3^(1/2)*ab17*jp31)/2))/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2),
(bc16*((ab16*jp32)/2 + (3^(1/2)*ab17*jp32)/2) + (ab18*bc18*jp32)/2)/(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2), (bc16*((ab16*jp33)/2 + (3^(1/2)*ab17*jp33)/2 -
1) + (ab18*bc18*jp33)/2)/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2),
(bc16*((ab16*jp34)/2 - c17 + (3^(1/2)*ab17*jp34)/2) +
(ab18*bc18*jp34)/2)/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2), (bc16*(c16 +
(ab16*jp35)/2 + (3^(1/2)*ab17*jp35)/2) + bc18*(c18 + (ab18*jp35)/2))/(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2), -(bc18*(c17 - (ab18*jp36)/2) -
bc16*((ab16*jp36)/2 + (3^(1/2)*ab17*jp36)/2))/(abs(bc16)^2 + abs(bc17)^2 +
abs(bc18)^2)];...
[ -(bc17*((ab18*jp31)/2 + 1) -
(3^(1/2)*ab18*bc16*jp31)/2)/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2),
(bc16*((3^(1/2)*ab18*jp32)/2 + 1) - (ab18*bc17*jp32)/2)/(abs(bc16)^2 + abs(bc17)^2 +
abs(bc18)^2), -((ab18*bc17*jp33)/2 -
(3^(1/2)*ab18*bc16*jp33)/2)/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2),
-(bc16*(c18 - (3^(1/2)*ab18*jp34)/2) + (ab18*bc17*jp34)/2)/(abs(bc16)^2 + abs(bc17)^2
+ abs(bc18)^2), -(bc17*(c18 + (ab18*jp35)/2) -
(3^(1/2)*ab18*bc16*jp35)/2)/(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2),
(bc16*(c16 + (3^(1/2)*ab18*jp36)/2) + bc17*(c17 - (ab18*jp36)/2))/(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2)]];
Jrrod(:,:,1) =[...
[ - (bc3*(bc3*(ab3*jp1 - 1) + ab1*bc1*jp1))/(2*(abs(bc1)^2 + abs(bc2)^2 +
abs(bc3)^2)) - (bc2^2*(ab3*jp1 - 1))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)), -
(bc2*(bc1 + ab3*bc2*jp2))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) -
(bc3*(ab1*bc1*jp2 + ab3*bc3*jp2))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)), -
(bc3*(bc1*(ab1*jp3 + 1) + ab3*bc3*jp3))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) -
(ab3*bc2^2*jp3)/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)), (bc2*(bc1*c3 -
ab3*bc2*jp4))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) - (bc3*(bc1*(c2 + ab1*jp4) +
ab3*bc3*jp4))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)), (bc2^2*(c3 -
ab3*jp5))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) + (bc3*(bc1*(c1 - ab1*jp5) +
bc3*(c3 - ab3*jp5)))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)), - (bc2*(bc1*c1 +
bc2*(c2 + ab3*jp6)))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) - (bc3*(bc3*(c2 +
ab3*jp6) + ab1*bc1*jp6))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2))];...
[ (bc1*bc2*(ab3*jp1 - 1))/(2*(abs(bc1)^2 + abs(bc2)^2 +
abs(bc3)^2)) - (ab1*bc2*bc3*jp1)/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)),
(bc1*(bc1 + ab3*bc2*jp2))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) + (bc3*(bc3 -
ab1*bc2*jp2))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)),
(ab3*bc1*bc2*jp3)/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) - (bc2*bc3*(ab1*jp3 +
1))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)), - (bc3*(bc3*c3 + bc2*(c2 +
ab1*jp4)))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) - (bc1*(bc1*c3 -
ab3*bc2*jp4))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)),
(bc2*bc3*(c1 - ab1*jp5))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) - (bc1*bc2*(c3 -
ab3*jp5))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)), (bc1*(bc1*c1 +
bc2*(c2 + ab3*jp6)))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) + (bc3*(bc3*c1 -
ab1*bc2*jp6))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2))];...
[ (bc1*(bc3*(ab3*jp1 - 1) + ab1*bc1*jp1))/(2*(abs(bc1)^2 + abs(bc2)^2 +
abs(bc3)^2)) + (ab1*bc2^2*jp1)/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)),
(bc1*(ab1*bc1*jp2 + ab3*bc3*jp2))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) -
(bc2*(bc3 - ab1*bc2*jp2))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)),
(bc1*(bc1*(ab1*jp3 + 1) + ab3*bc3*jp3))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) +
(bc2^2*(ab1*jp3 + 1))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)), (bc2*(bc3*c3 +
bc2*(c2 + ab1*jp4)))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) + (bc1*(bc1*(c2 +
ab1*jp4) + ab3*bc3*jp4))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)), - (bc2^2*(c1 -
ab1*jp5))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) - (bc1*(bc1*(c1 - ab1*jp5) +
bc3*(c3 - ab3*jp5)))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)),
(bc1*(bc3*(c2 + ab3*jp6) + ab1*bc1*jp6))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2)) -
(bc2*(bc3*c1 - ab1*bc2*jp6))/(2*(abs(bc1)^2 + abs(bc2)^2 + abs(bc3)^2))]];
Jrrod(:,:,2) =[...
[ - (bc6*(bc6*(ab6*jp7 - 1) + ab4*bc4*jp7))/(2*(abs(bc4)^2 + abs(bc5)^2 +
abs(bc6)^2)) - (bc5^2*(ab6*jp7 - 1))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)), -
(bc5*(bc4 + ab6*bc5*jp8))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) -
(bc6*(ab4*bc4*jp8 + ab6*bc6*jp8))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)), -
(bc6*(bc4*(ab4*jp9 + 1) + ab6*bc6*jp9))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) -
(ab6*bc5^2*jp9)/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)), (bc5*(bc4*c6 -
ab6*bc5*jp10))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) - (bc6*(bc4*(c5 + ab4*jp10)
+ ab6*bc6*jp10))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)), (bc5^2*(c6 -
ab6*jp11))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) + (bc6*(bc4*(c4 - ab4*jp11) +
bc6*(c6 - ab6*jp11)))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)), - (bc5*(bc4*c4 +
bc5*(c5 + ab6*jp12)))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) - (bc6*(bc6*(c5 +
ab6*jp12) + ab4*bc4*jp12))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2))];...
[ (bc4*bc5*(ab6*jp7 - 1))/(2*(abs(bc4)^2 + abs(bc5)^2 +
abs(bc6)^2)) - (ab4*bc5*bc6*jp7)/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)),
(bc4*(bc4 + ab6*bc5*jp8))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) + (bc6*(bc6 -
ab4*bc5*jp8))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)),
(ab6*bc4*bc5*jp9)/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) - (bc5*bc6*(ab4*jp9 +
1))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)), - (bc6*(bc6*c6 + bc5*(c5 +
ab4*jp10)))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) - (bc4*(bc4*c6 -
ab6*bc5*jp10))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)),
(bc5*bc6*(c4 - ab4*jp11))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) - (bc4*bc5*(c6 -
ab6*jp11))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)), (bc4*(bc4*c4 +
bc5*(c5 + ab6*jp12)))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) + (bc6*(bc6*c4 -
ab4*bc5*jp12))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2))];...
[ (bc4*(bc6*(ab6*jp7 - 1) + ab4*bc4*jp7))/(2*(abs(bc4)^2 + abs(bc5)^2 +
abs(bc6)^2)) + (ab4*bc5^2*jp7)/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)),
(bc4*(ab4*bc4*jp8 + ab6*bc6*jp8))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) -
(bc5*(bc6 - ab4*bc5*jp8))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)),
(bc4*(bc4*(ab4*jp9 + 1) + ab6*bc6*jp9))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) +
(bc5^2*(ab4*jp9 + 1))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)), (bc5*(bc6*c6 +
bc5*(c5 + ab4*jp10)))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) + (bc4*(bc4*(c5 +
ab4*jp10) + ab6*bc6*jp10))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)), - (bc5^2*(c4 -
ab4*jp11))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)) - (bc4*(bc4*(c4 - ab4*jp11) +
bc6*(c6 - ab6*jp11)))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2)),
(bc4*(bc6*(c5 + ab6*jp12) + ab4*bc4*jp12))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2))
- (bc5*(bc6*c4 - ab4*bc5*jp12))/(2*(abs(bc4)^2 + abs(bc5)^2 + abs(bc6)^2))]];
Jrrod(:,:,3) =[...
[ (bc9*(bc9*((ab9*jp13)/2 + 1) + bc7*((ab7*jp13)/2 -
(3^(1/2)*ab8*jp13)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) +
(bc8*(bc8*((ab9*jp13)/2 + 1) + (3^(1/2)*ab9*bc7*jp13)/2))/(2*(abs(bc7)^2 + abs(bc8)^2
+ abs(bc9)^2)), (bc8*(bc7*((3^(1/2)*ab9*jp14)/2 - 1) +
(ab9*bc8*jp14)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) +
(bc9*(bc7*((ab7*jp14)/2 - (3^(1/2)*ab8*jp14)/2) + (ab9*bc9*jp14)/2))/(2*(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2)), (bc8*((ab9*bc8*jp15)/2 +
(3^(1/2)*ab9*bc7*jp15)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) -
(bc9*(bc7*((3^(1/2)*ab8*jp15)/2 - (ab7*jp15)/2 + 1) -
(ab9*bc9*jp15)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)),
(bc8*(bc7*(c9 + (3^(1/2)*ab9*jp16)/2) + (ab9*bc8*jp16)/2))/(2*(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2)) - (bc9*(bc7*(c8 - (ab7*jp16)/2 + (3^(1/2)*ab8*jp16)/2) -
(ab9*bc9*jp16)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)),
(bc9*(bc7*(c7 + (ab7*jp17)/2 - (3^(1/2)*ab8*jp17)/2) + bc9*(c9 +
(ab9*jp17)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) + (bc8*(bc8*(c9 +
(ab9*jp17)/2) + (3^(1/2)*ab9*bc7*jp17)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 +
abs(bc9)^2)), - (bc8*(bc7*(c7 - (3^(1/2)*ab9*jp18)/2) + bc8*(c8 -
(ab9*jp18)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) - (bc9*(bc9*(c8 -
(ab9*jp18)/2) - bc7*((ab7*jp18)/2 - (3^(1/2)*ab8*jp18)/2)))/(2*(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2))];...
[ (bc9*(bc8*((ab7*jp13)/2 - (3^(1/2)*ab8*jp13)/2) -
(3^(1/2)*ab9*bc9*jp13)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) -
(bc7*(bc8*((ab9*jp13)/2 + 1) + (3^(1/2)*ab9*bc7*jp13)/2))/(2*(abs(bc7)^2 + abs(bc8)^2
+ abs(bc9)^2)), - (bc7*(bc7*((3^(1/2)*ab9*jp14)/2 - 1) +
(ab9*bc8*jp14)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) -
(bc9*(bc9*((3^(1/2)*ab9*jp14)/2 - 1) - bc8*((ab7*jp14)/2 -
(3^(1/2)*ab8*jp14)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)),
- (bc9*(bc8*((3^(1/2)*ab8*jp15)/2 - (ab7*jp15)/2 + 1) +
(3^(1/2)*ab9*bc9*jp15)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) -
(bc7*((ab9*bc8*jp15)/2 + (3^(1/2)*ab9*bc7*jp15)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 +
abs(bc9)^2)), - (bc9*(bc9*(c9 + (3^(1/2)*ab9*jp16)/2) + bc8*(c8 -
(ab7*jp16)/2 + (3^(1/2)*ab8*jp16)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) -
(bc7*(bc7*(c9 + (3^(1/2)*ab9*jp16)/2) + (ab9*bc8*jp16)/2))/(2*(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2)), (bc9*(bc8*(c7 + (ab7*jp17)/2 -
(3^(1/2)*ab8*jp17)/2) - (3^(1/2)*ab9*bc9*jp17)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 +
abs(bc9)^2)) - (bc7*(bc8*(c9 + (ab9*jp17)/2) +
(3^(1/2)*ab9*bc7*jp17)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)),
(bc7*(bc7*(c7 - (3^(1/2)*ab9*jp18)/2) + bc8*(c8 - (ab9*jp18)/2)))/(2*(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2)) + (bc9*(bc9*(c7 - (3^(1/2)*ab9*jp18)/2) + bc8*((ab7*jp18)/2
- (3^(1/2)*ab8*jp18)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2))];...
[ - (bc8*(bc8*((ab7*jp13)/2 - (3^(1/2)*ab8*jp13)/2) -
(3^(1/2)*ab9*bc9*jp13)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) -
(bc7*(bc9*((ab9*jp13)/2 + 1) + bc7*((ab7*jp13)/2 -
(3^(1/2)*ab8*jp13)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)),
(bc8*(bc9*((3^(1/2)*ab9*jp14)/2 - 1) - bc8*((ab7*jp14)/2 -
(3^(1/2)*ab8*jp14)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) -
(bc7*(bc7*((ab7*jp14)/2 - (3^(1/2)*ab8*jp14)/2) + (ab9*bc9*jp14)/2))/(2*(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2)), (bc8*(bc8*((3^(1/2)*ab8*jp15)/2 - (ab7*jp15)/2 + 1) +
(3^(1/2)*ab9*bc9*jp15)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)) +
(bc7*(bc7*((3^(1/2)*ab8*jp15)/2 - (ab7*jp15)/2 + 1) -
(ab9*bc9*jp15)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)), (bc7*(bc7*(c8 -
(ab7*jp16)/2 + (3^(1/2)*ab8*jp16)/2) - (ab9*bc9*jp16)/2))/(2*(abs(bc7)^2 + abs(bc8)^2
+ abs(bc9)^2)) + (bc8*(bc9*(c9 + (3^(1/2)*ab9*jp16)/2) + bc8*(c8 - (ab7*jp16)/2 +
(3^(1/2)*ab8*jp16)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)), - (bc7*(bc7*(c7 +
(ab7*jp17)/2 - (3^(1/2)*ab8*jp17)/2) + bc9*(c9 + (ab9*jp17)/2)))/(2*(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2)) - (bc8*(bc8*(c7 + (ab7*jp17)/2 - (3^(1/2)*ab8*jp17)/2) -
(3^(1/2)*ab9*bc9*jp17)/2))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2)), (bc7*(bc9*(c8
- (ab9*jp18)/2) - bc7*((ab7*jp18)/2 - (3^(1/2)*ab8*jp18)/2)))/(2*(abs(bc7)^2 +
abs(bc8)^2 + abs(bc9)^2)) - (bc8*(bc9*(c7 - (3^(1/2)*ab9*jp18)/2) + bc8*((ab7*jp18)/2
- (3^(1/2)*ab8*jp18)/2)))/(2*(abs(bc7)^2 + abs(bc8)^2 + abs(bc9)^2))]];
Jrrod(:,:,4) =[...
[ (bc12*(bc12*((ab12*jp19)/2 + 1) + bc10*((ab10*jp19)/2 -
(3^(1/2)*ab11*jp19)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) +
(bc11*(bc11*((ab12*jp19)/2 + 1) + (3^(1/2)*ab12*bc10*jp19)/2))/(2*(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2)),
(bc11*(bc10*((3^(1/2)*ab12*jp20)/2 - 1) + (ab12*bc11*jp20)/2))/(2*(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2)) + (bc12*(bc10*((ab10*jp20)/2 - (3^(1/2)*ab11*jp20)/2) +
(ab12*bc12*jp20)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)),
(bc11*((ab12*bc11*jp21)/2 + (3^(1/2)*ab12*bc10*jp21)/2))/(2*(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2)) - (bc12*(bc10*((3^(1/2)*ab11*jp21)/2 - (ab10*jp21)/2 + 1)
- (ab12*bc12*jp21)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)),
(bc11*(bc10*(c12 + (3^(1/2)*ab12*jp22)/2) + (ab12*bc11*jp22)/2))/(2*(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2)) - (bc12*(bc10*(c11 - (ab10*jp22)/2 +
(3^(1/2)*ab11*jp22)/2) - (ab12*bc12*jp22)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 +
abs(bc12)^2)), (bc12*(bc10*(c10 + (ab10*jp23)/2 -
(3^(1/2)*ab11*jp23)/2) + bc12*(c12 + (ab12*jp23)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 +
abs(bc12)^2)) + (bc11*(bc11*(c12 + (ab12*jp23)/2) +
(3^(1/2)*ab12*bc10*jp23)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)),
- (bc11*(bc10*(c10 - (3^(1/2)*ab12*jp24)/2) + bc11*(c11 -
(ab12*jp24)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) - (bc12*(bc12*(c11 -
(ab12*jp24)/2) - bc10*((ab10*jp24)/2 - (3^(1/2)*ab11*jp24)/2)))/(2*(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2))];...
[ (bc12*(bc11*((ab10*jp19)/2 - (3^(1/2)*ab11*jp19)/2) -
(3^(1/2)*ab12*bc12*jp19)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) -
(bc10*(bc11*((ab12*jp19)/2 + 1) + (3^(1/2)*ab12*bc10*jp19)/2))/(2*(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2)), - (bc10*(bc10*((3^(1/2)*ab12*jp20)/2 - 1) +
(ab12*bc11*jp20)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) -
(bc12*(bc12*((3^(1/2)*ab12*jp20)/2 - 1) - bc11*((ab10*jp20)/2 -
(3^(1/2)*ab11*jp20)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)),
- (bc12*(bc11*((3^(1/2)*ab11*jp21)/2 - (ab10*jp21)/2 + 1) +
(3^(1/2)*ab12*bc12*jp21)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) -
(bc10*((ab12*bc11*jp21)/2 + (3^(1/2)*ab12*bc10*jp21)/2))/(2*(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2)), - (bc12*(bc12*(c12 +
(3^(1/2)*ab12*jp22)/2) + bc11*(c11 - (ab10*jp22)/2 +
(3^(1/2)*ab11*jp22)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) -
(bc10*(bc10*(c12 + (3^(1/2)*ab12*jp22)/2) + (ab12*bc11*jp22)/2))/(2*(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2)), (bc12*(bc11*(c10 +
(ab10*jp23)/2 - (3^(1/2)*ab11*jp23)/2) - (3^(1/2)*ab12*bc12*jp23)/2))/(2*(abs(bc10)^2
+ abs(bc11)^2 + abs(bc12)^2)) - (bc10*(bc11*(c12 + (ab12*jp23)/2) +
(3^(1/2)*ab12*bc10*jp23)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)),
(bc10*(bc10*(c10 - (3^(1/2)*ab12*jp24)/2) + bc11*(c11 -
(ab12*jp24)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) + (bc12*(bc12*(c10 -
(3^(1/2)*ab12*jp24)/2) + bc11*((ab10*jp24)/2 -
(3^(1/2)*ab11*jp24)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2))];...
[ - (bc11*(bc11*((ab10*jp19)/2 - (3^(1/2)*ab11*jp19)/2) -
(3^(1/2)*ab12*bc12*jp19)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) -
(bc10*(bc12*((ab12*jp19)/2 + 1) + bc10*((ab10*jp19)/2 -
(3^(1/2)*ab11*jp19)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)),
(bc11*(bc12*((3^(1/2)*ab12*jp20)/2 - 1) - bc11*((ab10*jp20)/2 -
(3^(1/2)*ab11*jp20)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) -
(bc10*(bc10*((ab10*jp20)/2 - (3^(1/2)*ab11*jp20)/2) +
(ab12*bc12*jp20)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)),
(bc11*(bc11*((3^(1/2)*ab11*jp21)/2 - (ab10*jp21)/2 + 1) +
(3^(1/2)*ab12*bc12*jp21)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) +
(bc10*(bc10*((3^(1/2)*ab11*jp21)/2 - (ab10*jp21)/2 + 1) -
(ab12*bc12*jp21)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)), (bc10*(bc10*(c11
- (ab10*jp22)/2 + (3^(1/2)*ab11*jp22)/2) - (ab12*bc12*jp22)/2))/(2*(abs(bc10)^2 +
abs(bc11)^2 + abs(bc12)^2)) + (bc11*(bc12*(c12 + (3^(1/2)*ab12*jp22)/2) + bc11*(c11 -
(ab10*jp22)/2 + (3^(1/2)*ab11*jp22)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 +
abs(bc12)^2)), - (bc10*(bc10*(c10 + (ab10*jp23)/2 - (3^(1/2)*ab11*jp23)/2) +
bc12*(c12 + (ab12*jp23)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) -
(bc11*(bc11*(c10 + (ab10*jp23)/2 - (3^(1/2)*ab11*jp23)/2) -
(3^(1/2)*ab12*bc12*jp23)/2))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)),
(bc10*(bc12*(c11 - (ab12*jp24)/2) - bc10*((ab10*jp24)/2 -
(3^(1/2)*ab11*jp24)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2)) -
(bc11*(bc12*(c10 - (3^(1/2)*ab12*jp24)/2) + bc11*((ab10*jp24)/2 -
(3^(1/2)*ab11*jp24)/2)))/(2*(abs(bc10)^2 + abs(bc11)^2 + abs(bc12)^2))]];
Jrrod(:,:,5) =[...
[ (bc15*(bc15*((ab15*jp25)/2 + 1) + bc13*((ab13*jp25)/2 +
(3^(1/2)*ab14*jp25)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) +
(bc14*(bc14*((ab15*jp25)/2 + 1) - (3^(1/2)*ab15*bc13*jp25)/2))/(2*(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2)), (bc15*(bc13*((ab13*jp26)/2 +
(3^(1/2)*ab14*jp26)/2) + (ab15*bc15*jp26)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 +
abs(bc15)^2)) - (bc14*(bc13*((3^(1/2)*ab15*jp26)/2 + 1) -
(ab15*bc14*jp26)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)),
(bc15*(bc13*((ab13*jp27)/2 + (3^(1/2)*ab14*jp27)/2 - 1) +
(ab15*bc15*jp27)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) +
(bc14*((ab15*bc14*jp27)/2 - (3^(1/2)*ab15*bc13*jp27)/2))/(2*(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2)),
(bc15*(bc13*((ab13*jp28)/2 - c14 + (3^(1/2)*ab14*jp28)/2) +
(ab15*bc15*jp28)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) + (bc14*(bc13*(c15
- (3^(1/2)*ab15*jp28)/2) + (ab15*bc14*jp28)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 +
abs(bc15)^2)), (bc15*(bc13*(c13 + (ab13*jp29)/2 +
(3^(1/2)*ab14*jp29)/2) + bc15*(c15 + (ab15*jp29)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 +
abs(bc15)^2)) + (bc14*(bc14*(c15 + (ab15*jp29)/2) -
(3^(1/2)*ab15*bc13*jp29)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)),
- (bc14*(bc13*(c13 + (3^(1/2)*ab15*jp30)/2) + bc14*(c14 -
(ab15*jp30)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) - (bc15*(bc15*(c14 -
(ab15*jp30)/2) - bc13*((ab13*jp30)/2 + (3^(1/2)*ab14*jp30)/2)))/(2*(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2))];...
[ (bc15*(bc14*((ab13*jp25)/2 + (3^(1/2)*ab14*jp25)/2) +
(3^(1/2)*ab15*bc15*jp25)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) -
(bc13*(bc14*((ab15*jp25)/2 + 1) - (3^(1/2)*ab15*bc13*jp25)/2))/(2*(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2)), (bc13*(bc13*((3^(1/2)*ab15*jp26)/2 + 1) -
(ab15*bc14*jp26)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) +
(bc15*(bc15*((3^(1/2)*ab15*jp26)/2 + 1) + bc14*((ab13*jp26)/2 +
(3^(1/2)*ab14*jp26)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)),
(bc15*(bc14*((ab13*jp27)/2 + (3^(1/2)*ab14*jp27)/2 - 1) +
(3^(1/2)*ab15*bc15*jp27)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) -
(bc13*((ab15*bc14*jp27)/2 - (3^(1/2)*ab15*bc13*jp27)/2))/(2*(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2)), - (bc13*(bc13*(c15 -
(3^(1/2)*ab15*jp28)/2) + (ab15*bc14*jp28)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 +
abs(bc15)^2)) - (bc15*(bc15*(c15 - (3^(1/2)*ab15*jp28)/2) - bc14*((ab13*jp28)/2 - c14
+ (3^(1/2)*ab14*jp28)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)),
(bc15*(bc14*(c13 + (ab13*jp29)/2 + (3^(1/2)*ab14*jp29)/2) +
(3^(1/2)*ab15*bc15*jp29)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) -
(bc13*(bc14*(c15 + (ab15*jp29)/2) - (3^(1/2)*ab15*bc13*jp29)/2))/(2*(abs(bc13)^2 +
abs(bc14)^2 + abs(bc15)^2)), (bc13*(bc13*(c13 + (3^(1/2)*ab15*jp30)/2) +
bc14*(c14 - (ab15*jp30)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) +
(bc15*(bc15*(c13 + (3^(1/2)*ab15*jp30)/2) + bc14*((ab13*jp30)/2 +
(3^(1/2)*ab14*jp30)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2))];...
[ - (bc14*(bc14*((ab13*jp25)/2 + (3^(1/2)*ab14*jp25)/2) +
(3^(1/2)*ab15*bc15*jp25)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) -
(bc13*(bc15*((ab15*jp25)/2 + 1) + bc13*((ab13*jp25)/2 +
(3^(1/2)*ab14*jp25)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)), -
(bc13*(bc13*((ab13*jp26)/2 + (3^(1/2)*ab14*jp26)/2) +
(ab15*bc15*jp26)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) -
(bc14*(bc15*((3^(1/2)*ab15*jp26)/2 + 1) + bc14*((ab13*jp26)/2 +
(3^(1/2)*ab14*jp26)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)), -
(bc14*(bc14*((ab13*jp27)/2 + (3^(1/2)*ab14*jp27)/2 - 1) +
(3^(1/2)*ab15*bc15*jp27)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) -
(bc13*(bc13*((ab13*jp27)/2 + (3^(1/2)*ab14*jp27)/2 - 1) +
(ab15*bc15*jp27)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)), (bc14*(bc15*(c15
- (3^(1/2)*ab15*jp28)/2) - bc14*((ab13*jp28)/2 - c14 +
(3^(1/2)*ab14*jp28)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) -
(bc13*(bc13*((ab13*jp28)/2 - c14 + (3^(1/2)*ab14*jp28)/2) +
(ab15*bc15*jp28)/2))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)), -
(bc13*(bc13*(c13 + (ab13*jp29)/2 + (3^(1/2)*ab14*jp29)/2) + bc15*(c15 +
(ab15*jp29)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2)) - (bc14*(bc14*(c13 +
(ab13*jp29)/2 + (3^(1/2)*ab14*jp29)/2) + (3^(1/2)*ab15*bc15*jp29)/2))/(2*(abs(bc13)^2
+ abs(bc14)^2 + abs(bc15)^2)), (bc13*(bc15*(c14 - (ab15*jp30)/2) -
bc13*((ab13*jp30)/2 + (3^(1/2)*ab14*jp30)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 +
abs(bc15)^2)) - (bc14*(bc15*(c13 + (3^(1/2)*ab15*jp30)/2) + bc14*((ab13*jp30)/2 +
(3^(1/2)*ab14*jp30)/2)))/(2*(abs(bc13)^2 + abs(bc14)^2 + abs(bc15)^2))]];
Jrrod(:,:,6) =[...
[ (bc18*(bc18*((ab18*jp31)/2 + 1) + bc16*((ab16*jp31)/2 +
(3^(1/2)*ab17*jp31)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) +
(bc17*(bc17*((ab18*jp31)/2 + 1) - (3^(1/2)*ab18*bc16*jp31)/2))/(2*(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2)), (bc18*(bc16*((ab16*jp32)/2 +
(3^(1/2)*ab17*jp32)/2) + (ab18*bc18*jp32)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 +
abs(bc18)^2)) - (bc17*(bc16*((3^(1/2)*ab18*jp32)/2 + 1) -
(ab18*bc17*jp32)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)),
(bc18*(bc16*((ab16*jp33)/2 + (3^(1/2)*ab17*jp33)/2 - 1) +
(ab18*bc18*jp33)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) +
(bc17*((ab18*bc17*jp33)/2 - (3^(1/2)*ab18*bc16*jp33)/2))/(2*(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2)),
(bc18*(bc16*((ab16*jp34)/2 - c17 + (3^(1/2)*ab17*jp34)/2) +
(ab18*bc18*jp34)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) + (bc17*(bc16*(c18
- (3^(1/2)*ab18*jp34)/2) + (ab18*bc17*jp34)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 +
abs(bc18)^2)), (bc18*(bc16*(c16 + (ab16*jp35)/2 +
(3^(1/2)*ab17*jp35)/2) + bc18*(c18 + (ab18*jp35)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 +
abs(bc18)^2)) + (bc17*(bc17*(c18 + (ab18*jp35)/2) -
(3^(1/2)*ab18*bc16*jp35)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)),
- (bc17*(bc16*(c16 + (3^(1/2)*ab18*jp36)/2) + bc17*(c17 -
(ab18*jp36)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) - (bc18*(bc18*(c17 -
(ab18*jp36)/2) - bc16*((ab16*jp36)/2 + (3^(1/2)*ab17*jp36)/2)))/(2*(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2))];...
[ (bc18*(bc17*((ab16*jp31)/2 + (3^(1/2)*ab17*jp31)/2) +
(3^(1/2)*ab18*bc18*jp31)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) -
(bc16*(bc17*((ab18*jp31)/2 + 1) - (3^(1/2)*ab18*bc16*jp31)/2))/(2*(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2)), (bc16*(bc16*((3^(1/2)*ab18*jp32)/2 + 1) -
(ab18*bc17*jp32)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) +
(bc18*(bc18*((3^(1/2)*ab18*jp32)/2 + 1) + bc17*((ab16*jp32)/2 +
(3^(1/2)*ab17*jp32)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)),
(bc18*(bc17*((ab16*jp33)/2 + (3^(1/2)*ab17*jp33)/2 - 1) +
(3^(1/2)*ab18*bc18*jp33)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) -
(bc16*((ab18*bc17*jp33)/2 - (3^(1/2)*ab18*bc16*jp33)/2))/(2*(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2)), - (bc16*(bc16*(c18 -
(3^(1/2)*ab18*jp34)/2) + (ab18*bc17*jp34)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 +
abs(bc18)^2)) - (bc18*(bc18*(c18 - (3^(1/2)*ab18*jp34)/2) - bc17*((ab16*jp34)/2 - c17
+ (3^(1/2)*ab17*jp34)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)),
(bc18*(bc17*(c16 + (ab16*jp35)/2 + (3^(1/2)*ab17*jp35)/2) +
(3^(1/2)*ab18*bc18*jp35)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) -
(bc16*(bc17*(c18 + (ab18*jp35)/2) - (3^(1/2)*ab18*bc16*jp35)/2))/(2*(abs(bc16)^2 +
abs(bc17)^2 + abs(bc18)^2)), (bc16*(bc16*(c16 + (3^(1/2)*ab18*jp36)/2) +
bc17*(c17 - (ab18*jp36)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) +
(bc18*(bc18*(c16 + (3^(1/2)*ab18*jp36)/2) + bc17*((ab16*jp36)/2 +
(3^(1/2)*ab17*jp36)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2))];...
[ - (bc17*(bc17*((ab16*jp31)/2 + (3^(1/2)*ab17*jp31)/2) +
(3^(1/2)*ab18*bc18*jp31)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) -
(bc16*(bc18*((ab18*jp31)/2 + 1) + bc16*((ab16*jp31)/2 +
(3^(1/2)*ab17*jp31)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)), -
(bc16*(bc16*((ab16*jp32)/2 + (3^(1/2)*ab17*jp32)/2) +
(ab18*bc18*jp32)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) -
(bc17*(bc18*((3^(1/2)*ab18*jp32)/2 + 1) + bc17*((ab16*jp32)/2 +
(3^(1/2)*ab17*jp32)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)), -
(bc17*(bc17*((ab16*jp33)/2 + (3^(1/2)*ab17*jp33)/2 - 1) +
(3^(1/2)*ab18*bc18*jp33)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) -
(bc16*(bc16*((ab16*jp33)/2 + (3^(1/2)*ab17*jp33)/2 - 1) +
(ab18*bc18*jp33)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)), (bc17*(bc18*(c18
- (3^(1/2)*ab18*jp34)/2) - bc17*((ab16*jp34)/2 - c17 +
(3^(1/2)*ab17*jp34)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) -
(bc16*(bc16*((ab16*jp34)/2 - c17 + (3^(1/2)*ab17*jp34)/2) +
(ab18*bc18*jp34)/2))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)), -
(bc16*(bc16*(c16 + (ab16*jp35)/2 + (3^(1/2)*ab17*jp35)/2) + bc18*(c18 +
(ab18*jp35)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2)) - (bc17*(bc17*(c16 +
(ab16*jp35)/2 + (3^(1/2)*ab17*jp35)/2) + (3^(1/2)*ab18*bc18*jp35)/2))/(2*(abs(bc16)^2
+ abs(bc17)^2 + abs(bc18)^2)), (bc16*(bc18*(c17 - (ab18*jp36)/2) -
bc16*((ab16*jp36)/2 + (3^(1/2)*ab17*jp36)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 +
abs(bc18)^2)) - (bc17*(bc18*(c16 + (3^(1/2)*ab18*jp36)/2) + bc17*((ab16*jp36)/2 +
(3^(1/2)*ab17*jp36)/2)))/(2*(abs(bc16)^2 + abs(bc17)^2 + abs(bc18)^2))]];
function SimbolicasJacobianasLinks
syms jp1 jp2 jp3 jp4 jp5 jp6 jp7 jp8 jp9 jp10 jp11 jp12 jp13 jp14 jp15 jp16 jp17 jp18 jp19
jp20 jp21 jp22 jp23 j24 jp25 jp26 jp27 jp28 jp29 jp30 jp31 jp32 jp33 jp34 jp35 jp36 real
Jp= [ jp1 jp2 jp3 jp4 jp5 jp6;
jp7 jp8 jp9 jp10 jp11 jp12;....
jp13 jp14 jp15 jp16 jp17 jp18; jp19 jp20 jp21 jp22 jp23 jp24;...
jp25 jp26 jp27 jp28 jp29 jp30; jp31 jp32 jp33 jp34 jp35 jp36];
syms bc1 bc2 bc3 bc4 bc5 bc6 bc7 bc8 bc9 bc10 bc11 bc12 bc13 bc14 bc15 bc16 bc17 bc18 real
bc6;bc7 bc8
bc12; bc13
syms dx dy dz dfii dteta dpsii real
dX= formula([dx dy dz dfii dteta dpsii]);
syms c1 c2
c9 c10 c11
c12 c13 c14
c15 c16 c17
c9;c10 c11
c12;c13 c14
c15;c16 c17
syms zeta1_dot zeta2_dot zeta3_dot zeta4_dot zeta5_dot zeta6_dot real
syms ab1 ab2 ab3 ab4 ab5 ab6 ab7 ab8 ab9 ab10 ab11 ab12 ab13 ab14 ab15 ab16 ab17 ab18 real
AB= [ab1 ab2 ab3; ab4 ab5 ab6; ab7 ab8 ab9; ab10 ab11 ab12; ab13 ab14 ab15; ab16 ab17 ab18];
alfa_ij=[0, 0, 2*pi/3, 2*pi/3, 4*pi/3, 4*pi/3];
F_R_Fij(:,:,i)=rotz(rad2deg(alfa_ij(i)));
Fij_R_fk=rotz(180)*rotx(90);
Zetah_dot=formula([zeta1_dot zeta2_dot zeta3_dot zeta4_dot zeta5_dot zeta6_dot]');
fk_w_k= [zeros(6,2),Jp*dX'];
dRbrazo = cross(F_R_Fij(:,:,i)*Fij_R_fk*fk_w_k(i,:)', AB(i,:)/2);
dwbrazo= F_R_Fij(:,:,i)*Fij_R_fk *[0;0;Jp(i,:)*dX'];
dwr= (-1/(norm(BC(i,:))^2) * cross(dX(1:3) + cross(dX(4:6),c(i,:)) -
cross(dwbrazo,AB(i,:)),BC(i,:)));
dRrod = cross(dwr,BC(i,:)/2);
[Drb,S]=coeffs(dRbrazo(j),dX);
[Dwb,S]=coeffs(dwbrazo(j),dX);
[Dwr,S]=coeffs(dwr(j),dX);
[Drr,S]=coeffs(dRrod(j),dX);
if isempty(Drb)
Jrbrazo(j,:,i)=sym(zeros(1,6));
Jrbrazo(j,:,i)=Drb;
if isempty(Dwb)
Jwbrazo(j,:,i)=sym(zeros(1,6));
Jwbrazo(j,:,i)=Dwb;
if isempty(Dwr)
Jwrod(j,:,i)=sym(zeros(1,6));
Jwrod(j,:,i)=Dwr;
if isempty(Drr)
Jrrod(j,:,i)=sym(zeros(1,6));
Jrrod(j,:,i)=Drr;
Código de la especificación del WS e identificación de la manipulabilidad.
La función FunctionVolumen tiene como entrada la longitud de de los eslabones superiores x(1) e
inferiores x(2) y retorna el valor del WS WS, las coordenadas cartesianas de la nube de puntos x4, y4,
z4 y la posición 𝑃௠. PuntoC.
function [WS, x4, y4, z4, PuntoC] = FunctionVolumen(x)
% Dimensiones de las plataformas
H = 230/1000; D=89/1000;
h = 82.6/1000; d=60/1000;
r4= sqrt(L_rod^2 - (sqrt(H^2-D^2)-sqrt(h^2-d^2))^2 - (D-d)^2);
liminf = L_brazo + r4;
R=2*(L_rod+L_brazo);
% Condiciones iniciales
Centro= ;
% Limite a evaluar; Limite inferior
LimEvaluar= [0,0,-R];
% Limita el punto inferior del WS
CoordInf= LimiteApto2(Centro,LimEvaluar,L_rod,L_brazo);
if CoordInf(3) < liminf
CoordInf(3) = liminf;
% Limita el punto superior del WS
CoordSup= LimiteApto2(CoordInf(1:3)*2/3,LimEvaluar/24, L_rod,L_brazo);
PuntoC=[mean([CoordInf(1),CoordSup(1)]),mean([CoordInf(2),CoordSup(2)]),mean([CoordIn
f(3),CoordSup(3)])];
% coordenadas esfericas
radio= CoordSup(1:3)-PuntoC;
dradio=radio.*radio;
r=sqrt(sum(dradio));
intervalos=CoordSup(3):(CoordInf(3)-CoordSup(3))/paso:CoordInf(3);
for i=1:numel(intervalos)
for phi=-pi/3: pi/(2*paso):pi/3
PuntoM=[0,0,intervalos(i)];
Coord= LimiteApto2(PuntoM,[r*cos(phi) , r*sin(phi)
,intervalos(i)],L_rod,L_brazo);
if Coord(1) < 0.001
Coord(1)=0;
if abs(Coord(2)) < 0.001
Coord(2)=0;
x4(i,j)=Coord(1);
y4(i,j)=Coord(2);
z4(i,j)=Coord(3);
PuntoC=[0,0,(z4(1,1)+z4(end,1))/2];
% Calculo del volume
WS=CalculoVolumen(x4,y4,z4,PuntoC);
La función LimiteApto2 analiza las 2 posiciones (Centro y CoordAnali) junto con la longitud de
de los eslabones superiores e inferiores y retorna las coordenadas cartesianas aptas Coordenada
function Coordenada= LimiteApto2(Centro,CoordAnali,L_rod,L_brazo)
% tolerancia de 0.1 mm.
error=0.0001;
Vector=CoordAnali-Centro;
dVector=Vector.*Vector;
mV=sqrt(sum(dVector));
vup= [Vector(1)/mV, Vector(2)/mV, Vector(3)/mV]; % vector unitario del Vector
a=0; b=mV;
aw=0; bw=1;Lw=bw-aw;k=0;
if abs(Lw*(b-a))>error
while abs(Lw*(b-a))>error
w1=aw+(0.618*Lw);
w2=bw-(0.618*Lw);
X1=w1*(b-a)+a;
X2=w2*(b-a)+a;
PX1= [X1*vup+Centro,0,0,0];
[PosOKX1,ZetahX1]=Eval_Posicion2(PX1,L_rod,L_brazo);
PX2= [X2*vup+Centro,0,0,0];
[PosOKX2,ZetahX2]=Eval_Posicion2(PX2,L_rod,L_brazo);
%if Eval_Posicion(PX1,L_rod,L_brazo)== false % Evalua la posición deseada y
determina TRUE si la posicion se puede alcanzar y FALSE si hay restricciones
en la posicion
if PosOKX1== false
Coordenada=PX1;
w1=aw+(0.618*Lw);
w2=bw-(0.618*Lw);
%X1=w1*(b-a)+a;
PX1= [X1*vup+Centro,0,0,0];
[PosOKX1,ZetahX1]=Eval_Posicion2(PX1,L_rod,L_brazo);
%if Eval_Posicion(PX1,L_rod,L_brazo)== false % Evalua la posición deseada y
determina TRUE si la posicion se puede alcanzar y FALSE si hay restricciones
en la posicion
if PosOKX1== false
Coordenada=PX1;
La función Eval_Posicion2 evalua la posición PosDeseada según la longitud de los eslabones y
determina TRUE si la posicion se puede alcanzar, FALSE si hay restricciones en la posicion y 𝜁௜ Zetah.
function [PosOK,Zetah] = Eval_Posicion2(PosDeseada,l_rod,l_brazo)
% Angulos y posicion deseada
[Zetah,alarm]=CinematicaInversa3(l_brazo,l_rod,PosDeseada);
Zetah=deg2rad(Zetah);
% Restricciones: el angulo debe ser mayor a 90 grados. La altura del punto B
(articulacion Universal) debe estar entre la plataforma superior y la inferior ->
Bz= -l_brazo*sin(Zetah(j));
if abs(imag(Zetah(j)))>0.001 || real(Zetah(j))<0 || Bz < PosDeseada(3) || alarm>0
Pos(j)= false;
Pos(j)= true;
PosOK=Pos(1)*Pos(2)*Pos(3)*Pos(4)*Pos(5)*Pos(6);
La función CalculoVolumen recibe las coordenadas no restringidas de la nube de puntos y la posición
𝑃௠ y genera el valor del WS Volumen2.
function Volumen2=CalculoVolumen(x,y,z,CentroRotacion)
% Calculo del volumen y dibujo del volumen
Vol2(1)=0;
Size=size(x);
i=Size(1);
j=Size(2);
for o=1:i-1
for p=1:j-1
% Nuevo Volumen con 3 vectores
u= [x(o,p+1),y(o,p+1),z(o,p+1)] - [x(o,p),y(o,p),z(o,p)];
v= [x(o+1,p+1),y(o+1,p+1),z(o+1,p+1)]- [x(o,p),y(o,p),z(o,p)];
w= [x(o,p),y(o,p),z(o,p)] - CentroRotacion;
Vol_inf=1/6*abs(dot(cross(u,v),w));
% Nuevo Volumen con 3 vectores
u= [x(o+1,p+1),y(o+1,p+1),z(o+1,p+1)]- [x(o,p),y(o,p),z(o,p)];
v= [x(o+1,p),y(o+1,p),z(o+1,p)] - [x(o,p),y(o,p),z(o,p)];
w= [x(o,p),y(o,p),z(o,p)] - CentroRotacion;
Vol_sup=1/6*abs(dot(cross(u,v),w));
Vol2(k)=Vol_inf+Vol_sup;
Volumen2=sum(Vol2);
Volumen2=3*Volumen2;
La función FuncionManipulabilidad evalúa 𝜂 GCI que tiene como entradas las coordenadas
cartesianas de la nube de puntos no restringida, la posición 𝑃௠, el número de puntos 𝑁 y las longitudes de
los eslabones x. Se resalta que las matrices jacobianas son resueltas con la función JP detallada en el Anexo
function GCI = FuncionManipulabilidad(x4,y4,z4,PuntoC,paso,x)
l_brazo= x(1);
l_rod= x(2);
x=x4'; x=x(:)';
y=y4'; y=y(:)';
z=z4'; z=z(:)';
matriz=unique([x',y',z'],'rows');
x=matriz(:,1)';
y=matriz(:,2)';
z=matriz(:,3)';
% determinación del vector unitario del centro (PuntoC) al punto i
for i=1:numel(x)
Vector=[x(i),y(i),z(i)]-PuntoC;
dVector=Vector.*Vector;
mV=sqrt(sum(dVector));
% vector unitario
vup= [Vector(1)/mV, Vector(2)/mV, Vector(3)/mV];
% puntos a evaluar
vmagni= [mV/paso:mV/paso:mV];
for j=1:numel(vmagni)
% punto de estudio
Pest= [PuntoC+vup*vmagni(j),0,0,0];
[PosOK,zeta] = Eval_Posicion2(Pest,l_rod,l_brazo);
% Jacobiana de esa posición
[Jp,JpV2,AA]=JP(l_brazo, Pest(1), Pest(2), Pest(3), 0, 0, 0, zeta(1),
zeta(2), zeta(3), zeta(4), zeta(5), zeta(6));
P=AA(:,2:7);
Pinv=inv(P);
Q=diag(-AA(:,1));
% Jacobiana de traslacion
Jt=Pinv(1:3,:)*Q;
% valores singulares
Vs_Jt=svd(Jt);
km(k,1:3)=Pest(1:3);
km(k,4) =max(Vs_Jt)/min(Vs_Jt);
% indice de angularidad
Jr=Pinv(4:6,:)*Q;
Vs_Jr=svd(Jr);
km(k,5) =max(Vs_Jr)/min(Vs_Jr);
km(k,6)= (km(k,4)+km(k,5))/2;
GCI=mean(km(:,6));
Esquema del sistema controlado utilizando MATLAB Simulink (R)
La Figura E.1. señala la configuración del sistema controlado, el cual se compone de los subsistemas
Generador de Trayectoria, Controlador, matricesMCG_S y Mecanismo; adicionalmente, se
evaluan las salidas controladas de posición (SalidaControl_Pos), velocidad (SalidaControl_Vel),
aceleración (SalidaControl_Acel) y el torque requerido (torque).
Fig. E.1 Esquema del controlador.
La Figura E.2 ilustra la configuración del subsistema Generador de Trayectoria. Las posiciones
deseadas px, py pz corresponden a 𝑥, 𝑦, 𝑧; los vectores anx, any, anz están definidas por 𝜃̇, 𝜑̇, 𝜓̇; vx, vy, vz
determinan 𝑥̇, 𝑦̇, 𝑧̇; wx, wy, wz se rigen po 𝜃̇, 𝜑̇ , 𝜓̇; ax, ay, az corresponden a 𝑥̈, 𝑦̈, 𝑧̈ y alfax, alfay, alfaz
compete a 𝜃̈, 𝜑̈ , 𝜓̈. Las salidas de posición, velocidad y aceleración son multiplexadas en las salidas 1,2 y 3
respectivamente.
Fig. E.2. Subsistema del bloque Generador de trayectoria.
El subsistema Mecanismo, representado por fcn , representa la dinámica del HEXA 6RUS, la cual
define la aceleración de la plataforma móvil a partir de las expresiones M, C, G y 𝜏௖௢௡.
function a = fcn(M,C,G,T)
a = M\(T-C-G);
El bloque matricesMCH_S genera las expresiones M, C y G pertenecientes a la modelación dinámica
mostrada en la Sección 4.4 y cuya programación se detalla en el Anexo C
function [M,C,G] = matricesMCG_S(x)
M=zeros(6);
C=zeros(6,1);
G=zeros(6,1);
[M,C,G,Parar] = matricesMCG(x);
function [M,C,G] = matricesMCG_S(x)
M=zeros(6);
C=zeros(6,1);
G=zeros(6,1);
[M,C,G,Parar] = matricesMCG(x);
Código de la implementación del EDMER
nparam=4; %Numero de variables a optimizar
% Factor de penalidad
% limites de los parametros x1= brazo, x2= rod x3=zita ts=x4
xsup(1)= 0.500; xsup(2)= 0.500; xsup(3)= 1; xsup(4)= 1; % limites superiores de
las variables
xinf(1)= 0.07; xinf(2)= 0.18; xinf(3)= 0.5; xinf(4)=0.15; % limites inferiores de
las variables
x1=[xinf(1), xsup(1)];
x2=[xinf(2), xsup(2)];
x3=[xinf(3), xsup(3)];
x4=[xinf(4), xsup(4)];
% Combinacion de los extremos
Z(m,:)= [x1(i),x2(j),x3(k),x4(l)];
CantFunObj=4;
% Creacion de la primera población de padres basado en los limites
for i=1:size(Z,1)
Ini(i,1+CantFunObj:1+CantFunObj+nparam-1)= Z(i,:);
Funciones= FuncionObjetivoWsGciEc(Ini(i,:),CantFunObj);
Ini(i,1:CantFunObj)=Funciones +
EDMO_RestriccionWsGciEc(Ini(i,:),Rm,CantFunObj,Funciones);
Ini(i,CantFunObj+nparam+1:CantFunObj+nparam+CantFunObj)=EDMO_RestriccionWsGciEc(Ini(i,:),
Rm,CantFunObj,Funciones);
% creación del resto de los padres iniciales
for i=1:npop-size(Z,1)
for j=1:nparam
% población inicial dentro de los limites inferiores y superiores
P(i,j+CantFunObj)=rand*(xsup(j)-xinf(j)) + xinf(j);
Funciones=FuncionObjetivoWsGciEc(P(i,:),CantFunObj);
P(i,1:CantFunObj)= Funciones +
EDMO_RestriccionWsGciEc(P(i,:),Rm,CantFunObj,Funciones);
P(i,CantFunObj+nparam+1:CantFunObj+nparam+CantFunObj)=EDMO_RestriccionWsGciEc(P(i,:),Rm,C
antFunObj,Funciones);
P=[P;Ini];
Npop=[1:npop];
% numero de generaciones
for t=1:csLimit
for i=1:npop
D= randi([1,nparam]); A= randi([1,npop]);
Bnpop=Npop(Npop ~= A); % retira el valor de A para no repetirlo
B= Bnpop(randi(length(Bnpop)));
Cnpop=Bnpop(Bnpop ~= B); % retira el valor de B para no repetirlo
C= Cnpop(randi(length(Cnpop)));
if A ==B || A ==C || C ==B
print('A = B = C');
for j=1:nparam
if r <Cr || j==D
Ptemp(i,j+CantFunObj)=P(C,j+CantFunObj) + F*(P(A
,j+CantFunObj)-P(B ,j+CantFunObj));
if Ptemp(i,j+CantFunObj)> xsup(j) || Ptemp(i,j+CantFunObj)<
Ptemp(i,j+CantFunObj)= r *(xsup(j)-xinf(j)) + xinf(j);
Ptemp(i,j+CantFunObj)=P(i,j+CantFunObj);
Funciones= FuncionObjetivoWsGciEc(Ptemp(i,:),CantFunObj);
Ptemp(i,1:CantFunObj)= Funciones +
EDMO_RestriccionWsGciEc(Ptemp(i,:),Rm,CantFunObj,Funciones);
Ptemp(i,CantFunObj+nparam+1:CantFunObj+nparam+CantFunObj)=
EDMO_RestriccionWsGciEc(Ptemp(i,:),Rm,CantFunObj,Funciones);
Ppadre=P(i,:);
Phijo=Ptemp(i,:);
M=sortrows([M;P(i,:);Ptemp(i,:)],1);
% determinación de niveles de significancia
Orden=EDMO_NivelesSignificancia(M,CantFunObj,npop);
Champ= EDMO_TorneoDistancia(Orden,CantFunObj,npop);
Champ(:,end)=[];
P=sortrows(P,1);
% % seleccion del mejor punto
PosOptima=zeros(1,9);
while i <= size(P,1)
if P(i,1)<0 | P(i,2)<0 | P(i,3)<0 | P(i,4)<0
P(i,:)=[];
elseif norm(P(i,1:4)) < dist
dist=norm(P(i,1:4)); PosOptima=[P(i,:),dist];
La función FuncionObjetivoWsGciEc tiene como entrada el vector de diseño y la salida son los valores
del WS (Anexo D), 𝜂 (Anexo D), EC (Anexo E) y 𝑒௖ (Anexo E).
function FunObj=FuncionObjetivoWsGciEc(x,CantFunObj)
X1=x(1+CantFunObj);
X2=x(2+CantFunObj);
X3=x(3+CantFunObj);
X4=x(4+CantFunObj);
[Volumen, x4, y4, z4, PuntoC] = FunctionVolumen([X1, X2]);
FunObj(1)= (0.118447648-Volumen)/(0.118447648-3.41187e-5);
[px, py, pz, vx, vy, vz, ax, ay, az, tiempo] = GeneradorTrayectoria2(x4, y4, z4,
[EsFControl,error,ErrorControl]= Funciones_Merito_Sin(X1, X2, X3,X4, Volumen, x4,
y4, z4, PuntoC,px, py, pz, vx, vy, vz, ax, ay, az, tiempo);
FunObj(3)= (EsFControl- 2.02)/(727.3926185-2.02);
FunObj(4)= ErrorControl;
FunObj(2)= (FuncionManipulabilidad(x4,y4,z4,PuntoC,4,[X1,X2])-
2.287517683)/(17.48117681-2.287517683);
La función EDMO_RestriccionWsGciEc recibe el valor de las FOs y determina si la penalidad de
function penalidad=EDMO_RestriccionWsGciEc(x,Rm,CantFunObj,Funciones)
%Restriccion de la funcion de WS
g(1)= 1 - Funciones(1);
% Restriccion de FuncionManipulabilidad
g(2)= 1 - Funciones(2);
% Restriccion de Esfuerzo de control
g(3)= 1 - Funciones(3);
% Restriccion del Error de control
g(4)= 1 - Funciones(4);
for i=1:length(g)
g(i)=abs(g(i));
omega=sum(g);
penalidad=Rm*omega*ones(1,CantFunObj);
La función EDMO_NivelesSignificancia recibe la matriz correspondiente a los padres e hijos, la
cantidad de FOs y el tamaño de población de padres originales para retornar una matriz M ordenada según
el nivel de significancia
function Orden=EDMO_NivelesSignificancia(M,CantFunObj,npopOrig)
M= sortrows(M); % organiza la matriz M de menor a mayor deacuerdo a la primera
funcion objetivo
npop=length(M);
while t==1
while i<=size(M,1)
while j<= size(M,1)
if i~= j || (j==size(M,1) && i==size(M,1))
Mi=M(i,:);
Mj=M(j,:);
[condh2,condp2] = dominancia(CantFunObj,M(i,:),M(j,:));
if condh2==1
if condp2==1
j=10*size(M,1);
if apto==1 % si Mi no tiene quien lo domine agregar Mi al frente Fk
F(k,:)=[M(i,:)]; k=k+1;
M= setdiff(M,F,'rows');
F(:,end+1)=front; Orden=[Orden;F];
if size(Orden,1) >= npopOrig
front=front+1;
if size(M,1)<2
M(:,end+1)=front;
Orden=[Orden;M];
La función dominancia realiza el análisis de dominancia según el pseudocódigo Pseudocódigo 6-1
donde recibe el vector M y el vector a analizar P y regresa si la FO es dominante.
function [condh2,condp2] = dominancia(CantFunObj,M,P)
condh=0; condp=0;condh2=0;condp2=0;
for k=1:CantFunObj
if M(1,k) <= P(1,k)
condh=condh+1; % compara si cada funcion objetivo de M es menor o
igual a la funcion de P
if P(1,k) <= M(1,k)
condp=condp+1; % compara si cada funcion objetivo del Pj es menor o
igual a la funcion de Mi
if condh==CantFunObj % Si el Mi no es peor que Pj
while k <= CantFunObj
if M(1,k)<P(1,k)
condh2=1; % Mi domina Pj
k=CantFunObj+1;
condh2=0; % Mi no domina a Pj
if condp==CantFunObj % Si el Pj no es peor que Mi
while k <= CantFunObj
if M(1,k)>P(1,k)
condp2=1; % Pj domina Mi
k=CantFunObj+1;
La función EDMO_TorneoDistancia realiza la clasificación de hacinamiento donde recibe la matriz de
FOs, el número de FOs y la cantidad de población original de padres y retornar las primeras N soluciones
function Champ= EDMO_TorneoDistancia(Orden,CantFunObj,npopOrig)
% operador de seleccion del torneo de distancia del libro DEB Multiobjective
optimization pag 235
clear M l g i j
[~,~,X] = unique(M(:,end));
C = accumarray(X,1:size(M,1),[],@(r){M(r,:)});
while g==1
sum=sum+size(A,1);
if sum <npopOrig
% pase al siguiente nivel de significancia
Champ=[Champ;A];
% Calculo de crowding
A=sortrows(A,1);
l=size(A,1);
d(1:size(A,1))=0;
if l==1 || l==2
% Agregar A a Champ y terminar el ranking
Champ=[Champ;A];
Dist1(1)=Inf; Dist1(size(A,1))=Inf;
for j=2:size(A)-1 % correr desde j=2:size(A)-1
f1max=max(A(:,1)); f1min=min(A(:,1));
Dist1(j)= abs((A(j-1,1)-A(j+1,1))/(f1max-f1min));
A=[A,Dist1'];
Dist2(1)=Inf; Dist2(size(A,1))=Inf;
A=sortrows(A,2);
for j=2:size(A)-1 % correr desde j=2:size(A)-1
f2max=max(A(:,2)); f2min=min(A(:,2));
Dist2(j)= abs((A(j-1,2)-A(j+1,2))/(f2max-f2min));
A(:,end)=A(:,end)+Dist2';
A=sortrows(A,size(A,2),'descend');
Falta= npopOrig-size(Champ,1);
A=A(1:Falta,:);
A(:,end)=[];
Champ=[Champ;A];
La función GeneradorTrayectoria2 recibe las coordenadas de la nube de puntos del WS y el punto 𝑃௠
(Sección 5.1.2) y (Anexo D) y genera las trayectorias de posición, velocidad y aceleración traslacional y
rotacional requeridos en la Figura E.2.
function [px, py, pz, vx, vy, vz, ax, ay, az, anx, any, anz, wx, wy, wz, alfax,
alfay, alfaz, tiempo]=GeneradorTrayectoria2(x4, y4, z4, PuntoC)
% Posiciones de WS
x4=(1*x4)';
y4=(1*y4)';
POS1=[x4(5,2:end-1); y4(5,2:end-1); z4(5,2:end-1)]';
POS2=[x4(1,2:end-1); y4(1,2:end-1); z4(1,2:end-1)]';
% Rotar 120 grados la POS 2 para que quede al frente de POS 1
for i=1:size(POS2,1)
POS2(i,:)=rotz(-120)*POS2(i,:)';
if POS2(i,2)<1e-10
POS2(i,2)=0;
POS2=sortrows(POS2,3,'ascend');
REC=[POS1;POS2];
Ampx=min(abs(REC(:,1))); Ampy=min(abs(REC(:,1)));
AmpxR=deg2rad(5);
AmpyR=deg2rad(5);
AmpzR=deg2rad(5);
alfa=2*Ampx/(tfin^2);
bbeta=Ampy/tfin^3;
% Configuracion de Simulink
NoSamples=1;
Ampz=0.8*abs(max(max(z4)) - min(min(z4)))/2;
Freq=2*pi/(NoSamples*tfin);
Bias=PuntoC(3);
pz=zeros(101,1);
for t= 0: tfin/100: tfin
tiempo(i,1)=t;
pz(i,1)=Ampz*sin(Freq*t+Phase) + Bias;
vz(i,1)=Ampz*Freq*cos(Freq*t);
az(i,1)=-Ampz*Freq^2*sin(Freq*t);
px(i,1)=alfa*t^2/2;
vx(i,1)=alfa*t;
ax(i,1)=alfa;
py(i,1)=bbeta*t^3/6;
vy(i,1)=bbeta*t^2/2;
ay(i,1)=bbeta*t;
alfa= 2*AmpxR/(tfin^2);
bbeta=6*AmpyR/tfin^3;
anx(i,1)=AmpzR*sin(Freq*t+Phase) + Bias;
wx(i,1)=AmpzR*Freq*cos(Freq*t);
alfax(i,1)=-AmpzR*Freq^2*sin(Freq*t);
any(i,1)=alfa*t;
wy(i,1)=alfa;
alfay(i,1)=0;
anz(i,1)=bbeta*t^3/6;
wz(i,1)=bbeta*t^2/2;
alfaz(i,1)=bbeta*t;
La función Funciones_Merito_Sin genera EC y 𝑒௖ con base en el modelo de Simscape (Anexo E), los
parámetros de diseño, WS y la trayectoria deseada.
function [EsFControl, ErrorControl] = Funciones_Merito_Sin(L_brazo,
L_rod,zita,ts,Volumen, x4, y4, z4, PuntoC, px, py, pz, vx, vy, vz, ax, ay, az, anx,
any, anz, wx, wy, wz, alfax, alfay, alfaz, tiempo)
%% Generacion de constantes del controladorConstantes del controlador
wn= 4/(zita*ts); kv = 7*zita*wn; kp = (10*zita^2+1)*wn^2;
ki= 5*zita*wn^3; k=[1, kv, kp, ki]; assignin('base','k',k);
%% Esfuerzo de control
assignin('base','L_brazo',L_brazo);
assignin('base','L_rod',L_rod);
assignin('base','PuntoC',PuntoC); tfin=tiempo(end);
assignin('base','px',[tiempo,px]);
assignin('base','py',[tiempo,py]);
assignin('base','pz',[tiempo,pz]);
assignin('base','vx',[tiempo,vx]);
assignin('base','vy',[tiempo,vy]);
assignin('base','vz',[tiempo,vz]);
assignin('base','ax',[tiempo,ax]);
assignin('base','ay',[tiempo,ay]);
assignin('base','az',[tiempo,az]);
assignin('base','anx',[tiempo,anx]);
assignin('base','any',[tiempo,any]);
assignin('base','anz',[tiempo,anz]);
assignin('base','wx',[tiempo,wx]);
assignin('base','wy',[tiempo,wy]);
assignin('base','wz',[tiempo,wz]);
assignin('base','alfax',[tiempo,alfax]);
assignin('base','alfay',[tiempo,alfay]); assignin('base','alfaz',[tiempo,alfaz]);
tfin=tiempo(end);
assignin('base','tfin',tfin);
% Configuracion de Simulink
simOut = sim('StaV1Sin',tfin);
torque=abs(torque.data);
Parar= Parar.data;
tiempo=tiempo.data;
while tiempo(n)<0.05
Positions=SalidaControl_Pos.data;
Velocities=SalidaControl_Vel.data;
Acelerations=SalidaControl_Acel.data;
Positions= Positions(n:end,:);
Velocities= Velocities(n:end,:);Acelerations= Acelerations(n:end,:);
erroPos=abs([Positions(:,1);Positions(:,2);Positions(:,3)]-
[Positions(:,7);Positions(:,8);Positions(:,9)]);
promedioPos=mean([[Positions(:,1);Positions(:,2);Positions(:,3)],[Positions(:,7);Position
s(:,8);Positions(:,9)]],2)+1e-16;
marePos=mean(abs(erroPos./promedioPos));
%velocidad
erroVel=abs([Velocities(:,1);Velocities(:,2);Velocities(:,3)]-
[Velocities(:,7);Velocities(:,8);Velocities(:,9)]);
promedioVel=mean([[Velocities(:,1);Velocities(:,2);Velocities(:,3)],[Velocities(:,7);Velo
cities(:,8);Velocities(:,9)]],2)+1e-16;
mareVel=mean(abs(erroVel./promedioVel));
% %Aceleracion
erroAcel=abs([Acelerations(:,1);Acelerations(:,2);Acelerations(:,3)]-
[Acelerations(:,7);Acelerations(:,8);Acelerations(:,9)]);
promedioAcel=mean([[Acelerations(:,1);Acelerations(:,2);Acelerations(:,3)],[Acelerations(
:,7);Acelerations(:,8);Acelerations(:,9)]],2)+1e-16;
mareAcel=mean(abs(erroAcel./promedioAcel));
ErrorControl=mean([marePos,mareVel,mareAcel]);
%% Salida: Esfuerzo de control
EsFControl=mean(trapz(tiempo(n:end,:),torque(n:end,:)))/Volumen;
assignin('base','tiempo',tiempo);
Validación del modelo dinámico del HEXA 6 RUS
El esquemático de la validación del modelamiento dinámico del HEXA 6 RUS (Sección 4.4) se presenta
en la Figura G.1. El objetivo es comparar el comportamiento del MP bajo un modelo virtual multifísico con
el modelo dinámico. Este procedimiento se basa en unas posiciones, velocidades y aceleraciones deseadas
que entran a los controladores, ambos con los mismos valores de parámetros de control y matrices M, C y
G (). De ambas simulaciones se extraen los valores de posición de la placa fija y los torques requeridos, con
el fin decompararlos. Para esto se requiere varias fases: la simplificación del modelo CAD, la importación
al software multifísico, la configuración del controlador, la generación de posición deseada y finalmente la
comparación de los modelos. Todas fases se detallan a continuación.
Fig. G.1. Esquemático de la validación.
Primero; se genera el modelo CAD del MP, en este trabajo se utiliza el software SOLIDWORKS®; las
dimensiones del MP se consideran en el Anexo H. Para esta comparación 𝑙௕= 𝑙௥= 350 𝑚𝑚. La
configuración final del modelo CAD lo muestra la Figura G.2.
Con el fin de hacer la validación in silico del comportamiento del HEXA 6 RUS, se usa el software
multifísico MATLAB SIMSCAPE®. Para estom se simplifica el modelo sustrayendo tornillos, pasadores,
rodamientos, soportes etc. para disminuir el costo computacional, etal como se visualiza en la Figura G.3.
Una vez reducido el modelo, este se importa en el software MATLAB SIMSCAPE® ,la posición de la
placa móvil al igual que las señales de torque de cada motor son almacenadas. Esta configuración se ilustra
en la Figura G.4.
Fig. G.2. Modelo CAD del HEXA 6 RUS
Fig. G.3. Modelo CAD simplificado cargado al SIMSCAPE®.
Tanto el MP en SIMSCAPE® como el MP matemáticamente modelado son controlados en MATLAB
SIMULINK® bajo los mismos valores de M, C, G (4-105)-(4-107) y valores de entrada. Las Figuras G.5
y G.6. detallan dicha configuración.
Se simularon 2 trayectorias. La primera es una circunferencia de 90 mm con punto de inicio en X=0,
Y=0 y Z=-480 mm. La segunda, considero movimientos senosoidales en los ejes X, Y y una rampa en Z.
Ambas señales sin movimiento rotacional.
La Figura G.7. muestra los movimientos de respuesta ante la primera trayectoria. En esta comparación
la señal naranja representa la señal del modelo multifísico SIMSCAPE® y la azul del MP matematicamente
modelado. De forma similar, la Figura G.8. ilustra el comportamiento en cada DOF de ambos modelos del
MP. La Figura G.9. presenta el comportamiento de los torques de cada actuador rotacional activo ante la
segunda señal simulada. Finalmente, la Figura G.10 muestra como es el comportamiento de cada pareja de
actuadores 1-2, 3-4 y 5-6, tal como se presentan en la Sección 4.2. En esta última gráfica se visualiza una
compensación de error de la interacción entre los actuadores en el modelo matématico y se evidencian
perturbaciones similares entre ambos modelos.
En conclusión, dadas las comparaciones de comportamiento de los dos modelos, es viable el uso del
modelo matématico de la Sección 4.4 en el desarrollo de lasfunciones objetivo presentadas en este estudio.
Fig. G.4. Configuración de las articulaciones, eslabones y placas del modelo simplificado.
Fig. G.5. Configuración del MP controlado usando el modelo multifísico.
Fig. G.6. Configuración del MP controlado usando el modelo matemático.
Fig. G.7. compraración de seguimiento de trayectoria descrita por el modelo matemático y el multifísico.
Fig. G.8. Comparación del comportamiento de posición entre el modelo matemático y el multifísico. A)
Movimientos traslacionales. B) Movimientos rotacionales de la placa móvil.
Fig. G.9. Paralelismo entre el torque requerido por el modelo matemático y el multifísico
Fig. G.10. Paralelismo entre el torque requerido. A) por la pareja de actuadores en el modelo
matemático y el multifísico. B) detalle de las señales entre 10 s y 15 s.
Planos de fabricación del HEXA 6 RUS