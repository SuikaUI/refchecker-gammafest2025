Generalizing from a Few Examples: A Survey on Few-Shot
YAQING WANG, Hong Kong University of Science and Technology and Baidu Research
QUANMING YAO∗, 4Paradigm Inc.
JAMES T. KWOK, Hong Kong University of Science and Technology
LIONEL M. NI, Hong Kong University of Science and Technology
Machine learning has been highly successful in data-intensive applications, but is often hampered when the
data set is small. Recently, Few-Shot Learning (FSL) is proposed to tackle this problem. Using prior knowledge,
FSL can rapidly generalize to new tasks containing only a few samples with supervised information. In this
paper, we conduct a thorough survey to fully understand FSL. Starting from a formal definition of FSL, we
distinguish FSL from several relevant machine learning problems. We then point out that the core issue in
FSL is that the empirical risk minimizer is unreliable. Based on how prior knowledge can be used to handle
this core issue, we categorize FSL methods from three perspectives: (i) data, which uses prior knowledge to
augment the supervised experience; (ii) model, which uses prior knowledge to reduce the size of the hypothesis
space; and (iii) algorithm, which uses prior knowledge to alter the search for the best hypothesis in the given
hypothesis space. With this taxonomy, we review and discuss the pros and cons of each category. Promising
directions, in the aspects of the FSL problem setups, techniques, applications and theories, are also proposed
to provide insights for future research.1
CCS Concepts: • Computing methodologies →Artificial intelligence; Machine learning; Learning
paradigms.
Additional Key Words and Phrases: Few-Shot Learning, One-Shot Learning, Low-Shot Learning, Small Sample
Learning, Meta-Learning, Prior Knowledge
ACM Reference Format:
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni. 2020. Generalizing from a Few Examples: A
Survey on Few-Shot Learning. ACM Comput. Surv. 1, 1, Article 1 , 34 pages. 
1145/3386252
INTRODUCTION
“Can machines think?” This is the question raised in Alan Turing’s seminal paper entitled “Computing Machinery and Intelligence” in 1950. He made the statement that “The idea behind digital
∗Corresponding Author
1A list of references, which will be updated periodically, can be found at 
Authors’ addresses: Yaqing Wang, , Department of Computer Science and Engineering, Hong
Kong University of Science and Technology, Business Intelligence Lab and National Engineering Laboratory of Deep
Learning Technology and Application, Baidu Research; Quanming Yao, , 4Paradigm Inc.;
James T. Kwok, , Department of Computer Science and Engineering, Hong Kong University of Science
and Technology; Lionel M. Ni, , Department of Computer Science and Engineering, Hong Kong University of
Science and Technology.
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and
the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored.
Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires
prior specific permission and/or a fee. Request permissions from .
© 2020 Association for Computing Machinery.
0360-0300/2020/3-ART1 $15.00
 
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
 
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
computers may be explained by saying that these machines are intended to carry out any operations which could be done by a human computer”. In other words, the ultimate goal of machines
is to be as intelligent as humans. In recent years, due to the emergence of powerful computing
devices (e.g., GPU and distributed platforms), large data sets (e.g., ImageNet data with 1000 classes
 ), advanced models and algorithms (e.g., convolutional neural networks (CNN) and long
short-term memory (LSTM) ), AI speeds up its pace to be like humans and defeats humans
in many fields. To name a few, AlphaGo defeats human champions in the ancient game of
Go; and residual network (ResNet) obtains better classification performance than humans on
ImageNet. AI also supports the development of intelligent tools in many aspects of daily life, such
as voice assistants, search engines, autonomous driving cars, and industrial robots.
Albeit its prosperity, current AI techniques cannot rapidly generalize from a few examples.
The aforementioned successful AI applications rely on learning from large-scale data. In contrast,
humans are capable of learning new tasks rapidly by utilizing what they learned in the past. For
example, a child who learned how to add can rapidly transfer his knowledge to learn multiplication
given a few examples (e.g., 2 × 3 = 2 + 2 + 2 and 1 × 3 = 1 + 1 + 1). Another example is that given a
few photos of a stranger, a child can easily identify the same person from a large number of photos.
Bridging this gap between AI and humans is an important direction. It can be tackled by machine
learning, which is concerned with the question of how to construct computer programs that
automatically improve with experience . In order to learn from a limited number of examples
with supervised information, a new machine learning paradigm called Few-Shot Learning (FSL)
 is proposed. A typical example is character generation , in which computer programs
are asked to parse and generate new handwritten characters given a few examples. To handle this
task, one can decompose the characters into smaller parts transferable across characters, and then
aggregate these smaller components into new characters. This is a way of learning like human .
Naturally, FSL can also advance robotics , which develops machines that can replicate human
actions. Examples include one-shot imitation , multi-armed bandits , visual navigation
 , and continuous control .
Another classic FSL scenario is where examples with supervised information are hard or impossible to acquire due to privacy, safety or ethic issues. A typical example is drug discovery,
which tries to discover properties of new molecules so as to identify useful ones as new drugs .
Due to possible toxicity, low activity, and low solubility, new molecules do not have many real
biological records on clinical candidates. Hence, it is important to learn effectively from a small
number of samples. Similar examples where the target tasks do not have many examples include
FSL translation , and cold-start item recommendation . Through FSL, learning suitable
models for these rare cases can become possible.
FSL can also help relieve the burden of collecting large-scale supervised data. For example,
although ResNet outperforms humans on ImageNet, each class needs to have sufficient labeled
images which can be laborious to collect. FSL can reduce the data gathering effort for data-intensive
applications. Examples include image classification , image retrieval , object tracking ,
gesture recognition , image captioning, visual question answering , video event detection
 , language modeling , and neural architecture search .
Driven by the academic goal for AI to approach humans and the industrial demand for inexpensive
learning, FSL has drawn much recent attention and is now a hot topic. Many related machine
learning approaches have been proposed, such as meta-learning , embedding learning
 and generative modeling . However, currently, there is no work that
provides an organized taxonomy to connect these FSL methods, explains why some methods work
while others fail, nor discusses the pros and cons of different approaches. Therefore, in this paper,
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
we conduct a survey on the FSL problem. In contrast, the survey in only focuses on concept
learning and experience learning for small samples.
Contributions of this survey can be summarized as follows:
• We give a formal definition on FSL, which naturally connects to the classic machine learning
definition in . The definition is not only general enough to include existing FSL works,
but also specific enough to clarify what the goal of FSL is and how we can solve it. This
definition is helpful for setting future research targets in the FSL area.
• We list the relevant learning problems for FSL with concrete examples, clarifying their
relatedness and differences with respect to FSL. These discussions can help better discriminate
and position FSL among various learning problems.
• We point out that the core issue of FSL supervised learning problem is the unreliable empirical
risk minimizer, which is analyzed based on error decomposition in machine learning.
This provides insights to improve FSL methods in a more organized and systematic way.
• We perform an extensive literature review, and organize them in an unified taxonomy
from the perspectives of data, model and algorithm. We also present a summary of insights
and a discussion on the pros and cons of each category. These can help establish a better
understanding of FSL methods.
• We propose promising future directions for FSL in the aspects of problem setup, techniques,
applications and theories. These insights are based on the weaknesses of the current development of FSL, with possible improvements to make in the future.
Organization of the Survey
The remainder of this survey is organized as follows. Section 2 provides an overview for FSL,
including its formal definition, relevant learning problems, core issue, and a taxonomy of existing
works in terms of data, model and algorithm. Section 3 is for methods that augment data to solve
FSL problem. Section 4 is for methods that reduce the size of hypothesis space so as to make FSL
feasible. Section 5 is for methods that alter the search strategy of algorithm to deal with the FSL
problem. In Section 6, we propose future directions for FSL in terms of problem setup, techniques,
applications and theories. Finally, the survey closes with conclusion in Section 7.
Notation and Terminology
Consider a learning task T, FSL deals with a data set D = {Dtrain, Dtest} consisting of a training set
Dtrain = {(xi,yi)}I
i=1 where I is small, and a testing set Dtest = {xtest}. Letp(x,y) be the ground-truth
joint probability distribution of input x and output y, and ˆh be the optimal hypothesis from x to
y. FSL learns to discover ˆh by fitting Dtrain and testing on Dtest. To approximate ˆh, the FSL model
determines a hypothesis space H of hypotheses h(·;θ)’s, where θ denotes all the parameters used
by h. Here, a parametric h is used, as a nonparametric model often requires large data sets, and
thus not suitable for FSL. A FSL algorithm is an optimization strategy that searches H in order to
find the θ that parameterizes the best h∗∈H. The FSL performance is measured by a loss function
ℓ(ˆy,y) defined over the prediction ˆy = h(x;θ) and the observed output y.
In this section, we first provide a formal definition of the FSL problem in Section 2.1 with concrete
examples. To differentiate the FSL problem from relevant machine learning problems, we discuss
their relatedness and differences in Section 2.2. In Section 2.3, we discuss the core issue that makes
FSL difficult. Section 2.4 then presents a unified taxonomy according to how existing works handle
the core issue.
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
Problem Definition
As FSL is a sub-area in machine learning, before giving the definition of FSL, let us recall how
machine learning is defined in the literature.
Definition 2.1 (Machine Learning ). A computer program is said to learn from experience
E with respect to some classes of taskT and performance measure P if its performance can improve
with E on T measured by P.
For example, consider an image classification task (T), a machine learning program can improve
its classification accuracy (P) through E obtained by training on a large number of labeled images
(e.g., the ImageNet data set ). Another example is the recent computer program AlphaGo ,
which has defeated the human champion in playing the ancient game of Go (T). It improves its
winning rate (P) against opponents by training on a database (E) of around 30 million recorded
moves of human experts as well as playing against itself repeatedly. These are summarized in
Table 1. Examples of machine learning problems based on Definition 2.1.
experience E
performance P
image classification 
large-scale labeled images for each class
classification
the ancient game of Go 
a database containing around 30 million recorded moves
of human experts and self-play records
winning rate
Typical machine learning applications, as in the examples mentioned above, require a lot of
examples with supervised information. However, as mentioned in the introduction, this may be
difficult or even not possible. FSL is a special case of machine learning, which targets at obtaining
good learning performance given limited supervised information provided in the training set Dtrain,
which consists of examples of inputs xi’s along with their corresponding output yi’s . Formally,
we define FSL in Definition 2.2.
Definition 2.2. Few-Shot Learning (FSL) is a type of machine learning problems (specified by E,
T and P), where E contains only a limited number of examples with supervised information for the
Existing FSL problems are mainly supervised learning problems. Concretely, few-shot classification
learns classifiers given only a few labeled examples of each class. Example applications include
image classification , sentiment classification from short text and object recognition
 . Formally, using notations from Section 1.2, few-shot classification learns a classifier h which
predicts label yi for each input xi. Usually, one considers the N-way-K-shot classification ,
in which Dtrain contains I = KN examples from N classes each with K examples. Few-shot regression
 estimates a regression function h given only a few input-output example pairs sampled
from that function, where output yi is the observed value of the dependent variable y, and xi is
the input which records the observed value of the independent variable x. Apart from few-shot
supervised learning, another instantiation of FSL is few-shot reinforcement learning , which
targets at finding a policy given only a few trajectories consisting of state-action pairs.
We now show three typical scenarios of FSL (Table 2):
• Acting as a test bed for learning like human. To move towards human intelligence, it is vital
that computer programs can solve the FSL problem. A popular task (T) is to generate samples
of a new character given only a few examples . Inspired by how humans learn, the
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
computer programs learn with the E consisting of both the given examples with supervised
information and pre-trained concepts such as parts and relations as prior knowledge. The
generated characters are evaluated through the pass rate of visual Turing test (P), which
discriminates whether the images are generated by humans or machines. With this prior
knowledge, computer programs can also learn to classify, parse and generate new handwritten
characters with a few examples like humans.
• Learning for rare cases. When obtaining sufficient examples with supervised information
is hard or impossible, FSL can learn models for the rare cases. For example, consider a
drug discovery task (T) which tries to predict whether a new molecule has toxic effects .
The percentage of molecules correctly assigned as toxic or non-toxic (P) improves with E
obtained by both the new molecule’s limited assay, and many similar molecules’ assays as
prior knowledge.
• Reducing data gathering effort and computational cost. FSL can help relieve the burden of
collecting large number of examples with supervised information. Consider few-shot image
classification task (T) . The image classification accuracy (P) improves with the E obtained
by a few labeled images for each class of the target T, and prior knowledge extracted from
the other classes (such as raw images to co-training). Methods succeed in this task usually
have higher generality. Therefore, they can be easily applied for tasks of many samples.
Table 2. Three FSL examples based on Definition 2.2.
experience E
performance P
supervised information
prior knowledge
character generation 
a few examples of new
pre-learned knowledge of
parts and relations
pass rate of visual
Turing test
drug toxicity discovery 
new molecule’s limited
similar molecules’ assays
classification
image classification 
a few labeled images for
each class of the target T
raw images of other classes,
or pre-trained models
classification
In comparison to Table 1, Table 2 has one extra column under “experience E" which is marked
as “prior knowledge". As E only contains a few examples with supervised information directly
related to T, it is natural that common supervised learning approaches often fail on FSL problems.
Therefore, FSL methods make the learning of targetT feasible by combining the available supervised
information in E with some prior knowledge, which is “any information the learner has about the
unknown function before seeing the examples" . One typical type of FSL methods is Bayesian
learning . It combines the provided training set Dtrain with some prior probability distribution
which is available before Dtrain is given .
Remark 1. When there is only one example with supervised information in E, FSL is called one-shot
learning . When E does not contain any example with supervised information for the
target T, FSL becomes a zero-shot learning problem (ZSL) . As the target class does not contain
examples with supervised information, ZSL requires E to contain information from other modalities
(such as attributes, WordNet, and word embeddings used in rare object recognition tasks), so as to
transfer some supervised information and make learning possible.
Relevant Learning Problems
In this section, we discuss some relevant machine learning problems. The relatedness and difference
with respect to FSL are clarified.
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
• Weakly supervised learning learns from experience E containing only weak supervision
(such as incomplete, inexact, inaccurate or noisy supervised information). The most relevant
problem to FSL is weakly supervised learning with incomplete supervision where only a small
amount of samples have supervised information. According to whether the oracle or human
intervention is leveraged, this can be further classified into the following:
– Semi-supervised learning , which learns from a small number of labeled samples and
(usually a large number of) unlabeled samples in E. Example applications are text and
webpage classification. Positive-unlabeled learning is a special case of semi-supervised
learning, in which only positive and unlabeled samples are given. For example, to recommend friends in social networks, we only know the users’ current friends according to the
friend list, while their relationships to other people are unknown.
– Active learning , which selects informative unlabeled data to query an oracle for
output y. This is usually used for applications where annotation labels are costly, such as
pedestrian detection.
By definition, weakly supervised learning with incomplete supervision includes only classification and regression, while FSL also includes reinforcement learning problems. Moreover,
weakly supervised learning with incomplete supervision mainly uses unlabeled data as additional information in E, while FSL leverages various kinds of prior knowledge such as
pre-trained models, supervised data from other domains or modalities and does not restrict
to using unlabeled data. Therefore, FSL becomes weakly supervised learning problem only
when prior knowledge is unlabeled data and the task is classification or regression.
• Imbalanced learning learns from experience E with a skewed distribution for y. This
happens when some values of y are rarely taken, as in fraud detection and catastrophe
anticipation applications. It trains and tests to choose among all possible y’s. In contrast,
FSL trains and tests for y with a few examples, while possibly taking the other y’s as prior
knowledge for learning.
• Transfer learning transfers knowledge from the source domain/task, where training
data is abundant, to the target domain/task, where training data is scarce. It can be used in
applications such as cross-domain recommendation, WiFi localization across time periods,
space and mobile devices. Domain adaptation is a type of transfer learning in which the
source/target tasks are the same but the source/target domains are different. For example, in
sentiment analysis, the source domain data contains customer comments on movies, while the
target domain data contains customer comments on daily goods. Transfer learning methods
are popularly used in FSL , where the prior knowledge is transferred from the
source task to the few-shot task.
• Meta-learning improves P of the new task T by the provided data set and the metaknowledge extracted across tasks by a meta-learner. Specifically, the meta-learner gradually
learns generic information (meta-knowledge) across tasks, and the learner generalizes the
meta-learner for a new task T using task-specific information. It has been successfully
applied in problems such as learning optimizers , dealing with the cold-start problem
in collaborative filtering , and guiding policies by natural language . Meta-learning
methods can be used to deal with the FSL problem. As will be shown in Sections 4 and 5, the
meta-learner is taken as prior knowledge to guide each specific FSL task. A formal definition
of meta-learning and how it is used for the FSL problem are provided in Appendix A.
Core Issue
In any machine learning problem, usually there are prediction errors and one cannot obtain perfect
predictions. In this section, we illustrate the core issue of FSL based on error decomposition in
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
supervised machine learning . This analysis applies to FSL supervised learning including
classification and regression, and can also provide insights for understanding FSL reinforcement
Empirical Risk Minimization. Given a hypothesis h, we want to minimize its expected risk R,
which is the loss measured with respect to p(x,y). Specifically,
ℓ(h(x),y) dp(x,y) = E[ℓ(h(x),y)].
As p(x,y) is unknown, the empirical risk (which is the average of sample losses over the training
set Dtrain of I samples)
ℓ(h(xi),yi),
is usually used as a proxy for R(h), leading to empirical risk minimization (with possibly
some regularizers). For illustration, let
• ˆh = arg minh R(h) be the function that minimizes the expected risk;
• h∗= arg minh∈H R(h) be the function in H that minimizes the expected risk;
• hI = arg minh∈H RI(h) be the function in H that minimizes the empirical risk.
As ˆh is unknown, one has to approximate it by some h ∈H. h∗is the best approximation for ˆh in
H, while hI is the best hypothesis in H obtained by empirical risk minimization. For simplicity,
we assume that ˆh,h∗and hI are unique. The total error can be decomposed as :
E[R(hI) −R(ˆh)] = E[R(h∗) −R(ˆh)]
+ E[R(hI) −R(h∗)]
Eest(H, I)
where the expectation is with respect to the random choice of Dtrain. The approximation error
Eapp(H) measures how close the functions in H can approximate the optimal hypothesis ˆh, and
the estimation error Eest(H, I) measures the effect of minimizing the empirical risk RI(h) instead of
the expected risk R(h) within H.
As shown, the total error is affected by H (hypothesis space) and I (number of examples in
Dtrain). In other words, learning to reduce the total error can be attempted from the perspectives of
(i) data, which provides Dtrain; (ii) model, which determines H; and (iii) algorithm, which searches
for the optimal hI ∈H that fits Dtrain.
Unreliable Empirical Risk Minimizer. In general, Eest(H, I) can be reduced by having a larger
number of examples . Thus, when there is sufficient training data with supervised
information (i.e., I is large), the empirical risk minimizer hI can provide a good approximation
R(hI) to the best possible R(h∗) for h’s in H.
However, in FSL, the number of available examples I is small. The empirical risk RI(h) may then
be far from being a good approximation of the expected risk R(h), and the resultant empirical risk
minimizer hI overfits. Indeed, this is the core issue of FSL supervised learning, i.e., the empirical
risk minimizer hI is no longer reliable. Therefore, FSL is much harder. A comparison of learning
with sufficient and few training samples is shown in Figure 1.
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
(a) Large I.
(b) Small I.
Fig. 1. Comparison of learning with sufficient and few training samples.
To alleviate the problem of having an unreliable empirical risk minimizer hI in FSL supervised
learning, prior knowledge must be used. Based on which aspect is enhanced using prior knowledge,
existing FSL works can be categorized into the following perspectives (Figure 2).
(b) Model.
(c) Algorithm.
Fig. 2. Different perspectives on how FSL methods solve the few-shot problem.
• Data. These methods use prior knowledge to augment Dtrain, and increase the number of
samples from I to ˜I, where ˜I ≫I. Standard machine learning models and algorithms can
then be used on the augmented data, and a more accurate empirical risk minimizer h ˜I can be
obtained (Figure 2(a)).
• Model. These methods use prior knowledge to constrain the complexity of H, which results in
a much smaller hypothesis space ˜H. As shown in Figure 2(b), the gray area is not considered
for optimization as they are known to be unlikely to contain the optimal h∗according to
prior knowledge. For this smaller ˜H, Dtrain is sufficient to learn a reliable hI .
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
• Algorithm. These methods use prior knowledge to search for the θ which parameterizes the
best hypothesis h∗in H. Prior knowledge alters the search strategy by providing a good
initialization (gray triangle in Figure 2(c)), or guiding the search steps (the gray dotted lines
in Figure 2(b)). For the latter, the resultant search steps are affected by both prior knowledge
and empirical risk minimizer.
Accordingly, existing works can be categorized into a unified taxonomy as shown in Figure 3.
We will detail each category in the following sections.
Fig. 3. A taxonomy of FSL methods based on the focus of each method.
FSL methods in this section use prior knowledge to augment data Dtrain, such that the supervised
information in E is enriched. With the augmented sample set, the data is sufficient enough to obtain
a reliable hI (Figure 4).
Data augmentation via hand-crafted rules is usually used as pre-processing in FSL methods. They
can introduce different kinds of invariance for the model to capture. For example, on images, one
can use translation , flipping , shearing , scaling , reflection
 , cropping and rotation . However, designing these rules depends heavily
on domain knowledge and requires expensive labor cost. Moreover, the augmentation rules can be
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
specific to the data set, making them hard to be applied to other data sets. Moreover, it is unlikely
that human can enumerate all possible invariance. Therefore, manual data augmentation cannot
solve the FSL problem completely .
Besides these hand-crafted rules, we review in the following more advanced data augmentation
methods. Depending on what samples are transformed and added to Dtrain, we categorize these
methods as shown in Table 3.
Fig. 4. Solving the FSL problem by data augmentation.
Table 3. Characteristics for FSL methods focusing on the data perspective. The transformer t(·) takes input
(x,y) and returns synthesized sample ( ˜x, ˜y) to augment the few-shot Dtrain.
input (x, y)
transformer t
output ( ˜x, ˜y)
transforming samples from
original (xi, yi)
learned transformation
function on xi
(t(xi), yi)
transforming samples from a
weakly labeled or unlabeled
weakly labeled or unlabeled
a predictor trained from
( ¯x, t( ¯x))
transforming samples from
similar data sets
samples {( ˆxj, ˆyj)} from
similar data sets
an aggregator to combine
{( ˆxj, ˆyj)}
(t({ ˆxj }), t({ ˆyj }))
Transforming Samples from Dtrain
This strategy augments Dtrain by transforming each (xi,yi) ∈Dtrain into several samples with
variations. The transformation procedure is included in experience E as prior knowledge so as to
generate additional samples. An early FSL paper learns a set of geometric transformations
from a similar class by iteratively aligning each sample with the other samples. The learned
transformation is applied to each (xi,yi) to form a large data set, which can then be learned by
standard machine learning methods. Similarly, a set of auto-encoders, each representing one intraclass variability, are learned from similar classes in . New samples are generated by adding the
learned variations to xi. In , by assuming that all categories share some transformable variability
across samples, a single transformation function is learned to transfer variation between sample
pairs learned from the other classes to (xi,yi). In , instead of enumerating the variabilities
within pairs, it transforms each xi to several samples using a set of independent attribute strength
regressors learned from a large set of scene images, and assigns the label of the original xi to
these new samples. Improved upon , a continuous attribute subspace is used to add attribute
variations to x in .
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
Transforming Samples from a Weakly Labeled or Unlabeled Data Set
This strategy augments Dtrain by selecting samples with the target label from a large data set
which is weakly labeled or unlabeled. For example, in photos taken by a surveillance camera, there
are people, cars and roads but none of them are labeled. Another example is a video for a long
presentation. This contains a series of gestures of the speaker, but none of them are annotated
explicitly. As such a data set contains large variations of samples, augmenting them to Dtrain helps
depict a clearer p(x,y). Moreover, collecting such a data set is easier as human effort is not needed
for labeling. However, though the collection cost is low, a major issue is how to select samples with
the target label to be augmented to Dtrain. In , an exemplar SVM is learned for each target
label in Dtrain, which is then used to predict labels for samples from a weakly labeled data set.
Samples having the target labels are then added to Dtrain. In , instead of learning a classifier,
label propagation is directly used to label an unlabeled data set. In , a progressive strategy is
used to select informative unlabeled samples. The selected samples are then assigned pseudo-labels
and used to update the CNN.
Transforming Samples from Similar Data Sets
This strategy augments Dtrain by aggregating and adapting input-output pairs from a similar but
larger data sets. The aggregation weight is usually based on some similarity measure between
samples. In , it extracts the aggregation weight from an auxiliary text corpus . As these
samples may not come from the target FSL class, directly augmenting the aggregated samples to
Dtrain may be misleading. Therefore, a generative adversarial network (GAN) is designed to
generate indistinguishable synthetic ˜x aggregated from a data set of many samples . It has two
generators, one maps samples of the few-shot class to the large-scale class, and the other maps
samples of the large-scale class to the few-shot class (to compensate for the lack of samples in GAN
training).
Discussion and Summary
The choice of which augmentation strategy to use depends on the application. Sometimes, a large
number of weakly supervised or unlabeled samples exist for the target task (or class), but few-shot
learning is preferred because of the high cost of gathering annotated data and/or computational
cost (which corresponds to the third scenario introduced in Section 2.1). In this case, one can
perform augmentation by transforming samples from a weakly labeled or unlabeled data set. When
a large-scale unlabeled data set is hard to collect, but the few-shot class has some similar classes,
one can transform samples from these similar classes. If only some learned transformers rather
than raw samples are available, augmentation can be done by transforming the original samples
from Dtrain.
In general, solving a FSL problem by augmenting Dtrain is straightforward and easy to understand.
The data is augmented by taking advantage of the prior information for the target task. On the other
hand, the weakness of solving the FSL problem by data augmentation is that the augmentation
policy is often tailor-made for each data set in an adhoc manner, and cannot be used easily on
other data sets (especially for data sets from other domains). Recently, AutoAugment , which
automatically learns the augmentation policy for deep network training, is proposed to address
this issue. Apart from that, existing methods are mainly designed for images, as the generated
images can be visually evaluated by humans easily. In contrast, text and audio involve syntax and
structures, and are harder to generate. A recent attempt on using data augmentation for text is
reported in .
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
In order to approximate the ground-truth hypothesis ˆh, the model has to determine a hypothesis
space H containing a family of hypotheses h’s, such that the distance between the optimal h∗∈H
and ˆh is small.
Given the few-shot Dtrain with limited samples, one can choose a small H with only simple
models (such as linear classifiers) . However, real-world problems are typically complicated,
and cannot be well represented by an hypothesis h from a small H (which can lead to a large
Eapp(H) in (1)) . Therefore, a large enough H is preferred in FSL, which makes standard
machine learning models infeasible. FSL methods in this section manage to learn by constraining
H to a smaller hypothesis space ˜H via prior knowledge in E (Figure 2(b)). The empirical risk
minimizer is then more reliable, and the risk of overfitting is reduced.
In terms of what prior knowledge is used, methods belonging to this category can be further
classified into four types (Table 4).
Table 4. Characteristics for FSL methods focusing on the model perspective.
prior knowledge
how to constrain H
multitask learning
other T ’s with their data sets D’s
share/tie parameter
embedding learning
embedding learned from/together with
other T ’s
project samples to a smaller embedding
space in which similar and dissimilar
samples can be easily discriminated
learning with external memory
embedding learned from other T ’s to
interact with memory
refine samples using key-value pairs
stored in memory
generative modeling
prior model learned from other T ’s
restrict the form of distribution
Multitask Learning
In the presence of multiple related tasks, multitask learning learns these tasks simultaneously by exploiting both task-generic and task-specific information. Hence, they can be naturally
used for FSL. Here, we present some instantiations of using multitask learning in FSL .
We are given C related tasks T1, . . . ,TC, in which some of them have very few samples while
some have a larger number of samples. Each task Tc has a data set Dc = {Dc
test}, in which
train is the training set and Dc
test is the test set. Among these C tasks, we regard the few-shot tasks
as target tasks, and the rest as source tasks. Multitask learning learns from Dc
train’s to obtain θc for
each Tc. As these tasks are jointly learned, the parameter θc of hc learned for task Tc is constrained
by the other tasks. According to how the task parameters are constrained, we divide methods in
this strategy as (i) parameter sharing; and (ii) parameter tying .
Parameter Sharing. This strategy directly shares some parameters among tasks (Figure 5).
In , the two task networks share the first few layers for the generic information, and learn
different final layers to deal with different outputs. In , two natural language processing tasks on
legal texts are solved together: charge prediction and legal attribute prediction. A single embedding
function is used to encode the criminal case description, which is then fed to task-specific embedding
functions and classifiers. In , a variational auto-encoder is first pre-trained from the source tasks,
and then cloned to the target task. Some layers in the two variational auto-encoders are shared
in order to capture the generic information, while allowing both tasks to have some task-specific
layers. The target task can only update its task-specific layers, while the source task can update
both the shared and task-specific layers. In , both the original and generated samples are first
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
mapped to a task-specific space by learning separate embedding functions for the source and target
tasks, and are then embedded by a shared variational auto-encoder.
Fig. 5. Solving the FSL problem by multitask learning with parameter sharing.
Parameter Tying. This strategy encourages parameters (θc’s) of different tasks to be similar
(Figure 6) . A popular approach is by regularizing the θc’s. In , all pairwise differences of
θc’s are penalized. In , there is a CNN for the source task, and another one for the target task.
Layers of these two CNNs are aligned using some specially designed regularization terms.
Fig. 6. Solving the FSL problem by multitask learning with parameter tying.
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
Embedding Learning
Embedding learning embeds each sample xi ∈X ⊆Rd to a lower-dimensional zi ∈
Z ⊆Rm, such that similar samples are close together while dissimilar samples can be more easily
differentiated. In this lower-dimensional Z, one can then construct a smaller hypothesis space ˜H
which subsequently requires fewer training samples. The embedding function is mainly learned
from prior knowledge, and can additionally use task-specific information from Dtrain.
Embedding learning has the following key components: (i) a function f which embeds test
sample xtest ∈Dtest to Z, (ii) a function д which embeds training sample xi ∈Dtrain to Z, and (iii)
a similarity function s(·, ·) which measures the similarity between f (xtest) and д(xi) in Z. The test
sample xtest is assigned to the class of xi, whose embedding д(xi) is most similar to f (xtest) in Z
according to s. Although one can use a common embedding function for both xi and xtest, using
two separate embedding functions may obtain better accuracy . A summary of existing
embedding learning methods is shown in Table 5.
According to whether the parameters of embedding functions f and д vary across tasks, we
classify these FSL methods as using a (i) task-specific embedding model; (ii) task-invariant (i.e.,
general) embedding model; and (iii) hybrid embedding model, which encodes both task-specific
and task-invariant information.
Table 5. Characteristics of embedding learning methods.
embedding function
f for xtest
embedding function
д for Dtrain
similarity measure s
task-specific
mAP-DLM/SSVM 
the same as f
cosine similarity
task-invariant
class relevance
pseudo-metric 
the same as f
squared ℓ2 distance
convolutional siamese
the same as f
weighted ℓ1 distance
Micro-Set 
logistic projection
the same as f
ℓ2 distance
Matching Nets 
CNN, biLSTM
cosine similarity
resLSTM 
cosine similarity
Active MN 
cosine similarity
another CNN
learned distance
ProtoNet 
the same as f
squared ℓ2 distance
semi-supervised
ProtoNet 
the same as f
squared ℓ2 distance
CNN, biLSTM
cosine similarity
LSTM, biLSTM
the same as f
Relation Net 
the same as f
the same as f
learned distance
the same as f
Gaussian similarity
SNAIL 
the same as f
Learnet 
adaptive CNN
weighted ℓ1 distance
DCCN 
adaptive CNN
R2-D2 
adaptive CNN
TADAM 
adaptive CNN
the same as f
squared ℓ2 distance
Task-Specific Embedding Model. Task-specific embedding methods learn an embedding
function tailored for each task, by using only information from that task. For example, using the
few-shot data Dc
train of task Tc, all pairwise rankings among samples in Dc
train are enumerated as
sample pairs in . The number of training samples is thus increased, and an embedding function
can be learned even though only the task-specific information is used.
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
Task-Invariant Embedding Model. Task-invariant embedding methods learn a general embedding function from a large-scale data set containing sufficient samples with various outputs,
and then directly use this on the new few-shot Dtrain without retraining (Figure 7). The first FSL
embedding model embeds the samples using a kernel. Recently, more complicated embeddings
are learned by a convolutional siamese net .
Fig. 7. Solving the FSL problem by task-invariant embedding model.
Although task-invariant embedding does not update the embedding model parameter using the
few-shot Dtrain, many methods in this category simulate the few-shot scenario while
training the embedding model. Assume that we have training sets {Dc}, each has N classes. In
each Dc, samples from only U out of its N classes are used for training. The embedding model
is optimized by maximizing the performance on the remaining N −U classes. Thus, the learned
model will have good generalization for few-shot tasks. An early attempt learns a linear
embedding from {Dc}. Recently, more complicated task-invariant embedding models are learned
via meta-learning2 methods:
(1) Matching Nets and its variants : Matching Nets meta-learns different
embedding functions (f and д) for the training sample xi and test sample xtest. The residual
LSTM (resLSTM) proposes better designs for f and д. An active learning variant of
Matching Nets adds a sample selection step, which labels the most beneficial unlabeled
sample and uses it to augment Dtrain. The Matching Nets is also extended to set-to-set
matching , which is useful in labeling multiple parts of a sample.
(2) Prototypical Networks (ProtoNet) and its variants : Instead of comparing
f (xtest) with eachд(xi) where xi ∈Dtrain, ProtoNet only compares f (xtest) with the class
prototypes in Dtrain. For class n, its prototype is simplycn = 1
i=1 д(xi), where the K xi’s are
from class n. Empirically, this leads to more stable results and reduces the computation cost.
The idea of using prototypes is introduced to the Matching Nets in . A semi-supervised
variant of ProtoNet assigns unlabeled samples to augment Dtrain via soft-assignment during
learning .
(3) Other methods. Examples include Attentive Recurrent Comparators (ARC) , which
uses a LSTM with attention to compare different regions of xtest with prototype cn, and
then embeds the comparison results as an intermediate embedding. Additionally, it uses a
bidirectional LSTM (biLSTM) to embed all comparisons as the final embedding. The Relation
Net uses a CNN to embed xtest and xi to Z, then concatenates them as the embedding,
which is fed to another CNN to output a similarity score. The graph neural network (GNN) is
2A brief introduction on meta-learning is provided in Appendix A. The few-shot task is actually one of the meta-testing
task Tt with Dt = {Dt
test}. For illustration simplicity, we drop the subscript and superscript t.
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
used in to leverage information from local neighborhoods. In few-shot reinforcement
learning applications (as in continuous control and visual navigation), temporal information is
important. The Simple Neural AttentIve Learner (SNAIL) is an embedding network with
interleaved temporal convolution layers and attention layers. The temporal convolution layer
aggregates information from past time steps, while the attention layer selectively attends to
specific time steps relevant to the current input.
Hybrid Embedding Model. Although task-invariant embedding methods can be applied to
new tasks with a low computation cost, they do not leverage specific knowledge of the current
task. When task specialty is the reason that Dtrain has only a few examples (such as learning for
rare cases), simply applying a task-invariant embedding function may not be suitable. To alleviate
this problem, hybrid embedding models adapt the generic task-invariant embedding model learned
from prior knowledge by the task-specific information in Dtrain This is done by learning a function
which takes information extracted from Dtrain as input and returns an embedding which acts as the
parameter for f (·) (Figure 8).
Fig. 8. Solving the FSL problem by hybrid embedding model.
Learnet improves the task-invariant convolutional siamese net by incorporating the
specific information of Dtrain. It learns a meta-learner from multiple meta-training sets, and maps
each training example xi ∈Dtrain to the parameter of the learner (a convolutional siamese net).
In this way, the parameter of f (·) changes with the given xi, resulting in a hybrid embedding.
Improved upon Learnet, the classification layer of the learner is replaced by ridge regression in
 , such that parameters can be efficiently obtained in closed-form. The following two works
 take Dtrain as a whole to output the task-specific parameter for f (·). Task dependent
adaptive metric (TADAM) averages class prototypes into the task embedding, and uses a
meta-learned function to map it to the ProtoNet parameters. Dynamic Conditional Convolutional
Network (DCCN) uses a fixed set of filters, and learns the combination coefficients using
Learning with External Memory
Learning with external memory extracts knowledge from Dtrain, and stores it in
an external memory (Figure 9). Each new sample xtest is then represented by a weighted average of
contents extracted from the memory. This limits xtest to be represented by contents in the memory,
and thus essentially reduces the size of H.
A key-value memory is usually used in FSL. Let the memory be M ∈Rb×m, with each of
its b memory slots M(i) ∈Rm consisting of a key-value pair M(i) = (Mkey(i), Mvalue(i)). A test
sample xtest is first embedded by an embedding function f . However, unlike embedding methods,
f (xtest) is not used directly as the representation of xtest. Instead, it is only used to query for the
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
Fig. 9. Solving the FSL problem by learning with external memory. This figure illustrates a simplified example
where the embedding function f is used for representation learning and the memory takes f (xi) as the key
and output yi as the label.
most similar memory slots, based on the similarity s(f (xtest), Mkey(i)) between f (xtest) and each
key Mkey(i). The values of the most similar memory slots (Mvalue(i)’s) are extracted and combined
to form the representation of xtest. This is then used as input to a simple classifier (such as a softmax
function) to make prediction. As manipulating M is expensive, M usually has a small size. When M
is not full, new samples can be written to vacant memory slots. When M is full, one has to decide
which memory slots to be replaced. Table 6 introduces the characteristics for methods with external
Table 6. Characteristics of FSL methods based on learning with external memory. Here, f is an embedding
function usually pre-trained by CNN or LSTM.
similarity s
value Mvalue
MANN 
f (xi, yi−1)
f (xi, yi−1)
cosine similarity
squared ℓ2 distance
abstraction memory 
word embedding of yi
dot product
representations
dot product
life-long memory 
cosine similarity
Mem2Vec 
word embedding of yi, age
dot product
MetaNet 
fast weight
cosine similarity
fast weight
cosine similarity
parameters
MN-Net 
dot product
As each xtest is represented as a weighted average of values extracted from the memory, the
quality of key-value pairs in the memory is important. According to the functionality of the memory,
FSL methods in this category can be subdivided into two types.
Refining Representations. The following methods carefully put Dtrain into the memory, such
that the stored key-value pairs can represent xtest more accurately. Memory-Augmented Neural
Networks (MANN) meta-learns the embedding f , and maps samples of the same class to
the same value. Samples of the same class then refine their class representations in the memory
together. This class representation can be viewed as a refined class prototype in ProtoNet .
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
The surprise-based memory module updates M only when it cannot represent an xi well.
Hence, updating M using this xi makes M more expressive, and also reduces the computation cost.
The abstract memory uses two memories. One extracts relevant key-value pairs from a fixed
memory containing large-scale machine annotated data set, and the other refines the extracted
values and abstracts out the most useful information for few-shot (image) classification. This idea
is extended to few-shot video classification in .
Along this line, some methods pay special attention to protecting the few-shot classes in the
memory. Note that few-shot classes are small, and so have a lower chance of being kept in M.
Each few-shot sample in M can also be easily replaced by samples from the more abundant
classes. To alleviate this problem, lifelong memory is proposed. Unlike previous memories
 which wipe out the memory content across tasks, the lifelong memory erases
the “oldest" memory value when the memory is full. The ages of all the memory slots are then
reset to zero. For a new sample, when the returned Mvalue(i) value matches its ground-truth output,
it is merged with the current Mkey(i) instead of being written to a new memory slot. Hence, it is
more likely that all classes occupy an equal number of memory slots, and rare classes are protected.
Recently, this lifelong memory is adapted to learn word representations in .
However, even with the use of a lifelong memory, rare samples can still be forgotten. After each
update, the lifelong memory resets the age of the selected M(i) to zero, and increases the ages of
the other non-empty memory slots by one. When the memory is full and the returned value is
wrong, the oldest memory slot is replaced. As the rare class samples seldom update their M(i)’s,
they have a higher chance of being erased.
Refining Parameters. Recall that the Learnet and its variants (Section 4.2.3) map information from Dtrain to parameterize the embedding function д(·) for a new xtest. This parameter can
be refined using a memory. Meta Networks (MetaNet) parameterizes a classification model
using a “slow" weight which is meta-learned from multiple data sets, and a “fast" weight which is a
task-specific embedding of Dtrain. As shown in , the computation cost of MetaNet can be reduced
by learning to modify each neuron rather the complete parameter. MN-Net uses a memory to
refine the embedding learned in the Matching Nets, whose output is used to parameterize a CNN
as in Learnet.
Generative Modeling
Generative modeling methods estimate the probability distribution p(x) from the observed xi’s with
the help of prior knowledge (Figure 10). Estimation of p(x) usually involves estimations of p(x|y)
and p(y). Methods in this class can deal with many tasks, such as generation ,
recognition , reconstruction , and image flipping .
Fig. 10. Solving the FSL problem by generative modeling.
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
In generative modeling, the observed x is assumed to be drawn from some distribution p(x;θ)
parameterized by θ. Usually, there exists a latent variable z ∼p(z;γ), so that x ∼
p(x|z;θ)p(z;γ)dz.
The prior distribution p(z;γ), which is learned from other data sets, brings in prior knowledge that
is vital to FSL. By combining the provided training set Dtrain with this p(z;γ), the resultant posterior
probability distribution is constrained. In other words, H is constrained to a much smaller ˜H.
According to what the latent variable z represents, we group these FSL generative modeling
methods into three types.
Decomposable Components. Although samples with supervised information are scarce in a
FSL problem, they may share some smaller decomposable components with samples from the other
tasks. For example, consider the recognition of a person using only a few face photos provided.
Although similar faces may be hard to find, one can easily find photos with similar eyes, noses
or mouths. With a larger number of samples, models for these decomposable components can
be easily learned. One then only needs to find the correct combination of these decomposable
components, and decides which target class this combination belongs to. As the decomposable
components are chosen by human, this strategy is more interpretable. Bayesian One-Shot uses
a generative model to capture the interactions between decomposable components (i.e., shapes
and appearances of objects) and target class (i.e., objects to be recognized). Bayesian Program
Learning (BPL) models characters by separating it into types, tokens and further templates,
parts, primitives. To generate a new character, one needs to search a large combination space
containing theses components. In , this inference cost is reduced by only considering the top
possible combinations. In natural language processing, a recent work models spans instead
of the complete parse tree, and adapts parsers between syntactically distant domains by training
individual classifiers for spans.
Groupwise Shared Prior. Often, similar tasks have similar prior probabilities, and this can
be utilized in FSL. For example, consider the three-class classification of “orange cat", “leopard"
and “Bengal tiger". These three species are similar, but Bengal tiger is endangered, while orange
cats and leopards are abundant. Hence, one can learn a prior probability from “orange cats" and
“leopards", and use this as the prior for the few-shot class “Bengal tiger".
In , a set of data sets {Dc} are grouped into a hierarchy via unsupervised learning. Data
sets in each group together learn the class prior probabilities. For a new few-shot class, one first
finds the group this new class belongs to, and then models it by the class prior drawn from the
groupwise shared prior probability. In , the feature learning step in is further improved
with the use of deep Boltzmann machines .
Parameters of Inference Networks. To find the best θ, one has to maximize the posterior
p(z|x;θ,γ) = p(x,z;θ,γ)
p(x|z;θ)p(z;γ)
p(x|z;θ)p(z;γ)dz
Due to the integral in the denominator, it is intractable to solve (2). A variational distribution
q(z;δ), which is learned from data, is often used to approximate p(z|x;θ,γ). Recently, this q(z;δ) is
approximated via amortized variational inference with the inference network . Although z no
longer has semantic meaning, the powerful representation learned by these deep models can lead
to better performance. Once learned, the inference network can be applied to a new task directly,
which is more efficient and requires less human knowledge. As the inference network has a large
number of parameters, it is usually trained using some auxiliary large-scale data sets. Many classic
inference networks are adapted to the FSL problem. For example, the variational auto-encoder
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
(VAE) is used in , autoregressive model is used in , generative adversarial
networks (GAN) is used in , and a combination of VAE and GAN is proposed in .
Discussion and Summary
When there exist similar tasks or auxiliary tasks, multitask learning can be used to constrain the
H of the few-shot task. However, note that joint training of all the tasks together is required. Thus,
when a new few-shot task arrives, the whole multitask model has to be trained again, which can be
costly and slow. Moreover, the sizes of D and Dc should not comparable, otherwise, the few-shot
task may be overwhelmed by tasks with many samples.
When there exist a large-scale data set containing sufficient samples of various classes, one can
use embedding learning methods. These methods map samples to a good embedding space in which
samples from different classes can be well-separated, and so a smaller ˜H is needed. However, they
may not work well when the few-shot task is not closely related to the other tasks. Moreover, more
exploration on how to mix the invariant and task-specific information of tasks is helpful.
When a memory network is available, it can be readily used for FSL by training a simple
model (e.g., classifier) on top of the memory. By using carefully-designed update rule, one can
selectively protect memory slots. The weakness of this strategy is that it incurs additional space
and computational costs, which increase with memory size. Therefore, current external memory
has a limited size.
Finally, when one wants to perform tasks such as generation and reconstruction besides FSL,
generative models can be used. They learn prior probability p(z;γ) from the other data sets, which
reduces H to a smaller ˜H. The learned generative models can also be used to generate samples for
data augmentation. However, generative modeling methods have high inference cost, and are more
difficult to derive than deterministic models.
The algorithm is the strategy to search in the hypothesis space H for the parameter θ of the
best hypothesis h∗ . At the tth iteration, θt = θt−1 + ∆θt−1, where ∆θt−1 is the update. For
example, for the popular stochastic gradient descent (SGD) and its variants , θ is updated as
θt = θt−1 −αt∇θt−1ℓ(h(xt;θt−1),yt),
where αt is the stepsize. With θ initialized at θ0, θt can be written as
When supervised information is rich, there are enough training samples to update θ, and to find
an appropriate stepsize α by cross-validation. However, in FSL, the provided few-shot Dtrain is not
large enough, and the obtained empirical risk minimizer is unreliable.
Methods in this section use prior knowledge to influence how θ is obtained, either by (i) providing
a good initialized parameter θ0, or (ii) directly learning an optimizer to output search steps. In terms
of how the search strategy is affected by prior knowledge, we classify methods in this section into
three groups (Table 7):
(1) Refining existing parameters. An initial θ0 learned from other tasks, and is then refined using
(2) Refining meta-learned parameters. An initial θ0 is meta-learned from a set of tasks, which are
drawn from the same task distribution as the few-shot task, and then further refined by the
learner using Dtrain.
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
(3) Learning the optimizer. This strategy learns a meta-learner as optimizer to output search
steps for each learner directly, such as changing the search direction or stepsize.
Table 7. Characteristics for FSL methods focusing on the algorithm perspective.
prior knowledge
how to search θ of the h∗in H
refining existing parameters
learned θ0
refine θ0 by Dtrain
refining meta-learned parameters
meta-learner
refine θ0 by Dtrain
learning the optimizer
meta-learner
use search steps provided by the meta-learner
Refining Existing Parameters
This strategy takes θ0 of a pre-trained model learned from related tasks as a good initialization, and
adapts it to θ by Dtrain. The assumption is that θ0 captures some general structures of the large-scale
data. Therefore, it can be adapted to D with a few iterations.
Fine-Tuning Existing Parameter by Regularization. This strategy fine-tunes the pre-trained
θ0 for the few-shot task by regularization (Figure 11), and is popularly used in practice. In ,
a CNN pre-trained on the ImageNet for image classification is tuned using a large data set for
foreground segmentation, then further fine-tuned using a single shot of segmented object for object
segmentation. Given the few-shot Dtrain, simply fine-tuning θ0 by gradient descent may lead to
overfitting. Hence, how to adapt θ0 without overfitting to Dtrain is a key design issue.
Fig. 11. Solving the FSL problem by fine-tuning existing parameter θ0 by regularization.
In this section, methods fine-tune θ0 by regularization to prevent overfitting. They can be grouped
as follows:
(1) Early-stopping. It requires separating a validation set from Dtrain to monitor the training
procedure. Learning is stopped when there is no performance improvement on the validation
(2) Selectively updating θ0. Only a portion of θ0 is updated in order to avoid overfitting. For
example, in , given a set of pre-trained filters, it only learns a strength parameter that is
multiplied with the filters.
(3) Updating related parts of θ0 together. One can group elements of θ0 (such as the neurons in
a deep neural network), and update each group jointly with the same update information.
In , the filters of a pre-trained CNN are clustered together according to some auxiliary
information, and then fine-tuned by groupwise back-propagation using Dtrain.
(4) Using a model regression network. A model regression network captures the task-agnostic
transformation which maps the parameter values obtained by training on a few examples
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
to the parameter values that will be obtained by training on a lot of samples. Similarly, in
 , the transformation function that maps the embedding of xi to a classification decision
boundary is learned.
Aggregating a Set of Parameters. Sometimes, we do not have a suitable θ0 to start with.
Instead, we have many models that are learned from related tasks. For example, in face recognition,
we may already have recognition models for the eye, nose, and ear. Therefore, one can aggregate
these model parameters to a suitable model, which is then either directly used or refined by Dtrain
(Figure 12).
Fig. 12. Solving the FSL problem by aggregating a set of parameters θ0’s into θ. Provided with a set of
pre-trained θ0’s, one only needs to learn the combination weights (blue lines).
As discussed in Section 3, samples from unlabeled data sets (Section 3.2) and similar labeled data
sets (Section 3.3) can be used to augment the few-shot Dtrain. Instead of using the samples directly,
the following methods use models (with parameters θ0’s) pre-trained from these data sets. The
problem is then how to adapt them efficiently to the new task using Dtrain.
(1) Unlabeled data set. Although there is no supervised information, similar samples can be
grouped together. Therefore, one can pre-train functions from the unlabeled data to cluster
and separate samples well. A neural network is then used to adapt them to the new task with
the few-shot Dtrain .
(2) Similar data sets. In , few-shot object classification is performed by leveraging samples
and classifiers from similar classes. First, it replaces the features of samples from these similar
classes by features from the new class. The learned classifier is then reused, and only the
classification threshold is adjusted for the new class. In , they learn to combine
existing parameters learned from similar data sets using Dtrain.
Fine-Tuning Existing Parameter with New Parameters. The pre-trained θ0 may not be enough
to encode the new FSL task completely. Hence, an additional parameter(s) δ is used to take the
specialty of Dtrain into account (Figure 13). Specifically, this strategy expands the model parameter
to become θ = {θ0,δ}, and fine-tunes θ0 while learning δ. In , it uses the lower layers of a pretrained CNN for feature embedding, and learns a linear classifier on the embedded features using
Dtrain. In font style transfer , a network is first pre-trained to capture the fonts in gray images.
To generate stylish colored fonts, this is fine-tuned together with the training of an additional
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
Fig. 13. Solving the FSL problem by fine-tuning existing parameter θ0 with new parameters.
Refining Meta-Learned Parameter
Methods in this section use meta-learning to refine the meta-learned parameter θ0 (Figure 14). The
θ0 is continuously optimized by the meta-learner according to performance of the learner. This is
different from Section 5.1 in which θ0 is fixed.
Fig. 14. Solving the FSL problem by refining the meta-learned parameter θ0.
The meta-learned θ0 is often refined by gradient descent. A representative method is the Model-
Agnostic Meta-Learning (MAML) . It meta-learns θ0, which is then adjusted to obtain a good
task-specific parameter ϕs for some Ts ∼P(T) via a few effective gradient descent steps, as:
ϕs = θ0 −α∇θ0Ls
train(θ0). Here, Ls
train(θ0) is the sum of losses over the training samples in Dtrain, and
α is the stepsize. Note thatϕs is invariant to permutation of the samples. The meta-learned parameter
θ0 is updated by feedbacks from multiple meta-training tasks as θ0 ←θ0 −β∇θ0
Ts∼P(T ) Ls
test(θ0) is the sum of losses over the test samples in Dtest and β is another stepsize. By
continuously refining θ0 using the few-shot samples in Dtrain, the meta-learner improves its θ0 to
quickly adapt to the few-shot training set.
Recently, many improvements have been proposed for MAML, mainly along the following three
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
(1) Incorporating task-specific information. MAML provides the same initialization for all tasks.
However, this neglects task-specific information, and is appropriate only when the set of
tasks are all very similar. To address this problem, in , it learns to choose {θ0} from a
subset of a good initialization parameter for a new task.
(2) Modeling the uncertainty of using a meta-learned θ0. Learning with a few examples inevitably
results in a model with higher uncertainty . Hence, the learned model may not be able
to perform prediction on the new task with high confidence. The ability to measure this
uncertainty provides hints for active learning and further data collection . There are works
that consider uncertainty for the meta-learned θ0 , uncertainty for the task-specific
ϕs , and uncertainty for class n’s class-specific parameter ϕs,n .
(3) Improving the refining procedure. Refinement by a few gradient descent steps may not be
reliable. Regularization can be used to correct the descent direction. In , the model
regression network is used to regularize task Ts’s ϕs to be close to the model trained
with large-scale samples.
Learning the Optimizer
In Section 5.2, the meta-learner θ0 acts as a good initialization for T ∼P(T) with data D, and it
is adjusted to a task-specific parameter ϕ via a few effective gradient descent steps. In contrast,
instead of using gradient descent, methods in this section learns an optimizer which can directly
output the update (Ít
i=1 ∆θi−1 in (4)) (Figure 15). There is then no need to tune the stepsize α or
find the search direction, as the learning algorithm does that automatically.
Fig. 15. Solving the FSL problem by learning the optimizer.
At the tth iteration, this line of works learn an meta-learner which takes the error signal
computed at the (t −1)th iteration, and directly outputs update ∆ϕt−1 to update the task-specific
parameter ϕt−1 of the learner as ϕt = ϕt−1 +∆ϕt−1. Therefore, in contrast to strategies mentioned in
Sections 5.1 and 5.2, this strategy provides an optimizer for the new task (which is in turn optimized
by the learner). This ϕt is then used to compute the loss ℓt(ϕt) = ℓ(h(xt;ϕt),yt) using the tth
sample (xt,yt) ∈Dtrain, which acts as the error signal to be fed into the meta-learner at the next
iteration. After learning a task, the meta-learner is improved by gradient descent on the loss on
the test set Dtest. By learning from a set of Ts’s drawn from P(T), the meta-learner improves on
proposing efficient algorithms for FSL. Recently, obtains ϕt by instantiating (3) with the cell
state update in the LSTM (where ϕ is set to the cell state of the LSTM).
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
Discussion and Summary
Refining existing parameters can reduce the search effort in H. By using an existing θ0 as initialization, these methods usually need a lower computation cost to obtain a good hypothesis
h ∈H. Learning focuses on refining these existing parameters. However, as θ0 is learned from
tasks different from the current task, this strategy may sacrifice precision for speed.
The other two strategies rely on meta-learning. By learning from a set of related tasks, the metalearned θ0 can be closer to the task-specific parameter ϕt for a new task Tt. Learning search steps
by a meta-learner can directly guide the learning algorithm. In other words, the meta-learner acts
as an optimizer. However, important issues such as how to meta-learn across different granularities
(such as coarse-grained classifications of animals versus fine-grained classification of dog species)
or different data sources (such as images versus texts) are still open. From this perspective,
meta-learning and multi-tasks are similar, and so there is also a concern on how to avoid negative
transfer 
FUTURE WORKS
In this section, we discuss four key directions for the further development of FSL, namely, (i)
problem setups, (ii) techniques, (iii) applications and (iv) theories.
Problem Setups
Existing FSL methods often use prior knowledge from one single modality (such as images, texts,
or videos). However, though Dtrain has a few examples for the modality currently used, there may
exist another modality in which supervised samples are abundant. An example is in the study of
extinct animals. While this animal species may only have a limited number of visual examples,
there might be a lot of information about it in the textual domain (such as textbooks or web pages),
as people tend to pay special attention to the rare class. Therefore, prior knowledge from multiple
modalities can provide prior knowledge for complementary views. In zero-shot learning (ZSL),
multi-modality data has been frequently used. Example prior information are attributes ,
WordNet , word embeddings , co-occurrence statistics , and knowledge graphs
Recently, there have been efforts in borrowing techniques from ZSL methods to FSL problems.
For example, one can use the few-shot Dtrain to fine-tune the parameters learned by ZSL methods
 . However, fine-tuning using a small number of samples may lead to overfitting. Another
possibility is to force the embedding learned by multiple modalities to match in a shared space
 . A recent work exploits the structured relationships among labels and utilizes a
GNN to align the embedding for FSL. As different modalities may contain different structures, this
should be carefully handled. For example, texts need to obey syntactic structures while images do
not. In the future, a promising direction is to consider the use of multi-modality information in
designing FSL methods.
Techniques
In previous sections, according to how the prior knowledge in FSL is used, we categorize FSL
methods from the perspectives of data (Section 3), model (Section 4), and algorithm (Section 5).
Each of these components can be improved. For example, using state-of-the-art ResNet as the
embedding function can be better than using the VGG .
Meta-learning-based FSL methods, as reviewed in Sections 4 and 5, are particularly interesting.
By learning across tasks, meta-learning can adapt to new tasks rapidly with a small inference
cost. However, the tasks considered in meta-learning are often assumed to be drawn from a single
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
task distribution p(T). In practice, we can have a large number of tasks whose task relatedness is
unknown or expensive to determine. In this case, directly learning from all these tasks can lead to
negative transfer . Besides, current FSL methods often consider a static and fixed P(T) .
However, in streaming applications, p(T) is dynamic and new tasks are continually arriving.
Hence, this should also be incorporated into p(T). An important issue is how to avoid catastrophic
forgetting in a dynamic setting, which means that information on the old tasks should not be
forgotten.
As discussed in previous sections, different FSL methods have pros and cons, and there is no
absolute winner in all settings. Moreover, both the hypothesis space H and search strategies in
H often rely on human design. Automated machine learning (AutoML) , by constructing
task-aware machine learning models, has achieved state-of-the-art on many applications. Recently,
AutoML has been used on data augmentation . Another direction is to extend the AutoML
methods of automated feature engineering , model selection and neural architecture search
 to FSL. One can then obtain better algorithm designs whose components are learned by
AutoML in an economic, efficient and effective manner.
Applications
Recall that FSL is needed due to rareness of samples, endeavor to reduce data gathering effort and
computational cost, or as a stepping stone to mimic human-like learning. Hence, many real-world
applications involve FSL. Computer vision is one of very first testbed for FSL algorithms. FSL
has also attracted a lot of recent attention in many other applications, such as robotics, natural
language processing, and acoustic signal processing. In summary, there are many interesting fields
and applications for FSL to explore.
Computer Vision. Most existing works target FSL problems in computer vision. The two most
popular applications are character recognition 
and image classification . Very high
accuracies have already been obtained on the standard benchmark data sets (such as Ominiglot and
miniImageNet), leaving little space for further improvement . Recently, a large and diverse
benchmark data set, constructed from multiple image data sources, is presented in . Besides
character recognition and image classification, other image applications have also been considered.
These include object recognition , font style transfer , phrase grounding ,
image retrieval , object tracking , specific object counting in images , scene location
recognition , gesture recognition , part labeling , image generation ,
image translation across domains , shape view reconstruction for 3D objects , and image
captioning and visual question answering .
FSL has also been successfully used in video applications, including motion prediction , video
classification , action localization , person re-identification , event detection ,
and object segmentation .
Robotics. In order for robots to behave more like human, they should be able to generalize
from a few demonstrations. Hence, FSL has played an important role in robotics. For example,
learning of robot arm movement using imitating learning from a single demonstration , and
learning manipulation actions from a few demonstrations with the help of a teacher who corrects
the false actions .
Apart from imitating users, robots can improve their behavior through interacting with users.
Recently, assistive strategies are learned from a few interactions through FSL reinforcement learning
 . Other examples of FSL in robotics include multi-armed bandits , visual navigation ,
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Generalizing from a Few Examples: A Survey on Few-Shot Learning
and continuous control . Recently, these applications are further extended to dynamic
environments .
Natural Language Processing. Recently, the use of FSL has drawn attention in natural language
processing. Example applications include parsing , translation , sentence completion (which
fills in the blanks using a word chosen from a provided set) , sentiment classification
from short reviews , user intent classification for dialog systems , criminal charge
prediction , word similarity tasks such as nonce definition , and multi-label text
classification . Recently, a new relation classification data set called FewRel is released.
This compensates for the lack of benchmark data set for FSL tasks in natural language processing.
Acoustic Signal Processing. Apart from the early efforts on using FSL to recognize spoken
words from one example , recent endeavors are on voice synthesis. A popular task is voice
cloning from a few audio samples of the user . This can be useful in generating personal voice
navigation in map applications, or mimicking the parents’ voice in story-telling to kids in a smart
home toolkit. Recently, it is possible to perform voice conversion from one user to another using
one-shot voice or text sample or even across different languages .
Others. For example, a recent attempt in the context of medical applications is few-shot
drug discovery . For learning of deep networks, one-shot architecture search (OAS) is studied in
 . Unlike random search and grid search which require multiple runs to find the best
architecture, OAS methods can find good architectures by training the supernet once. FSL has also
been used in curve fitting and understanding number analogy by logic reasoning
to perform calculations .
FSL uses prior knowledge to compensate for the lack of supervised information. This is related
to the theoretical study of sample complexity, which is the number of training samples needed
to obtain a model with small empirical risk RI(h) having high probability . H needs to
be less complicated to make the provided I samples enough. Recall that FSL methods use prior
knowledge to augment more samples (i.e., increase I), constrain H (i.e., reduce the complexity of
H) and alter the search strategy (i.e., increase the probability of finding a good h). This suggests
that FSL methods can reduce the required sample complexity using prior knowledge. A detailed
analysis on this aspect will be useful.
Besides, recall that FSL is related to domain adaptation , and existing theoretical
bounds on domain adaptation may be inspiring . For example, recent analysis shows that
better risk bounds can be obtained by fine-tuning feedforward neural networks . By considering
a specific meta-learning method, the risk of transferring a model trained on one task to another
task is examined in . However, only a small number of methods have been studied so far. There
are still a lot of theoretical issues to explore.
Finally, convergence of the FSL algorithms is not fully understood. In particular, meta-learning
methods optimize θ over a task distribution instead of over a single task. Recent analysis in 
provides sufficient conditions for convergence of one meta-learning method. The meta-learner
learns the lower layers of a deep network, while the learner learns the last layer, all using gradient
descent. A more general analysis on the convergence of meta-learning methods will be highly
ACM Comput. Surv., Vol. 1, No. 1, Article 1. Publication date: March 2020.
Yaqing Wang, Quanming Yao, James T. Kwok, and Lionel M. Ni
CONCLUSION
Few-Shot Learning (FSL) targets at bridging the gap between AI and human learning. It can learn
new tasks containing only a few examples with supervised information by incorporating prior
knowledge. FSL acts as a test-bed for AI, makes the learning of rare cases possible, or helps to
relieve the burden of collecting large-scale supervised date in industrial applications. In this survey,
we provide a comprehensive and systematic review of FSL. We first formally define FSL, and discuss
the relatedness and differences of FSL with relevant learning problems such as weakly supervised
learning, imbalanced learning, transfer learning and meta-learning. We then point out the core
issue of FSL is the unreliable empirical risk minimizer that makes FSL hard to learn. Understanding
the core issue helps categorize different works into data, model and algorithm according to how
they solve the core issue using prior knowledge: data augments the supervised experience of FSL,
model constrains the hypothesis space of FSL to be smaller, and algorithm alters the search strategy
for the best hypothesis in the given hypothesis space. In each category, the pros and cons are
thoroughly discussed and some summary and insights are presented. To inspire future research in
FSL, we also provide possible directions on problem setups, techniques, applications and theories
to explore.
APPENDIX: META-LEARNING
Meta-learning improves P of the new task T by the provided data set and the meta-knowledge
extracted across tasks by a meta-learner (Figure 16). Let p(T) be the distribution of task T. In metetraining, it learns from a set of tasks Ts ∼p(T). Each task Ts operates on data set Ds of N classes,
where Ds = {Ds
test} consists of a training set Ds
train and a test set Ds
test. Each learner learns
train and measures the test error on Ds
test. The parameter θ0 of meta-learner is optimized to
minimize the error across all learners, as:
θ0 = arg min
θ0 ETs∼p(T )
((xi,yi))∈Ds ℓ(h(xi;θ0),yi).
In meta-testing, another disjoint set of tasks Tt ∼p(T) is used to test the generalization ability
of the meta-learner. Each Tt works on a data set Dt of N ′ classes, where Dt = {Dt
test}. The
learner learns from the training set Dt
train and evaluates on the test set Dt
test. The loss averaged
across Tt’s is taken as the meta-learning testing error.
ACKNOWLEDGMENTS
This research is partially done in 4Paradigm Inc. when Yaqing Wang took the internship.