C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Gaussian Processes for Machine Learning
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Adaptive Computation and Machine Learning
Thomas Dietterich, Editor
Christopher Bishop, David Heckerman, Michael Jordan, and Michael Kearns, Associate Editors
Bioinformatics: The Machine Learning Approach,
Pierre Baldi and Søren Brunak
Reinforcement Learning: An Introduction,
Richard S. Sutton and Andrew G. Barto
Graphical Models for Machine Learning and Digital Communication,
Brendan J. Frey
Learning in Graphical Models,
Michael I. Jordan
Causation, Prediction, and Search, second edition,
Peter Spirtes, Clark Glymour, and Richard Scheines
Principles of Data Mining,
David Hand, Heikki Mannila, and Padhraic Smyth
Bioinformatics: The Machine Learning Approach, second edition,
Pierre Baldi and Søren Brunak
Learning Kernel Classiﬁers: Theory and Algorithms,
Ralf Herbrich
Learning with Kernels: Support Vector Machines, Regularization, Optimization, and Beyond,
Bernhard Sch¨olkopf and Alexander J. Smola
Introduction to Machine Learning,
Ethem Alpaydin
Gaussian Processes for Machine Learning,
Carl Edward Rasmussen and Christopher K. I. Williams
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Gaussian Processes for Machine Learning
Carl Edward Rasmussen
Christopher K. I. Williams
The MIT Press
Cambridge, Massachusetts
London, England
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
c⃝2006 Massachusetts Institute of Technology
All rights reserved. No part of this book may be reproduced in any form by any electronic or mechanical
means (including photocopying, recording, or information storage and retrieval) without permission in
writing from the publisher.
MIT Press books may be purchased at special quantity discounts for business or sales promotional use.
For information, please email special or write to Special Sales Department,
The MIT Press, 55 Hayward Street, Cambridge, MA 02142.
Typeset by the authors using LATEX2ε.
This book was printed and bound in the United States of America.
Library of Congress Cataloging-in-Publication Data
Rasmussen, Carl Edward.
Gaussian processes for machine learning / Carl Edward Rasmussen, Christopher K. I. Williams.
p. cm. —(Adaptive computation and machine learning)
Includes bibliographical references and indexes.
ISBN 0-262-18253-X
1. Gaussian processes—Data processing. 2. Machine learning—Mathematical models.
I. Williams, Christopher K. I. II. Title. III. Series.
QA274.4.R37 2006
519.2'3—dc22
2005053433
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
The actual science of logic is conversant at present only with things either
certain, impossible, or entirely doubtful, none of which (fortunately) we have to
reason on. Therefore the true logic for this world is the calculus of Probabilities,
which takes account of the magnitude of the probability which is, or ought to
be, in a reasonable man’s mind.
— James Clerk Maxwell 
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Series Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Symbols and Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Introduction
A Pictorial Introduction to Bayesian Modelling . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Regression
Weight-space View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
The Standard Linear Model . . . . . . . . . . . . . . . . . . . . . .
Projections of Inputs into Feature Space . . . . . . . . . . . . . . .
Function-space View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Varying the Hyperparameters . . . . . . . . . . . . . . . . . . . . . . . . .
Decision Theory for Regression . . . . . . . . . . . . . . . . . . . . . . . .
An Example Application . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Smoothing, Weight Functions and Equivalent Kernels
. . . . . . . . . . .
Incorporating Explicit Basis Functions . . . . . . . . . . . . . . . . . . . .
Marginal Likelihood . . . . . . . . . . . . . . . . . . . . . . . . . .
History and Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Classiﬁcation
Classiﬁcation Problems
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
Decision Theory for Classiﬁcation
. . . . . . . . . . . . . . . . . .
Linear Models for Classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . .
Gaussian Process Classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . .
The Laplace Approximation for the Binary GP Classiﬁer . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Predictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Marginal Likelihood . . . . . . . . . . . . . . . . . . . . . . . . . .
Multi-class Laplace Approximation . . . . . . . . . . . . . . . . . . . . . .
Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Expectation Propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Predictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Marginal Likelihood . . . . . . . . . . . . . . . . . . . . . . . . . .
Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A Toy Problem
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
One-dimensional Example
. . . . . . . . . . . . . . . . . . . . . .
Binary Handwritten Digit Classiﬁcation Example . . . . . . . . . .
10-class Handwritten Digit Classiﬁcation Example . . . . . . . . .
Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
∗Sections marked by an asterisk contain advanced material that may be omitted on a ﬁrst reading.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Appendix: Moment Derivations . . . . . . . . . . . . . . . . . . . . . . . .
3.10 Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Covariance Functions
Preliminaries
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Mean Square Continuity and Diﬀerentiability . . . . . . . . . . . .
Examples of Covariance Functions
. . . . . . . . . . . . . . . . . . . . . .
Stationary Covariance Functions . . . . . . . . . . . . . . . . . . .
Dot Product Covariance Functions . . . . . . . . . . . . . . . . . .
Other Non-stationary Covariance Functions . . . . . . . . . . . . .
Making New Kernels from Old . . . . . . . . . . . . . . . . . . . .
Eigenfunction Analysis of Kernels . . . . . . . . . . . . . . . . . . . . . . .
An Analytic Example
. . . . . . . . . . . . . . . . . . . . . . . . .
Numerical Approximation of Eigenfunctions . . . . . . . . . . . . .
Kernels for Non-vectorial Inputs
. . . . . . . . . . . . . . . . . . . . . . .
String Kernels
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Fisher Kernels
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Model Selection and Adaptation of Hyperparameters
The Model Selection Problem . . . . . . . . . . . . . . . . . . . . . . . . .
Bayesian Model Selection
. . . . . . . . . . . . . . . . . . . . . . . . . . .
Cross-validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Model Selection for GP Regression . . . . . . . . . . . . . . . . . . . . . .
Marginal Likelihood . . . . . . . . . . . . . . . . . . . . . . . . . .
Cross-validation
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
Examples and Discussion
. . . . . . . . . . . . . . . . . . . . . . .
Model Selection for GP Classiﬁcation . . . . . . . . . . . . . . . . . . . . .
Derivatives of the Marginal Likelihood for Laplace’s Approximation 125
Derivatives of the Marginal Likelihood for EP . . . . . . . . . . . .
Cross-validation
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Relationships between GPs and Other Models
Reproducing Kernel Hilbert Spaces . . . . . . . . . . . . . . . . . . . . . .
Regularization
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Regularization Deﬁned by Diﬀerential Operators . . . . . . . . . .
Obtaining the Regularized Solution . . . . . . . . . . . . . . . . . .
The Relationship of the Regularization View to Gaussian Process
Prediction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Spline Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A 1-d Gaussian Process Spline Construction . . . . . . . . . . . . .
Support Vector Machines
. . . . . . . . . . . . . . . . . . . . . . . . . . .
Support Vector Classiﬁcation . . . . . . . . . . . . . . . . . . . . .
Support Vector Regression
. . . . . . . . . . . . . . . . . . . . . .
Least-squares Classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . .
Probabilistic Least-squares Classiﬁcation . . . . . . . . . . . . . . .
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relevance Vector Machines
. . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Theoretical Perspectives
The Equivalent Kernel
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
Some Speciﬁc Examples of Equivalent Kernels
. . . . . . . . . . .
Asymptotic Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Consistency
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Equivalence and Orthogonality . . . . . . . . . . . . . . . . . . . .
Average-case Learning Curves . . . . . . . . . . . . . . . . . . . . . . . . .
PAC-Bayesian Analysis
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
The PAC Framework . . . . . . . . . . . . . . . . . . . . . . . . . .
PAC-Bayesian Analysis
. . . . . . . . . . . . . . . . . . . . . . . .
PAC-Bayesian Analysis of GP Classiﬁcation . . . . . . . . . . . . .
Comparison with Other Supervised Learning Methods . . . . . . . . . . .
Appendix: Learning Curve for the Ornstein-Uhlenbeck Process . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Approximation Methods for Large Datasets
Reduced-rank Approximations of the Gram Matrix . . . . . . . . . . . . .
Greedy Approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Approximations for GPR with Fixed Hyperparameters . . . . . . . . . . .
Subset of Regressors . . . . . . . . . . . . . . . . . . . . . . . . . .
The Nystr¨om Method . . . . . . . . . . . . . . . . . . . . . . . . .
Subset of Datapoints
. . . . . . . . . . . . . . . . . . . . . . . . .
Projected Process Approximation . . . . . . . . . . . . . . . . . . .
Bayesian Committee Machine . . . . . . . . . . . . . . . . . . . . .
Iterative Solution of Linear Systems
. . . . . . . . . . . . . . . . .
Comparison of Approximate GPR Methods . . . . . . . . . . . . .
Approximations for GPC with Fixed Hyperparameters . . . . . . . . . . .
Approximating the Marginal Likelihood and its Derivatives . . . . . . . .
Appendix: Equivalence of SR and GPR Using the Nystr¨om Approximate
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Further Issues and Conclusions
Multiple Outputs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Noise Models with Dependencies . . . . . . . . . . . . . . . . . . . . . . .
Non-Gaussian Likelihoods . . . . . . . . . . . . . . . . . . . . . . . . . . .
Derivative Observations . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Prediction with Uncertain Inputs . . . . . . . . . . . . . . . . . . . . . . .
Mixtures of Gaussian Processes . . . . . . . . . . . . . . . . . . . . . . . .
Global Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Evaluation of Integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Student’s t Process
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.10 Invariances
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.11 Latent Variable Models
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.12 Conclusions and Future Directions . . . . . . . . . . . . . . . . . . . . . .
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Appendix A Mathematical Background
A.1 Joint, Marginal and Conditional Probability . . . . . . . . . . . . . . . . .
A.2 Gaussian Identities
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.3 Matrix Identities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Matrix Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . .
Matrix Norms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.4 Cholesky Decomposition . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.5 Entropy and Kullback-Leibler Divergence
. . . . . . . . . . . . . . . . . .
A.6 Limits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.7 Measure and Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Lp Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.8 Fourier Transforms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.9 Convexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Appendix B Gaussian Markov Processes
Fourier Analysis
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sampling and Periodization . . . . . . . . . . . . . . . . . . . . . .
Continuous-time Gaussian Markov Processes
. . . . . . . . . . . . . . . .
Continuous-time GMPs on R . . . . . . . . . . . . . . . . . . . . .
The Solution of the Corresponding SDE on the Circle . . . . . . .
Discrete-time Gaussian Markov Processes . . . . . . . . . . . . . . . . . .
Discrete-time GMPs on Z . . . . . . . . . . . . . . . . . . . . . . .
The Solution of the Corresponding Diﬀerence Equation on PN
The Relationship Between Discrete-time and Sampled Continuous-time
GMPs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Markov Processes in Higher Dimensions . . . . . . . . . . . . . . . . . . .
Appendix C Datasets and Code
Bibliography
Author Index
Subject Index
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Series Foreword
The goal of building systems that can adapt to their environments and learn
from their experience has attracted researchers from many ﬁelds, including computer science, engineering, mathematics, physics, neuroscience, and cognitive
science. Out of this research has come a wide variety of learning techniques that
have the potential to transform many scientiﬁc and industrial ﬁelds. Recently,
several research communities have converged on a common set of issues surrounding supervised, unsupervised, and reinforcement learning problems. The
MIT Press series on Adaptive Computation and Machine Learning seeks to
unify the many diverse strands of machine learning research and to foster high
quality research and innovative applications.
One of the most active directions in machine learning has been the development of practical Bayesian methods for challenging learning problems.
Gaussian Processes for Machine Learning presents one of the most important
Bayesian machine learning approaches based on a particularly eﬀective method
for placing a prior distribution over the space of functions. Carl Edward Rasmussen and Chris Williams are two of the pioneers in this area, and their book
describes the mathematical foundations and practical application of Gaussian
processes in regression and classiﬁcation tasks. They also show how Gaussian
processes can be interpreted as a Bayesian version of the well-known support
vector machine methods. Students and researchers who study this book will be
able to apply Gaussian process methods in creative ways to solve a wide range
of problems in science and engineering.
Thomas Dietterich
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Over the last decade there has been an explosion of work in the “kernel makernel machines
chines” area of machine learning. Probably the best known example of this is
work on support vector machines, but during this period there has also been
much activity concerning the application of Gaussian process models to machine learning tasks. The goal of this book is to provide a systematic and uni-
ﬁed treatment of this area. Gaussian processes provide a principled, practical,
probabilistic approach to learning in kernel machines. This gives advantages
with respect to the interpretation of model predictions and provides a wellfounded framework for learning and model selection. Theoretical and practical
developments of over the last decade have made Gaussian processes a serious
competitor for real supervised learning applications.
Roughly speaking a stochastic process is a generalization of a probability
Gaussian process
distribution (which describes a ﬁnite-dimensional random variable) to functions.
By focussing on processes which are Gaussian, it turns out that the
computations required for inference and learning become relatively easy. Thus,
the supervised learning problems in machine learning which can be thought of
as learning a function from examples can be cast directly into the Gaussian
process framework.
Our interest in Gaussian process (GP) models in the context of machine
Gaussian processes
in machine learning
learning was aroused in 1994, while we were both graduate students in Geoﬀ
Hinton’s Neural Networks lab at the University of Toronto. This was a time
when the ﬁeld of neural networks was becoming mature and the many connections to statistical physics, probabilistic models and statistics became well
known, and the ﬁrst kernel-based learning algorithms were becoming popular.
In retrospect it is clear that the time was ripe for the application of Gaussian
processes to machine learning problems.
Many researchers were realizing that neural networks were not so easy to
neural networks
apply in practice, due to the many decisions which needed to be made: what
architecture, what activation functions, what learning rate, etc., and the lack of
a principled framework to answer these questions. The probabilistic framework
was pursued using approximations by MacKay [1992b] and using Markov chain
Monte Carlo (MCMC) methods by Neal . Neal was also a graduate student in the same lab, and in his thesis he sought to demonstrate that using the
Bayesian formalism, one does not necessarily have problems with “overﬁtting”
when the models get large, and one should pursue the limit of large models.
While his own work was focused on sophisticated Markov chain methods for
inference in large ﬁnite networks, he did point out that some of his networks
became Gaussian processes in the limit of inﬁnite size, and “there may be simlarge neural networks
≡Gaussian processes
pler ways to do inference in this case.”
It is perhaps interesting to mention a slightly wider historical perspective.
The main reason why neural networks became popular was that they allowed
the use of adaptive basis functions, as opposed to the well known linear models.
adaptive basis functions
The adaptive basis functions, or hidden units, could “learn” hidden features
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
useful for the modelling problem at hand. However, this adaptivity came at the
cost of a lot of practical problems. Later, with the advancement of the “kernel
era”, it was realized that the limitation of ﬁxed basis functions is not a big
many ﬁxed basis
restriction if only one has enough of them, i.e. typically inﬁnitely many, and
one is careful to control problems of overﬁtting by using priors or regularization.
The resulting models are much easier to handle than the adaptive basis function
models, but have similar expressive power.
Thus, one could claim that (as far a machine learning is concerned) the
adaptive basis functions were merely a decade-long digression, and we are now
back to where we came from. This view is perhaps reasonable if we think of
models for solving practical learning problems, although MacKay [2003, ch. 45],
for example, raises concerns by asking “did we throw out the baby with the bath
water?”, as the kernel view does not give us any hidden representations, telling
useful representations
us what the useful features are for solving a particular problem. As we will
argue in the book, one answer may be to learn more sophisticated covariance
functions, and the “hidden” properties of the problem are to be found here.
An important area of future developments for GP models is the use of more
expressive covariance functions.
Supervised learning problems have been studied for more than a century
supervised learning
in statistics
in statistics, and a large body of well-established theory has been developed.
More recently, with the advance of aﬀordable, fast computation, the machine
learning community has addressed increasingly large and complex problems.
Much of the basic theory and many algorithms are shared between the
statistics and
machine learning
statistics and machine learning community. The primary diﬀerences are perhaps
the types of the problems attacked, and the goal of learning. At the risk of
oversimpliﬁcation, one could say that in statistics a prime focus is often in
data and models
understanding the data and relationships in terms of models giving approximate
summaries such as linear relations or independencies. In contrast, the goals in
machine learning are primarily to make predictions as accurately as possible and
algorithms and
predictions
to understand the behaviour of learning algorithms. These diﬀering objectives
have led to diﬀerent developments in the two ﬁelds: for example, neural network
algorithms have been used extensively as black-box function approximators in
machine learning, but to many statisticians they are less than satisfactory,
because of the diﬃculties in interpreting such models.
Gaussian process models in some sense bring together work in the two combridging the gap
munities. As we will see, Gaussian processes are mathematically equivalent to
many well known models, including Bayesian linear models, spline models, large
neural networks (under suitable conditions), and are closely related to others,
such as support vector machines. Under the Gaussian process viewpoint, the
models may be easier to handle and interpret than their conventional counterparts, such as e.g. neural networks. In the statistics community Gaussian
processes have also been discussed many times, although it would probably be
excessive to claim that their use is widespread except for certain speciﬁc applications such as spatial models in meteorology and geology, and the analysis of
computer experiments. A rich theory also exists for Gaussian process models
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
in the time series analysis literature; some pointers to this literature are given
in Appendix B.
The book is primarily intended for graduate students and researchers in
intended audience
machine learning at departments of Computer Science, Statistics and Applied
Mathematics. As prerequisites we require a good basic grounding in calculus,
linear algebra and probability theory as would be obtained by graduates in numerate disciplines such as electrical engineering, physics and computer science.
For preparation in calculus and linear algebra any good university-level textbook on mathematics for physics or engineering such as Arfken would
be ﬁne. For probability theory some familiarity with multivariate distributions
(especially the Gaussian) and conditional probability is required. Some background mathematical material is also provided in Appendix A.
The main focus of the book is to present clearly and concisely an overview
of the main ideas of Gaussian processes in a machine learning context. We have
also covered a wide range of connections to existing models in the literature,
and cover approximate inference for faster practical algorithms. We have presented detailed algorithms for many methods to aid the practitioner. Software
implementations are available from the website for the book, see Appendix C.
We have also included a small set of exercises in each chapter; we hope these
will help in gaining a deeper understanding of the material.
In order limit the size of the volume, we have had to omit some topics, such
as, for example, Markov chain Monte Carlo methods for inference. One of the
most diﬃcult things to decide when writing a book is what sections not to write.
Within sections, we have often chosen to describe one algorithm in particular
in depth, and mention related work only in passing. Although this causes the
omission of some material, we feel it is the best approach for a monograph, and
hope that the reader will gain a general understanding so as to be able to push
further into the growing literature of GP models.
The book has a natural split into two parts, with the chapters up to and
book organization
including chapter 5 covering core material, and the remaining sections covering
the connections to other methods, fast approximations, and more specialized
properties. Some sections are marked by an asterisk. These sections may be
omitted on a ﬁrst reading, and are not pre-requisites for later (un-starred)
We wish to express our considerable gratitude to the many people with
acknowledgements
whom we have interacted during the writing of this book. In particular Moray
Allan, David Barber, Peter Bartlett, Miguel Carreira-Perpi˜n´an, Marcus Gallagher, Manfred Opper, Anton Schwaighofer, Matthias Seeger, Hanna Wallach,
Joe Whittaker, and Andrew Zisserman all read parts of the book and provided
valuable feedback. Dilan G¨or¨ur, Malte Kuss, Iain Murray, Joaquin Qui˜nonero-
Candela, Leif Rasmussen and Sam Roweis were especially heroic and provided
comments on the whole manuscript. We thank Chris Bishop, Miguel Carreira-
Perpi˜n´an, Nando de Freitas, Zoubin Ghahramani, Peter Gr¨unwald, Mike Jordan, John Kent, Radford Neal, Joaquin Qui˜nonero-Candela, Ryan Rifkin, Stefan Schaal, Anton Schwaighofer, Matthias Seeger, Peter Sollich, Ingo Steinwart,
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Amos Storkey, Volker Tresp, Sethu Vijayakumar, Grace Wahba, Joe Whittaker
and Tong Zhang for valuable discussions on speciﬁc issues. We also thank Bob
Prior and the staﬀat MIT Press for their support during the writing of the
book. We thank the Gatsby Computational Neuroscience Unit (UCL) and Neil
Lawrence at the Department of Computer Science, University of Sheﬃeld for
hosting our visits and kindly providing space for us to work, and the Department of Computer Science at the University of Toronto for computer support.
Thanks to John and Fiona for their hospitality on numerous occasions. Some
of the diagrams in this book have been inspired by similar diagrams appearing
in published work, as follows: Figure 3.5, Sch¨olkopf and Smola ; Figure 5.2, MacKay [1992b]. CER gratefully acknowledges ﬁnancial support from
the German Research Foundation (DFG). CKIW thanks the School of Informatics, University of Edinburgh for granting him sabbatical leave for the period
October 2003-March 2004.
Finally, we reserve our deepest appreciation for our wives Agnes and Barbara, and children Ezra, Kate, Miro and Ruth for their patience and understanding while the book was being written.
Despite our best eﬀorts it is inevitable that some errors will make it through
to the printed version of the book. Errata will be made available via the book’s
website at
 
We have found the joint writing of this book an excellent experience. Although
hard at times, we are conﬁdent that the end result is much better than either
one of us could have written alone.
Now, ten years after their ﬁrst introduction into the machine learning comlooking ahead
munity, Gaussian processes are receiving growing attention.
Although GPs
have been known for a long time in the statistics and geostatistics ﬁelds, and
their use can perhaps be traced back as far as the end of the 19th century, their
application to real problems is still in its early phases. This contrasts somewhat
the application of the non-probabilistic analogue of the GP, the support vector machine, which was taken up more quickly by practitioners. Perhaps this
has to do with the probabilistic mind-set needed to understand GPs, which is
not so generally appreciated. Perhaps it is due to the need for computational
short-cuts to implement inference for large datasets. Or it could be due to the
lack of a self-contained introduction to this exciting ﬁeld—with this volume, we
hope to contribute to the momentum gained by Gaussian processes in machine
Carl Edward Rasmussen and Chris Williams
T¨ubingen and Edinburgh, summer 2005
Second printing: We thank Baback Moghaddam, Mikhail Parakhin, Leif Rasmussen, Benjamin Sobotta, Kevin S. Van Horn and Aki Vehtari for reporting
errors in the ﬁrst printing which have now been corrected.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Symbols and Notation
Matrices are capitalized and vectors are in bold type. We do not generally distinguish between probabilities and probability densities. A subscript asterisk, such as in X∗, indicates reference to a test set
quantity. A superscript asterisk denotes complex conjugate.
left matrix divide: A\b is the vector x which solves Ax = b
an equality which acts as a deﬁnition
equality up to an additive constant
determinant of K matrix
Euclidean length of vector y, i.e.
RKHS inner product
the transpose of vector y
proportional to; e.g. p(x|y) ∝f(x, y) means that p(x|y) is equal to f(x, y) times
a factor which is independent of x
distributed according to; example: x ∼N(µ, σ2)
partial derivatives (w.r.t. f)
the (Hessian) matrix of second derivatives
vector of all 0’s (of length n)
vector of all 1’s (of length n)
number of classes in a classiﬁcation problem
cholesky(A)
Cholesky decomposition: L is a lower triangular matrix such that LL⊤= A
Gaussian process posterior covariance
dimension of input space X
data set: D = {(xi, yi)|i = 1, . . . , n}
(vector argument) a diagonal matrix containing the elements of vector w
(matrix argument) a vector containing the diagonal elements of matrix W
Kronecker delta, δpq = 1 iﬀp = q and 0 otherwise
E or Eq(x)[z(x)]
expectation; expectation of z(x) when x ∼q(x)
Gaussian process (or vector of) latent function values, f = (f(x1), . . . , f(xn))⊤
Gaussian process (posterior) prediction (random variable)
Gaussian process posterior mean
Gaussian process: f ∼GP
 m(x), k(x, x′)
, the function f is distributed as a
Gaussian process with mean function m(x) and covariance function k(x, x′)
h(x) or h(x)
either ﬁxed basis function (or set of basis functions) or weight function
set of basis functions evaluated at all training points
the identity matrix (of size n)
Bessel function of the ﬁrst kind
covariance (or kernel) function evaluated at x and x′
K or K(X, X)
n × n covariance (or Gram) matrix
n × n∗matrix K(X, X∗), the covariance between training and test cases
k(x∗) or k∗
vector, short for K(X, x∗), when there is only a single test case
covariance matrix for the (noise free) f values
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Symbols and Notation
covariance matrix for the (noisy) y values; for independent homoscedastic noise,
Ky = Kf + σ2
modiﬁed Bessel function
loss function, the loss of predicting b, when a is true; note argument order
natural logarithm (base e)
logarithm to the base 2
characteristic length-scale (for input dimension d)
logistic function, λ(z) = 1/
 1 + exp(−z)
the mean function of a Gaussian process
a measure (see section A.7)
N(µ, Σ) or N(x|µ, Σ)
(the variable x has a) Gaussian (Normal) distribution with mean vector µ and
covariance matrix Σ
short for unit Gaussian x ∼N(0, I)
number of training (and test) cases
dimension of feature space
number of hidden units in a neural network
the natural numbers, the positive integers
big Oh; for functions f and g on N, we write f(n) = O(g(n)) if the ratio
f(n)/g(n) remains bounded as n →∞
either matrix of all zeros or diﬀerential operator
y|x and p(y|x)
conditional random variable y given x and its probability (density)
the regular n-polygon
φ(xi) or Φ(X)
feature map of input xi (or input set X)
cumulative unit Gaussian: Φ(z) = (2π)−1/2 R z
−∞exp(−t2/2)dt
the sigmoid of the latent value: π(x) = σ(f(x)) (stochastic if f(x) is stochastic)
MAP prediction: π evaluated at ¯f(x∗).
mean prediction: expected value of π(x∗). Note, in general that ˆπ(x∗) ̸= ¯π(x∗)
the real numbers
RL(f) or RL(c)
the risk or expected loss for f, or classiﬁer c (averaged w.r.t. inputs and outputs)
expected loss for predicting l, averaged w.r.t. the model’s pred. distr. at x∗
decision region for class c
power spectrum
any sigmoid function, e.g. logistic λ(z), cumulative Gaussian Φ(z), etc.
variance of the (noise free) signal
noise variance
vector of hyperparameters (parameters of the covariance function)
trace of (square) matrix A
the circle with circumference l
V or Vq(x)[z(x)]
variance; variance of z(x) when x ∼q(x)
input space and also the index set for the stochastic process
D × n matrix of the training inputs {xi}n
i=1: the design matrix
matrix of test inputs
the ith training input
the dth coordinate of the ith training input xi
the integers . . . , −2, −1, 0, 1, 2, . . .
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Introduction
In this book we will be concerned with supervised learning, which is the problem
of learning input-output mappings from empirical data (the training dataset).
Depending on the characteristics of the output, this problem is known as either
regression, for continuous outputs, or classiﬁcation, when outputs are discrete.
A well known example is the classiﬁcation of images of handwritten digits.
digit classiﬁcation
The training set consists of small digitized images, together with a classiﬁcation
from 0, . . . , 9, normally provided by a human. The goal is to learn a mapping
from image to classiﬁcation label, which can then be used on new, unseen
Supervised learning is an attractive way to attempt to tackle this
problem, since it is not easy to specify accurately the characteristics of, say, the
handwritten digit 4.
An example of a regression problem can be found in robotics, where we wish
robotic control
to learn the inverse dynamics of a robot arm. Here the task is to map from
the state of the arm (given by the positions, velocities and accelerations of the
joints) to the corresponding torques on the joints. Such a model can then be
used to compute the torques needed to move the arm along a given trajectory.
Another example would be in a chemical plant, where we might wish to predict
the yield as a function of process parameters such as temperature, pressure,
amount of catalyst etc.
In general we denote the input as x, and the output (or target) as y. The
the dataset
input is usually represented as a vector x as there are in general many input
variables—in the handwritten digit recognition example one may have a 256dimensional input obtained from a raster scan of a 16 × 16 image, and in the
robot arm example there are three input measurements for each joint in the
The target y may either be continuous (as in the regression case) or
discrete (as in the classiﬁcation case). We have a dataset D of n observations,
D = {(xi, yi)|i = 1, . . . , n}.
Given this training data we wish to make predictions for new inputs x∗
training is inductive
that we have not seen in the training set. Thus it is clear that the problem
at hand is inductive; we need to move from the ﬁnite training data D to a
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Introduction
function f that makes predictions for all possible input values. To do this we
must make assumptions about the characteristics of the underlying function,
as otherwise any function which is consistent with the training data would be
equally valid. A wide variety of methods have been proposed to deal with the
supervised learning problem; here we describe two common approaches. The
two approaches
ﬁrst is to restrict the class of functions that we consider, for example by only
considering linear functions of the input. The second approach is (speaking
rather loosely) to give a prior probability to every possible function, where
higher probabilities are given to functions that we consider to be more likely, for
example because they are smoother than other functions.1 The ﬁrst approach
has an obvious problem in that we have to decide upon the richness of the class
of functions considered; if we are using a model based on a certain class of
functions (e.g. linear functions) and the target function is not well modelled by
this class, then the predictions will be poor. One may be tempted to increase the
ﬂexibility of the class of functions, but this runs into the danger of overﬁtting,
where we can obtain a good ﬁt to the training data, but perform badly when
making test predictions.
The second approach appears to have a serious problem, in that surely
there are an uncountably inﬁnite set of possible functions, and how are we
going to compute with this set in ﬁnite time?
This is where the Gaussian
Gaussian process
process comes to our rescue.
A Gaussian process is a generalization of the
Gaussian probability distribution. Whereas a probability distribution describes
random variables which are scalars or vectors (for multivariate distributions),
a stochastic process governs the properties of functions. Leaving mathematical
sophistication aside, one can loosely think of a function as a very long vector,
each entry in the vector specifying the function value f(x) at a particular input
x. It turns out, that although this idea is a little na¨ıve, it is surprisingly close
what we need. Indeed, the question of how we deal computationally with these
inﬁnite dimensional objects has the most pleasant resolution imaginable: if you
ask only for the properties of the function at a ﬁnite number of points, then
inference in the Gaussian process will give you the same answer if you ignore the
inﬁnitely many other points, as if you would have taken them all into account!
And these answers are consistent with answers to any other ﬁnite queries you
consistency
may have. One of the main attractions of the Gaussian process framework is
precisely that it unites a sophisticated and consistent view with computational
tractability
tractability.
It should come as no surprise that these ideas have been around for some
time, although they are perhaps not as well known as they might be. Indeed,
many models that are commonly employed in both machine learning and statistics are in fact special cases of, or restricted kinds of Gaussian processes. In this
volume, we aim to give a systematic and uniﬁed treatment of the area, showing
connections to related models.
1These two approaches may be regarded as imposing a restriction bias and a preference
bias respectively; see e.g. Mitchell .
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
1.1 A Pictorial Introduction to Bayesian Modelling
(a), prior
(b), posterior
Figure 1.1: Panel (a) shows four samples drawn from the prior distribution. Panel
(b) shows the situation after two datapoints have been observed. The mean prediction
is shown as the solid line and four samples from the posterior are shown as dashed
lines. In both plots the shaded region denotes twice the standard deviation at each
input value x.
A Pictorial Introduction to Bayesian Modelling
In this section we give graphical illustrations of how the second (Bayesian)
method works on some simple regression and classiﬁcation examples.
We ﬁrst consider a simple 1-d regression problem, mapping from an input
regression
x to an output f(x). In Figure 1.1(a) we show a number of sample functions
drawn at random from the prior distribution over functions speciﬁed by a parrandom functions
ticular Gaussian process which favours smooth functions. This prior is taken
to represent our prior beliefs over the kinds of functions we expect to observe,
before seeing any data. In the absence of knowledge to the contrary we have
assumed that the average value over the sample functions at each x is zero.
mean function
Although the speciﬁc random functions drawn in Figure 1.1(a) do not have a
mean of zero, the mean of f(x) values for any ﬁxed x would become zero, independent of x as we kept on drawing more functions. At any value of x we
can also characterize the variability of the sample functions by computing the
pointwise variance
variance at that point. The shaded region denotes twice the pointwise standard
deviation; in this case we used a Gaussian process which speciﬁes that the prior
variance does not depend on x.
Suppose that we are then given a dataset D = {(x1, y1), (x2, y2)} consistfunctions that agree
with observations
ing of two observations, and we wish now to only consider functions that pass
though these two data points exactly. (It is also possible to give higher preference to functions that merely pass “close” to the datapoints.) This situation
is illustrated in Figure 1.1(b). The dashed lines show sample functions which
are consistent with D, and the solid line depicts the mean value of such functions. Notice how the uncertainty is reduced close to the observations. The
combination of the prior and the data leads to the posterior distribution over
posterior over functions
functions.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Introduction
If more datapoints were added one would see the mean function adjust itself
to pass through these points, and that the posterior uncertainty would reduce
close to the observations.
Notice, that since the Gaussian process is not a
parametric model, we do not have to worry about whether it is possible for the
non-parametric
model to ﬁt the data (as would be the case if e.g. you tried a linear model on
strongly non-linear data). Even when a lot of observations have been added,
there may still be some ﬂexibility left in the functions. One way to imagine the
reduction of ﬂexibility in the distribution of functions as the data arrives is to
draw many random functions from the prior, and reject the ones which do not
agree with the observations. While this is a perfectly valid way to do inference,
it is impractical for most purposes—the exact analytical computations required
to quantify these properties will be detailed in the next chapter.
The speciﬁcation of the prior is important, because it ﬁxes the properties of
prior speciﬁcation
the functions considered for inference. Above we brieﬂy touched on the mean
and pointwise variance of the functions. However, other characteristics can also
be speciﬁed and manipulated.
Note that the functions in Figure 1.1(a) are
smooth and stationary (informally, stationarity means that the functions look
similar at all x locations). These are properties which are induced by the covariance function of the Gaussian process; many other covariance functions are
covariance function
possible. Suppose, that for a particular application, we think that the functions
in Figure 1.1(a) vary too rapidly (i.e. that their characteristic length-scale is
too short). Slower variation is achieved by simply adjusting parameters of the
covariance function. The problem of learning in Gaussian processes is exactly
the problem of ﬁnding suitable properties for the covariance function. Note,
that this gives us a model of the data, and characteristics (such a smoothness,
modelling and
interpreting
characteristic length-scale, etc.) which we can interpret.
We now turn to the classiﬁcation case, and consider the binary (or twoclassiﬁcation
class) classiﬁcation problem. An example of this is classifying objects detected
in astronomical sky surveys into stars or galaxies. Our data has the label +1 for
stars and −1 for galaxies, and our task will be to predict π(x), the probability
that an example with input vector x is a star, using as inputs some features
that describe each object. Obviously π(x) should lie in the interval . A
Gaussian process prior over functions does not restrict the output to lie in this
interval, as can be seen from Figure 1.1(a). The approach that we shall adopt
is to squash the prior function f pointwise through a response function which
squashing function
restricts the output to lie in . A common choice for this function is the
logistic function λ(z) = (1 + exp(−z))−1, illustrated in Figure 1.2(b). Thus the
prior over f induces a prior over probabilistic classiﬁcations π.
This set up is illustrated in Figure 1.2 for a 2-d input space.
(a) we see a sample drawn from the prior over functions f which is squashed
through the logistic function (panel (b)). A dataset is shown in panel (c), where
the white and black circles denote classes +1 and −1 respectively. As in the
regression case the eﬀect of the data is to downweight in the posterior those
functions that are incompatible with the data. A contour plot of the posterior
mean for π(x) is shown in panel (d). In this example we have chosen a short
characteristic length-scale for the process so that it can vary fairly rapidly; in
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
1.2 Roadmap
logistic function
Figure 1.2: Panel (a) shows a sample from prior distribution on f in a 2-d input
space. Panel (b) is a plot of the logistic function λ(z). Panel (c) shows the location
of the data points, where the open circles denote the class label +1, and closed circles
denote the class label −1. Panel (d) shows a contour plot of the mean predictive
probability as a function of x; the decision boundaries between the two classes are
shown by the thicker lines.
this case notice that all of the training points are correctly classiﬁed, including
the two “outliers” in the NE and SW corners. By choosing a diﬀerent lengthscale we can change this behaviour, as illustrated in section 3.7.1.
The book has a natural split into two parts, with the chapters up to and including chapter 5 covering core material, and the remaining chapters covering the
connections to other methods, fast approximations, and more specialized properties. Some sections are marked by an asterisk. These sections may be omitted
on a ﬁrst reading, and are not pre-requisites for later (un-starred) material.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Introduction
Chapter 2 contains the deﬁnition of Gaussian processes, in particular for the
regression
use in regression. It also discusses the computations needed to make predictions for regression. Under the assumption of Gaussian observation noise the
computations needed to make predictions are tractable and are dominated by
the inversion of a n × n matrix. In a short experimental section, the Gaussian
process model is applied to a robotics task.
Chapter 3 considers the classiﬁcation problem for both binary and multiclassiﬁcation
class cases. The use of a non-linear response function means that exact computation of the predictions is no longer possible analytically. We discuss a number
of approximation schemes, include detailed algorithms for their implementation
and discuss some experimental comparisons.
As discussed above, the key factor that controls the properties of a Gaussian
covariance functions
process is the covariance function. Much of the work on machine learning so far,
has used a very limited set of covariance functions, possibly limiting the power
of the resulting models. In chapter 4 we discuss a number of valid covariance
functions and their properties and provide some guidelines on how to combine
covariance functions into new ones, tailored to speciﬁc needs.
Many covariance functions have adjustable parameters, such as the charlearning
acteristic length-scale and variance illustrated in Figure 1.1.
Chapter 5 describes how such parameters can be inferred or learned from the data, based on
either Bayesian methods (using the marginal likelihood) or methods of crossvalidation. Explicit algorithms are provided for some schemes, and some simple
practical examples are demonstrated.
Gaussian process predictors are an example of a class of methods known as
connections
kernel machines; they are distinguished by the probabilistic viewpoint taken.
In chapter 6 we discuss other kernel machines such as support vector machines
(SVMs), splines, least-squares classiﬁers and relevance vector machines (RVMs),
and their relationships to Gaussian process prediction.
In chapter 7 we discuss a number of more theoretical issues relating to
Gaussian process methods including asymptotic analysis, average-case learning
curves and the PAC-Bayesian framework.
One issue with Gaussian process prediction methods is that their basic comfast approximations
plexity is O(n3), due to the inversion of a n×n matrix. For large datasets this is
prohibitive (in both time and space) and so a number of approximation methods
have been developed, as described in chapter 8.
The main focus of the book is on the core supervised learning problems of
regression and classiﬁcation.
In chapter 9 we discuss some rather less standard
settings that GPs have been used in, and complete the main part of the book
with some conclusions.
Appendix A gives some mathematical background, while Appendix B deals
speciﬁcally with Gaussian Markov processes. Appendix C gives details of how
to access the data and programs that were used to make the some of the ﬁgures
and run the experiments described in the book.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
Supervised learning can be divided into regression and classiﬁcation problems.
Whereas the outputs for classiﬁcation are discrete class labels, regression is
concerned with the prediction of continuous quantities. For example, in a ﬁnancial application, one may attempt to predict the price of a commodity as
a function of interest rates, currency exchange rates, availability and demand.
In this chapter we describe Gaussian process methods for regression problems;
classiﬁcation problems are discussed in chapter 3.
There are several ways to interpret Gaussian process (GP) regression models.
One can think of a Gaussian process as deﬁning a distribution over functions,
and inference taking place directly in the space of functions, the function-space
two equivalent views
Although this view is appealing it may initially be diﬃcult to grasp,
so we start our exposition in section 2.1 with the equivalent weight-space view
which may be more familiar and accessible to many, and continue in section
2.2 with the function-space view. Gaussian processes often have characteristics
that can be changed by setting certain parameters and in section 2.3 we discuss
how the properties change as these parameters are varied.
The predictions
from a GP model take the form of a full predictive distribution; in section 2.4
we discuss how to combine a loss function with the predictive distributions
using decision theory to make point predictions in an optimal way. A practical
comparative example involving the learning of the inverse dynamics of a robot
arm is presented in section 2.5. We give some theoretical analysis of Gaussian
process regression in section 2.6, and discuss how to incorporate explicit basis
functions into the models in section 2.7. As much of the material in this chapter
can be considered fairly standard, we postpone most references to the historical
overview in section 2.8.
Weight-space View
The simple linear regression model where the output is a linear combination of
the inputs has been studied and used extensively. Its main virtues are simplic-
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
ity of implementation and interpretability. Its main drawback is that it only
allows a limited ﬂexibility; if the relationship between input and output cannot reasonably be approximated by a linear function, the model will give poor
predictions.
In this section we ﬁrst discuss the Bayesian treatment of the linear model.
We then make a simple enhancement to this class of models by projecting the
inputs into a high-dimensional feature space and applying the linear model
there. We show that in some feature spaces one can apply the “kernel trick” to
carry out computations implicitly in the high dimensional space; this last step
leads to computational savings when the dimensionality of the feature space is
large compared to the number of data points.
We have a training set D of n observations, D = {(xi, yi) | i = 1, . . . , n},
training set
where x denotes an input vector (covariates) of dimension D and y denotes
a scalar output or target (dependent variable); the column vector inputs for
all n cases are aggregated in the D × n design matrix 1 X, and the targets
design matrix
are collected in the vector y, so we can write D = (X, y). In the regression
setting the targets are real values. We are interested in making inferences about
the relationship between inputs and targets, i.e. the conditional distribution of
the targets given the inputs (but we are not interested in modelling the input
distribution itself).
The Standard Linear Model
We will review the Bayesian analysis of the standard linear regression model
with Gaussian noise
f(x) = x⊤w,
y = f(x) + ε,
where x is the input vector, w is a vector of weights (parameters) of the linear
model, f is the function value and y is the observed target value. Often a bias
bias, oﬀset
weight or oﬀset is included, but as this can be implemented by augmenting the
input vector x with an additional element whose value is always one, we do not
explicitly include it in our notation. We have assumed that the observed values
y diﬀer from the function values f(x) by additive noise, and we will further
assume that this noise follows an independent, identically distributed Gaussian
distribution with zero mean and variance σ2
ε ∼N(0, σ2
This noise assumption together with the model directly gives rise to the likelilikelihood
hood, the probability density of the observations given the parameters, which is
1In statistics texts the design matrix is usually taken to be the transpose of our deﬁnition,
but our choice is deliberate and has the advantage that a data point is a standard (column)
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.1 Weight-space View
factored over cases in the training set (because of the independence assumption)
p(y|X, w) =
p(yi|xi, w) =
(2πσ2n)n/2 exp
|y −X⊤w|2
= N(X⊤w, σ2
where |z| denotes the Euclidean length of vector z. In the Bayesian formalism
we need to specify a prior over the parameters, expressing our beliefs about the
parameters before we look at the observations. We put a zero mean Gaussian
prior with covariance matrix Σp on the weights
w ∼N(0, Σp).
The rˆole and properties of this prior will be discussed in section 2.2; for now
we will continue the derivation with the prior as speciﬁed.
Inference in the Bayesian linear model is based on the posterior distribution
over the weights, computed by Bayes’ rule, (see eq. (A.3))2
posterior =
likelihood × prior
marginal likelihood,
p(w|y, X) = p(y|X, w)p(w)
where the normalizing constant, also known as the marginal likelihood (see page
marginal likelihood
19), is independent of the weights and given by
p(y|X, w)p(w) dw.
The posterior in eq. (2.5) combines the likelihood and the prior, and captures
everything we know about the parameters. Writing only the terms from the
likelihood and prior which depend on the weights, and “completing the square”
p(w|X, y) ∝exp
(y −X⊤w)⊤(y −X⊤w)
2(w −¯w)⊤  1
where ¯w = σ−2
n XX⊤+ Σ−1
p )−1Xy, and we recognize the form of the
posterior distribution as Gaussian with mean ¯w and covariance matrix A−1
p(w|X, y) ∼N( ¯w= 1
A−1Xy, A−1),
where A = σ−2
n XX⊤+ Σ−1
p . Notice that for this model (and indeed for any
Gaussian posterior) the mean of the posterior distribution p(w|y, X) is also
its mode, which is also called the maximum a posteriori (MAP) estimate of
MAP estimate
2Often Bayes’ rule is stated as p(a|b) = p(b|a)p(a)/p(b); here we use it in a form where we
additionally condition everywhere on the inputs X (but neglect this extra conditioning for
the prior which is independent of the inputs).
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
intercept, w1
intercept, w1
intercept, w1
Figure 2.1:
Example of Bayesian linear model f(x) = w1 + w2x with intercept
w1 and slope parameter w2. Panel (a) shows the contours of the prior distribution
p(w) ∼N(0, I), eq. (2.4). Panel (b) shows three training points marked by crosses.
Panel (c) shows contours of the likelihood p(y|X, w) eq. (2.3), assuming a noise level of
σn = 1; note that the slope is much more “well determined” than the intercept. Panel
(d) shows the posterior, p(w|X, y) eq. (2.7); comparing the maximum of the posterior
to the likelihood, we see that the intercept has been shrunk towards zero whereas the
more ’well determined’ slope is almost unchanged. All contour plots give the 1 and
2 standard deviation equi-probability contours. Superimposed on the data in panel
(b) are the predictive mean plus/minus two standard deviations of the (noise-free)
predictive distribution p(f∗|x∗, X, y), eq. (2.9).
w. In a non-Bayesian setting the negative log prior is sometimes thought of
as a penalty term, and the MAP point is known as the penalized maximum
likelihood estimate of the weights, and this may cause some confusion between
the two approaches.
Note, however, that in the Bayesian setting the MAP
estimate plays no special rˆole.3 The penalized maximum likelihood procedure
3In this case, due to symmetries in the model and posterior, it happens that the mean
of the predictive distribution is the same as the prediction at the mean of the posterior.
However, this is not the case in general.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.1 Weight-space View
is known in this case as ridge regression [Hoerl and Kennard, 1970] because of
ridge regression
the eﬀect of the quadratic penalty term 1
p w from the log prior.
To make predictions for a test case we average over all possible parameter
predictive distribution
values, weighted by their posterior probability.
This is in contrast to non-
Bayesian schemes, where a single parameter is typically chosen by some criterion. Thus the predictive distribution for f∗≜f(x∗) at x∗is given by averaging
the output of all possible linear models w.r.t. the Gaussian posterior
p(f∗|x∗, X, y) =
p(f∗|x∗, w)p(w|X, y) dw
∗A−1Xy, x⊤
The predictive distribution is again Gaussian, with a mean given by the posterior mean of the weights from eq. (2.8) multiplied by the test input, as one would
expect from symmetry considerations. The predictive variance is a quadratic
form of the test input with the posterior covariance matrix, showing that the
predictive uncertainties grow with the magnitude of the test input, as one would
expect for a linear model.
An example of Bayesian linear regression is given in Figure 2.1. Here we
have chosen a 1-d input space so that the weight-space is two-dimensional and
can be easily visualized. Contours of the Gaussian prior are shown in panel (a).
The data are depicted as crosses in panel (b). This gives rise to the likelihood
shown in panel (c) and the posterior distribution in panel (d). The predictive
distribution and its error bars are also marked in panel (b).
Projections of Inputs into Feature Space
In the previous section we reviewed the Bayesian linear model which suﬀers
from limited expressiveness. A very simple idea to overcome this problem is to
ﬁrst project the inputs into some high dimensional space using a set of basis
feature space
functions and then apply the linear model in this space instead of directly on
the inputs themselves. For example, a scalar input x could be projected into
the space of powers of x: φ(x) = (1, x, x2, x3, . . .)⊤to implement polynomial
polynomial regression
regression. As long as the projections are ﬁxed functions (i.e. independent of
the parameters w) the model is still linear in the parameters, and therefore
linear in the parameters
analytically tractable.4 This idea is also used in classiﬁcation, where a dataset
which is not linearly separable in the original data space may become linearly
separable in a high dimensional feature space, see section 3.3. Application of
this idea begs the question of how to choose the basis functions? As we shall
demonstrate (in chapter 5), the Gaussian process formalism allows us to answer
this question. For now, we assume that the basis functions are given.
Speciﬁcally, we introduce the function φ(x) which maps a D-dimensional
input vector x into an N dimensional feature space. Further let the matrix
4Models with adaptive basis functions, such as e.g. multilayer perceptrons, may at ﬁrst
seem like a useful extension, but they are much harder to treat, except in the limit of an
inﬁnite number of hidden units, see section 4.2.3.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
Φ(X) be the aggregation of columns φ(x) for all cases in the training set. Now
the model is
f(x) = φ(x)⊤w,
where the vector of parameters now has length N. The analysis for this model
is analogous to the standard linear model, except that everywhere Φ(X) is
substituted for X. Thus the predictive distribution becomes
explicit feature space
formulation
f∗|x∗, X, y ∼N
φ(x∗)⊤A−1Φy, φ(x∗)⊤A−1φ(x∗)
with Φ = Φ(X) and A = σ−2
n ΦΦ⊤+ Σ−1
To make predictions using this
equation we need to invert the A matrix of size N × N which may not be
convenient if N, the dimension of the feature space, is large. However, we can
rewrite the equation in the following way
alternative formulation
f∗|x∗, X, y ∼N
∗ΣpΦ(K + σ2
∗ΣpΦ(K + σ2
nI)−1Φ⊤Σpφ∗
where we have used the shorthand φ(x∗) = φ∗and deﬁned K = Φ⊤ΣpΦ.
To show this for the mean, ﬁrst note that using the deﬁnitions of A and K
we have σ−2
n Φ(K + σ2
n Φ(Φ⊤ΣpΦ + σ2
nI) = AΣpΦ. Now multiplying
through by A−1 from left and (K + σ2
nI)−1 from the right gives σ−2
nI)−1, showing the equivalence of the mean expressions in eq. (2.11)
and eq. (2.12). For the variance we use the matrix inversion lemma, eq. (A.9),
setting Z−1 = Σp, W −1 = σ2
nI and V = U = Φ therein. In eq. (2.12) we
need to invert matrices of size n × n which is more convenient when n < N.
computational load
Geometrically, note that n datapoints can span at most n dimensions in the
feature space.
Notice that in eq. (2.12) the feature space always enters in the form of
∗ΣpΦ, or φ⊤
∗Σpφ∗; thus the entries of these matrices are invariably of
the form φ(x)⊤Σpφ(x′) where x and x′ are in either the training or the test sets.
Let us deﬁne k(x, x′) = φ(x)⊤Σpφ(x′). For reasons that will become clear later
we call k(·, ·) a covariance function or kernel. Notice that φ(x)⊤Σpφ(x′) is an
inner product (with respect to Σp). As Σp is positive deﬁnite we can deﬁne Σ1/2
so that (Σ1/2
)2 = Σp; for example if the SVD (singular value decomposition)
of Σp = UDU ⊤, where D is diagonal, then one form for Σ1/2
is UD1/2U ⊤.
Then deﬁning ψ(x) = Σ1/2
φ(x) we obtain a simple dot product representation
k(x, x′) = ψ(x) · ψ(x′).
If an algorithm is deﬁned solely in terms of inner products in input space
then it can be lifted into feature space by replacing occurrences of those inner
products by k(x, x′); this is sometimes called the kernel trick. This technique is
kernel trick
particularly valuable in situations where it is more convenient to compute the
kernel than the feature vectors themselves. As we will see in the coming sections,
this often leads to considering the kernel as the object of primary interest, and
its corresponding feature space as having secondary practical importance.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.2 Function-space View
Function-space View
An alternative and equivalent way of reaching identical results to the previous
section is possible by considering inference directly in function space. We use
a Gaussian process (GP) to describe a distribution over functions. Formally:
Deﬁnition 2.1 A Gaussian process is a collection of random variables, any
Gaussian process
ﬁnite number of which have a joint Gaussian distribution.
A Gaussian process is completely speciﬁed by its mean function and cocovariance and
mean function
variance function. We deﬁne mean function m(x) and the covariance function
k(x, x′) of a real process f(x) as
m(x) = E[f(x)],
k(x, x′) = E[(f(x) −m(x))(f(x′) −m(x′))],
and will write the Gaussian process as
 m(x), k(x, x′)
Usually, for notational simplicity we will take the mean function to be zero,
although this need not be done, see section 2.7.
In our case the random variables represent the value of the function f(x)
at location x. Often, Gaussian processes are deﬁned over time, i.e. where the
index set of the random variables is time. This is not (normally) the case in
index set ≡
input domain
our use of GPs; here the index set X is the set of possible inputs, which could
be more general, e.g. RD. For notational convenience we use the (arbitrary)
enumeration of the cases in the training set to identify the random variables
such that fi ≜f(xi) is the random variable corresponding to the case (xi, yi)
as would be expected.
A Gaussian process is deﬁned as a collection of random variables. Thus, the
deﬁnition automatically implies a consistency requirement, which is also sometimes known as the marginalization property.
This property simply means
marginalization
that if the GP e.g. speciﬁes (y1, y2) ∼N(µ, Σ), then it must also specify
y1 ∼N(µ1, Σ11) where Σ11 is the relevant submatrix of Σ, see eq. (A.6).
In other words, examination of a larger set of variables does not change the
distribution of the smaller set. Notice that the consistency requirement is automatically fulﬁlled if the covariance function speciﬁes entries of the covariance
matrix.5 The deﬁnition does not exclude Gaussian processes with ﬁnite index
ﬁnite index set
sets (which would be simply Gaussian distributions), but these are not particularly interesting for our purposes.
5Note, however, that if you instead speciﬁed e.g. a function for the entries of the inverse
covariance matrix, then the marginalization property would no longer be fulﬁlled, and one
could not think of this as a consistent collection of random variables—this would not qualify
as a Gaussian process.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
A simple example of a Gaussian process can be obtained from our Bayesian
Bayesian linear model
is a Gaussian process
linear regression model f(x) = φ(x)⊤w with prior w ∼N(0, Σp). We have for
the mean and covariance
E[f(x)] = φ(x)⊤E[w] = 0,
E[f(x)f(x′)] = φ(x)⊤E[ww⊤]φ(x′) = φ(x)⊤Σpφ(x′).
Thus f(x) and f(x′) are jointly Gaussian with zero mean and covariance given
by φ(x)⊤Σpφ(x′). Indeed, the function values f(x1), . . . , f(xn) corresponding
to any number of input points n are jointly Gaussian, although if N < n then
this Gaussian is singular (as the joint covariance matrix will be of rank N).
In this chapter our running example of a covariance function will be the
squared exponential6 (SE) covariance function; other covariance functions are
discussed in chapter 4. The covariance function speciﬁes the covariance between
pairs of random variables
 f(xp), f(xq)
= k(xp, xq) = exp
2|xp −xq|2
Note, that the covariance between the outputs is written as a function of the
inputs. For this particular covariance function, we see that the covariance is
almost unity between variables whose corresponding inputs are very close, and
decreases as their distance in the input space increases.
It can be shown (see section 4.3.1) that the squared exponential covariance
function corresponds to a Bayesian linear regression model with an inﬁnite
number of basis functions. Indeed for every positive deﬁnite covariance function
basis functions
k(·, ·), there exists a (possibly inﬁnite) expansion in terms of basis functions
(see Mercer’s theorem in section 4.3). We can also obtain the SE covariance
function from the linear combination of an inﬁnite number of Gaussian-shaped
basis functions, see eq. (4.13) and eq. (4.30).
The speciﬁcation of the covariance function implies a distribution over functions. To see this, we can draw samples from the distribution of functions evaluated at any number of points; in detail, we choose a number of input points,7 X∗
and write out the corresponding covariance matrix using eq. (2.16) elementwise.
Then we generate a random Gaussian vector with this covariance matrix
 0, K(X∗, X∗)
and plot the generated values as a function of the inputs. Figure 2.2(a) shows
three such samples. The generation of multivariate Gaussian samples is described in section A.2.
In the example in Figure 2.2 the input values were equidistant, but this
need not be the case.
Notice that “informally” the functions look smooth.
smoothness
In fact the squared exponential covariance function is inﬁnitely diﬀerentiable,
leading to the process being inﬁnitely mean-square diﬀerentiable (see section
4.1). We also see that the functions seem to have a characteristic length-scale,
characteristic
length-scale
6Sometimes this covariance function is called the Radial Basis Function (RBF) or Gaussian;
here we prefer squared exponential.
7Technically, these input points play the rˆole of test inputs and therefore carry a subscript
asterisk; this will become clearer later when both training and test points are involved.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.2 Function-space View
output, f(x)
output, f(x)
(a), prior
(b), posterior
Figure 2.2:
Panel (a) shows three functions drawn at random from a GP prior;
the dots indicate values of y actually generated; the two other functions have (less
correctly) been drawn as lines by joining a large number of evaluated points. Panel (b)
shows three random functions drawn from the posterior, i.e. the prior conditioned on
the ﬁve noise free observations indicated. In both plots the shaded area represents the
pointwise mean plus and minus two times the standard deviation for each input value
(corresponding to the 95% conﬁdence region), for the prior and posterior respectively.
which informally can be thought of as roughly the distance you have to move in
input space before the function value can change signiﬁcantly, see section 4.2.1.
For eq. (2.16) the characteristic length-scale is around one unit. By replacing
|xp−xq| by |xp−xq|/ℓin eq. (2.16) for some positive constant ℓwe could change
the characteristic length-scale of the process. Also, the overall variance of the
random function can be controlled by a positive pre-factor before the exp in
eq. (2.16). We will discuss more about how such factors aﬀect the predictions
in section 2.3, and say more about how to set such scale parameters in chapter
Prediction with Noise-free Observations
We are usually not primarily interested in drawing random functions from the
prior, but want to incorporate the knowledge that the training data provides
about the function. Initially, we will consider the simple special case where the
observations are noise free, that is we know {(xi, fi)|i = 1, . . . , n}. The joint
joint prior
distribution of the training outputs, f, and the test outputs f∗according to the
If there are n training points and n∗test points then K(X, X∗) denotes the
n × n∗matrix of the covariances evaluated at all pairs of training and test
points, and similarly for the other entries K(X, X), K(X∗, X∗) and K(X∗, X).
To get the posterior distribution over functions we need to restrict this joint
prior distribution to contain only those functions which agree with the observed
data points. Graphically in Figure 2.2 you may think of generating functions
from the prior, and rejecting the ones that disagree with the observations, algraphical rejection
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
though this strategy would not be computationally very eﬃcient. Fortunately,
in probabilistic terms this operation is extremely simple, corresponding to conditioning the joint Gaussian prior distribution on the observations (see section
A.2 for further details) to give
noise-free predictive
distribution
f∗|X∗, X, f ∼N
 K(X∗, X)K(X, X)−1f,
K(X∗, X∗) −K(X∗, X)K(X, X)−1K(X, X∗)
Function values f∗(corresponding to test inputs X∗) can be sampled from the
joint posterior distribution by evaluating the mean and covariance matrix from
eq. (2.19) and generating samples according to the method described in section
Figure 2.2(b) shows the results of these computations given the ﬁve datapoints marked with + symbols. Notice that it is trivial to extend these computations to multidimensional inputs – one simply needs to change the evaluation
of the covariance function in accordance with eq. (2.16), although the resulting
functions may be harder to display graphically.
Prediction using Noisy Observations
It is typical for more realistic modelling situations that we do not have access
to function values themselves, but only noisy versions thereof y = f(x) + ε.8
Assuming additive independent identically distributed Gaussian noise ε with
variance σ2
n, the prior on the noisy observations becomes
cov(yp, yq) = k(xp, xq) + σ2
cov(y) = K(X, X) + σ2
where δpq is a Kronecker delta which is one iﬀp = q and zero otherwise. It
follows from the independence9 assumption about the noise, that a diagonal
matrix10 is added, in comparison to the noise free case, eq. (2.16). Introducing
the noise term in eq. (2.18) we can write the joint distribution of the observed
target values and the function values at the test locations under the prior as
K(X, X) + σ2
Deriving the conditional distribution corresponding to eq. (2.19) we arrive at
predictive distribution
the key predictive equations for Gaussian process regression
f∗|X, y, X∗∼N
 ¯f∗, cov(f∗)
¯f∗≜E[f∗|X, y, X∗] = K(X∗, X)[K(X, X) + σ2
cov(f∗) = K(X∗, X∗) −K(X∗, X)[K(X, X) + σ2
−1K(X, X∗).
8There are some situations where it is reasonable to assume that the observations are
noise-free, for example for computer simulations, see e.g. Sacks et al. .
9More complicated noise models with non-trivial covariance structure can also be handled,
see section 9.2.
10Notice that the Kronecker delta is on the index of the cases, not the value of the input;
for the signal part of the covariance function the input value is the index set to the random
variables describing the function, for the noise part it is the identity of the point.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.2 Function-space View
Observations
Gaussian ﬁeld
Figure 2.3: Graphical model (chain graph) for a GP for regression. Squares represent observed variables and circles represent unknowns. The thick horizontal bar
represents a set of fully connected nodes. Note that an observation yi is conditionally
independent of all other nodes given the corresponding latent variable, fi. Because of
the marginalization property of GPs addition of further inputs, x, latent variables, f,
and unobserved targets, y∗, does not change the distribution of any other variables.
Notice that we now have exact correspondence with the weight space view in
eq. (2.12) when identifying K(C, D) = Φ(C)⊤ΣpΦ(D), where C, D stand for either X or X∗. For any set of basis functions, we can compute the corresponding
correspondence with
weight-space view
covariance function as k(xp, xq) = φ(xp)⊤Σpφ(xq); conversely, for every (positive deﬁnite) covariance function k, there exists a (possibly inﬁnite) expansion
in terms of basis functions, see section 4.3.
The expressions involving K(X, X), K(X, X∗) and K(X∗, X∗) etc. can look
compact notation
rather unwieldy, so we now introduce a compact form of the notation setting
K = K(X, X) and K∗= K(X, X∗). In the case that there is only one test
point x∗we write k(x∗) = k∗to denote the vector of covariances between the
test point and the n training points. Using this compact notation and for a
single test point x∗, equations 2.23 and 2.24 reduce to
V[f∗] = k(x∗, x∗) −k⊤
Let us examine the predictive distribution as given by equations 2.25 and 2.26.
predictive distribution
Note ﬁrst that the mean prediction eq. (2.25) is a linear combination of observations y; this is sometimes referred to as a linear predictor. Another way to
linear predictor
look at this equation is to see it as a linear combination of n kernel functions,
each one centered on a training point, by writing
αik(xi, x∗)
where α = (K + σ2
nI)−1y. The fact that the mean prediction for f(x∗) can be
written as eq. (2.27) despite the fact that the GP can be represented in terms
of a (possibly inﬁnite) number of basis functions is one manifestation of the
representer theorem; see section 6.2 for more on this point. We can understand
representer theorem
this result intuitively because although the GP deﬁnes a joint Gaussian distribution over all of the y variables, one for each point in the index set X, for
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
output, f(x)
post. covariance, cov(f(x),f(x’))
(a), posterior
(b), posterior covariance
Figure 2.4: Panel (a) is identical to Figure 2.2(b) showing three random functions
drawn from the posterior. Panel (b) shows the posterior co-variance between f(x) and
f(x′) for the same data for three diﬀerent values of x′. Note, that the covariance at
close points is high, falling to zero at the training points (where there is no variance,
since it is a noise-free process), then becomes negative, etc. This happens because if
the smooth function happens to be less than the mean on one side of the data point,
it tends to exceed the mean on the other side, causing a reversal of the sign of the
covariance at the data points. Note for contrast that the prior covariance is simply
of Gaussian shape and never negative.
making predictions at x∗we only care about the (n+1)-dimensional distribution
deﬁned by the n training points and the test point. As a Gaussian distribution is marginalized by just taking the relevant block of the joint covariance
matrix (see section A.2) it is clear that conditioning this (n+1)-dimensional
distribution on the observations gives us the desired result. A graphical model
representation of a GP is given in Figure 2.3.
Note also that the variance in eq. (2.24) does not depend on the observed
targets, but only on the inputs; this is a property of the Gaussian distribution.
The variance is the diﬀerence between two terms: the ﬁrst term K(X∗, X∗) is
simply the prior covariance; from that is subtracted a (positive) term, representing the information the observations gives us about the function. We can
very simply compute the predictive distribution of test targets y∗by adding
noisy predictions
nI to the variance in the expression for cov(f∗).
The predictive distribution for the GP model gives more than just pointwise
joint predictions
errorbars of the simpliﬁed eq. (2.26). Although not stated explicitly, eq. (2.24)
holds unchanged when X∗denotes multiple test inputs; in this case the covariance of the test targets are computed (whose diagonal elements are the
pointwise variances). In fact, eq. (2.23) is the mean function and eq. (2.24) the
covariance function of the (Gaussian) posterior process; recall the deﬁnition
posterior process
of Gaussian process from page 13. The posterior covariance in illustrated in
Figure 2.4(b).
It will be useful (particularly for chapter 5) to introduce the marginal likelihood (or evidence) p(y|X) at this point. The marginal likelihood is the integral
marginal likelihood
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.3 Varying the Hyperparameters
input: X (inputs), y (targets), k (covariance function), σ2
n (noise level),
x∗(test input)
2: L := cholesky(K + σ2
α := L⊤\(L\y)
4: ¯f∗:= k⊤
predictive mean eq. (2.25)
6: V[f∗] := k(x∗, x∗) −v⊤v
predictive variance eq. (2.26)
log p(y|X) := −1
i log Lii −n
eq. (2.30)
8: return: ¯f∗(mean), V[f∗] (variance), log p(y|X) (log marginal likelihood)
Algorithm 2.1: Predictions and log marginal likelihood for Gaussian process regression. The implementation addresses the matrix inversion required by eq. (2.25) and
(2.26) using Cholesky factorization, see section A.4.
For multiple test cases lines
4-6 are repeated. The log determinant required in eq. (2.30) is computed from the
Cholesky factor (for large n it may not be possible to represent the determinant itself).
The computational complexity is n3/6 for the Cholesky decomposition in line 2, and
n2/2 for solving triangular systems in line 3 and (for each test case) in line 5.
of the likelihood times the prior
p(y|f, X)p(f|X) df.
The term marginal likelihood refers to the marginalization over the function
Under the Gaussian process model the prior is Gaussian, f|X ∼
N(0, K), or
log p(f|X) = −1
2f ⊤K−1f −1
2 log |K| −n
and the likelihood is a factorized Gaussian y|f ∼N(f, σ2
nI) so we can make use
of equations A.7 and A.8 to perform the integration yielding the log marginal
likelihood
log p(y|X) = −1
2y⊤(K + σ2
2 log |K + σ2
This result can also be obtained directly by observing that y ∼N(0, K +σ2
A practical implementation of Gaussian process regression (GPR) is shown
in Algorithm 2.1. The algorithm uses Cholesky decomposition, instead of directly inverting the matrix, since it is faster and numerically more stable, see
section A.4. The algorithm returns the predictive mean and variance for noise
free test data—to compute the predictive distribution for noisy test data y∗,
simply add the noise variance σ2
n to the predictive variance of f∗.
Varying the Hyperparameters
Typically the covariance functions that we use will have some free parameters.
For example, the squared-exponential covariance function in one dimension has
the following form
ky(xp, xq) = σ2
2ℓ2 (xp −xq)2
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
(b), ℓ= 0.3
Figure 2.5: (a) Data is generated from a GP with hyperparameters (ℓ, σf, σn) =
(1, 1, 0.1), as shown by the + symbols. Using Gaussian process prediction with these
hyperparameters we obtain a 95% conﬁdence region for the underlying function f
(shown in grey). Panels (b) and (c) again show the 95% conﬁdence region, but this
time for hyperparameter values (0.3, 1.08, 0.00005) and (3.0, 1.16, 0.89) respectively.
The covariance is denoted ky as it is for the noisy targets y rather than for the
underlying function f. Observe that the length-scale ℓ, the signal variance σ2
and the noise variance σ2
n can be varied. In general we call the free parameters
hyperparameters
hyperparameters.11
In chapter 5 we will consider various methods for determining the hyperparameters from training data. However, in this section our aim is more simply to
explore the eﬀects of varying the hyperparameters on GP prediction. Consider
the data shown by + signs in Figure 2.5(a). This was generated from a GP
with the SE kernel with (ℓ, σf, σn) = (1, 1, 0.1). The ﬁgure also shows the 2
standard-deviation error bars for the predictions obtained using these values of
the hyperparameters, as per eq. (2.24). Notice how the error bars get larger
for input values that are distant from any training points. Indeed if the x-axis
11We refer to the parameters of the covariance function as hyperparameters to emphasize
that they are parameters of a non-parametric model; in accordance with the weight-space
view, section 2.1, the parameters (weights) of the underlying parametric model have been
integrated out.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.4 Decision Theory for Regression
were extended one would see the error bars reﬂect the prior standard deviation
of the process σf away from the data.
If we set the length-scale shorter so that ℓ= 0.3 and kept the other parameters the same, then generating from this process we would expect to see
plots like those in Figure 2.5(a) except that the x-axis should be rescaled by a
factor of 0.3; equivalently if the same x-axis was kept as in Figure 2.5(a) then
a sample function would look much more wiggly.
If we make predictions with a process with ℓ= 0.3 on the data generated
too short length-scale
from the ℓ= 1 process then we obtain the result in Figure 2.5(b). The remaining
two parameters were set by optimizing the marginal likelihood, as explained in
chapter 5. In this case the noise parameter is reduced to σn = 0.00005 as the
greater ﬂexibility of the “signal” means that the noise level can be reduced.
This can be observed at the two datapoints near x = 2.5 in the plots. In Figure
2.5(a) (ℓ= 1) these are essentially explained as a similar function value with
diﬀering noise. However, in Figure 2.5(b) (ℓ= 0.3) the noise level is very low,
so these two points have to be explained by a sharp variation in the value of
the underlying function f. Notice also that the short length-scale means that
the error bars in Figure 2.5(b) grow rapidly away from the datapoints.
In contrast, we can set the length-scale longer, for example to ℓ= 3, as shown
too long length-scale
in Figure 2.5(c). Again the remaining two parameters were set by optimizing the
marginal likelihood. In this case the noise level has been increased to σn = 0.89
and we see that the data is now explained by a slowly varying function with a
lot of noise.
Of course we can take the position of a quickly-varying signal with low noise,
or a slowly-varying signal with high noise to extremes; the former would give rise
to a white-noise process model for the signal, while the latter would give rise to a
constant signal with added white noise. Under both these models the datapoints
produced should look like white noise. However, studying Figure 2.5(a) we see
that white noise is not a convincing model of the data, as the sequence of y’s does
not alternate suﬃciently quickly but has correlations due to the variability of
the underlying function. Of course this is relatively easy to see in one dimension,
model comparison
but methods such as the marginal likelihood discussed in chapter 5 generalize
to higher dimensions and allow us to score the various models. In this case the
marginal likelihood gives a clear preference for (ℓ, σf, σn) = (1, 1, 0.1) over the
other two alternatives.
Decision Theory for Regression
In the previous sections we have shown how to compute predictive distributions
for the outputs y∗corresponding to the novel test input x∗. The predictive distribution is Gaussian with mean and variance given by eq. (2.25) and eq. (2.26).
In practical applications, however, we are often forced to make a decision about
how to act, i.e. we need a point-like prediction which is optimal in some sense.
optimal predictions
To this end we need a loss function, L(ytrue, yguess), which speciﬁes the loss incurred by guessing the value yguess when the true value is ytrue. For
example, the loss function could equal the absolute deviation between the guess
and the truth.
Notice that we computed the predictive distribution without reference to
the loss function. In non-Bayesian paradigms, the model is typically trained
non-Bayesian paradigm
by minimizing the empirical risk (or loss). In contrast, in the Bayesian setting
Bayesian paradigm
there is a clear separation between the likelihood function (used for training, in
addition to the prior) and the loss function. The likelihood function describes
how the noisy measurements are assumed to deviate from the underlying noisefree function. The loss function, on the other hand, captures the consequences
of making a speciﬁc choice, given an actual true state. The likelihood and loss
function need not have anything in common.12
Our goal is to make the point prediction yguess which incurs the smallest loss,
but how can we achieve that when we don’t know ytrue? Instead, we minimize
the expected loss or risk, by averaging w.r.t. our model’s opinion as to what the
expected loss, risk
truth might be
˜RL(yguess|x∗) =
L(y∗, yguess)p(y∗|x∗, D) dy∗.
Thus our best guess, in the sense that it minimizes the expected loss, is
yoptimal|x∗= argmin
˜RL(yguess|x∗).
In general the value of yguess that minimizes the risk for the loss function |yguess−
absolute error loss
y∗| is the median of p(y∗|x∗, D), while for the squared loss (yguess −y∗)2 it is
squared error loss
the mean of this distribution. When the predictive distribution is Gaussian
the mean and the median coincide, and indeed for any symmetric loss function
and symmetric predictive distribution we always get yguess as the mean of the
predictive distribution. However, in many practical problems the loss functions
can be asymmetric, e.g. in safety critical applications, and point predictions
may be computed directly from eq. (2.32) and eq. (2.33). A comprehensive
treatment of decision theory can be found in Berger .
An Example Application
In this section we use Gaussian process regression to learn the inverse dynamics
of a seven degrees-of-freedom SARCOS anthropomorphic robot arm. The task
is to map from a 21-dimensional input space (7 joint positions, 7 joint velocities,
7 joint accelerations) to the corresponding 7 joint torques. This task has previously been used to study regression algorithms by Vijayakumar and Schaal
 , Vijayakumar et al. and Vijayakumar et al. .13 Following
12Beware of fallacious arguments like: a Gaussian likelihood implies a squared error loss
13We thank Sethu Vijayakumar for providing us with the data.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.5 An Example Application
this previous work we present results below on just one of the seven mappings,
from the 21 input variables to the ﬁrst of the seven torques.
One might ask why it is necessary to learn this mapping; indeed there exist
why learning?
physics-based rigid-body-dynamics models which allow us to obtain the torques
from the position, velocity and acceleration variables. However, the real robot
arm is actuated hydraulically and is rather lightweight and compliant, so the
assumptions of the rigid-body-dynamics model are violated (as we see below).
It is worth noting that the rigid-body-dynamics model is nonlinear, involving
trigonometric functions and squares of the input variables.
An inverse dynamics model can be used in the following manner: a planning
module decides on a trajectory that takes the robot from its start to goal states,
and this speciﬁes the desired positions, velocities and accelerations at each time.
The inverse dynamics model is used to compute the torques needed to achieve
this trajectory and errors are corrected using a feedback controller.
The dataset consists of 48,933 input-output pairs, of which 44,484 were used
as a training set and the remaining 4,449 were used as a test set. The inputs
were linearly rescaled to have zero mean and unit variance on the training set.
The outputs were centered so as to have zero mean on the training set.
Given a prediction method, we can evaluate the quality of predictions in
several ways. Perhaps the simplest is the squared error loss, where we compute
the squared residual (y∗−¯f(x∗))2 between the mean prediction and the target
at each test point. This can be summarized by the mean squared error (MSE),
by averaging over the test set. However, this quantity is sensitive to the overall
scale of the target values, so it makes sense to normalize by the variance of the
targets of the test cases to obtain the standardized mean squared error (SMSE).
This causes the trivial method of guessing the mean of the training targets to
have a SMSE of approximately 1.
Additionally if we produce a predictive distribution at each test input we
can evaluate the negative log probability of the target under the model.14 As
GPR produces a Gaussian predictive density, one obtains
−log p(y∗|D, x∗) = 1
2 log(2πσ2
∗) + (y∗−¯f(x∗))2
where the predictive variance σ2
∗for GPR is computed as σ2
∗= V(f∗) + σ2
where V(f∗) is given by eq. (2.26); we must include the noise variance σ2
are predicting the noisy target y∗. This loss can be standardized by subtracting
the loss that would be obtained under the trivial model which predicts using
a Gaussian with the mean and variance of the training data. We denote this
the standardized log loss (SLL). The mean SLL is denoted MSLL. Thus the
MSLL will be approximately zero for simple methods and negative for better
A number of models were tested on the data. A linear regression (LR) model
provides a simple baseline for the SMSE. By estimating the noise level from the
14 It makes sense to use the negative log probability so as to obtain a loss, not a utility.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
Table 2.1: Test results on the inverse dynamics problem for a number of diﬀerent
methods. The “–” denotes a missing entry, caused by two methods not producing full
predictive distributions, so MSLL could not be evaluated.
residuals on the training set one can also obtain a predictive variance and thus
get a MSLL value for LR. The rigid-body-dynamics (RBD) model has a number
of free parameters; these were estimated by Vijayakumar et al. using a
least-squares ﬁtting procedure. We also give results for the locally weighted
projection regression (LWPR) method of Vijayakumar et al. which is an
on-line method that cycles through the dataset multiple times. For the GP
models it is computationally expensive to make use of all 44,484 training cases
due to the O(n3) scaling of the basic algorithm. In chapter 8 we present several
diﬀerent approximate GP methods for large datasets. The result given in Table
2.1 was obtained with the subset of regressors (SR) approximation with a subset
size of 4096. This result is taken from Table 8.1, which gives full results of the
various approximation methods applied to the inverse dynamics problem. The
squared exponential covariance function was used with a separate length-scale
parameter for each of the 21 input dimensions, plus the signal and noise variance
parameters σ2
n. These parameters were set by optimizing the marginal
likelihood eq. (2.30) on a subset of the data (see also chapter 5).
The results for the various methods are presented in Table 2.1. Notice that
the problem is quite non-linear, so the linear regression model does poorly in
comparison to non-linear methods.15 The non-linear method LWPR improves
over linear regression, but is outperformed by GPR.
Smoothing, Weight Functions and Equivalent Kernels
Gaussian process regression aims to reconstruct the underlying signal f by
removing the contaminating noise ε. To do this it computes a weighted average
of the noisy observations y as ¯f(x∗) = k(x∗)⊤(K+σ2
nI)−1y; as ¯f(x∗) is a linear
combination of the y values, Gaussian process regression is a linear smoother
linear smoother
 . In this section
we study smoothing ﬁrst in terms of a matrix analysis of the predictions at the
training points, and then in terms of the equivalent kernel.
15It is perhaps surprising that RBD does worse than linear regression. However, Stefan
Schaal states that the RBD parameters were optimized on a very large
dataset, of which the training data used here is subset, and if the RBD model were optimized
w.r.t. this training set one might well expect it to outperform linear regression.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.6 Smoothing, Weight Functions and Equivalent Kernels
The predicted mean values ¯f at the training points are given by
¯f = K(K + σ2
Let K have the eigendecomposition K = Pn
i , where λi is the ith
eigendecomposition
eigenvalue and ui is the corresponding eigenvector.
As K is real and symmetric positive semideﬁnite, its eigenvalues are real and non-negative, and its
eigenvectors are mutually orthogonal. Let y = Pn
i=1γiui for some coeﬃcients
Notice that if λi/(λi + σ2
n) ≪1 then the component in y along ui is eﬀectively
eliminated. For most covariance functions that are used in practice the eigenvalues are larger for more slowly varying eigenvectors (e.g. fewer zero-crossings)
so that this means that high-frequency components in y are smoothed out.
The eﬀective number of parameters or degrees of freedom of the smoother is
degrees of freedom
deﬁned as tr(K(K + σ2
nI)−1) = Pn
i=1 λi/(λi + σ2
n), see Hastie and Tibshirani
[1990, sec. 3.5]. Notice that this counts the number of eigenvectors which are
not eliminated.
We can deﬁne a vector of functions h(x∗) = (K + σ2
nI)−1k(x∗). Thus we
have ¯f(x∗) = h(x∗)⊤y, making it clear that the mean prediction at a point
x∗is a linear combination of the target values y. For a ﬁxed test point x∗,
h(x∗) gives the vector of weights applied to targets y. h(x∗) is called the weight
function [Silverman, 1984]. As Gaussian process regression is a linear smoother,
weight function
the weight function does not depend on y.
Note the diﬀerence between a
linear model, where the prediction is a linear combination of the inputs, and a
linear smoother, where the prediction is a linear combination of the training set
Understanding the form of the weight function is made complicated by the
matrix inversion of K+σ2
nI and the fact that K depends on the speciﬁc locations
of the n datapoints. Idealizing the situation one can consider the observations
to be “smeared out” in x-space at some density of observations. In this case
analytic tools can be brought to bear on the problem, as shown in section 7.1.
By analogy to kernel smoothing, Silverman called the idealized weight
function the equivalent kernel; see also Girosi et al. [1995, sec. 2.1].
equivalent kernel
A kernel smoother centres a kernel function16 κ on x∗and then computes
kernel smoother
κi = κ(|xi −x∗|/ℓ) for each data point (xi, yi), where ℓis a length-scale. The
Gaussian is a commonly used kernel function.
The prediction for f(x∗) is
computed as ˆf(x∗) = Pn
i=1wiyi where wi = κi/ Pn
j=1 κj. This is also known
as the Nadaraya-Watson estimator, see e.g. Scott [1992, sec. 8.1].
The weight function and equivalent kernel for a Gaussian process are illustrated in Figure 2.6 for a one-dimensional input variable x. We have used the
squared exponential covariance function and have set the length-scale ℓ= 0.0632
(so that ℓ2 = 0.004). There are n = 50 training points spaced randomly along
16Note that this kernel function does not need to be a valid covariance function.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
Figure 2.6: Panels (a)-(c) show the weight function h(x∗) (dots) corresponding to
the n = 50 training points, the equivalent kernel (solid) and the original squared
exponential kernel (dashed). Panel (d) shows the equivalent kernels for two diﬀerent
data densities. See text for further details. The small cross at the test point is to
scale in all four plots.
the x-axis. Figures 2.6(a) and 2.6(b) show the weight function and equivalent
kernel for x∗= 0.5 and x∗= 0.05 respectively, for σ2
n = 0.1. Figure 2.6(c) is also
for x∗= 0.5 but uses σ2
n = 10. In each case the dots correspond to the weight
function h(x∗) and the solid line is the equivalent kernel, whose construction is
explained below. The dashed line shows a squared exponential kernel centered
on the test point, scaled to have the same height as the maximum value in the
equivalent kernel. Figure 2.6(d) shows the variation in the equivalent kernel as
a function of n, the number of datapoints in the unit interval.
Many interesting observations can be made from these plots. Observe that
the equivalent kernel has (in general) a shape quite diﬀerent to the original SE
kernel. In Figure 2.6(a) the equivalent kernel is clearly oscillatory (with negative
sidelobes) and has a higher spatial frequency than the original kernel. Figure
2.6(b) shows similar behaviour although due to edge eﬀects the equivalent kernel
is truncated relative to that in Figure 2.6(a). In Figure 2.6(c) we see that at
higher noise levels the negative sidelobes are reduced and the width of the
equivalent kernel is similar to the original kernel. Also note that the overall
height of the equivalent kernel in (c) is reduced compared to that in (a) and
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.7 Incorporating Explicit Basis Functions
(b)—it averages over a wider area. The more oscillatory equivalent kernel for
lower noise levels can be understood in terms of the eigenanalysis above; at
higher noise levels only the large λ (slowly varying) components of y remain,
while for smaller noise levels the more oscillatory components are also retained.
In Figure 2.6(d) we have plotted the equivalent kernel for n = 10 and n =
250 datapoints in ; notice how the width of the equivalent kernel decreases
as n increases. We discuss this behaviour further in section 7.1.
The plots of equivalent kernels in Figure 2.6 were made by using a dense
grid of ngrid points on and then computing the smoother matrix K(K +
gridI)−1. Each row of this matrix is the equivalent kernel at the appropriate
However, in order to get the scaling right one has to set σ2
nngrid/n; for ngrid > n this means that the eﬀective variance at each of the
ngrid points is larger, but as there are correspondingly more points this eﬀect
cancels out. This can be understood by imagining the situation if there were
ngrid/n independent Gaussian observations with variance σ2
grid at a single xposition; this would be equivalent to one Gaussian observation with variance
n. In eﬀect the n observations have been smoothed out uniformly along the
interval. The form of the equivalent kernel can be obtained analytically if we
go to the continuum limit and look to smooth a noisy function. The relevant
theory and some example equivalent kernels are given in section 7.1.
Incorporating Explicit Basis Functions
It is common but by no means necessary to consider GPs with a zero mean function. Note that this is not necessarily a drastic limitation, since the mean of the
posterior process is not conﬁned to be zero. Yet there are several reasons why
one might wish to explicitly model a mean function, including interpretability
of the model, convenience of expressing prior information and a number of analytical limits which we will need in subsequent chapters. The use of explicit
basis functions is a way to specify a non-zero mean over functions, but as we
will see in this section, one can also use them to achieve other interesting eﬀects.
Using a ﬁxed (deterministic) mean function m(x) is trivial: Simply apply
ﬁxed mean function
the usual zero mean GP to the diﬀerence between the observations and the
ﬁxed mean function. With
 m(x), k(x, x′)
the predictive mean becomes
¯f∗= m(X∗) + K(X∗, X)K−1
y (y −m(X)),
where Ky = K + σ2
nI, and the predictive variance remains unchanged from
eq. (2.24).
However, in practice it can often be diﬃcult to specify a ﬁxed mean function.
In many cases it may be more convenient to specify a few ﬁxed basis functions,
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
whose coeﬃcients, β, are to be inferred from the data. Consider
stochastic mean
g(x) = f(x) + h(x)⊤β,
where f(x) ∼GP
 0, k(x, x′)
here f(x) is a zero mean GP, h(x) are a set of ﬁxed basis functions, and β are
additional parameters. This formulation expresses that the data is close to a
global linear model with the residuals being modelled by a GP. This idea was
explored explicitly as early as 1975 by Blight and Ott , who used the GP
to model the residuals from a polynomial regression, i.e. h(x) = (1, x, x2, . . .).
polynomial regression
When ﬁtting the model, one could optimize over the parameters β jointly with
the hyperparameters of the covariance function. Alternatively, if we take the
prior on β to be Gaussian, β ∼N(b, B), we can also integrate out these
parameters. Following O’Hagan we obtain another GP
 h(x)⊤b, k(x, x′) + h(x)⊤Bh(x′)
now with an added contribution in the covariance function caused by the uncertainty in the parameters of the mean. Predictions are made by plugging
the mean and covariance functions of g(x) into eq. (2.39) and eq. (2.24). After
rearranging, we obtain
¯g(X∗) = H⊤
y (y −H⊤¯β) = ¯f(X∗) + R⊤¯β,
cov(g∗) = cov(f∗) + R⊤(B−1 + HK−1
where the H matrix collects the h(x) vectors for all training (and H∗all test)
cases, ¯β = (B−1 + HK−1
y H⊤)−1(HK−1
y y + B−1b), and R = H∗−HK−1
Notice the nice interpretation of the mean expression, eq. (2.41) top line: ¯β is
the mean of the global linear model parameters, being a compromise between
the data term and prior, and the predictive mean is simply the mean linear
output plus what the GP model predicts from the residuals. The covariance is
the sum of the usual covariance term and a new non-negative contribution.
Exploring the limit of the above expressions as the prior on the β parameter becomes vague, B−1 →O (where O is the matrix of zeros), we obtain a
predictive distribution which is independent of b
¯g(X∗) = ¯f(X∗) + R⊤¯β,
cov(g∗) = cov(f∗) + R⊤(HK−1
where the limiting ¯β = (HK−1
y H⊤)−1HK−1
y y. Notice that predictions under
the limit B−1 →O should not be implemented na¨ıvely by plugging the modiﬁed
covariance function from eq. (2.40) into the standard prediction equations, since
the entries of the covariance function tend to inﬁnity, thus making it unsuitable
for numerical implementation. Instead eq. (2.42) must be used. Even if the
non-limiting case is of interest, eq. (2.41) is numerically preferable to a direct
implementation based on eq. (2.40), since the global linear part will often add
some very large eigenvalues to the covariance matrix, aﬀecting its condition
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.8 History and Related Work
Marginal Likelihood
In this short section we brieﬂy discuss the marginal likelihood for the model
with a Gaussian prior β ∼N(b, B) on the explicit parameters from eq. (2.40),
as this will be useful later, particularly in section 6.3.1. We can express the
marginal likelihood from eq. (2.30) as
log p(y|X, b, B) = −1
2(H⊤b −y)⊤(Ky + H⊤BH)−1(H⊤b −y)
2 log |Ky + H⊤BH| −n
where we have included the explicit mean. We are interested in exploring the
limit where B−1 →O, i.e. when the prior is vague. In this limit the mean of the
prior is irrelevant (as was the case in eq. (2.42)), so without loss of generality
(for the limiting case) we assume for now that the mean is zero, b = 0, giving
log p(y|X, b=0, B) = −1
2 log |Ky| −1
2 log |B| −1
2 log |A| −n
where A = B−1 + HK−1
y H⊤and C = K−1
y H⊤A−1HK−1
and we have used
the matrix inversion lemma, eq. (A.9) and eq. (A.10).
We now explore the behaviour of the log marginal likelihood in the limit of
vague priors on β. In this limit the variances of the Gaussian in the directions
spanned by columns of H⊤will become inﬁnite, and it is clear that this will
require special treatment. The log marginal likelihood consists of three terms:
a quadratic form in y, a log determinant term, and a term involving log 2π.
Performing an eigendecomposition of the covariance matrix we see that the
contributions to quadratic form term from the inﬁnite-variance directions will
be zero. However, the log determinant term will tend to minus inﬁnity. The
standard solution [Wahba, 1985, Ansley and Kohn, 1985] in this case is to
project y onto the directions orthogonal to the span of H⊤and compute the
marginal likelihood in this subspace.
Let the rank of H⊤be m.
shown in Ansley and Kohn this means that we must discard the terms
2 log |B| −m
2 log 2π from eq. (2.44) to give
log p(y|X) = −1
2 log |Ky| −1
2 log |A| −n−m
where A = HK−1
y H⊤and C = K−1
y H⊤A−1HK−1
History and Related Work
Prediction with Gaussian processes is certainly not a very recent topic, especially for time series analysis; the basic theory goes back at least as far as the
time series
work of Wiener and Kolmogorov in the 1940’s. Indeed Lauritzen
 discusses relevant work by the Danish astronomer T. N. Thiele dating
from 1880.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Regression
Gaussian process prediction is also well known in the geostatistics ﬁeld where it is known as kriging,17 and in meteorology [Thompson, 1956, Daley, 1991] although this literakriging
ture naturally has focussed mostly on two- and three-dimensional input spaces.
Whittle [1963, sec. 5.4] also suggests the use of such methods for spatial prediction. Ripley and Cressie provide useful overviews of Gaussian
process prediction in spatial statistics.
Gradually it was realized that Gaussian process prediction could be used in
a general regression context. For example O’Hagan presents the general
theory as given in our equations 2.23 and 2.24, and applies it to a number of
one-dimensional regression problems. Sacks et al. describe GPR in the
context of computer experiments (where the observations y are noise free) and
computer experiments
discuss a number of interesting directions such as the optimization of parameters
in the covariance function (see our chapter 5) and experimental design (i.e. the
choice of x-points that provide most information on f). The authors describe
a number of computer simulations that were modelled, including an example
where the response variable was the clock asynchronization in a circuit and the
inputs were six transistor widths. Santner et al. is a recent book on the
use of GPs for the design and analysis of computer experiments.
Williams and Rasmussen described Gaussian process regression in
machine learning
a machine learning context, and described optimization of the parameters in
the covariance function, see also Rasmussen . They were inspired to use
Gaussian process by the connection to inﬁnite neural networks as described in
section 4.2.3 and in Neal . The “kernelization” of linear ridge regression
described above is also known as kernel ridge regression see e.g. Saunders et al.
Relationships between Gaussian process prediction and regularization theory, splines, support vector machines (SVMs) and relevance vector machines
(RVMs) are discussed in chapter 6.
1. Replicate the generation of random functions from Figure 2.2.
regular (or random) grid of scalar inputs and the covariance function from
eq. (2.16). Hints on how to generate random samples from multi-variate
Gaussian distributions are given in section A.2.
Invent some training
data points, and make random draws from the resulting GP posterior
using eq. (2.19).
2. In eq. (2.11) we saw that the predictive variance at x∗under the feature
space regression model was var(f(x∗)) = φ(x∗)⊤A−1φ(x∗). Show that
cov(f(x∗), f(x′
∗)) = φ(x∗)⊤A−1φ(x′
∗). Check that this is compatible with
the expression given in eq. (2.24).
17Matheron named the method after the South African mining engineer D. G. Krige.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
2.9 Exercises
3. The Wiener process is deﬁned for x ≥0 and has f(0) = 0. (See section B.2.1 for further details.) It has mean zero and a non-stationary
covariance function k(x, x′) = min(x, x′). If we condition on the Wiener
process passing through f(1) = 0 we obtain a process known as the Brownian bridge (or tied-down Wiener process). Show that this process has
covariance k(x, x′) = min(x, x′)−xx′ for 0 ≤x, x′ ≤1 and mean 0. Write
a computer program to draw samples from this process at a ﬁnite grid of
x points in .
4. Let varn(f(x∗)) be the predictive variance of a Gaussian process regression model at x∗given a dataset of size n. The corresponding predictive
variance using a dataset of only the ﬁrst n −1 training points is denoted varn−1(f(x∗)). Show that varn(f(x∗)) ≤varn−1(f(x∗)), i.e. that
the predictive variance at x∗cannot increase as more training data is obtained. One way to approach this problem is to use the partitioned matrix
equations given in section A.3 to decompose varn(f(x∗)) = k(x∗, x∗) −
nI)−1k∗. An alternative information theoretic argument is given
in Williams and Vivarelli . Note that while this conclusion is true
for Gaussian process priors and Gaussian noise models it does not hold
generally, see Barber and Saad .
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
In chapter 2 we have considered regression problems, where the targets are
real valued. Another important class of problems is classiﬁcation1 problems,
where we wish to assign an input pattern x to one of C classes, C1, . . . , CC.
Practical examples of classiﬁcation problems are handwritten digit recognition
(where we wish to classify a digitized image of a handwritten digit into one of
ten classes 0-9), and the classiﬁcation of objects detected in astronomical sky
surveys into stars or galaxies. (Information on the distribution of galaxies in
the universe is important for theories of the early universe.) These examples
nicely illustrate that classiﬁcation problems can either be binary (or two-class,
binary, multi-class
C = 2) or multi-class (C > 2).
We will focus attention on probabilistic classiﬁcation, where test predictions
probabilistic
classiﬁcation
take the form of class probabilities; this contrasts with methods which provide
only a guess at the class label, and this distinction is analogous to the diﬀerence
between predictive distributions and point predictions in the regression setting.
Since generalization to test cases inherently involves some level of uncertainty,
it seems natural to attempt to make predictions in a way that reﬂects these
uncertainties. In a practical application one may well seek a class guess, which
can be obtained as the solution to a decision problem, involving the predictive
probabilities as well as a speciﬁcation of the consequences of making speciﬁc
predictions (the loss function).
Both classiﬁcation and regression can be viewed as function approximation
problems. Unfortunately, the solution of classiﬁcation problems using Gaussian
processes is rather more demanding than for the regression problems considered
in chapter 2.
This is because we assumed in the previous chapter that the
likelihood function was Gaussian; a Gaussian process prior combined with a
Gaussian likelihood gives rise to a posterior Gaussian process over functions,
and everything remains analytically tractable. For classiﬁcation models, where
the targets are discrete class labels, the Gaussian likelihood is inappropriate;2
non-Gaussian likelihood
1In the statistics literature classiﬁcation is often called discrimination.
2One may choose to ignore the discreteness of the target values, and use a regression
treatment, where all targets happen to be say ±1 for binary classiﬁcation. This is known as
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
in this chapter we treat methods of approximate inference for classiﬁcation,
where exact inference is not feasible.3
Section 3.1 provides a general discussion of classiﬁcation problems, and describes the generative and discriminative approaches to these problems.
section 2.1 we saw how Gaussian process regression (GPR) can be obtained
by generalizing linear regression.
In section 3.2 we describe an analogue of
linear regression in the classiﬁcation case, logistic regression.
In section 3.3
logistic regression is generalized to yield Gaussian process classiﬁcation (GPC)
using again the ideas behind the generalization of linear regression to GPR.
For GPR the combination of a GP prior with a Gaussian likelihood gives rise
to a posterior which is again a Gaussian process. In the classiﬁcation case the
likelihood is non-Gaussian but the posterior process can be approximated by a
GP. The Laplace approximation for GPC is described in section 3.4 (for binary
classiﬁcation) and in section 3.5 (for multi-class classiﬁcation), and the expectation propagation algorithm (for binary classiﬁcation) is described in section 3.6.
Both of these methods make use of a Gaussian approximation to the posterior.
Experimental results for GPC are given in section 3.7, and a discussion of these
results is provided in section 3.8.
Classiﬁcation Problems
The natural starting point for discussing approaches to classiﬁcation is the
joint probability p(y, x), where y denotes the class label. Using Bayes’ theorem
this joint probability can be decomposed either as p(y)p(x|y) or as p(x)p(y|x).
This gives rise to two diﬀerent approaches to classiﬁcation problems. The ﬁrst,
which we call the generative approach, models the class-conditional distribugenerative approach
tions p(x|y) for y = C1, . . . , CC and also the prior probabilities of each class,
and then computes the posterior probability for each class using
p(y)p(x|y)
c=1 p(Cc)p(x|Cc)
The alternative approach, which we call the discriminative approach, focusses
discriminative approach
on modelling p(y|x) directly. Dawid calls the generative and discriminative approaches the sampling and diagnostic paradigms, respectively.
To turn both the generative and discriminative approaches into practical
methods we will need to create models for either p(x|y), or p(y|x) respectively.4
These could either be of parametric form, or non-parametric models such as
those based on nearest neighbours.
For the generative case a simple, comgenerative model
least-squares classiﬁcation, see section 6.5.
3Note, that the important distinction is between Gaussian and non-Gaussian likelihoods;
regression with a non-Gaussian likelihood requires a similar treatment, but since classiﬁcation
deﬁnes an important conceptual and application area, we have chosen to treat it in a separate
chapter; for non-Gaussian likelihoods in general, see section 9.3.
4For the generative approach inference for p(y) is generally straightforward, being estimation of a binomial probability in the binary case, or a multinomial probability in the
multi-class case.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.1 Classiﬁcation Problems
mon choice would be to model the class-conditional densities with Gaussians:
p(x|Cc) = N(µc, Σc). A Bayesian treatment can be obtained by placing appropriate priors on the mean and covariance of each of the Gaussians. However,
note that this Gaussian model makes a strong assumption on the form of classconditional density and if this is inappropriate the model may perform poorly.
For the binary discriminative case one simple idea is to turn the output of a
discriminative model
regression model into a class probability using a response function (the inverse
of a link function), which “squashes” its argument, which can lie in the domain
(−∞, ∞), into the range , guaranteeing a valid probabilistic interpretation.
One example is the linear logistic regression model
p(C1|x) = λ(x⊤w),
where λ(z) =
1 + exp(−z),
which combines the linear model with the logistic response function. Another
response function
common choice of response function is the cumulative density function of a
standard normal distribution Φ(z) =
−∞N(x|0, 1)dx. This approach is known
as probit regression. Just as we gave a Bayesian approach to linear regression in
probit regression
chapter 2 we can take a parallel approach to logistic regression, as discussed in
section 3.2. As in the regression case, this model is an important step towards
the Gaussian process classiﬁer.
Given that there are the generative and discriminative approaches, which
generative or
discriminative?
one should we prefer? This is perhaps the biggest question in classiﬁcation,
and we do not believe that there is a right answer, as both ways of writing the
joint p(y, x) are correct. However, it is possible to identify some strengths and
weaknesses of the two approaches. The discriminative approach is appealing
in that it is directly modelling what we want, p(y|x). Also, density estimation
for the class-conditional distributions is a hard problem, particularly when x is
high dimensional, so if we are just interested in classiﬁcation then the generative
approach may mean that we are trying to solve a harder problem than we need
to. However, to deal with missing input values, outliers and unlabelled data
missing values
points in a principled fashion it is very helpful to have access to p(x), and
this can be obtained from marginalizing out the class label y from the joint
as p(x) = P
y p(y)p(x|y) in the generative approach. A further factor in the
choice of a generative or discriminative approach could also be which one is
most conducive to the incorporation of any prior information which is available.
See Ripley [1996, sec. 2.1] for further discussion of these issues. The Gaussian
process classiﬁers developed in this chapter are discriminative.
Decision Theory for Classiﬁcation
The classiﬁers described above provide predictive probabilities p(y∗|x∗) for a
test input x∗. However, sometimes one actually needs to make a decision and
to do this we need to consider decision theory. Decision theory for the regression problem was considered in section 2.4; here we discuss decision theory for
classiﬁcation problems. A comprehensive treatment of decision theory can be
found in Berger .
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
Let L(c, c′) be the loss incurred by making decision c′ if the true class is Cc.
Usually L(c, c) = 0 for all c. The expected loss5 (or risk) of taking decision c′
loss, risk
given x is RL(c′|x) = P
c L(c, c′)p(Cc|x) and the optimal decision c∗is the one
that minimizes RL(c′|x). One common choice of loss function is the zero-one
loss, where a penalty of one unit is paid for an incorrect classiﬁcation, and 0
zero-one loss
for a correct one. In this case the optimal decision rule is to choose the class Cc
that maximizes6 p(Cc|x), as this minimizes the expected error at x. However,
the zero-one loss is not always appropriate. A classic example of this is the
asymmetric loss
diﬀerence in loss of failing to spot a disease when carrying out a medical test
compared to the cost of a false positive on the test, so that L(c, c′) ̸= L(c′, c).
The optimal classiﬁer (using zero-one loss) is known as the Bayes classi-
Bayes classiﬁer
By this construction the feature space is divided into decision regions
R1, . . . , RC such that a pattern falling in decision region Rc is assigned to class
decision regions
Cc. (There can be more than one decision region corresponding to a single class.)
The boundaries between the decision regions are known as decision surfaces or
decision boundaries.
One would expect misclassiﬁcation errors to occur in regions where the maximum class probability maxj p(Cj|x) is relatively low. This could be due to
either a region of strong overlap between classes, or lack of training examples
within this region. Thus one sensible strategy is to add a reject option so that
reject option
if maxj p(Cj|x) ≥θ for a threshold θ in (0, 1) then we go ahead and classify
the pattern, otherwise we reject it and leave the classiﬁcation task to a more
sophisticated system. For multi-class classiﬁcation we could alternatively require the gap between the most probable and the second most probable class to
exceed θ, and otherwise reject. As θ is varied from 0 to 1 one obtains an errorreject curve, plotting the percentage of patterns classiﬁed incorrectly against
the percentage rejected. Typically the error rate will fall as the rejection rate
increases. Hansen et al. provide an analysis of the error-reject trade-oﬀ.
We have focused above on the probabilistic approach to classiﬁcation, which
involves a two-stage approach of ﬁrst computing a posterior distribution over
functions and then combining this with the loss function to produce a decision.
However, it is worth noting that some authors argue that if our goal is to
eventually make a decision then we should aim to approximate the classiﬁcation
function that minimizes the risk (expected loss), which is deﬁned as
risk minimization
p(y, x) dydx,
where p(y, x) is the joint distribution of inputs and targets and c(x) is a classiﬁcation function that assigns an input pattern x to one of C classes . As p(y, x) is unknown, in this approach one often
then seeks to minimize an objective function which includes the empirical risk
i=1 L(yi, c(xi)) as well as a regularization term. While this is a reasonable
5In Economics one usually talks of maximizing expected utility rather than minimizing
expected loss; loss is negative utility. This suggests that statisticians are pessimists while
economists are optimists.
6If more than one class has equal posterior probability then ties can be broken arbitrarily.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.2 Linear Models for Classiﬁcation
method, we note that the probabilistic approach allows the same inference stage
to be re-used with diﬀerent loss functions, it can help us to incorporate prior
knowledge on the function and/or noise model, and has the advantage of giving
probabilistic predictions which can be helpful e.g. for the reject option.
Linear Models for Classiﬁcation
In this section we brieﬂy review linear models for binary classiﬁcation, which
form the foundation of Gaussian process classiﬁcation models in the next section. We follow the SVM literature and use the labels y = +1 and y = −1 to
distinguish the two classes, although for the multi-class case in section 3.5 we
use 0/1 labels. The likelihood is
p(y=+1|x, w) = σ(x⊤w),
given the weight vector w and σ(z) can be any sigmoid7 function. When using
the logistic, σ(z) = λ(z) from eq. (3.2), the model is usually called simply logistic
linear logistic regression
regression, but to emphasize the parallels to linear regression we prefer the term
linear logistic regression. When using the cumulative Gaussian σ(z) = Φ(z),
we call the model linear probit regression.
linear probit regression
As the probability of the two classes must sum to 1, we have p(y=−1|x, w) =
1 −p(y = +1|x, w). Thus for a data point (xi, yi) the likelihood is given by
i w) if yi = +1, and 1 −σ(x⊤
i w) if yi = −1. For symmetric likelihood
functions, such as the logistic or probit where σ(−z) = 1 −σ(z), this can be
written more concisely as
concise notation
p(yi|xi, w) = σ(yifi),
where fi ≜f(xi) = x⊤
Deﬁning the logit transformation as logit(x) =
 p(y =+1|x)/p(y =−1|x)
we see that the logistic regression model can be
written as logit(x) = x⊤w. The logit(x) function is also called the log odds
log odds ratio
ratio. Generalized linear modelling [McCullagh and Nelder, 1983] deals with
the issue of extending linear models to non-Gaussian data scenarios; the logit
transformation is the canonical link function for binary data and this choice
simpliﬁes the algebra and algorithms.
Given a dataset D = {(xi, yi)|i = 1, . . . , n}, we assume that the labels are
generated independently, conditional on f(x). Using the same Gaussian prior
w ∼N(0, Σp) as for regression in eq. (2.4) we then obtain the un-normalized
log posterior
log p(w|X, y)
log σ(yifi).
In the linear regression case with Gaussian noise the posterior was Gaussian
with mean and covariance as given in eq. (2.8). For classiﬁcation the posterior
7A sigmoid function is a monotonically increasing function mapping from R to . It
derives its name from being shaped like a letter S.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
does not have a simple analytic form. However, it is easy to show that for
some sigmoid functions, such as the logistic and cumulative Gaussian, the log
likelihood is a concave function of w for ﬁxed D. As the quadratic penalty on
w is also concave then the log posterior is a concave function, which means
that it is relatively easy to ﬁnd its unique maximum. The concavity can also be
unique maximum
derived from the fact that the Hessian of log p(w|X, y) is negative deﬁnite (see
section A.9 for further details). The standard algorithm for ﬁnding the maximum is Newton’s method, which in this context is usually called the iteratively
reweighted least squares (IRLS) algorithm, as described e.g. in McCullagh and
IRLS algorithm
Nelder . However, note that Minka provides evidence that other
optimization methods (e.g. conjugate gradient ascent) may be faster than IRLS.
Notice that a maximum likelihood treatment (corresponding to an unpeproperties of maximum
likelihood
nalized version of eq. (3.6)) may result in some undesirable outcomes. If the
dataset is linearly separable (i.e. if there exists a hyperplane which separates the
positive and negative examples) then maximizing the (unpenalized) likelihood
will cause |w| to tend to inﬁnity, However, this will still give predictions in 
for p(y = +1|x, w), although these predictions will be “hard” (i.e. zero or one).
If the problem is ill-conditioned, e.g. due to duplicate (or linearly dependent)
input dimensions, there will be no unique solution.
As an example, consider linear logistic regression in the case where x-space
is two dimensional and there is no bias weight so that w is also two-dimensional.
The prior in weight space is Gaussian and for simplicity we have set Σp = I.
Contours of the prior p(w) are illustrated in Figure 3.1(a). If we have a data set
D as shown in Figure 3.1(b) then this induces a posterior distribution in weight
space as shown in Figure 3.1(c).
Notice that the posterior is non-Gaussian
and unimodal, as expected. The dataset is not linearly separable but a weight
vector in the direction (1, 1)⊤is clearly a reasonable choice, as the posterior
distribution shows. To make predictions based the training set D for a test
predictions
point x∗we have
p(y∗=+1|x∗, D) =
p(y∗=+1|w, x∗)p(w|D) dw,
integrating the prediction p(y∗=+1|w, x∗) = σ(x⊤
∗w) over the posterior distribution of weights. This leads to contours of the predictive distribution as shown
in Figure 3.1(d). Notice how the contours are bent, reﬂecting the integration
of many diﬀerent but plausible w’s.
In the multi-class case we use the multiple logistic (or softmax) function
multiple logistic
p(y = Cc|x, W) =
c′ exp(x⊤wc′),
where wc is the weight vector for class c, and all weight vectors are collected into the matrix W.
The corresponding log likelihood is of the form
c=1 δc,yi[x⊤
i wc −log(P
i wc′))]. As in the binary case the log
likelihood is a concave function of W.
It is interesting to note that in a generative approach where the classconditional distributions p(x|y) are Gaussian with the same covariance matrix,
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.3 Gaussian Process Classiﬁcation
Figure 3.1: Linear logistic regression: Panel (a) shows contours of the prior distribution p(w) = N(0, I). Panel (b) shows the dataset, with circles indicating class +1
and crosses denoting class −1. Panel (c) shows contours of the posterior distribution
p(w|D). Panel (d) shows contours of the predictive distribution p(y∗=+1|x∗).
p(y|x) has the form given by eq. (3.4) and eq. (3.8) for the two- and multi-class
cases respectively (when the constant function 1 is included in x).
Gaussian Process Classiﬁcation
For binary classiﬁcation the basic idea behind Gaussian process prediction
is very simple—we place a GP prior over the latent function f(x) and then
latent function
“squash” this through the logistic function to obtain a prior on π(x) ≜p(y =
+1|x) = σ(f(x)). Note that π is a deterministic function of f, and since f
is stochastic, so is π. This construction is illustrated in Figure 3.2 for a onedimensional input space.
It is a natural generalization of the linear logistic
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
latent function, f(x)
class probability, π(x)
Figure 3.2: Panel (a) shows a sample latent function f(x) drawn from a Gaussian
process as a function of x. Panel (b) shows the result of squashing this sample function through the logistic logit function, λ(z) = (1 + exp(−z))−1 to obtain the class
probability π(x) = λ(f(x)).
regression model and parallels the development from linear regression to GP
regression that we explored in section 2.1. Speciﬁcally, we replace the linear
f(x) function from the linear logistic model in eq. (3.6) by a Gaussian process,
and correspondingly the Gaussian prior on the weights by a GP prior.
The latent function f plays the rˆole of a nuisance function: we do not
nuisance function
observe values of f itself (we observe only the inputs X and the class labels y)
and we are not particularly interested in the values of f, but rather in π, in
particular for test cases π(x∗). The purpose of f is solely to allow a convenient
formulation of the model, and the computational goal pursued in the coming
sections will be to remove (integrate out) f.
We have tacitly assumed that the latent Gaussian process is noise-free, and
noise-free latent process
combined it with smooth likelihood functions, such as the logistic or probit.
However, one can equivalently think of adding independent noise to the latent
process in combination with a step-function likelihood. In particular, assuming
Gaussian noise and a step-function likelihood is exactly equivalent to a noisefree8 latent process and probit likelihood, see exercise 3.10.1.
Inference is naturally divided into two steps: ﬁrst computing the distribution
of the latent variable corresponding to a test case
p(f∗|X, y, x∗) =
p(f∗|X, x∗, f)p(f|X, y) df,
where p(f|X, y) = p(y|f)p(f|X)/p(y|X) is the posterior over the latent variables, and subsequently using this distribution over the latent f∗to produce a
probabilistic prediction
¯π∗≜p(y∗=+1|X, y, x∗) =
σ(f∗)p(f∗|X, y, x∗) df∗.
8This equivalence explains why no numerical problems arise from considering a noise-free
process if care is taken with the implementation, see also comment at the end of section 3.4.3.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.4 The Laplace Approximation for the Binary GP Classiﬁer
In the regression case (with Gaussian likelihood) computation of predictions was
straightforward as the relevant integrals were Gaussian and could be computed
analytically. In classiﬁcation the non-Gaussian likelihood in eq. (3.9) makes
the integral analytically intractable.
Similarly, eq. (3.10) can be intractable
analytically for certain sigmoid functions, although in the binary case it is
only a one-dimensional integral so simple numerical techniques are generally
Thus we need to use either analytic approximations of integrals, or solutions
based on Monte Carlo sampling. In the coming sections, we describe two analytic approximations which both approximate the non-Gaussian joint posterior
with a Gaussian one: the ﬁrst is the straightforward Laplace approximation
method [Williams and Barber, 1998], and the second is the more sophisticated
expectation propagation (EP) method due to Minka . (The cavity TAP approximation of Opper and Winther is closely related to the EP method.)
A number of other approximations have also been suggested, see e.g. Gibbs and
MacKay , Jaakkola and Haussler , and Seeger . Neal 
describes the use of Markov chain Monte Carlo (MCMC) approximations. All
of these methods will typically scale as O(n3); for large datasets there has been
much work on further approximations to reduce computation time, as discussed
in chapter 8.
The Laplace approximation for the binary case is described in section 3.4,
and for the multi-class case in section 3.5. The EP method for binary classiﬁcation is described in section 3.6. Relationships between Gaussian process
classiﬁers and other techniques such as spline classiﬁers, support vector machines and least-squares classiﬁcation are discussed in sections 6.3, 6.4 and 6.5
respectively.
The Laplace Approximation for the Binary
GP Classiﬁer
Laplace’s method utilizes a Gaussian approximation q(f|X, y) to the posterior p(f|X, y) in the integral (3.9).
Doing a second order Taylor expansion
of log p(f|X, y) around the maximum of the posterior, we obtain a Gaussian
approximation
q(f|X, y) = N(f|ˆf, A−1) ∝exp
2(f −ˆf)⊤A(f −ˆf)
where ˆf = argmaxf p(f|X, y) and A = −∇∇log p(f|X, y)|f=ˆf is the Hessian of
the negative log posterior at that point.
The structure of the rest of this section is as follows: In section 3.4.1 we
describe how to ﬁnd ˆf and A. Section 3.4.2 explains how to make predictions
having obtained q(f|y), and section 3.4.3 gives more implementation details
for the Laplace GP classiﬁer.
The Laplace approximation for the marginal
likelihood is described in section 3.4.4.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
latent times target, zi=yifi
log likelihood, log p(yi|fi)
log likelihood
1st derivative
2nd derivative
latent times target, zi=yifi
log likelihood, log p(yi|fi)
log likelihood
1st derivative
2nd derivative
(a), logistic
(b), probit
Figure 3.3: The log likelihood and its derivatives for a single case as a function of
zi = yifi, for (a) the logistic, and (b) the cumulative Gaussian likelihood. The two
likelihood functions are fairly similar, the main qualitative diﬀerence being that for
large negative arguments the log logistic behaves linearly whereas the log cumulative
Gaussian has a quadratic penalty. Both likelihoods are log concave.
By Bayes’ rule the posterior over the latent variables is given by p(f|X, y) =
p(y|f)p(f|X)/p(y|X), but as p(y|X) is independent of f, we need only consider
the un-normalized posterior when maximizing w.r.t. f. Taking the logarithm
un-normalized posterior
and introducing expression eq. (2.29) for the GP prior gives
Ψ(f) ≜log p(y|f) + log p(f|X)
= log p(y|f) −1
2f ⊤K−1f −1
2 log |K| −n
Diﬀerentiating eq. (3.12) w.r.t. f we obtain
∇Ψ(f) = ∇log p(y|f) −K−1f,
∇∇Ψ(f) = ∇∇log p(y|f) −K−1 = −W −K−1,
where W ≜−∇∇log p(y|f) is diagonal, since the likelihood factorizes over
cases (the distribution for yi depends only on fi, not on fj̸=i). Note, that if the
likelihood p(y|f) is log concave, the diagonal elements of W are non-negative,
and the Hessian in eq. (3.14) is negative deﬁnite, so that Ψ(f) is concave and
has a unique maximum (see section A.9 for further details).
There are many possible functional forms of the likelihood, which gives the
target class probability as a function of the latent variable f. Two commonly
used likelihood functions are the logistic, and the cumulative Gaussian, see
log likelihoods
and their derivatives
Figure 3.3. The expressions for the log likelihood for these likelihood functions
and their ﬁrst and second derivatives w.r.t. the latent variable are given in the
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.4 The Laplace Approximation for the Binary GP Classiﬁer
following table:
log p(yi|fi)
log p(yi|fi)
log p(yi|fi)
 1 + exp(−yifi)
−πi(1 −πi)
log Φ(yifi)
Φ(yifi)2 −yifiN(fi)
where we have deﬁned πi = p(yi = 1|fi) and t = (y + 1)/2. At the maximum
of Ψ(f) we have
∇Ψ = 0 =⇒ˆf = K
 ∇log p(y|ˆf)
as a self-consistent equation for ˆf (but since ∇log p(y|ˆf) is a non-linear function
of ˆf, eq. (3.17) cannot be solved directly). To ﬁnd the maximum of Ψ we use
Newton’s method, with the iteration
Newton’s method
f new = f −(∇∇Ψ)−1∇Ψ = f + (K−1 + W)−1(∇log p(y|f) −K−1f)
= (K−1 + W)−1 Wf + ∇log p(y|f)
To gain more intuition about this update, let us consider what happens to
datapoints that are well-explained under f so that ∂log p(yi|fi)/∂fi and Wii
are close to zero for these points.
As an approximation, break f into two
subvectors, f1 that corresponds to points that are not well-explained, and f2 to
those that are. Then it is easy to show (see exercise 3.10.4) that
= K11(I11 + W11K11)−1 W11f1 + ∇log p(y1|f1)
where K21 denotes the n2 × n1 block of K containing the covariance between
the two groups of points, etc. This means that f new
is computed by ignoring
intuition on inﬂuence of
well-explained points
entirely the well-explained points, and f new
is predicted from f new
usual GP prediction methods (i.e. treating these points like test points). Of
course, if the predictions of f new
fail to match the targets correctly they would
cease to be well-explained and so be updated on the next iteration.
Having found the maximum posterior ˆf, we can now specify the Laplace
approximation to the posterior as a Gaussian with mean ˆf and covariance matrix
given by the negative inverse Hessian of Ψ from eq. (3.14)
q(f|X, y) = N
 ˆf, (K−1 + W)−1
One problem with the Laplace approximation is that it is essentially uncontrolled, in that the Hessian (evaluated at ˆf) may give a poor approximation
to the true shape of the posterior. The peak could be much broader or narrower than the Hessian indicates, or it could be a skew peak, while the Laplace
approximation assumes it has elliptical contours.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
Predictions
The posterior mean for f∗under the Laplace approximation can be expressed
by combining the GP predictive mean eq. (2.25) with eq. (3.17) into
latent mean
Eq[f∗|X, y, x∗] = k(x∗)⊤K−1ˆf = k(x∗)⊤∇log p(y|ˆf).
Compare this with the exact mean, given by Opper and Winther as
Ep[f∗|X, y, x∗] =
E[f∗|f, X, x∗]p(f|X, y)df
k(x∗)⊤K−1f p(f|X, y)df = k(x∗)⊤K−1E[f|X, y],
where we have used the fact that for a GP E[f∗|f, X, x∗] = k(x∗)⊤K−1f and
have let E[f|X, y] denote the posterior mean of f given X and y. Notice the
similarity between the middle expression of eq. (3.21) and eq. (3.22), where the
exact (intractable) average E[f|X, y] has been replaced with the modal value
ˆf = Eq[f|X, y].
A simple observation from eq. (3.21) is that positive training examples will
give rise to a positive coeﬃcient for their kernel function (as ∇i log p(yi|fi) > 0
sign of kernel
coeﬃcients
in this case), while negative examples will give rise to a negative coeﬃcient;
this is analogous to the solution to the support vector machine, see eq. (6.34).
Also note that training points which have ∇i log p(yi|fi) ≃0 (i.e. that are
well-explained under ˆf) do not contribute strongly to predictions at novel test
points; this is similar to the behaviour of non-support vectors in the support
vector machine (see section 6.4).
We can also compute Vq[f∗|X, y], the variance of f∗|X, y under the Gaussian
approximation. This comprises of two terms, i.e.
Vq[f∗|X, y, x∗] = Ep(f∗|X,x∗,f)[(f∗−E[f∗|X, x∗, f])2]
+ Eq(f|X,y)[(E[f∗|X, x∗, f] −E[f∗|X, y, x∗])2].
The ﬁrst term is due to the variance of f∗if we condition on a particular value
of f, and is given by k(x∗, x∗) −k(x∗)⊤K−1k(x∗), cf. eq. (2.19). The second
term in eq. (3.23) is due to the fact that E[f∗|X, x∗, f] = k(x∗)⊤K−1f depends
on f and thus there is an additional term of k(x∗)⊤K−1 cov(f|X, y)K−1k(x∗).
Under the Gaussian approximation cov(f|X, y) = (K−1 + W)−1, and thus
latent variance
Vq[f∗|X, y, x∗] = k(x∗, x∗)−k⊤
∗K−1k∗+ k⊤
∗K−1(K−1 + W)−1K−1k∗
= k(x∗, x∗)−k⊤
∗(K + W −1)−1k∗,
where the last line is obtained using the matrix inversion lemma eq. (A.9).
Given the mean and variance of f∗, we make predictions by computing
averaged predictive
probability
¯π∗≃Eq[π∗|X, y, x∗] =
σ(f∗)q(f∗|X, y, x∗) df∗,
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.4 The Laplace Approximation for the Binary GP Classiﬁer
where q(f∗|X, y, x∗) is Gaussian with mean and variance given by equations
3.21 and 3.24 respectively. Notice that because of the non-linear form of the
sigmoid the predictive probability from eq. (3.25) is diﬀerent from the sigmoid
of the expectation of f: ˆπ∗= σ(Eq[f∗|y]). We will call the latter the MAP
prediction to distinguish it from the averaged predictions from eq. (3.25).
MAP prediction
In fact, as shown in Bishop [1995, sec. 10.3], the predicted test labels
identical binary
given by choosing the class of highest probability obtained by averaged and
MAP predictions are identical for binary9 classiﬁcation.
To see this, note
that the decision boundary using the the MAP value Eq[f∗|X, y, x∗] corresponds to σ(Eq[f∗|X, y, x∗]) = 1/2 or Eq[f∗|X, y, x∗] = 0. The decision boundary of the averaged prediction, Eq[π∗|X, y, x∗] = 1/2, also corresponds to
Eq[f∗|X, y, x∗] = 0. This follows from the fact that σ(f∗) −1/2 is antisymmetric while q(f∗|X, y, x∗) is symmetric.
Thus if we are concerned only about the most probable classiﬁcation, it is
not necessary to compute predictions using eq. (3.25). However, as soon as we
also need a conﬁdence in the prediction (e.g. if we are concerned about a reject
option) we need Eq[π∗|X, y, x∗]. If σ(z) is the cumulative Gaussian function
then eq. (3.25) can be computed analytically, as shown in section 3.9.
the other hand if σ is the logistic function then we need to resort to sampling
methods or analytical approximations to compute this one-dimensional integral.
One attractive method is to note that the logistic function λ(z) is the c.d.f.
(cumulative density function) corresponding to the p.d.f. (probability density
function) p(z) = sech2(z/2)/4; this is known as the logistic or sech-squared
distribution, see Johnson et al. [1995, ch. 23]. Then by approximating p(z) as a
mixture of Gaussians, one can approximate λ(z) by a linear combination of error
functions. This approximation was used by Williams and Barber [1998, app. A]
and Wood and Kohn .
Another approximation suggested in MacKay
[1992d] is ¯π∗≃λ(κ(f∗|y) ¯f∗), where κ2(f∗|y) = (1 + πVq[f∗|X, y, x∗]/8)−1.
The eﬀect of the latent predictive variance is, as the approximation suggests,
to “soften” the prediction that would be obtained using the MAP prediction
ˆπ∗= λ( ¯f∗), i.e. to move it towards 1/2.
Implementation
We give implementations for ﬁnding the Laplace approximation in Algorithm
3.1 and for making predictions in Algorithm 3.2. Care is taken to avoid numerically unstable computations while minimizing the computational eﬀort; both
can be achieved simultaneously. It turns out that several of the desired terms
can be expressed in terms of the symmetric positive deﬁnite matrix
computation of which costs only O(n2), since W is diagonal. The B matrix has
eigenvalues bounded below by 1 and bounded above by 1 + n maxij(Kij)/4, so
for many covariance functions B is guaranteed to be well-conditioned, and it is
9For multi-class predictions discussed in section 3.5 the situation is more complicated.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
input: K (covariance matrix), y (±1 targets), p(y|f) (likelihood function)
initialization
Newton iteration
W := −∇∇log p(y|f)
eval. W e.g. using eq. (3.15) or (3.16)
L := cholesky(I + W
b := Wf + ∇log p(y|f)
2 L⊤\(L\(W
eq. (3.18) using eq. (3.27)
until convergence
objective: −1
2a⊤f + log p(y|f)
10: log q(y|X, θ) := −1
2a⊤f + log p(y|f) −P
eq. (3.32)
return: ˆf := f (post. mode), log q(y|X, θ) (approx. log marg. likelihood)
Algorithm 3.1: Mode-ﬁnding for binary Laplace GPC. Commonly used convergence
criteria depend on the diﬀerence in successive values of the objective function Ψ(f)
from eq. (3.12), the magnitude of the gradient vector ∇Ψ(f) from eq. (3.13) and/or the
magnitude of the diﬀerence in successive values of f. In a practical implementation
one needs to secure against divergence by checking that each iteration leads to an
increase in the objective (and trying a smaller step size if not). The computational
complexity is dominated by the Cholesky decomposition in line 5 which takes n3/6
operations (times the number of Newton iterations), all other operations are at most
quadratic in n.
thus numerically safe to compute its Cholesky decomposition LL⊤= B, which
is useful in computing terms involving B−1 and |B|.
The mode-ﬁnding procedure uses the Newton iteration given in eq. (3.18),
involving the matrix (K−1+W)−1. Using the matrix inversion lemma eq. (A.9)
(K−1 + W)−1 = K −KW
where B is given in eq. (3.26). The advantage is that whereas K may have
eigenvalues arbitrarily close to zero (and thus be numerically unstable to invert),
we can safely work with B. In addition, Algorithm 3.1 keeps the vector a =
K−1f in addition to f, as this allows evaluation of the part of the objective
Ψ(f) in eq. (3.12) which depends on f without explicit reference to K−1 (again
to avoid possible numerical problems).
Similarly, for the computation of the predictive variance Vq[f∗|y] from eq. (3.24)
we need to evaluate a quadratic form involving the matrix (K + W −1)−1. Rewriting this as
(K + W −1)−1 = W
2 (K + W −1)−1W −1
achieves numerical stability (as opposed to inverting W itself, which may have
arbitrarily small eigenvalues). Thus the predictive variance from eq. (3.24) can
be computed as
Vq[f∗|y] = k(x∗, x∗) −k(x∗)⊤W
2 (LL⊤)−1W
= k(x∗, x∗) −v⊤v,
where v = L\ , X (inputs), y (±1 targets), k (covariance function),
p(y|f) (likelihood function), x∗test input
2: W := −∇∇log p(y|ˆf)
L := cholesky(I + W
4: ¯f∗:= k(x∗)⊤∇log p(y|ˆf)
eq. (3.21)
6: V[f∗] := k(x∗, x∗) −v⊤v
eq. (3.24) using eq. (3.29)
σ(z)N(z| ¯f∗, V[f∗])dz
eq. (3.25)
8: return: ¯π∗(predictive class probability (for class 1))
Algorithm 3.2: Predictions for binary Laplace GPC. The posterior mode ˆf (which
can be computed using Algorithm 3.1) is input. For multiple test inputs lines 4−7 are
applied to each test input. Computational complexity is n3/6 operations once (line
3) plus n2 operations per test case (line 5). The one-dimensional integral in line 7
can be done analytically for cumulative Gaussian likelihood, otherwise it is computed
using an approximation or numerical quadrature.
In practice we compute the Cholesky decomposition LL⊤= B during the
Newton steps in Algorithm 3.1, which can be re-used to compute the predictive
variance by doing backsubstitution with L as discussed above.
In addition,
L may again be re-used to compute |In + W
2 | = |B| (needed for the
computation of the marginal likelihood eq. (3.32)) as log |B| = 2 P log Lii. To
save computation, one could use an incomplete Cholesky factorization in the
incomplete Cholesky
factorization
Newton steps, as suggested by Fine and Scheinberg .
Sometimes it is suggested that it can be useful to replace K by K +ϵI where
ϵ is a small constant, to improve the numerical conditioning10 of K. However,
by taking care with the implementation details as above this should not be
necessary.
Marginal Likelihood
It will also be useful (particularly for chapter 5) to compute the Laplace approximation of the marginal likelihood p(y|X). (For the regression case with
Gaussian noise the marginal likelihood can again be calculated analytically, see
eq. (2.30).) We have
p(y|f)p(f|X) df =
Using a Taylor expansion of Ψ(f) locally around ˆf we obtain Ψ(f) ≃Ψ(ˆf) −
2(f −ˆf)⊤A(f −ˆf) and thus an approximation q(y|X) to the marginal likelihood
p(y|X) ≃q(y|X) = exp
2(f −ˆf)⊤A(f −ˆf)
10Neal refers to this as adding “jitter” in the context of Markov chain Monte Carlo
(MCMC) based inference; in his work the latent variables f are explicitly represented in
the Markov chain which makes addition of jitter diﬃcult to avoid.
Within the analytical
approximations of the distribution of f considered here, jitter is unnecessary.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
This Gaussian integral can be evaluated analytically to obtain an approximation
to the log marginal likelihood
log q(y|X, θ) = −1
2ˆf ⊤K−1ˆf + log p(y|ˆf) −1
2 log |B|,
where |B| = |K| · |K−1 + W| = |In + W
2 |, and θ is a vector of hyperparameters of the covariance function (which have previously been suppressed
from the notation for brevity).
Multi-class Laplace Approximation
Our presentation follows Williams and Barber . We ﬁrst introduce the
vector of latent function values at all n training points and for all C classes
1 , . . . , f 1
1 , . . . , f 2
n, . . . , f C
1 , . . . , f C
Thus f has length Cn. In the following we will generally refer to quantities
pertaining to a particular class with superscript c, and a particular case by
subscript i (as usual); thus e.g. the vector of C latents for a particular case is
fi. However, as an exception, vectors or matrices formed from the covariance
function for class c will have a subscript c.
The prior over f has the form
f ∼N(0, K). As we have assumed that the C latent processes are uncorrelated,
the covariance matrix K is block diagonal in the matrices K1, . . . , KC. Each
individual matrix Kc expresses the correlations of the latent function values
within the class c. Note that the covariance functions pertaining to the diﬀerent
classes can be diﬀerent. Let y be a vector of the same length as f
each i = 1, . . . , n has an entry of 1 for the class which is the label for example
i and 0 for the other C −1 entries.
i denote output of the softmax at training point i, i.e.
i |fi) = πc
c′ exp(f c′
Then π is a vector of the same length as f with entries πc
i . The multi-class
un-normalized posterior
analogue of eq. (3.12) is the log of the un-normalized posterior
2f ⊤K−1f +y⊤f −
2 log |K|−Cn
2 log 2π. (3.35)
As in the binary case we seek the MAP value ˆf of p(f|X, y). By diﬀerentiating
eq. (3.35) w.r.t. f we obtain
∇Ψ = −K−1f + y −π.
Thus at the maximum we have ˆf = K(y −ˆπ). Diﬀerentiating again, and using
i δcc′ + πc
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.5 Multi-class Laplace Approximation
we obtain11
∇∇Ψ = −K−1 −W,
where W ≜diag(π) −ΠΠ⊤,
where Π is a Cn×n matrix obtained by stacking vertically the diagonal matrices
diag(πc), and πc is the subvector of π pertaining to class c. As in the binary case
notice that −∇∇Ψ is positive deﬁnite, thus Ψ(f) is concave and the maximum
is unique (see also exercise 3.10.2).
As in the binary case we use Newton’s method to search for the mode of Ψ,
f new = (K−1 + W)−1(Wf + y −π).
This update if coded na¨ıvely would take O(C3n3) as matrices of size Cn have to
be inverted. However, as described in section 3.5.1, we can utilize the structure
of W to bring down the computational load to O(Cn3).
The Laplace approximation gives us a Gaussian approximation q(f|X, y) to
the posterior p(f|X, y). To make predictions at a test point x∗we need to compredictive
distribution for f∗
pute the posterior distribution q(f∗|X, y, x∗) where f(x∗) ≜f∗= (f 1
∗, . . . , f C
In general we have
q(f∗|X, y, x∗) =
p(f∗|X, x∗, f)q(f|X, y) df.
As p(f∗|X, x∗, f) and q(f|X, y) are both Gaussian, q(f∗|X, y, x∗) will also be
Gaussian and we need only compute its mean and covariance.
The predictive
mean for class c is given by
Eq[f c(x∗)|X, y, x∗] = kc(x∗)⊤K−1
c ˆf c = kc(x∗)⊤(yc −ˆπc),
where kc(x∗) is the vector of covariances between the test point and each of
the training points for the cth covariance function, and ˆf c is the subvector of
ˆf pertaining to class c. The last equality comes from using eq. (3.36) at the
maximum ˆf. Note the close correspondence to eq. (3.21). This can be put into
a vector form Eq[f∗|y] = Q⊤
∗(y −ˆπ) by deﬁning the Cn × C matrix
Using a similar argument to eq. (3.23) we obtain
covq(f∗|X, y, x∗) = Σ + Q⊤
∗K−1(K−1 + W)−1K−1Q∗
= diag(k(x∗, x∗)) −Q⊤
∗(K + W −1)−1Q∗,
where Σ is a diagonal C ×C matrix with Σcc = kc(x∗, x∗)−k⊤
and k(x∗, x∗) is a vector of covariances, whose c’th element is kc(x∗, x∗).
11There is a sign error in equation 23 of Williams and Barber but not in their
implementation.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
input: K (covariance matrix), y (0/1 targets)
initialization
Newton iteration
compute π and Π from f with eq. (3.34) and defn. of Π under eq. (3.38)
for c := 1 . . . C do
L := cholesky(In + D
2c L⊤\(L\D
E is block diag. D
2 (ICn + D
2 log determinant
M := cholesky(P
b := (D −ΠΠ⊤)f + y −π
b = Wf + y −π from eq. (3.39)
a := b −c + ERM ⊤\(M\(R⊤c))
eq. (3.39) using eq. (3.45) and (3.47)
until convergence
objective: −1
2a⊤f + y⊤f + P
16: log q(y|X, θ) := −1
2a⊤f + y⊤f + P
eq. (3.44)
return: ˆf := f (post. mode), log q(y|X, θ) (approx. log marg. likelihood)
Algorithm 3.3: Mode-ﬁnding for multi-class Laplace GPC, where D = diag(π), R
is a matrix of stacked identity matrices and a subscript c on a block diagonal matrix
indicates the n × n submatrix pertaining to class c. The computational complexity
is dominated by the Cholesky decomposition in lines 6 and 10 and the forward and
backward substitutions in line 7 with total complexity O((C + 1)n3) (times the number of Newton iterations), all other operations are at most O(Cn2) when exploiting
diagonal and block diagonal structures. The memory requirement is O(Cn2). For
comments on convergence criteria for line 15 and avoiding divergence, refer to the
caption of Algorithm 3.1 on page 46.
We now need to consider the predictive distribution q(π∗|y) which is obtained by softmaxing the Gaussian q(f∗|y). In the binary case we saw that the
predicted classiﬁcation could be obtained by thresholding the mean value of the
Gaussian. In the multi-class case one does need to take the variability around
the mean into account as it can aﬀect the overall classiﬁcation (see exercise
One simple way (which will be used in Algorithm 3.4) to estimate
the mean prediction Eq[π∗|y] is to draw samples from the Gaussian q(f∗|y),
softmax them and then average.
The Laplace approximation to the marginal likelihood can be obtained in
marginal likelihood
the same way as for the binary case, yielding
log p(y|X, θ) ≃log q(y|X, θ)
2ˆf ⊤K−1ˆf + y⊤ˆf −
2 log |ICn + W
As for the inversion of K−1 + W, the determinant term can be computed eﬃciently by exploiting the structure of W, see section 3.5.1.
In this section we have described the Laplace approximation for multi-class
classiﬁcation. However, there has also been some work on EP-type methods for
the multi-class case, see Seeger and Jordan .
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.5 Multi-class Laplace Approximation
input: K (covariance matrix), ˆf (posterior mode), x∗(test input)
2: compute π and Π from ˆf
using eq. (3.34) and defn. of Π under eq. (3.38)
for c := 1 . . . C do
L := cholesky(In + D
2c L⊤\(L\D
E is block diag. D
2 (ICn + D
6: end for
M := cholesky(P
8: for c := 1 . . . C do
∗:= (yc −πc)⊤kc
latent test mean from eq. (3.41)
c := Ec(R(M ⊤\(M\(R⊤b))))
for c′ := 1 . . . C do
Σcc′ := c⊤kc′
latent test covariance from eq. (3.43)
Σcc := Σcc + kc(x∗, x∗) −b⊤kc
16: end for
initialize Monte Carlo loop to estimate
18: for i := 1 : S do
predictive class probabilities using S samples
f∗∼N(µ∗, Σ)
sample latent values from joint Gaussian posterior
π∗:= π∗+ exp(f c
c′ exp(f c′
accumulate probability eq. (3.34)
22: ¯π∗:= π∗/S
normalize MC estimate of prediction vector
return: Eq(f)[π(f(x∗))|x∗, X, y] := ¯π∗(predicted class probability vector)
Algorithm 3.4: Predictions for multi-class Laplace GPC, where D = diag(π), R is
a matrix of stacked identity matrices and a subscript c on a block diagonal matrix
indicates the n × n submatrix pertaining to class c. The computational complexity
is dominated by the Cholesky decomposition in lines 4 and 7 with a total complexity
O((C + 1)n3), the memory requirement is O(Cn2). For multiple test cases repeat
from line 8 for each test case (in practice, for multiple test cases one may reorder the
computations in lines 8-16 to avoid referring to all Ec matrices repeatedly).
Implementation
The implementation follows closely the implementation for the binary case detailed in section 3.4.3, with the slight complications that K is now a block
diagonal matrix of size Cn × Cn and the W matrix is no longer diagonal, see
eq. (3.38). Care has to be taken to exploit the structure of these matrices to
reduce the computational burden.
The Newton iteration from eq. (3.39) requires the inversion of K−1 + W,
which we ﬁrst re-write as
(K−1 + W)−1 = K −K(K + W −1)−1K,
using the matrix inversion lemma, eq. (A.9). In the following the inversion of
the above matrix K + W −1 is our main concern. First, however, we apply the
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
matrix inversion lemma, eq. (A.9) to the W matrix:12
W −1 = (D −ΠΠ⊤)−1 = D−1 −R(I −R⊤DR)−1R⊤
= D−1 −RO−1R⊤,
where D = diag(π), R = D−1Π is a Cn × n matrix of stacked In unit matrices,
we use the fact that π normalizes over classes: R⊤DR = P
c Dc = In and O is
the zero matrix. Introducing the above in K + W −1 and applying the matrix
inversion lemma, eq. (A.9) again we have
(K + W −1)−1 = (K + D−1 −RO−1R⊤)−1
= E −ER(O + R⊤ER)−1R⊤E = E −ER(P
c Ec)−1R⊤E.
where E = (K + D−1)−1 = D
2 is a block diagonal matrix
and R⊤ER = P
c Ec. The Newton iterations can now be computed by inserting
eq. (3.47) and (3.45) in eq. (3.39), as detailed in Algorithm 3.3. The predictions
use an equivalent route to compute the Gaussian posterior, and the ﬁnal step
of deriving predictive class probabilities is done by Monte Carlo, as shown in
Algorithm 3.4.
Expectation Propagation
The expectation propagation (EP) algorithm [Minka, 2001] is a general approximation tool with a wide range of applications. In this section we present only its
application to the speciﬁc case of a GP model for binary classiﬁcation. We note
that Opper and Winther presented a similar method for binary GPC
based on the ﬁxed-point equations of the Thouless-Anderson-Palmer (TAP)
type of mean-ﬁeld approximation from statistical physics. The ﬁxed points for
the two methods are the same, although the precise details of the two algorithms
are diﬀerent. The EP algorithm naturally lends itself to sparse approximations,
which will not be discussed in detail here, but touched upon in section 8.4.
The object of central importance is the posterior distribution over the latent
variables, p(f|X, y). In the following notation we suppress the explicit dependence on hyperparameters, see section 3.6.2 for their treatment. The posterior
is given by Bayes’ rule, as the product of a normalization term, the prior and
the likelihood
p(f|X, y) =
where the prior p(f|X) is Gaussian and we have utilized the fact that the likelihood factorizes over the training cases. The normalization term is the marginal
likelihood
Z = p(y|X) =
p(yi|fi) df.
12Readers who are disturbed by our sloppy treatment of the inverse of singular matrices
are invited to insert the matrix (1 −ε)In between Π and Π⊤in eq. (3.46) and verify that
eq. (3.47) coincides with the limit ε →0.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.6 Expectation Propagation
So far, everything is exactly as in the regression case discussed in chapter 2.
However, in the case of classiﬁcation the likelihood p(yi|fi) is not Gaussian,
a property that was used heavily in arriving at analytical solutions for the
regression framework. In this section we use the probit likelihood (see page 35)
for binary classiﬁcation
p(yi|fi) = Φ(fiyi),
and this makes the posterior in eq. (3.48) analytically intractable. To overcome
this hurdle in the EP framework we approximate the likelihood by a local likelihood approximation13 in the form of an un-normalized Gaussian function in
the latent variable fi
p(yi|fi) ≃ti(fi| ˜Zi, ˜µi, ˜σ2
i ) ≜˜ZiN(fi|˜µi, ˜σ2
which deﬁnes the site parameters ˜Zi, ˜µi and ˜σ2
i . Remember that the notation
site parameters
N is used for a normalized Gaussian distribution. Notice that we are approximating the likelihood, i.e. a probability distribution which normalizes over the
targets yi, by an un-normalized Gaussian distribution over the latent variables
fi. This is reasonable, because we are interested in how the likelihood behaves
as a function of the latent fi. In the regression setting we utilized the Gaussian
shape of the likelihood, but more to the point, the Gaussian distribution for
the outputs yi also implied a Gaussian shape as a function of the latent variable fi. In order to compute the posterior we are of course primarily interested
in how the likelihood behaves as a function of fi.14
The property that the
likelihood should normalize over yi (for any value of fi) is not simultaneously
achievable with the desideratum of Gaussian dependence on fi; in the EP approximation we abandon exact normalization for tractability. The product of
the (independent) local likelihoods ti is
ti(fi| ˜Zi, ˜µi, ˜σ2
i ) = N(˜µ, ˜Σ)
where ˜µ is the vector of ˜µi and ˜Σ is diagonal with ˜Σii = ˜σ2
i . We approximate
the posterior p(f|X, y) by q(f|X, y)
q(f|X, y) ≜
ti(fi| ˜Zi, ˜µi, ˜σ2
i ) = N(µ, Σ),
with µ = Σ˜Σ−1 ˜µ,
and Σ = (K−1 + ˜Σ−1)−1,
where we have used eq. (A.7) to compute the product (and by deﬁnition, we
know that the distribution must normalize correctly over f). Notice, that we use
the tilde-parameters ˜µ and ˜Σ (and ˜Z) for the local likelihood approximations,
13Note, that although each likelihood approximation is local, the posterior approximation
produced by the EP algorithm is global because the latent variables are coupled through the
14However, for computing the marginal likelihood normalization becomes crucial, see section
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
and plain µ and Σ for the parameters of the approximate posterior. The normalizing term of eq. (3.53), ZEP = q(y|X), is the EP algorithm’s approximation
to the normalizing term Z from eq. (3.48) and eq. (3.49).
How do we choose the parameters of the local approximating distributions
ti? One of the most obvious ideas would be to minimize the Kullback-Leibler
(KL) divergence (see section A.5) between the posterior and its approximation:
KL divergence
 p(f|X, y)||q(f|X, y)
. Direct minimization of this KL divergence for the
joint distribution on f turns out to be intractable.
(One can alternatively
choose to minimize the reversed KL divergence KL
 q(f|X, y)||p(f|X, y)
respect to the distribution q(f|X, y); this has been used to carry out variational
inference for GPC, see, e.g. Seeger .)
Instead, the key idea in the EP algorithm is to update the individual ti approximations sequentially. Conceptually this is done by iterating the following
four steps: we start from some current approximate posterior, from which we
leave out the current ti, giving rise to a marginal cavity distribution. Secondly,
we combine the cavity distribution with the exact likelihood p(yi|fi) to get the
desired (non-Gaussian) marginal. Thirdly, we choose a Gaussian approximation
to the non-Gaussian marginal, and in the ﬁnal step we compute the ti which
makes the posterior have the desired marginal from step three. These four steps
are iterated until convergence.
In more detail, we optimize the ti approximations sequentially, using the
approximation so far for all the other variables. In particular the approximate
posterior for fi contains three kinds of terms:
1. the prior p(f|X)
2. the local approximate likelihoods tj for all cases j ̸= i
3. the exact likelihood for case i, p(yi|fi) = Φ(yifi)
Our goal is to combine these sources of information and choose parameters of ti
such that the marginal posterior is as accurate as possible. We will ﬁrst combine
the prior and the local likelihood approximations into the cavity distribution
tj(fj| ˜Zj, ˜µj, ˜σ2
and subsequently combine this with the exact likelihood for case i. Conceptually, one can think of the combination of prior and the n −1 approximate
likelihoods in eq. (3.54) in two ways, either by explicitly multiplying out the
terms, or (equivalently) by removing approximate likelihood i from the approximate posterior in eq. (3.53). Here we will follow the latter approach. The
marginal for fi from q(f|X, y) is obtained by using eq. (A.6) in eq. (3.53) to
q(fi|X, y) = N(fi|µi, σ2
This marginal eq. (3.55) contains one approximate term
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.6 Expectation Propagation
(namely ti) “too many”, so we need to divide it by ti to get the cavity discavity distribution
q−i(fi) ≜N(fi|µ−i, σ2
where µ−i = σ2
Note that the cavity distribution and its parameters carry the subscript −i,
indicating that they include all cases except number i.
The easiest way to
verify eq. (3.56) is to multiply the cavity distribution by the local likelihood
approximation ti from eq. (3.51) using eq. (A.7) to recover the marginal in
eq. (3.55). Notice that despite the appearance of eq. (3.56), the cavity mean
and variance are (of course) not dependent on ˜µi and ˜σ2
i , see exercise 3.10.5.
To proceed, we need to ﬁnd the new (un-normalized) Gaussian marginal
which best approximates the product of the cavity distribution and the exact
likelihood
ˆq(fi) ≜ˆZiN(ˆµi, ˆσ2
i ) ≃q−i(fi)p(yi|fi).
It is well known that when q(x) is Gaussian, the distribution q(x) which minimizes KL
 p(x)||q(x)
is the one whose ﬁrst and second moments match that
of p(x), see eq. (A.24). As ˆq(fi) is un-normalized we choose additionally to
impose the condition that the zero-th moments (normalizing constants) should
match when choosing the parameters of ˆq(fi) to match the right hand side of
eq. (3.57). This process is illustrated in Figure 3.4.
The derivation of the moments is somewhat lengthy, so we have moved the
details to section 3.9. The desired posterior marginal moments are
ˆZi = Φ(zi),
ˆµi = µ−i +
zi + N(zi)
The ﬁnal step is to compute the parameters of the approximation ti which
achieves a match with the desired moments. In particular, the product of the
cavity distribution and the local approximation must have the desired moments,
leading to
2(µ−i −˜µi)2/(σ2
which is easily veriﬁed by multiplying the cavity distribution by the local approximation using eq. (A.7) to obtain eq. (3.58). Note that the desired marginal
posterior variance ˆσ2
i given by eq. (3.58) is guaranteed to be smaller than the
cavity variance, such that ˜σ2
i > 0 is always satisﬁed.15
This completes the update for a local likelihood approximation ti. We then
have to update the approximate posterior using eq. (3.53), but since only a
15In cases where the likelihood is log concave, one can show that ˜σ2
i > 0, but for a general
likelihood there may be no such guarantee.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
likelihood
approximation
Figure 3.4: Approximating a single likelihood term by a Gaussian. Panel (a) dashdotted: the exact likelihood, Φ(fi) (the corresponding target being yi = 1) as a
function of the latent fi, dotted: Gaussian cavity distribution N(fi|µ−i =1, σ2
solid: posterior, dashed: posterior approximation. Panel (b) shows an enlargement of
panel (a).
single site has changed one can do this with a computationally eﬃcient rankone update, see section 3.6.3. The EP algorithm is used iteratively, updating
each local approximation in turn. It is clear that several passes over the data
are required, since an update of one local approximation potentially inﬂuences
all of the approximate marginal posteriors.
Predictions
The procedure for making predictions in the EP framework closely resembles
the algorithm for the Laplace approximation in section 3.4.2. EP gives a Gaussian approximation to the posterior distribution, eq. (3.53). The approximate
predictive mean for the latent variable f∗becomes
Eq[f∗|X, y, x∗] = k⊤
∗K−1µ = k⊤
∗K−1(K−1 + ˜Σ−1)−1 ˜Σ−1 ˜µ
∗(K + ˜Σ)−1 ˜µ.
The approximate latent predictive variance is analogous to the derivation from
eq. (3.23) and eq. (3.24), with ˜Σ playing the rˆole of W
Vq[f∗|X, y, x∗] = k(x∗, x∗) −k⊤
∗(K + ˜Σ)−1k∗.
The approximate predictive distribution for the binary target becomes
q(y∗= 1|X, y, x∗) = Eq[π∗|X, y, x∗] =
Φ(f∗)q(f∗|X, y, x∗) df∗,
where q(f∗|X, y, x∗) is the approximate latent predictive Gaussian with mean
and variance given by eq. (3.60) and eq. (3.61). This integral is readily evaluated
using eq. (3.80), giving the predictive probability
q(y∗= 1|X, y, x∗) = Φ
∗(K + ˜Σ)−1 ˜µ
1 + k(x∗, x∗) −k⊤
∗(K + ˜Σ)−1k∗
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.6 Expectation Propagation
Marginal Likelihood
The EP approximation to the marginal likelihood can be found from the normalization of eq. (3.53)
ZEP = q(y|X) =
ti(fi| ˜Zi, ˜µi, ˜σ2
Using eq. (A.7) and eq. (A.8) in an analogous way to the treatment of the
regression setting in equations (2.28) and (2.30) we arrive at
log(ZEP|θ) = −1
2 log |K + ˜Σ| −1
2 ˜µ⊤(K + ˜Σ)−1 ˜µ
(µ−i −˜µi)2
where θ denotes the hyperparameters of the covariance function. This expression has a nice intuitive interpretation: the ﬁrst two terms are the marginal
likelihood for a regression model for ˜µ, each component of which has independent Gaussian noise of variance ˜Σii (as ˜Σ is diagonal), cf. eq. (2.30). The
remaining three terms come from the normalization constants ˜Zi. The ﬁrst
of these penalizes the cavity (or leave-one-out) distributions for not agreeing
with the classiﬁcation labels, see eq. (3.82). In other words, we can see that
the marginal likelihood combines two desiderata, (1) the means of the local
likelihood approximations should be well predicted by a GP, and (2) the corresponding latent function, when ignoring a particular training example, should
be able to predict the corresponding classiﬁcation label well.
Implementation
The implementation for the EP algorithm follows the derivation in the previous
section closely, except that care has to be taken to achieve numerical stability,
in similar ways to the considerations for Laplace’s method in section 3.4.3.
In addition, we wish to be able to speciﬁcally handle the case were some site
variances ˜σ2
i may tend to inﬁnity; this corresponds to ignoring the corresponding
likelihood terms, and can form the basis of sparse approximations, touched upon
in section 8.4. In this limit, everything remains well-deﬁned, although this is
not obvious e.g. from looking at eq. (3.65). It turns out to be slightly more
convenient to use natural parameters ˜τi, ˜νi and τ−i, ν−i for the site and cavity
natural parameters
parameters
˜τi = ˜σ−2
˜S = diag(˜τ),
˜ν = ˜S ˜µ,
ν−i = τ−iµ−i (3.66)
rather than ˜σ2
i , ˜µi and σ2
−i, µ−i themselves. The symmetric matrix of central
importance is
B = I + ˜S
which plays a rˆole equivalent to eq. (3.26). Expressions involving the inverse of
B are computed via Cholesky factorization, which is numerically stable since
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
input: K (covariance matrix), y (±1 targets)
2: ˜ν := 0, ˜τ := 0, Σ := K, µ := 0
initialization and eq. (3.53)
for i := 1 to n do
τ−i := σ−2
compute approximate cavity para-
ν−i := σ−2
meters ν−i and τ−i using eq. (3.56)
compute the marginal moments ˆµi and ˆσ2
using eq. (3.58)
∆˜τ := ˆσ−2
−τ−i −˜τi and ˜τi := ˜τi + ∆˜τ
update site parameters
˜νi := ˆσ−2
˜τi and ˜νi using eq. (3.59)
 (∆˜τ)−1 + Σii
update Σ and µ by eq. (3.70) and
eq. (3.53). si is column i of Σ
L := cholesky(In + ˜S
re-compute the approximate
V := L⊤\ ˜S
posterior parameters Σ and µ
Σ := K −V ⊤V and µ := Σ˜ν
using eq. (3.53) and eq. (3.68)
16: until convergence
compute log ZEP
using eq. (3.65), (3.73) and (3.74) and the existing L
18: return: ˜ν, ˜τ (natural site param.), log ZEP (approx. log marg. likelihood)
Algorithm 3.5: Expectation Propagation for binary classiﬁcation. The targets y are
used only in line 7. In lines 13-15 the parameters of the approximate posterior are
re-computed (although they already exist); this is done because of the large number of
rank-one updates in line 10 which would eventually cause loss of numerical precision
in Σ. The computational complexity is dominated by the rank-one updates in line
10, which takes O(n2) per variable, i.e. O(n3) for an entire sweep over all variables.
Similarly re-computing Σ in lines 13-15 is O(n3).
the eigenvalues of B are bounded below by one. The parameters of the Gaussian
approximate posterior from eq. (3.53) are computed as
Σ = (K−1 + ˜S)−1 = K −K(K + ˜S−1)−1K = K −K ˜S
2 K. (3.68)
After updating the parameters of a site, we need to update the approximate
posterior eq. (3.53) taking the new site parameters into account. For the inverse
covariance matrix of the approximate posterior we have from eq. (3.53)
Σ−1 = K−1 + ˜S,
and thus Σ−1
new = K−1 + ˜Sold +(˜τ new
i , (3.69)
where ei is a unit vector in direction i, and we have used that ˜S = diag(˜τ).
Using the matrix inversion lemma eq. (A.9), on eq. (3.69) we obtain the new Σ
Σnew = Σold −
1 + (˜τ new
in time O(n2), where si is the i’th column of Σold. The posterior mean is then
calculated from eq. (3.53).
In the EP algorithm each site is updated in turn, and several passes over all
sites are required. Pseudocode for the EP-GPC algorithm is given in Algorithm
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.6 Expectation Propagation
input: ˜ν, ˜τ (natural site param.), X (inputs), y (±1 targets),
k (covariance function), x∗test input
2: L := cholesky(In + ˜S
B = In + ˜S
2 L⊤\(L\( ˜S
4: ¯f∗:= k(x∗)⊤(˜ν −z)
eq. (3.60) using eq. (3.71)
6: V[f∗] := k(x∗, x∗) −v⊤v
eq. (3.61) using eq. (3.72)
¯π∗:= Φ( ¯f∗/
1 + V[f∗])
eq. (3.63)
8: return: ¯π∗(predictive class probability (for class 1))
Algorithm 3.6: Predictions for expectation propagation. The natural site parameters
˜ν and ˜τ of the posterior (which can be computed using algorithm 3.5) are input. For
multiple test inputs lines 4-7 are applied to each test input. Computational complexity
is n3/6 + n2 operations once (line 2 and 3) plus n2 operations per test case (line
5), although the Cholesky decomposition in line 2 could be avoided by storing it in
Algorithm 3.5. Note the close similarity to Algorithm 3.2 on page 47.
There is no formal guarantee of convergence, but several authors have
reported that EP for Gaussian process models works relatively well.16
For the predictive distribution, we get the mean from eq. (3.60) which is
evaluated using
Eq[f∗|X, y, x∗] = k⊤
∗(K + ˜S−1)−1 ˜S−1˜ν = k⊤
 I −(K + ˜S−1)−1K
and the predictive variance from eq. (3.61) similarly by
Vq[f∗|X, y, x∗] = k(x∗, x∗) −k⊤
∗(K + ˜S−1)−1k∗
= k(x∗, x∗) −k⊤
Pseudocode for making predictions using EP is given in Algorithm 3.6.
Finally, we need to evaluate the approximate log marginal likelihood from
eq. (3.65). There are several terms which need careful consideration, principally
due to the fact the ˜τi values may be arbitrarily small (and cannot safely be
inverted). We start with the fourth and ﬁrst terms of eq. (3.65)
2 log |T −1+ ˜S−1| −1
2 log |K+ ˜Σ| =
2 log | ˜S−1(I+ ˜ST −1)| −1
2 log | ˜S−1B|
log(1+˜τiτ −1
where T is a diagonal matrix of cavity precisions Tii = τ−i = σ−2
−i and L is the
Cholesky factorization of B. In eq. (3.73) we have factored out the matrix ˜S−1
from both determinants, and the terms cancel. Continuing with the part of the
16It has been conjectured (but not proven) by L. Csat´o (personal communication) that EP
is guaranteed to converge if the likelihood is log concave.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
ﬁfth term from eq. (3.65) which is quadratic in ˜µ together with the second term
2 ˜µ⊤(T −1 + ˜S−1)−1 ˜µ −1
2 ˜µ⊤(K + ˜Σ)−1 ˜µ
2 ˜ν⊤˜S−1 (T −1 + ˜S−1)−1 −(K + ˜S−1)−1 ˜S−1˜ν
2 ˜ν⊤ (K−1 + ˜S)−1 −(T + ˜S)−1˜ν
2 ˜ν⊤ K −K ˜S
2 K −(T + ˜S)−1˜ν,
where in eq. (3.74) we apply the matrix inversion lemma eq. (A.9) to both
parenthesis to be inverted.
The remainder of the ﬁfth term in eq. (3.65) is
evaluated using the identity
−i(T −1 + ˜S−1)−1(µ−i −2˜µ) =
−iT( ˜S + T)−1( ˜Sµ−i −2˜ν),
where µ−i is the vector of cavity means µ−i.
The third term in eq. (3.65)
requires in no special treatment and can be evaluated as written.
Experiments
In this section we present the results of applying the algorithms for GP classiﬁcation discussed in the previous sections to several data sets. The purpose
is ﬁrstly to illustrate the behaviour of the methods and secondly to gain some
insights into how good the performance is compared to some other commonlyused machine learning methods for classiﬁcation.
Section 3.7.1 illustrates the action of a GP classiﬁer on a toy binary prediction problem with a 2-d input space, and shows the eﬀect of varying the
length-scale ℓin the SE covariance function. In section 3.7.2 we illustrate and
compare the behaviour of the two approximate GP methods on a simple onedimensional binary task. In section 3.7.3 we present results for a binary GP
classiﬁer on a handwritten digit classiﬁcation task, and study the eﬀect of varying the kernel parameters. In section 3.7.4 we carry out a similar study using
a multi-class GP classiﬁer to classify digits from all ten classes 0-9. In section
3.8 we discuss the methods from both experimental and theoretical viewpoints.
A Toy Problem
Figure 3.5 illustrates the operation of a Gaussian process classiﬁer on a binary
problem using the squared exponential kernel with a variable length-scale and
the logistic response function. The Laplace approximation was used to make
the plots. The data points lie within the square 2, as shown in panel (a).
Notice in particular the lone white point amongst the black points in the NE
corner, and the lone black point amongst the white points in the SW corner.
In panel (b) the length-scale is ℓ= 0.1, a relatively short value. In this case
the latent function is free to vary relatively quickly and so the classiﬁcations
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.7 Experiments
Figure 3.5: Panel (a) shows the location of the data points in the two-dimensional
space 2. The two classes are labelled as open circles (+1) and closed circles (-
1). Panels (b)-(d) show contour plots of the predictive probability Eq[π(x∗)|y] for
signal variance σ2
f = 9 and length-scales ℓof 0.1, 0.2 and 0.3 respectively. The decision boundaries between the two classes are shown by the thicker black lines. The
maximum value attained is 0.84, and the minimum is 0.19.
provided by thresholding the predictive probability Eq[π(x∗)|y] at 0.5 agrees
with the training labels at all data points. In contrast, in panel (d) the lengthscale is set to ℓ= 0.3. Now the latent function must vary more smoothly, and
so the two lone points are misclassiﬁed. Panel (c) was obtained with ℓ= 0.2.
As would be expected, the decision boundaries are more complex for shorter
length-scales. Methods for setting the hyperparameters based on the data are
discussed in chapter 5.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
predictive probability, π*
latent function, f(x)
Figure 3.6: One-dimensional toy classiﬁcation dataset: Panel (a) shows the dataset,
where points from class +1 have been plotted at π = 1 and class −1 at π = 0, together
with the predictive probability for Laplace’s method and the EP approximation. Also
shown is the probability p(y =+1|x) of the data generating process. Panel (b) shows
the corresponding distribution of the latent function f(x), showing curves for the
mean, and ±2 standard deviations, corresponding to 95% conﬁdence regions.
One-dimensional Example
Although Laplace’s method and the EP approximation often give similar results, we here present a simple one-dimensional problem which highlights some
of the diﬀerences between the methods.
The data, shown in Figure 3.6(a),
consists of 60 data points in three groups, generated from a mixture of three
Gaussians, centered on −6 (20 points), 0 (30 points) and 2 (10 points), where
the middle component has label −1 and the two other components label +1; all
components have standard deviation 0.8; thus the two left-most components
are well separated, whereas the two right-most components overlap.
Both approximation methods are shown with the same value of the hyperparameters, ℓ= 2.6 and σf = 7.0, chosen to maximize the approximate marginal
likelihood for Laplace’s method. Notice in Figure 3.6 that there is a considerable diﬀerence in the value of the predictive probability for negative inputs.
The Laplace approximation seems overly cautious, given the very clear separation of the data. This eﬀect can be explained as a consequence of the intuition
that the inﬂuence of “well-explained data points” is eﬀectively reduced, see the
discussion around eq. (3.19). Because the points in the left hand cluster are
relatively well-explained by the model, they don’t contribute as strongly to the
posterior, and thus the predictive probability never gets very close to 1. Notice
in Figure 3.6(b) the 95% conﬁdence region for the latent function for Laplace’s
method actually includes functions that are negative at x = −6, which does
not seem appropriate. For the positive examples centered around x = 2 on the
right-hand side of Figure 3.6(b), this eﬀect is not visible, because the points
around the transition between the classes at x=1 are not so “well-explained”;
this is because the points near the boundary are competing against the points
from the other class, attempting to pull the latent function in opposite directions. Consequently, the datapoints in this region all contribute strongly.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.7 Experiments
Another sign of this eﬀect is that the uncertainty in the latent function, which
is closely related to the “eﬀective” local density of the data, is very small in
the region around x = 1; the small uncertainty reveals a high eﬀective density,
which is caused by all data points in the region contributing with full weight. It
should be emphasized that the example was artiﬁcially constructed speciﬁcally
to highlight this eﬀect.
Finally, Figure 3.6 also shows clearly the eﬀects of uncertainty in the latent
function on Eq[π∗|y]. In the region between x = 2 to x = 4, the latent mean
in panel (b) increases slightly, but the predictive probability decreases in this
region in panel (a). This is caused by the increase in uncertainty for the latent
function; when the widely varying functions are squashed through the nonlinearity it is possible for both classes to get high probability, and the average
prediction becomes less extreme.
Binary Handwritten Digit Classiﬁcation Example
Handwritten digit and character recognition are popular real-world tasks for
testing and benchmarking classiﬁers, with obvious application e.g. in postal
services. In this section we consider the discrimination of images of the digit
3 from images of the digit 5 as an example of binary classiﬁcation; the speciﬁc
choice was guided by the experience that this is probably one of the most
diﬃcult binary subtasks. 10-class classiﬁcation of the digits 0-9 is described in
the following section.
We use the US Postal Service (USPS) database of handwritten digits which
USPS dataset
consists of 9298 segmented 16 × 16 greyscale images normalized so that the
intensity of the pixels lies in [−1, 1]. The data was originally split into a training
set of 7291 cases and a testset of the remaining 2007 cases, and has often been
used in this conﬁguration. Unfortunately, the data in the two partitions was
collected in slightly diﬀerent ways, such that the data in the two sets did not
stem from the same distribution.17 Since the basic underlying assumption for
most machine learning algorithms is that the distribution of the training and
test data should be identical, the original data partitions are not really suitable
as a test bed for learning algorithms, the interpretation of the results being
hampered by the change in distribution. Secondly, the original test set was
rather small, sometimes making it diﬃcult to diﬀerentiate the performance of
diﬀerent algorithms. To overcome these two problems, we decided to pool the
USPS repartitioned
two partitions and randomly split the data into two identically sized partitions
of 4649 cases each. A side-eﬀect is that it is not trivial to compare to results
obtained using the original partitions. All experiments reported here use the
repartitioned data. The binary 3s vs. 5s data has 767 training cases, divided
406/361 on 3s vs. 5s, while the test set has 773 cases split 418/355.
We present results of both Laplace’s method and EP using identical exsquared exponential
covariance function
perimental setups.
The squared exponential covariance function k(x, x′) =
17It is well known e.g. that the original test partition had more diﬃcult cases than the
training set.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
log lengthscale, log(l)
log magnitude, log(σf)
Log marginal likelihood
log lengthscale, log(l)
log magnitude, log(σf)
Information about test targets in bits
latent means, f
Training set latent means
latent means, f
Test set latent means
log lengthscale, log(l)
log magnitude, log(σf)
Number of test misclassifications
Figure 3.7: Binary Laplace approximation: 3s vs. 5s discrimination using the USPS
data. Panel (a) shows a contour plot of the log marginal likelihood as a function of
log(ℓ) and log(σf). The marginal likelihood has an optimum at log(ℓ) = 2.85 and
log(σf) = 2.35, with an optimum value of log p(y|X, θ) = −99. Panel (b) shows a
contour plot of the amount of information (in excess of a simple base-line model, see
text) about the test cases in bits as a function of the same variables. The statistical
uncertainty (because of the ﬁnite number of test cases) is about ±0.03 bits (95%
conﬁdence interval). Panel (c) shows a histogram of the latent means for the training
and test sets respectively at the values of the hyperparameters with optimal marginal
likelihood (from panel (a)). Panel (d) shows the number of test errors (out of 773)
when predicting using the sign of the latent mean.
f exp(−|x −x′|2/2ℓ2) was used, so there are two free parameters, namely σf
(the process standard deviation, which controls its vertical scaling), and the
length-scale ℓ(which controls the input length-scale). Let θ = (log(ℓ), log(σf))
hyperparameters
denote the vector of hyperparameters. We ﬁrst present the results of Laplace’s
method in Figure 3.7 and discuss these at some length. We then brieﬂy compare
these with the results of the EP method in Figure 3.8.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.7 Experiments
log lengthscale, log(l)
log magnitude, log(σf)
Log marginal likelihood
log lengthscale, log(l)
log magnitude, log(σf)
Information about test targets in bits
latent means, f
Training set latent means
latent means, f
Test set latent means
log lengthscale, log(l)
log magnitude, log(σf)
Number of test misclassifications
Figure 3.8: The EP algorithm on 3s vs. 5s digit discrimination task from the USPS
data. Panel (a) shows a contour plot of the log marginal likelihood as a function of
the hyperparameters log(ℓ) and log(σf). The marginal likelihood has an optimum
at log(ℓ) = 2.6 at the maximum value of log(σf), but the log marginal likelihood is
essentially ﬂat as a function of log(σf) in this region, so a good point is at log(σf) =
4.1, where the log marginal likelihood has a value of −90. Panel (b) shows a contour
plot of the amount of information (in excess of the baseline model) about the test cases
in bits as a function of the same variables. Zero bits corresponds to no information
and one bit to perfect binary generalization. The 773 test cases allows the information
to be determined within ±0.035 bits. Panel (c) shows a histogram of the latent means
for the training and test sets respectively at the values of the hyperparameters with
optimal marginal likelihood (from panel a). Panel (d) shows the number of test errors
(out of 773) when predicting using the sign of the latent mean.
In Figure 3.7(a) we show a contour plot of the approximate log marginal
Laplace results
likelihood (LML) log q(y|X, θ) as a function of log(ℓ) and log(σf), obtained
from runs on a grid of 17 evenly-spaced values of log(ℓ) and 23 evenly-spaced
values of log(σf). Notice that there is a maximum of the marginal likelihood
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
near log(ℓ) = 2.85 and log(σf) = 2.35. As will be explained in chapter 5, we
would expect that hyperparameters that yield a high marginal likelihood would
give rise to good predictions. Notice that an increase of 1 unit on the log scale
means that the probability is 2.7 times larger, so the marginal likelihood in
Figure 3.7(a) is fairly well peaked.
There are at least two ways we can measure the quality of predictions at the
test points. The ﬁrst is the test log predictive probability log2 p(y∗|x∗, D, θ).
test log predictive
probability
In Figure 3.7(b) we plot the average over the test set of the test log predictive
probability for the same range of hyperparameters.
We express this as the
amount of information in bits about the targets, by using log to the base 2.
Further, we oﬀ-set the value by subtracting the amount of information that a
simple base-line method would achieve. As a base-line model we use the best
base-line method
possible model which does not use the inputs; in this case, this model would
just produce a predictive distribution reﬂecting the frequency of the two classes
in the training set, i.e.
−418/773 log2(406/767) −355/773 log2(361/767) = 0.9956 bits,
essentially 1 bit. (If the classes had been perfectly balanced, and the training
and test partitions also exactly balanced, we would arrive at exactly 1 bit.)
Thus, our scaled information score used in Figure 3.7(b) would be zero for a
method that did random guessing and 1 bit for a method which did perfect
classiﬁcation (with complete conﬁdence). The information score measures how
interpretation of
information score
much information the model was able to extract from the inputs about the
identity of the output. Note that this is not the mutual information between
the model output and the test targets, but rather the Kullback-Leibler (KL)
divergence between them. Figure 3.7 shows that there is a good qualitative
agreement between the marginal likelihood and the test information, compare
panels (a) and (b).
The second (and perhaps most commonly used) method for measuring the
quality of the predictions is to compute the number of test errors made when
error rate
using the predictions. This is done by computing Eq[π∗|y] (see eq. (3.25)) for
each test point, thresholding at 1/2 to get “hard” predictions and counting the
number of errors. Figure 3.7(d) shows the number of errors produced for each
entry in the 17 × 23 grid of values for the hyperparameters. The general trend
in this table is that the number of errors is lowest in the top left-hand corner
and increases as one moves right and downwards. The number of errors rises
dramatically in the far bottom righthand corner. However, note in general that
the number of errors is quite small (there are 773 cases in the test set).
The qualitative diﬀerences between the two evaluation criteria depicted in
Figure 3.7 panels (b) and (d) may at ﬁrst sight seem alarming. And although
panels (a) and (b) show similar trends, one may worry about using (a) to select
the hyperparameters, if one is interested in minimizing the test misclassiﬁcation
rate. Indeed a full understanding of all aspects of these plots is quite involved,
but as the following discussion suggests, we can explain the major trends.
First, bear in mind that the eﬀect of increasing ℓis to make the kernel
function broader, so we might expect to observe eﬀects like those in Figure 3.5
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.7 Experiments
where large widths give rise to a lack of ﬂexibility. Keeping ℓconstant, the
eﬀect of increasing σf is to increase the magnitude of the values obtained for
ˆf. By itself this would lead to “harder” predictions (i.e. predictive probabilities
closer to 0 or 1), but we have to bear in mind that the variances associated
will also increase and this increased uncertainty for the latent variables tends
to “soften” the predictive probabilities, i.e. move them closer to 1/2.
The most marked diﬀerence between Figure 3.7(b) and (d) is the behaviour
in the the top left corner, where classiﬁcation error rate remains small, but
the test information and marginal likelihood are both poor. In the left hand
side of the plots, the length scale ℓis very short. This causes most points to
be deemed “far away” from most other points. In this regime the prediction
is dominated by the class-label of the nearest neighbours, and for the task at
hand, this happens to give a low misclassiﬁcation rate. In this parameter region
the test latent variables f∗are very close to zero, corresponding to probabilities
very close to 1/2. Consequently, the predictive probabilities carry almost no
information about the targets. In the top left corner, the predictive probabilities
for all 773 test cases lie in the interval [0.48, 0.53]. Notice that a large amount
of information implies a high degree of correct classiﬁcation, but not vice versa.
At the optimal marginal likelihood values of the hyperparameters, there are 21
misclassiﬁcations, which is slightly higher that the minimum number attained
which is 15 errors.
In exercise 3.10.6 readers are encouraged to investigate further the behaviour
of ˆf and the predictive probabilities etc. as functions of log(ℓ) and log(σf) for
themselves.
In Figure 3.8 we show the results on the same experiment, using the EP
EP results
method. The ﬁndings are qualitatively similar, but there are signiﬁcant differences. In panel (a) the approximate log marginal likelihood has a diﬀerent
shape than for Laplace’s method, and the maximum of the log marginal likelihood is about 9 units on a natural log scale larger (i.e. the marginal probability
is exp(9) ≃8000 times higher). Also note that the marginal likelihood has a
ridge (for log ℓ= 2.6) that extends into large values of log σf. For these very
large latent amplitudes (see also panel (c)) the probit likelihood function is well
approximated by a step function (since it transitions from low to high values
in the domain [−3, 3]). Once we are in this regime, it is of course irrelevant
exactly how large the magnitude is, thus the ridge. Notice, however, that this
does not imply that the prediction will always be “hard”, since the variance of
the latent function also grows.
Figure 3.8 shows a good qualitative agreement between the approximate
log marginal likelihood and the test information, compare panels (a) and (b).
The best value of the test information is signiﬁcantly higher for EP than for
Laplace’s method.
The classiﬁcation error rates in panel (d) show a fairly
similar behaviour to that of Laplace’s method. In Figure 3.8(c) we show the
latent means for training and test cases.
These show a clear separation on
the training set, and much larger magnitudes than for Laplace’s method. The
absolute values of the entries in f∗are quite large, often well in excess of 50,
which may suggest very “hard” predictions (probabilities close to zero or one),
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
π* averaged
π* averaged
Figure 3.9: MAP vs. averaged predictions for the EP algorithm for the 3’s vs. 5’s
digit discrimination using the USPS data. The optimal values of the hyperparameters
from Figure 3.8(a) log(ℓ) = 2.6 and log(σf) = 4.1 are used. The MAP predictions
σ(Eq[f∗|y]) are “hard”, mostly being very close to zero or one. On the other hand,
the averaged predictions Eq[π∗|y] from eq. (3.25) are a lot less extreme. In panel (a)
the 21 cases that were misclassiﬁed are indicated by crosses (correctly classiﬁed cases
are shown by points). Note that only 4 of the 21 misclassiﬁed points have conﬁdent
predictions (i.e. outside [0.1, 0.9]). Notice that all points fall in the triangles below
and above the horizontal line, conﬁrming that averaging does not change the “most
probable” class, and that it always makes the probabilities less extreme (i.e. closer to
1/2). Panel (b) shows histograms of averaged and MAP predictions, where we have
truncated values over 30.
since the sigmoid saturates for smaller arguments. However, when taking the
uncertainties in the latent variables into account, and computing the predictions
using averaging as in eq. (3.25) the predictive probabilities are “softened”. In
Figure 3.9 we can verify that the averaged predictive probabilities are much less
extreme than the MAP predictions.
In order to evaluate the performance of the two approximate methods for
GP classiﬁcation, we compared to a linear probit model, a support vector machine, a least-squares classiﬁer and a nearest neighbour approach, all of which
are commonly used in the machine learning community. In Figure 3.10 we show
error-reject curve
error-reject curves for both misclassiﬁcation rate and the test information measure. The error-reject curve shows how the performance develops as a function
of the fraction of test cases that is being rejected. To compute these, we ﬁrst
modify the methods that do not naturally produce probabilistic predictions to
do so, as described below. Based on the predictive probabilities, we reject test
cases for which the maximum predictive probability is smaller than a threshold.
Varying the threshold produces the error-reject curve.
The GP classiﬁers applied in Figure 3.10 used the hyperparameters which
optimized the approximate marginal likelihood for each of the two methods.
For the GP classiﬁers there were two free parameters σf and ℓ. The linear probit model (linear logistic models are probably more common, but we chose the
linear probit model
probit here, since the other likelihood based methods all used probit) can be
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.7 Experiments
rejection rate
misclassification rate
lin probit
rejection rate
test information, bits
lin probit
Figure 3.10: Panel (a) shows the error-reject curve and panel (b) the amount of
information about the test cases as a function of the rejection rate. The probabilistic
one nearest neighbour (P1NN) method has much worse performance than the other
methods. Gaussian processes with EP behaves similarly to SVM’s although the classiﬁcation rate for SVM for low rejection rates seems to be a little better. Laplace’s
method is worse than EP and SVM. The GP least squares classiﬁer (LSC) described
in section 6.5 performs the best.
implemented as GP model using Laplace’s method, which is equivalent to (although not computationally as eﬃcient as) iteratively reweighted least squares
(IRLS). The covariance function k(x, x′) = θ2x⊤x′ has a single hyperparameter, θ, which was set by maximizing the log marginal likelihood. This gives
log p(y|X, θ) = −105, at θ = 2.0, thus the marginal likelihood for the linear
covariance function is about 6 units on a natural log scale lower than the maximum log marginal likelihood for the Laplace approximation using the squared
exponential covariance function.
The support vector machine (SVM) classiﬁer (see section 6.4 for further desupport vector machine
tails on the SVM) used the same SE kernel as the GP classiﬁers. For the SVM
the rˆole of ℓis identical, and the trade-oﬀparameter C in the SVM formulation
(see eq. (6.37)) plays a similar rˆole to σ2
f. We carried out 5-fold cross validation
on a grid in parameter space to identify the best combination of parameters
w.r.t. the error rate; this turned out to be at C = 1, ℓ= 10.
Our experiments
were conducted using the SVMTorch software [Collobert and Bengio, 2001].
In order to compute probabilistic predictions, we squashed the test-activities
through a cumulative Gaussian, using the methods proposed by Platt :
we made a parameterized linear transformation of the test-activities and fed
this through the cumulative Gaussian.18 The parameters of the linear transformation were chosen to maximize the log predictive probability, evaluated on
the hold-out sets of the 5-fold cross validation.
The probabilistic one nearest neighbour (P1NN) method is a simple natprobabilistic
one nearest neighbour
ural extension to the classical one nearest neighbour method which provides
probabilistic predictions.
It computes the leave-one-out (LOO) one nearest
neighbour prediction on the training set, and records the fraction of cases π
where the LOO predictions were correct. On test cases, the method then pre-
18Platt used a logistic whereas we use a cumulative Gaussian.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
dicts the one nearest neighbour class with probability π, and the other class
with probability 1 −π. Rejections are based on thresholding on the distance to
the nearest neighbour.
The least-squares classiﬁer (LSC) is described in section 6.5. In order to
produce probabilistic predictions, the method of Platt was used (as described above for the SVM) using the predictive means only (the predictive
variances were ignored19), except that instead of the 5-fold cross validation,
leave-one-out cross-validation (LOO-CV) was used, and the kernel parameters
were also set using LOO-CV.
Figure 3.10 shows that the three best methods are the EP approximation for
GPC, the SVM and the least-squares classiﬁer (LSC). Presenting both the error
rates and the test information helps to highlight diﬀerences which may not be
apparent from a single plot alone. For example, Laplace’s method and EP seem
very similar on error rates, but quite diﬀerent in test information. Notice also,
that the error-reject curve itself reveals interesting diﬀerences, e.g. notice that
although the P1NN method has an error rate comparable to other methods at
zero rejections, things don’t improve very much when rejections are allowed.
Refer to section 3.8 for more discussion of the results.
10-class Handwritten Digit Classiﬁcation Example
We apply the multi-class Laplace approximation developed in section 3.5 to the
10-class handwritten digit classiﬁcation problem from the (repartitioned) USPS
dataset, having n = 4649 training cases and n∗= 4649 cases for testing, see
page 63. We used a squared exponential covariance function with two hyperparameters: a single signal amplitude σf, common to all 10 latent functions,
and a single length-scale parameter ℓ, common to all 10 latent functions and
common to all 256 input dimensions.
The behaviour of the method was investigated on a grid of values for the
hyperparameters, see Figure 3.11. Note that the correspondence between the
log marginal likelihood and the test information is not as close as for Laplace’s
method for binary classiﬁcation in Figure 3.7 on page 64. The maximum value
of the log marginal likelihood attained is -1018, and for the hyperparameters
corresponding to this point the error rate is 3.1% and the test information
2.67 bits. As with the binary classiﬁcation problem, the test information is
standardized by subtracting oﬀthe negative entropy (information) of the targets
which is −3.27 bits. The classiﬁcation error rate in Figure 3.11(c) shows a clear
minimum, and this is also attained at a shorter length-scale than where the
marginal likelihood and test information have their maxima. This eﬀect was
also seen in the experiments on binary classiﬁcation.
To gain some insight into the level of performance we compared these results with those obtained with the probabilistic one nearest neighbour method
P1NN, a multiple logistic regression model and a SVM. The P1NN ﬁrst uses an
19Of course, one could also have tried a variant where the full latent predictive distribution
was averaged over, but we did not do that here.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.7 Experiments
log lengthscale, log(l)
log magnitude, log(σf)
Log marginal likelihood
log lengthscale, log(l)
log magnitude, log(σf)
Information about the test targets in bits
log lengthscale, log(l)
log magnitude, log(σf)
Test set misclassification percentage
Figure 3.11:
10-way digit classiﬁcation using the Laplace approximation.
(a) shows the approximate log marginal likelihood, reaching a maximum value of
log p(y|X, θ) = −1018 at log ℓ= 2.35 and log σf = 2.6. In panel (b) information
about the test cases is shown. The maximum possible amount of information about
the test targets, corresponding to perfect classiﬁcation, would be 3.27 bits (the entropy
of the targets). At the point of maximum marginal likelihood, the test information is
2.67 bits. In panel (c) the test set misclassiﬁcation rate is shown in percent. At the
point of maximum marginal likelihood the test error rate is 3.1%.
internal leave-one-out assessment on the training set to estimate its probability of being correct, π. For the test set it then predicts the nearest neighbour
with probability π and all other classes with equal probability (1 −π)/9. We
obtained π = 0.967, a test information of 2.98 bits and a test set classiﬁcation
error rate of 3.0%.
We also compare to multiple linear logistic regression. One way to implement this method is to view it as a Gaussian process with a linear covariance
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
function, although it is equivalent and computationally more eﬃcient to do the
Laplace approximation over the “weights” of the linear model. In our case there
are 10×257 weights (256 inputs and one bias), whereas there are 10×4696 latent
function values in the GP. The linear covariance function k(x, x′) = θ2x⊤x′ has
a single hyperparameter θ (used for all 10 latent functions). Optimizing the log
marginal likelihood w.r.t. θ gives log p(y|X, θ) = −1339 at θ = 1.45. Using this
value for the hyperparameter, the test information is 2.95 bits and the test set
error rate is 5.7%.
Finally, a support vector machine (SVM) classiﬁer was trained using the
same SE kernel as the Gaussian process classiﬁers. (See section 6.4 for further
details on the SVM.) As in the binary SVM case there were two free parameters
ℓ(the length-scale of the kernel), and the trade-oﬀparameter C (see eq. (6.37)),
which plays a similar rˆole to σ2
f. We carried out 5-fold cross-validation on a grid
in parameter space to identify the best combination of parameters w.r.t. the
error rate; this turned out to be at C = 1, ℓ= 5.
Our experiments were
conducted using the SVMTorch software [Collobert and Bengio, 2001], which
implements multi-class SVM classiﬁcation using the one-versus-rest method described in section 6.5. The test set error rate for the SVM is 2.2%; we did not
attempt to evaluate the test information for the multi-class SVM.
Discussion
In the previous section we presented several sets of experiments comparing the
two approximate methods for inference in GPC models, and comparing them to
other commonly-used supervised learning methods. In this section we discuss
the results and attempt to relate them to the properties of the models.
For the binary examples from Figures 3.7 and 3.8, we saw that the two approximations showed quite diﬀerent qualitative behaviour of the approximated
log marginal likelihood, although the exact marginal likelihood is of course identical. The EP approximation gave a higher maximum value of the log marginal
likelihood (by about 9 units on the log scale) and the test information was
somewhat better than for Laplace’s method, although the test set error rates
were comparable. However, although this experiment seems to favour the EP
approximation, it is interesting to know how close these approximations are to
the exact (analytically intractable) solutions. In Figure 3.12 we show the results
Monte Carlo results
of running a sophisticated Markov chain Monte Carlo method called Annealed
Importance Sampling [Neal, 2001] carried out by Kuss and Rasmussen .
The USPS dataset for these experiments was identical to the one used in Figures 3.7 and 3.8, so the results are directly comparable. It is seen that the
MCMC results indicate that the EP method achieves a very high level of accuracy, i.e. that the diﬀerence between EP and Laplace’s method is caused almost
exclusively by approximation errors in Laplace’s method.
The main reason for the inaccuracy of Laplace’s method is that the high
dimensional posterior is skew, and that the symmetric approximation centered
on the mode is not characterizing the posterior volume very well. The posterior
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.8 Discussion
log lengthscale, log(l)
log magnitude, log(σf)
Log marginal likelihood
log lengthscale, log(l)
log magnitude, log(σf)
Information about test targets in bits
Figure 3.12:
The log marginal likelihood, panel (a), and test information, panel
(b), for the USPS 3’s vs. 5’s binary classiﬁcation task computed using Markov chain
Monte Carlo (MCMC). Comparing this to the Laplace approximation Figure 3.7 and
Figure 3.8 shows that the EP approximation is surprisingly accurate.
The slight
wiggliness of the contour lines are caused by ﬁnite sample eﬀects in the MCMC runs.
is a combination of the (correlated) Gaussian prior centered on the origin and
the likelihood terms which (softly) cut oﬀhalf-spaces which do not agree with
the training set labels. Therefore the posterior looks like a correlated Gaussian
restricted to the orthant which agrees with the labels. Its mode will be located
close to the origin in that orthant, and it will decrease rapidly in the direction
towards the origin due to conﬂicts from the likelihood terms, and decrease only
slowly in the opposite direction (because of the prior). Seen in this light it is
not surprising that the Laplace approximation is somewhat inaccurate. This
explanation is corroborated further by Kuss and Rasmussen .
It should be noted that all the methods compared on the binary digits classiﬁcation task except for the linear probit model are using the squared distance
between the digitized digit images measured directly in the image space as the
suitablility of the
covariance function
sole input to the algorithm. This distance measure is not very well suited for
the digit discrimination task—for example, two similar images that are slight
translations of each other may have a huge squared distance, although of course
identical labels. One of the strengths of the GP formalism is that one can use
prior distributions over (latent, in this case) functions, and do inference based
on these. If however, the prior over functions depends only on one particular aspect of the data (the squared distance in image space) which is not so well suited
for discrimination, then the prior used is also not very appropriate. It would be
more interesting to design covariance functions (parameterized by hyperparameters) which are more appropriate for the digit discrimination task, e.g. reﬂecting
on the known invariances in the images, such as the “tangent-distance” ideas
from Simard et al. ; see also Sch¨olkopf and Smola [2002, ch. 11] and section
9.10. The results shown here follow the common approach of using a generic
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
covariance function with a minimum of hyperparameters, but this doesn’t allow
us to incorporate much prior information about the problem. For an example
in the GP framework for doing inference about multiple hyperparameters with
more complex covariance functions which provide clearly interpretable information about the data, see the carbon dioxide modelling problem discussed on
Appendix: Moment Derivations
Consider the integral of a cumulative Gaussian, Φ, with respect to a Gaussian
N(x|µ, σ2) dx,
where Φ(x) =
initially for the special case v>0. Writing out in full, substituting z = y −x +
µ −m and w = x −µ and interchanging the order of the integrals
 −(z + w)2
or in matrix notation
i.e. an (incomplete) integral over a joint Gaussian. The inner integral corresponds to marginalizing over w (see eq. (A.6)), yielding
2π(v2 + σ2)
2(v2 + σ2)
which assumed v > 0. If v is negative, we can substitute the symmetry Φ(−z) =
1 −Φ(z) into eq. (3.77) to get
Zv<0 = 1 −Φ
Collecting the two cases, eq. (3.80) and eq. (3.81) we arrive at
N(x|µ, σ2) dx = Φ(z),
1 + σ2/v2 , (3.82)
for general v ̸= 0. We wish to compute the moments of
q(x) = Z−1Φ
N(x|µ, σ2),
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.10 Exercises
where Z is given in eq. (3.82). Perhaps the easiest way to do this is to diﬀerentiate w.r.t. µ on both sides of eq. (3.82)
N(x|µ, σ2) dx = ∂
N(x|µ, σ2) dx −µZ
1 + σ2/v2 ,
where we have used ∂Φ(z)/∂µ = N(z)∂z/∂µ. We recognize the ﬁrst term in
the integral in the top line of eq. (3.84) as Z/σ2 times the ﬁrst moment of q
which we are seeking. Multiplying through by σ2/Z and rearranging we obtain
ﬁrst moment
Eq[x] = µ +
1 + σ2/v2 .
Similarly, the second moment can be obtained by diﬀerentiating eq. (3.82) twice
N(x|µ, σ2) dx = −zN(z)
⇐⇒Eq[x2] = 2µEq[x] −µ2 + σ2 −
Φ(z)(v2 + σ2),
where the ﬁrst and second terms of the integral in the top line of eq. (3.86) are
multiples of the ﬁrst and second moments. The second central moment after
reintroducing eq. (3.85) into eq. (3.86) and simplifying is given by
second moment
(x−Eq[x])2
= Eq[x2]−Eq[x]2 = σ2−
(v2 + σ2)Φ(z)
1. For binary GPC, show the equivalence of using a noise-free latent process
combined with a probit likelihood and a latent process with Gaussian
noise combined with a step-function likelihood. Hint: introduce explicitly
additional noisy latent variables ˜fi, which diﬀer from fi by Gaussian noise.
Write down the step function likelihood for a single case as a function of
˜fi, integrate out the noisy variable, to arrive at the probit likelihood as a
function of the noise-free process.
2. Consider a multinomial random variable y having C states, with yc = 1 if
the variable is in state c, and 0 otherwise. State c occurs with probability
πc. Show that cov(y) = E[(y −π)(y −π)⊤] = diag(π) −ππ⊤. Observe that cov(y), being a covariance matrix, must necessarily be positive
semideﬁnite. Using this fact show that the matrix W = diag(π) −ΠΠ⊤
from eq. (3.38) is positive semideﬁnite. By showing that the vector of all
ones is an eigenvector of cov(y) with eigenvalue zero, verify that the matrix is indeed positive semideﬁnite, and not positive deﬁnite. (See section
4.1 for deﬁnitions of positive semideﬁnite and positive deﬁnite matrices.)
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Classiﬁcation
Figure 3.13: The decision regions for the three-class softmax function in z2-z3 space.
3. Consider the 3-class softmax function
exp(f1) + exp(f2) + exp(f3),
where c = 1, 2, 3 and f1, f2, f3 are the corresponding activations. To
more easily visualize the decision boundaries, let z2 = f2 −f1 and z3 =
f3 −f1. Thus
1 + exp(z2) + exp(z3),
and similarly for the other classes.
The decision boundary relating to
p(C1) > 1/3 is the curve exp(z2) + exp(z3) = 2. The decision regions for
the three classes are illustrated in Figure 3.13. Let f = (f1, f2, f3)⊤have
a Gaussian distribution centered on the origin, and let π(f) = softmax(f).
We now consider the eﬀect of this distribution on ¯π =
π(f)p(f) df. For
a Gaussian with given covariance structure this integral is easily approximated by drawing samples from p(f). Show that the classiﬁcation can be
made to fall into any of the three categories depending on the covariance
matrix. Thus, by considering displacements of the mean of the Gaussian
by ϵ from the origin into each of the three regions we have shown that
overall classiﬁcation depends not only on the mean of the Gaussian but
also on its covariance. Show that this conclusion is still valid when it is
recalled that z is derived from f as z = Tf where
so that cov(z) = Tcov(f)T ⊤.
4. Consider the update equation for f new given by eq. (3.18) when some of
the training points are well-explained under f so that ti ≃πi and Wii ≃0
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
3.10 Exercises
for these points.
Break f into two subvectors, f1 that corresponds to
points that are not well-explained, and f2 to those that are. Re-write
(K−1 + W)−1 from eq. (3.18) as K(I + WK)−1 and let K be partitioned
as K11, K12, K21, K22 and similarly for the other matrices. Using the
partitioned matrix inverse equations (see section A.3) show that
= K11(I11 + W11K11)−1 W11f1 + ∇log p(y1|f1)
See section 3.4.1 for the consequences of this result.
5. Show that the expressions in eq. (3.56) for the cavity mean µ−i and variance σ2
−i do not depend on the approximate likelihood terms ˜µi and ˜σ2
for the corresponding case, despite the appearance of eq. (3.56).
6. Consider the USPS 3s vs. 5s prediction problem discussed in section 3.7.3.
Use the implementation of the Laplace binary GPC provided to investigate how ˆf and the predictive probabilities etc. vary as functions of log(ℓ)
and log(σf).
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
We have seen that a covariance function is the crucial ingredient in a Gaussian
process predictor, as it encodes our assumptions about the function which we
wish to learn. From a slightly diﬀerent viewpoint it is clear that in supervised
learning the notion of similarity between data points is crucial; it is a basic
similarity
assumption that points with inputs x which are close are likely to have similar
target values y, and thus training points that are near to a test point should
be informative about the prediction at that point. Under the Gaussian process
view it is the covariance function that deﬁnes nearness or similarity.
An arbitrary function of input pairs x and x′ will not, in general, be a valid
valid covariance
covariance function.1 The purpose of this chapter is to give examples of some
commonly-used covariance functions and to examine their properties. Section
4.1 deﬁnes a number of basic terms relating to covariance functions. Section 4.2
gives examples of stationary, dot-product, and other non-stationary covariance
functions, and also gives some ways to make new ones from old. Section 4.3
introduces the important topic of eigenfunction analysis of covariance functions,
and states Mercer’s theorem which allows us to express the covariance function
(under certain conditions) in terms of its eigenfunctions and eigenvalues. The
covariance functions given in section 4.2 are valid when the input domain X is
a subset of RD. In section 4.4 we describe ways to deﬁne covariance functions
when the input domain is over structured objects such as strings and trees.
Preliminaries
A stationary covariance function is a function of x −x′. Thus it is invariant
stationarity
to translations in the input space.2 For example the squared exponential co-
1To be a valid covariance function it must be positive semideﬁnite, see eq. (4.2).
2In stochastic process theory a process which has constant mean and whose covariance
function is invariant to translations is called weakly stationary.
A process is strictly stationary if all of its ﬁnite dimensional distributions are invariant to translations [Papoulis,
1991, sec. 10.1].
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
variance function given in equation 2.16 is stationary. If further the covariance
function is a function only of |x −x′| then it is called isotropic; it is thus inisotropy
variant to all rigid motions. For example the squared exponential covariance
function given in equation 2.16 is isotropic. As k is now only a function of
r = |x −x′| these are also known as radial basis functions (RBFs).
If a covariance function depends only on x and x′ through x · x′ we call it
dot product covariance
a dot product covariance function. A simple example is the covariance function
k(x, x′) = σ2
0 + x · x′ which can be obtained from linear regression by putting
N(0, 1) priors on the coeﬃcients of xd (d = 1, . . . , D) and a prior of N(0, σ2
on the bias (or constant function) 1, see eq. (2.15). Another important example
is the inhomogeneous polynomial kernel k(x, x′) = (σ2
0 + x · x′)p where p is a
positive integer. Dot product covariance functions are invariant to a rotation
of the coordinates about the origin, but not translations.
A general name for a function k of two arguments mapping a pair of inputs
x ∈X, x′ ∈X into R is a kernel. This term arises in the theory of integral
operators, where the operator Tk is deﬁned as
(Tkf)(x) =
k(x, x′)f(x′) dµ(x′),
where µ denotes a measure; see section A.7 for further explanation of this point.3
A real kernel is said to be symmetric if k(x, x′) = k(x′, x); clearly covariance
functions must be symmetric from the deﬁnition.
Given a set of input points {xi|i = 1, . . . , n} we can compute the Gram
matrix K whose entries are Kij = k(xi, xj). If k is a covariance function we
Gram matrix
call the matrix K the covariance matrix.
covariance matrix
A real n × n matrix K which satisﬁes Q(v) = v⊤Kv ≥0 for all vectors
called positive semideﬁnite (PSD). If Q(v) = 0 only when v = 0
positive semideﬁnite
the matrix is positive deﬁnite. Q(v) is called a quadratic form. A symmetric
matrix is PSD if and only if all of its eigenvalues are non-negative. A Gram
matrix corresponding to a general kernel function need not be PSD, but the
Gram matrix corresponding to a covariance function is PSD.
A kernel is said to be positive semideﬁnite if
k(x, x′)f(x)f(x′) dµ(x) dµ(x′) ≥0,
for all f ∈L2(X, µ). Equivalently a kernel function which gives rise to PSD
Gram matrices for any choice of n ∈N and D is positive semideﬁnite.
see this let f be the weighted sum of delta functions at each xi. Since such
functions are limits of functions in L2(X, µ) eq. (4.2) implies that the Gram
matrix corresponding to any D is PSD.
For a one-dimensional Gaussian process one way to understand the characteristic length-scale of the process (if this exists) is in terms of the number of
upcrossing rate
upcrossings of a level u. Adler [1981, Theorem 4.1.1] states that the expected
3Informally speaking, readers will usually be able to substitute dx or p(x)dx for dµ(x).
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.2 Examples of Covariance Functions
number of upcrossings E[Nu] of the level u on the unit interval by a zero-mean,
stationary, almost surely continuous Gaussian process is given by
If k′′(0) does not exist (so that the process is not mean square diﬀerentiable)
then if such a process has a zero at x0 then it will almost surely have an inﬁnite
number of zeros in the arbitrarily small interval (x0, x0 +δ) [Blake and Lindsey,
1973, p. 303].
Mean Square Continuity and Diﬀerentiability
We now describe mean square continuity and diﬀerentiability of stochastic processes, following Adler [1981, sec. 2.2]. Let x1, x2, . . . be a sequence of points
and x∗be a ﬁxed point in RD such that |xk −x∗| →0 as k →∞. Then a
process f(x) is continuous in mean square at x∗if E[|f(xk) −f(x∗)|2] →0 as
mean square continuity
k →∞. If this holds for all x∗∈A where A is a subset of RD then f(x) is said
to be continuous in mean square (MS) over A. A random ﬁeld is continuous in
mean square at x∗if and only if its covariance function k(x, x′) is continuous
at the point x = x′ = x∗. For stationary covariance functions this reduces
to checking continuity at k(0). Note that MS continuity does not necessarily
imply sample function continuity; for a discussion of sample function continuity
and diﬀerentiability see Adler [1981, ch. 3].
The mean square derivative of f(x) in the ith direction is deﬁned as
f(x + hei) −f(x)
when the limit exists, where l.i.m denotes the limit in mean square and ei
mean square
diﬀerentiability
is the unit vector in the ith direction. The covariance function of ∂f(x)/∂xi
is given by ∂2k(x, x′)/∂xi∂x′
These deﬁnitions can be extended to higher
order derivatives. For stationary processes, if the 2kth-order partial derivative
∂2kk(x)/∂2xi1 . . . ∂2xik exists and is ﬁnite at x = 0 then the kth order partial
derivative ∂kf(x)/∂xi1 . . . xik exists for all x ∈RD as a mean square limit.
Notice that it is the properties of the kernel k around 0 that determine the
smoothness properties (MS diﬀerentiability) of a stationary process.
Examples of Covariance Functions
In this section we consider covariance functions where the input domain X is
a subset of the vector space RD. More general input spaces are considered in
section 4.4. We start in section 4.2.1 with stationary covariance functions, then
consider dot-product covariance functions in section 4.2.2 and other varieties
of non-stationary covariance functions in section 4.2.3. We give an overview
of some commonly used covariance functions in Table 4.1 and in section 4.2.4
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
we describe general methods for constructing new kernels from old.
exist several other good overviews of covariance functions, see e.g. Abrahamsen
Stationary Covariance Functions
In this section (and section 4.3) it will be convenient to allow kernels to be a map
from x ∈X, x′ ∈X into C (rather than R). If a zero-mean process f is complexvalued, then the covariance function is deﬁned as k(x, x′) = E[f(x)f ∗(x′)],
where ∗denotes complex conjugation.
A stationary covariance function is a function of τ = x −x′. Sometimes in
this case we will write k as a function of a single argument, i.e. k(τ).
The covariance function of a stationary process can be represented as the
Fourier transform of a positive ﬁnite measure.
Theorem 4.1 (Bochner’s theorem) A complex-valued function k on RD is the
Bochner’s theorem
covariance function of a weakly stationary mean square continuous complexvalued random process on RD if and only if it can be represented as
RD e2πis·τ dµ(s)
where µ is a positive ﬁnite measure.
The statement of Bochner’s theorem is quoted from Stein [1999, p. 24]; a proof
can be found in Gihman and Skorohod [1974, p. 208]. If µ has a density S(s)
spectral density
power spectrum
then S is known as the spectral density or power spectrum corresponding to k.
The construction given by eq. (4.5) puts non-negative power into each frequency s; this is analogous to the requirement that the prior covariance matrix
Σp on the weights in equation 2.4 be non-negative deﬁnite.
In the case that the spectral density S(s) exists, the covariance function and
the spectral density are Fourier duals of each other as shown in eq. (4.6);4 this
is known as the Wiener-Khintchine theorem, see, e.g. Chatﬁeld 
S(s)e2πis·τ ds,
k(τ)e−2πis·τ dτ.
Notice that the variance of the process is k(0) =
S(s) ds so the power spectrum
must be integrable to deﬁne a valid Gaussian process.
To gain some intuition for the deﬁnition of the power spectrum given in
eq. (4.6) it is important to realize that the complex exponentials e2πis·x are
eigenfunctions of a stationary kernel with respect to Lebesgue measure (see
section 4.3 for further details). Thus S(s) is, loosely speaking, the amount of
power allocated on average to the eigenfunction e2πis·x with frequency s. S(s)
must eventually decay suﬃciently fast as |s| →∞so that it is integrable; the
4See Appendix A.8 for details of Fourier transforms.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.2 Examples of Covariance Functions
rate of this decay of the power spectrum gives important information about
the smoothness of the associated stochastic process. For example it can determine the mean-square diﬀerentiability of the process (see section 4.3 for further
If the covariance function is isotropic (so that it is a function of r, where
r = |τ|) then it can be shown that S(s) is a function of s ≜|s| only [Adler,
1981, Theorem 2.5.2]. In this case the integrals in eq. (4.6) can be simpliﬁed
by changing to spherical polar coordinates and integrating out the angular
variables to obtain
S(s)JD/2−1(2πrs)sD/2 ds,
k(r)JD/2−1(2πrs)rD/2 dr,
where JD/2−1 is a Bessel function of order D/2−1. Note that the dependence on
the dimensionality D in equation 4.7 means that the same isotropic functional
form of the spectral density can give rise to diﬀerent isotropic covariance functions in diﬀerent dimensions. Similarly, if we start with a particular isotropic
covariance function k(r) the form of spectral density will in general depend on
D (see, e.g. the Mat´ern class spectral density given in eq. (4.15)) and in fact
k(r) may not be valid for all D. A necessary condition for the spectral density
to exist is that
rD−1|k(r)| dr < ∞; see Stein [1999, sec. 2.10] for more details.
We now give some examples of commonly-used isotropic covariance functions. The covariance functions are given in a normalized form where k(0) = 1;
we can multiply k by a (positive) constant σ2
f to get any desired process variance.
Squared Exponential Covariance Function
The squared exponential (SE) covariance function has already been introduced
squared exponential
in chapter 2, eq. (2.16) and has the form
kSE(r) = exp
with parameter ℓdeﬁning the characteristic length-scale. Using eq. (4.3) we
characteristic
length-scale
see that the mean number of level-zero upcrossings for a SE process in 1d is (2πℓ)−1, which conﬁrms the rˆole of ℓas a length-scale.
This covariance function is inﬁnitely diﬀerentiable, which means that the GP with this
covariance function has mean square derivatives of all orders, and is thus
very smooth.
The spectral density of the SE covariance function is S(s) =
(2πℓ2)D/2 exp(−2π2ℓ2s2).
Stein argues that such strong smoothness
assumptions are unrealistic for modelling many physical processes, and recommends the Mat´ern class (see below). However, the squared exponential is
probably the most widely-used kernel within the kernel machines ﬁeld.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
The SE kernel is inﬁnitely divisible in that (k(r))t is a valid kernel for all
inﬁnitely divisible
t > 0; the eﬀect of raising k to the power of t is simply to rescale ℓ.
We now digress brieﬂy, to show that the squared exponential covariance
function can also be obtained by expanding the input x into a feature space
deﬁned by Gaussian-shaped basis functions centered densely in x-space. For
inﬁnite network
construction for SE
covariance function
simplicity of exposition we consider scalar inputs with basis functions
φc(x) = exp
where c denotes the centre of the basis function. From sections 2.1 and 2.2 we
recall that with a Gaussian prior on the weights w ∼N(0, σ2
pI), this gives rise
to a GP with covariance function
k(xp, xq) = σ2
φc(xp)φc(xq).
Now, allowing an inﬁnite number of basis functions centered everywhere on an
interval (and scaling down the variance of the prior on the weights with the
number of basis functions) we obtain the limit
φc(xp)φc(xq) = σ2
φc(xp)φc(xq)dc.
Plugging in the Gaussian-shaped basis functions eq. (4.10) and letting the integration limits go to inﬁnity we obtain
k(xp, xq) = σ2
 −(xp −c)2
 −(xq −c)2
 −(xp −xq)2
which we recognize as a squared exponential covariance function with a
times longer length-scale. The derivation is adapted from MacKay . It
is straightforward to generalize this construction to multivariate x. See also
eq. (4.30) for a similar construction where the centres of the basis functions are
sampled from a Gaussian distribution; the constructions are equivalent when
the variance of this Gaussian tends to inﬁnity.
The Mat´ern Class of Covariance Functions
The Mat´ern class of covariance functions is given by
Mat´ern class
kMatern(r) = 21−ν
with positive parameters ν and ℓ, where Kν is a modiﬁed Bessel function
[Abramowitz and Stegun, 1965, sec. 9.6]. This covariance function has a spectral
S(s) = 2DπD/2Γ(ν + D/2)(2ν)ν
ℓ2 + 4π2s2−(ν+D/2)
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.2 Examples of Covariance Functions
input distance, r
covariance, k(r)
output, f(x)
Figure 4.1: Panel (a): covariance functions, and (b): random functions drawn from
Gaussian processes with Mat´ern covariance functions, eq. (4.14), for diﬀerent values of
ν, with ℓ= 1. The sample functions on the right were obtained using a discretization
of the x-axis of 2000 equally-spaced points.
in D dimensions. Note that the scaling is chosen so that for ν →∞we obtain
the SE covariance function e−r2/2ℓ2, see eq. (A.25). Stein named this the
Mat´ern class after the work of Mat´ern . For the Mat´ern class the process
f(x) is k-times MS diﬀerentiable if and only if ν > k. The Mat´ern covariance
functions become especially simple when ν is half-integer: ν = p + 1/2, where
p is a non-negative integer. In this case the covariance function is a product
of an exponential and a polynomial of order p, the general expression can be
derived from [Abramowitz and Stegun, 1965, eq. 10.2.15], giving
kν=p+1/2(r) = exp
 Γ(p + 1)
It is possible that the most interesting cases for machine learning are ν = 3/2
and ν = 5/2, for which
kν=3/2(r) =
kν=5/2(r) =
since for ν = 1/2 the process becomes very rough (see below), and for ν ≥7/2,
in the absence of explicit prior knowledge about the existence of higher order
derivatives, it is probably very hard from ﬁnite noisy training examples to
distinguish between values of ν ≥7/2 (or even to distinguish between ﬁnite
values of ν and ν →∞, the smooth squared exponential, in this case). For
example a value of ν = 5/2 was used in [Cornford et al., 2002].
Ornstein-Uhlenbeck Process and Exponential Covariance Function
The special case obtained by setting ν = 1/2 in the Mat´ern class gives the
exponential
exponential covariance function k(r) = exp(−r/ℓ). The corresponding process
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
input distance
covariance
output, f(x)
Figure 4.2: Panel (a) covariance functions, and (b) random functions drawn from
Gaussian processes with the γ-exponential covariance function eq. (4.18), for diﬀerent
values of γ, with ℓ= 1. The sample functions are only diﬀerentiable when γ = 2 (the
SE case). The sample functions on the right were obtained using a discretization of
the x-axis of 2000 equally-spaced points.
is MS continuous but not MS diﬀerentiable. In D = 1 this is the covariance
function of the Ornstein-Uhlenbeck (OU) process. The OU process [Uhlenbeck
Ornstein-Uhlenbeck
and Ornstein, 1930] was introduced as a mathematical model of the velocity
of a particle undergoing Brownian motion. More generally in D = 1 setting
ν + 1/2 = p for integer p gives rise to a particular form of a continuous-time
AR(p) Gaussian process; for further details see section B.2.1. The form of the
Mat´ern covariance function and samples drawn from it for ν = 1/2, ν = 2 and
ν →∞are illustrated in Figure 4.1.
The γ-exponential Covariance Function
The γ-exponential family of covariance functions, which includes both the ex-
γ-exponential
ponential and squared exponential, is given by
k(r) = exp
Although this function has a similar number of parameters to the Mat´ern class,
it is (as Stein notes) in a sense less ﬂexible. This is because the corresponding process is not MS diﬀerentiable except when γ = 2 (when it is in-
ﬁnitely MS diﬀerentiable). The covariance function and random samples from
the process are shown in Figure 4.2. A proof of the positive deﬁniteness of this
covariance function can be found in Schoenberg .
Rational Quadratic Covariance Function
The rational quadratic (RQ) covariance function
rational quadratic
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.2 Examples of Covariance Functions
input distance
covariance
output, f(x)
Figure 4.3: Panel (a) covariance functions, and (b) random functions drawn from
Gaussian processes with rational quadratic covariance functions, eq. (4.20), for diﬀerent values of α with ℓ= 1. The sample functions on the right were obtained using a
discretization of the x-axis of 2000 equally-spaced points.
with α, ℓ> 0 can be seen as a scale mixture (an inﬁnite sum) of squared
scale mixture
exponential (SE) covariance functions with diﬀerent characteristic length-scales
(sums of covariance functions are also a valid covariance, see section 4.2.4).
Parameterizing now in terms of inverse squared length scales, τ = ℓ−2, and
putting a gamma distribution on p(τ|α, β) ∝τ α−1 exp(−ατ/β),5 we can add
up the contributions through the following integral
p(τ|α, β)kSE(r|τ) dτ
where we have set β−1 = ℓ2. The rational quadratic is also discussed by Mat´ern
[1960, p. 17] using a slightly diﬀerent parameterization; in our notation the limit
of the RQ covariance for α →∞(see eq. (A.25)) is the SE covariance function
with characteristic length-scale ℓ, eq. (4.9). Figure 4.3 illustrates the behaviour
for diﬀerent values of α; note that the process is inﬁnitely MS diﬀerentiable for
every α in contrast to the Mat´ern covariance function in Figure 4.1.
The previous example is a special case of kernels which can be written as
superpositions of SE kernels with a distribution p(ℓ) of length-scales ℓ, k(r) =
exp(−r2/2ℓ2)p(ℓ) dℓ. This is in fact the most general representation for an
isotropic kernel which deﬁnes a valid covariance function in any dimension D,
see [Stein, 1999, sec. 2.10].
Piecewise Polynomial Covariance Functions with Compact Support
A family of piecewise polynomial functions with compact support provide anpiecewise polynomial
covariance functions
with compact support
other interesting class of covariance functions. Compact support means that
5 Note that there are several common ways to parameterize the Gamma distribution—our
choice is convenient here: α is the “shape” and β is the mean.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
input distance, r
covariance, k(r)
output, f(x)
Figure 4.4: Panel (a): covariance functions, and (b): random functions drawn from
Gaussian processes with piecewise polynomial covariance functions with compact support from eq. (4.21), with speciﬁed parameters.
the covariance between points become exactly zero when their distance exceeds
a certain threshold. This means that the covariance matrix will become sparse
by construction, leading to the possibility of computational advantages.6 The
challenge in designing these functions is how to guarantee positive deﬁnitepositive deﬁniteness
ness. Multiple algorithms for deriving such covariance functions are discussed
by Wendland [2005, ch. 9]. These functions are usually not positive deﬁnite
for all input dimensions, but their validity is restricted up to some maximum
restricted dimension
dimension D. Below we give examples of covariance functions kppD,q(r) which
are positive deﬁnite in RD
kppD,0(r) = (1 −r)j
where j = ⌊D
2 ⌋+ q + 1,
kppD,1(r) = (1 −r)j+1
 (j + 1)r + 1
kppD,2(r) = (1 −r)j+2
 (j2 + 4j + 3)r2 + (3j + 6)r + 3
kppD,3(r) = (1 −r)j+3
 (j3 + 9j2 + 23j + 15)r3+
(6j2 + 36j + 45)r2 + (15j + 45)r + 15
The properties of three of these covariance functions are illustrated in Figure 4.4. These covariance functions are 2q-times continuously diﬀerentiable,
and thus the corresponding processes are q-times mean-square diﬀerentiable,
see section 4.1.1.
It is interesting to ask to what extent one could use the
compactly-supported covariance functions described above in place of the other
covariance functions mentioned in this section, while obtaining inferences that
are similar. One advantage of the compact support is that it gives rise to sparsity of the Gram matrix which could be exploited, for example, when using
iterative solutions to GPR problem, see section 8.3.6.
6If the product of the inverse covariance matrix with a vector (needed e.g. for prediction)
is computed using a conjugate gradient algorithm, then products of the covariance matrix
with vectors are the basic computational unit, and these can obviously be carried out much
faster if the matrix is sparse.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.2 Examples of Covariance Functions
Further Properties of Stationary Covariance Functions
The covariance functions given above decay monotonically with r and are always
positive. However, this is not a necessary condition for a covariance function.
For example Yaglom shows that k(r) = c(αr)−νJν(αr) is a valid covariance function for ν ≥(D −2)/2 and α > 0; this function has the form of a
damped oscillation.
Anisotropic versions of these isotropic covariance functions can be created
anisotropy
by setting r2(x, x′) = (x −x′)⊤M(x −x′) for some positive semideﬁnite M.
If M is diagonal this implements the use of diﬀerent length-scales on diﬀerent
dimensions—for further discussion of automatic relevance determination see
section 5.1. General M’s have been considered by Mat´ern [1960, p. 19], Poggio
and Girosi and also in Vivarelli and Williams ; in the latter work a
low-rank M was used to implement a linear dimensionality reduction step from
the input space to lower-dimensional feature space. More generally, one could
assume the form
M = ΛΛ⊤+ Ψ
where Λ is a D × k matrix whose columns deﬁne k directions of high relevance,
and Ψ is a diagonal matrix (with positive entries), capturing the (usual) axisaligned relevances, see also Figure 5.1 on page 107. Thus M has a factor analysis
factor analysis distance
form. For appropriate choices of k this may represent a good trade-oﬀbetween
ﬂexibility and required number of parameters.
Stationary kernels can also be deﬁned on a periodic domain, and can be
readily constructed from stationary kernels on R. Given a stationary kernel
k(x), the kernel kT(x) = P
m∈Z k(x + ml) is periodic with period l, as shown in
periodization
section B.2.2 and Sch¨olkopf and Smola [2002, eq. 4.42].
Dot Product Covariance Functions
As we have already mentioned above the kernel k(x, x′) = σ2
0 + x · x′ can
be obtained from linear regression. If σ2
0 = 0 we call this the homogeneous
linear kernel, otherwise it is inhomogeneous. Of course this can be generalized
to k(x, x′) = σ2
0 + x⊤Σpx′ by using a general covariance matrix Σp on the
components of x, as described in eq. (2.4).7 It is also the case that k(x, x′) =
0 + x⊤Σpx′)p is a valid covariance function for positive integer p, because of
the general result that a positive-integer power of a given covariance function is
also a valid covariance function, as described in section 4.2.4. However, it is also
interesting to show an explicit feature space construction for the polynomial
covariance function.
We consider the homogeneous polynomial case as the
inhomogeneous case can simply be obtained by considering x to be extended
7Indeed the bias term could also be included in the general expression.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
by concatenating a constant. We write
k(x, x′) = (x · x′)p =
(xd1 · · · xdp)(x′
d1 · · · x′
dp) ≜φ(x) · φ(x′).
Notice that this sum apparently contains Dp terms but in fact it is less than this
as the order of the indices in the monomial xd1 · · · xdp is unimportant, e.g. for
p = 2, x1x2 and x2x1 are the same monomial. We can remove the redundancy
by deﬁning a vector m whose entry md speciﬁes the number of times index
d appears in the monomial, under the constraint that PD
i=1 mi = p.
φm(x), the feature corresponding to vector m is proportional to the monomial
D . The degeneracy of φm(x) is
m1!...mD! (where as usual we deﬁne
0! = 1), giving the feature map
m1! · · · mD!xm1
For example, for p = 2 in D = 2, we have φ(x) = (x2
2x1x2)⊤. Dotproduct kernels are sometimes used in a normalized form given by eq. (4.35).
For regression problems the polynomial kernel is a rather strange choice as
the prior variance grows rapidly with |x| for |x| > 1. However, such kernels
have proved eﬀective in high-dimensional classiﬁcation problems (e.g. take x
to be a vectorized binary image) where the input data are binary or greyscale
normalized to [−1, 1] on each dimension [Sch¨olkopf and Smola, 2002, sec. 7.8].
Other Non-stationary Covariance Functions
Above we have seen examples of non-stationary dot product kernels. However,
there are also other interesting kernels which are not of this form. In this section
we ﬁrst describe the covariance function belonging to a particular type of neural
network; this construction is due to Neal .
Consider a network which takes an input x, has one hidden layer with NH
units and then linearly combines the outputs of the hidden units with a bias b
to obtain f(x). The mapping can be written
f(x) = b +
vjh(x; uj),
where the vjs are the hidden-to-output weights and h(x; u) is the hidden unit
transfer function (which we shall assume is bounded) which depends on the
input-to-hidden weights u. For example, we could choose h(x; u) = tanh(x·u).
This architecture is important because it has been shown by Hornik that
networks with one hidden layer are universal approximators as the number of
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.2 Examples of Covariance Functions
hidden units tends to inﬁnity, for a wide class of transfer functions (but excluding polynomials). Let b and the v’s have independent zero-mean distributions
of variance σ2
v, respectively, and let the weights uj for each hidden unit
be independently and identically distributed. Denoting all weights by w, we
obtain (following Neal )
Ew[f(x)] = 0
Ew[f(x)f(x′)] = σ2
vEu[h(x; uj)h(x′; uj)]
vEu[h(x; u)h(x′; u)],
where eq. (4.28) follows because all of the hidden units are identically distributed.
The ﬁnal term in equation 4.28 becomes ω2Eu[h(x; u)h(x′; u)] by
letting σ2
v scale as ω2/NH.
The sum in eq. (4.27) is over NH identically and independently distributed
random variables.
As the transfer function is bounded, all moments of the
distribution will be bounded and hence the central limit theorem can be applied,
showing that the stochastic process will converge to a Gaussian process in the
limit as NH →∞.
By evaluating Eu[h(x; u)h(x′; u)] we can obtain the covariance function of
the neural network. For example if we choose the error function h(z) = erf(z) =
neural network
covariance function
0 e−t2 dt as the transfer function, let h(x; u) = erf(u0 + PD
j=1ujxj) and
choose u ∼N(0, Σ) then we obtain [Williams, 1998]
kNN(x, x′) = 2
(1 + 2˜x⊤Σ˜x)(1 + 2˜x′⊤Σ˜x′)
where ˜x = (1, x1, . . . , xd)⊤is an augmented input vector. This is a true “neural
network” covariance function. The “sigmoid” kernel k(x, x′) = tanh(a+bx·x′)
has sometimes been proposed, but in fact this kernel is never positive deﬁnite and is thus not a valid covariance function, see, e.g. Sch¨olkopf and Smola
[2002, p. 113]. Figure 4.5 shows a plot of the neural network covariance function
and samples from the prior. We have set Σ = diag(σ2
0, σ2). Samples from a GP
with this covariance function can be viewed as superpositions of the functions
erf(u0+ux), where σ2
0 controls the variance of u0 (and thus the amount of oﬀset
of these functions from the origin), and σ2 controls u and thus the scaling on
the x-axis. In Figure 4.5(b) we observe that the sample functions with larger σ
vary more quickly. Notice that the samples display the non-stationarity of the
covariance function in that for large values of +x or −x they should tend to a
constant value, consistent with the construction as a superposition of sigmoid
functions.
Another interesting construction is to set h(x; u) = exp 
(a), covariance
(b), sample functions
Figure 4.5: Panel (a): a plot of the covariance function kNN(x, x′) for σ0 = 10, σ = 10.
Panel (b): samples drawn from the neural network covariance function with σ0 = 2
and σ as shown in the legend. The samples were obtained using a discretization of
the x-axis of 500 equally-spaced points.
kG(x, x′) =
(2πσ2u)d/2
where 1/σ2
g. This is
in general a non-stationary covariance function, but if σ2
u →∞(while scaling
ω2 appropriately) we recover the squared exponential kG(x, x′) ∝exp(−|x −
For a ﬁnite value of σ2
u, kG(x, x′) comprises a squared exponential covariance function modulated by the Gaussian decay envelope function
exp(−x⊤x/2σ2
m) exp(−x′⊤x′/2σ2
m), cf. the vertical rescaling construction described in section 4.2.4.
One way to introduce non-stationarity is to introduce an arbitrary non-linear
mapping (or warping) u(x) of the input x and then use a stationary covariance
function in u-space. Note that x and u need not have the same dimensionality as
each other. This approach was used by Sampson and Guttorp to model
patterns of solar radiation in southwestern British Columbia using Gaussian
processes.
Another interesting example of this warping construction is given in MacKay
 where the one-dimensional input variable x is mapped to the two-dimensional
u(x) = (cos(x), sin(x)) to give rise to a periodic random function of x. If we
periodic random
use the squared exponential kernel in u-space, then
k(x, x′) = exp
−2 sin2   x−x′
as (cos(x) −cos(x′))2 + (sin(x) −sin(x′))2 = 4 sin2 
output, f(x)
Figure 4.6: Panel (a) shows the chosen length-scale function ℓ(x). Panel (b) shows
three samples from the GP prior using Gibbs’ covariance function eq. (4.32). This
ﬁgure is based on Fig. 3.9 in Gibbs .
We have described above how to make an anisotropic covariance function
varying length-scale
by scaling diﬀerent dimensions diﬀerently. However, we are not free to make
these length-scales ℓd be functions of x, as this will not in general produce a
valid covariance function. Gibbs derived the covariance function
k(x, x′) =
 2ℓd(x)ℓd(x′)
where each ℓi(x) is an arbitrary positive function of x. Note that k(x, x) = 1
for all x.
This covariance function is obtained by considering a grid of N
Gaussian basis functions with centres cj and a corresponding length-scale on
input dimension d which varies as a positive function ℓd(cj). Taking the limit
as N →∞the sum turns into an integral and after some algebra eq. (4.32) is
An example of a variable length-scale function and samples from the prior
corresponding to eq. (4.32) are shown in Figure 4.6. Notice that as the lengthscale gets shorter the sample functions vary more rapidly as one would expect.
The large length-scale regions on either side of the short length-scale region can
be quite strongly correlated. If one tries the converse experiment by creating
a length-scale function ℓ(x) which has a longer length-scale region between
two shorter ones then the behaviour may not be quite what is expected; on
initially transitioning into the long length-scale region the covariance drops oﬀ
quite sharply due to the prefactor in eq. (4.32), before stabilizing to a slower
variation. See Gibbs [1997, sec. 3.10.3] for further details. Exercises 4.5.4 and
4.5.5 invite you to investigate this further.
Paciorek and Schervish have generalized Gibbs’ construction to obtain
non-stationary versions of arbitrary isotropic covariance functions. Let kS be a
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
covariance function
expression
polynomial
(x · x′ + σ2
squared exponential
exponential
γ-exponential
rational quadratic
neural network
sin−1  2˜x⊤Σ˜x′
(1+2˜x⊤Σ˜x)(1+2˜x′⊤Σ˜x′)
Table 4.1: Summary of several commonly-used covariance functions. The covariances
are written either as a function of x and x′, or as a function of r = |x −x′|. Two
columns marked ‘S’ and ‘ND’ indicate whether the covariance functions are stationary
and nondegenerate respectively. Degenerate covariance functions have ﬁnite rank, see
section 4.3 for more discussion of this issue.
stationary, isotropic covariance function that is valid in every Euclidean space
RD for D = 1, 2, . . ..
Let Σ(x) be a D × D matrix-valued function which
is positive deﬁnite for all x, and let Σi ≜Σ(xi).
(The set of Gibbs’ ℓi(x)
functions deﬁne a diagonal Σ(x).) Then deﬁne the quadratic form
Qij = (xi −xj)⊤((Σi + Σj)/2)−1(xi −xj).
Paciorek and Schervish show that
kNS(xi, xj) = 2D/2|Σi|1/4|Σj|1/4|Σi + Σj|−1/2kS(
is a valid non-stationary covariance function.
In chapter 2 we described the linear regression model in feature space f(x) =
O’Hagan suggested making w a function of x to allow for
diﬀerent values of w to be appropriate in diﬀerent regions.
Thus he put a
Gaussian process prior on w of the form cov(w(x), w(x′)) = W0kw(x, x′) for
some positive deﬁnite matrix W0, giving rise to a prior on f(x) with covariance
kf(x, x′) = φ(x)⊤W0φ(x′)kw(x, x′).
Finally we note that the Wiener process with covariance function k(x, x′) =
min(x, x′) is a fundamental non-stationary process. See section B.2.1 and texts
Wiener process
such as Grimmett and Stirzaker [1992, ch. 13] for further details.
Making New Kernels from Old
In the previous sections we have developed many covariance functions some of
which are summarized in Table 4.1. In this section we show how to combine or
modify existing covariance functions to make new ones.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.2 Examples of Covariance Functions
The sum of two kernels is a kernel. Proof: consider the random process
f(x) = f1(x) + f2(x), where f1(x) and f2(x) are independent. Then k(x, x′) =
k1(x, x′) + k2(x, x′). This construction can be used e.g. to add together kernels
with diﬀerent characteristic length-scales.
The product of two kernels is a kernel. Proof: consider the random process
f(x) = f1(x)f2(x), where f1(x) and f2(x) are independent. Then k(x, x′) =
k1(x, x′)k2(x, x′).8 A simple extension of this argument means that kp(x, x′) is
a valid covariance function for p ∈N.
Let a(x) be a given deterministic function and consider g(x) = a(x)f(x)
where f(x) is a random process. Then cov(g(x), g(x′)) = a(x)k(x, x′)a(x′).
vertical rescaling
Such a construction can be used to normalize kernels by choosing a(x) =
k−1/2(x, x) (assuming k(x, x) > 0 ∀x), so that
˜k(x, x′) =
This ensures that ˜k(x, x) = 1 for all x.
We can also obtain a new process by convolution (or blurring). Consider
an arbitrary ﬁxed kernel h(x, z) and the map g(x) =
h(x, z)f(z) dz. Then
convolution
clearly cov(g(x), g(x′)) =
h(x, z)k(z, z′)h(x′, z′) dz dz′.
If k(x1, x′
1) and k(x2, x′
2) are covariance functions over diﬀerent spaces X1
and X2, then the direct sum k(x, x′) = k1(x1, x′
1) + k2(x2, x′
2) and the tensor
direct sum
tensor product
product k(x, x′) = k1(x1, x′
1)k2(x2, x′
2) are also covariance functions (deﬁned
on the product space X1 ×X2), by virtue of the sum and product constructions.
The direct sum construction can be further generalized. Consider a function f(x), where x is D-dimensional.
An additive model [Hastie and Tibshirani, 1990] has the form f(x) = c + PD
i=1fi(xi), i.e. a linear combinaadditive model
tion of functions of one variable.
If the individual fi’s are taken to be independent stochastic processes, then the covariance function of f will have the
form of a direct sum. If we now admit interactions of two variables, so that
f(x) = c + PD
i=1fi(xi) + P
ij,j<i fij(xi, xj) and the various fi’s and fij’s are
independent stochastic processes, then the covariance function will have the
form k(x, x′) = PD
i=1ki(xi, x′
j=1 kij(xi, xj; x′
j). Indeed this process can be extended further to provide a functional ANOVA9 decomposition,
ranging from a simple additive model up to full interaction of all D input varifunctional ANOVA
ables. (The sum can also be truncated at some stage.) Wahba [1990, ch. 10]
and Stitson et al. suggest using tensor products for kernels with interactions so that in the example above kij(xi, xj; x′
j) would have the form
i)kj(xj; x′
j). Note that if D is large then the large number of pairwise
(or higher-order) terms may be problematic; Plate has investigated using
a combination of additive GP models plus a general covariance function that
permits full interactions.
8If f1 and f2 are Gaussian processes then the product f will not in general be a Gaussian
process, but there exists a GP with this covariance function.
9ANOVA stands for analysis of variance, a statistical technique that analyzes the interactions between various attributes.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
Eigenfunction Analysis of Kernels
We ﬁrst deﬁne eigenvalues and eigenfunctions and discuss Mercer’s theorem
which allows us to express the kernel (under certain conditions) in terms of these
quantities. Section 4.3.1 gives the analytical solution of the eigenproblem for the
SE kernel under a Gaussian measure. Section 4.3.2 discusses how to compute
approximate eigenfunctions numerically for cases where the exact solution is
not known.
It turns out that Gaussian process regression can be viewed as Bayesian
linear regression with a possibly inﬁnite number of basis functions, as discussed
in chapter 2.
One possible basis set is the eigenfunctions of the covariance
function. A function φ(·) that obeys the integral equation
k(x, x′)φ(x) dµ(x) = λφ(x′),
is called an eigenfunction of kernel k with eigenvalue λ with respect to measure10
eigenvalue,
eigenfunction
µ. The two measures of particular interest to us will be (i) Lebesgue measure
over a compact subset C of RD, or (ii) when there is a density p(x) so that
dµ(x) can be written p(x)dx.
In general there are an inﬁnite number of eigenfunctions, which we label
φ1(x), φ2(x), . . . We assume the ordering is chosen such that λ1 ≥λ2 ≥. . ..
The eigenfunctions are orthogonal with respect to µ and can be chosen to be
normalized so that
φi(x)φj(x) dµ(x) = δij where δij is the Kronecker delta.
Mercer’s theorem allows us to express the kernel k
Mercer’s theorem
in terms of the eigenvalues and eigenfunctions.
Theorem 4.2 (Mercer’s theorem). Let (X, µ) be a ﬁnite measure space and
k ∈L∞(X 2, µ2) be a kernel such that Tk : L2(X, µ) →L2(X, µ) is positive
deﬁnite (see eq. (4.2)). Let φi ∈L2(X, µ) be the normalized eigenfunctions of
Tk associated with the eigenvalues λi > 0. Then:
1. the eigenvalues {λi}∞
i=1 are absolutely summable
k(x, x′) =
holds µ2 almost everywhere, where the series converges absolutely and
uniformly µ2 almost everywhere.
This decomposition is just the inﬁnite-dimensional analogue of the diagonalization of a Hermitian matrix. Note that the sum may terminate at some value
N ∈N (i.e. the eigenvalues beyond N are zero), or the sum may be inﬁnite.
We have the following deﬁnition [Press et al., 1992, p. 794]
10For further explanation of measure see Appendix A.7.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.3 Eigenfunction Analysis of Kernels
Deﬁnition 4.1 A degenerate kernel has only a ﬁnite number of non-zero eigenvalues.
A degenerate kernel is also said to have ﬁnite rank. If a kernel is not degenerate
degenerate,
nondegenerate
it is said to be nondegenerate. As an example a N-dimensional linear regression
model in feature space (see eq. (2.10)) gives rise to a degenerate kernel with at
most N non-zero eigenvalues. (Of course if the measure only puts weight on a
ﬁnite number of points n in x-space then the eigendecomposition is simply that
of a n × n matrix, even if the kernel is nondegenerate.)
The statement of Mercer’s theorem above referred to a ﬁnite measure µ.
If we replace this with Lebesgue measure and consider a stationary covariance
function, then directly from Bochner’s theorem eq. (4.5) we obtain
k(x −x′) =
RD e2πis·(x−x′) dµ(s) =
RD e2πis·x
e2πis·x′∗
The complex exponentials e2πis·x are the eigenfunctions of a stationary kernel
w.r.t. Lebesgue measure.
Note the similarity to eq. (4.37) except that the
summation has been replaced by an integral.
The rate of decay of the eigenvalues gives important information about the
smoothness of the kernel. For example Ritter et al. showed that in 1-d
with µ uniform on , processes which are r-times mean-square diﬀerentiable
have λi ∝i−(2r+2) asymptotically. This makes sense as “rougher” processes
have more power at high frequencies, and so their eigenvalue spectrum decays
more slowly. The same phenomenon can be read oﬀfrom the power spectrum
of the Mat´ern class as given in eq. (4.15).
Hawkins gives the exact eigenvalue spectrum for the OU process on
 . Widom [1963; 1964] gives an asymptotic analysis of the eigenvalues of
stationary kernels taking into account the eﬀect of the density dµ(x) = p(x)dx;
Bach and Jordan [2002, Table 3] use these results to show the eﬀect of varying
p(x) for the SE kernel.
An exact eigenanalysis of the SE kernel under the
Gaussian density is given in the next section.
An Analytic Example
For the case that p(x) is a Gaussian and for the squared-exponential kernel
k(x, x′) = exp(−(x−x′)2/2ℓ2), there are analytic results for the eigenvalues and
eigenfunctions, as given by Zhu et al. [1998, sec. 4]. Putting p(x) = N(x|0, σ2)
we ﬁnd that the eigenvalues λk and eigenfunctions φk (for convenience let k =
0, 1, . . . ) are given by
φk(x) = exp
 −(c −a)x2
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
Figure 4.7:
The ﬁrst 3 eigenfunctions of the squared exponential kernel w.r.t. a
Gaussian density. The value of k = 0, 1, 2 is equal to the number of zero-crossings
of the function. The dashed line is proportional to the density p(x).
where Hk(x) = (−1)k exp(x2) dk
dxk exp(−x2) is the kth order Hermite polynomial
 , a−1 = 4σ2, b−1 = 2ℓ2 and
A = a + b + c,
Hints on the proof of this result are given in exercise 4.5.9. A plot of the ﬁrst
three eigenfunctions for a = 1 and b = 3 is shown in Figure 4.7.
The result for the eigenvalues and eigenfunctions is readily generalized to
the multivariate case when the kernel and Gaussian density are products of
the univariate expressions, as the eigenfunctions and eigenvalues will simply
be products too. For the case that a and b are equal on all D dimensions,
the degeneracy of the eigenvalue ( 2a
A )D/2Bk is
which is O(kD−1). As
we see that the
’th eigenvalue has a value given by
A )D/2Bk, and this can be used to determine the rate of decay of the spectrum.
Numerical Approximation of Eigenfunctions
The standard numerical method for approximating the eigenfunctions and eigenvalues of eq. (4.36) is to use a numerical routine to approximate the integral
 . For example letting dµ(x) = p(x)dx in eq. (4.36)
one could use the approximation
λiφi(x′) =
k(x, x′)p(x)φi(x) dx ≃1
k(xl, x′)φi(xl),
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.4 Kernels for Non-vectorial Inputs
where the xl’s are sampled from p(x). Plugging in x′ = xl for l = 1, . . . , n into
eq. (4.42) we obtain the matrix eigenproblem
Kui = λmat
where K is the n × n Gram matrix with entries Kij = k(xi, xj), λmat
is the ith
matrix eigenvalue and ui is the corresponding eigenvector (normalized so that
i ui = 1). We have φi(xj) ∼√n(ui)j where the √n factor arises from the
diﬀering normalizations of the eigenvector and eigenfunction. Thus
an obvious estimator for λi for i = 1, . . . , n. For ﬁxed n one would expect that
the larger eigenvalues would be better estimated than the smaller ones. The
theory of the numerical solution of eigenvalue problems shows that for a ﬁxed i,
will converge to λi in the limit that n →∞[Baker, 1977, Theorem 3.4].
It is also possible to study the convergence further; for example it is quite
easy using the properties of principal components analysis (PCA) in feature
space to show that for any l, 1 ≤l ≤n, En[ 1
i=l+1λi, where En denotes expectation with respect to
samples of size n drawn from p(x). For further details see Shawe-Taylor and
Williams .
The Nystr¨om method for approximating the ith eigenfunction is given by
where k(x′)⊤= (k(x1, x′), . . . , k(xn, x′)), which is obtained from eq. (4.42) by
dividing both sides by λi. Equation 4.44 extends the approximation φi(xj) ≃
√n(ui)j from the sample points x1, . . . , xn to all x.
There is an interesting relationship between the kernel PCA method of
Sch¨olkopf et al. and the eigenfunction expansion discussed above. The
kernel PCA
eigenfunction expansion has (at least potentially) an inﬁnite number of nonzero eigenvalues. In contrast, the kernel PCA algorithm operates on the n × n
matrix K and yields n eigenvalues and eigenvectors. Eq. (4.42) clariﬁes the
relationship between the two. However, note that eq. (4.44) is identical (up to
scaling factors) to Sch¨olkopf et al. [1998, eq. 4.1] which describes the projection
of a new point x′ onto the ith eigenvector in the kernel PCA feature space.
Kernels for Non-vectorial Inputs
So far in this chapter we have assumed that the input x is a vector, measuring
the values of a number of attributes (or features). However, for some learning
problems the inputs are not vectors, but structured objects such as strings,
trees or general graphs. For example, we may have a biological problem where
we want to classify proteins (represented as strings of amino acid symbols).11
11Proteins are initially made up of 20 diﬀerent amino acids, of which a few may later be
modiﬁed bringing the total number up to 26 or 30.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
Or our input may be parse-trees derived from a linguistic analysis. Or we may
wish to represent chemical compounds as labelled graphs, with vertices denoting
atoms and edges denoting bonds.
To follow the discriminative approach we need to extract some features from
the input objects and build a predictor using these features. (For a classiﬁcation
problem, the alternative generative approach would construct class-conditional
models over the objects themselves.)
Below we describe two approaches to
this feature extraction problem and the eﬃcient computation of kernels from
them: in section 4.4.1 we cover string kernels, and in section 4.4.2 we describe
Fisher kernels. There exist other proposals for constructing kernels for strings,
for example Watkins describes the use of pair hidden Markov models
(HMMs that generate output symbols for two strings conditional on the hidden
state) for this purpose.
String Kernels
We start by deﬁning some notation for strings. Let A be a ﬁnite alphabet of
characters.
The concatenation of strings x and y is written xy and |x| denotes
the length of string x. The string s is a substring of x if we can write x = usv
for some (possibly empty) u, s and v.
Let φs(x) denote the number of times that substring s appears in string x.
Then we deﬁne the kernel between two strings x and x′ as
k(x, x′) =
wsφs(x)φs(x′),
where ws is a non-negative weight for substring s. For example, we could set
ws = λ|s|, where 0 < λ < 1, so that shorter substrings get more weight than
longer ones.
A number of interesting special cases are contained in the deﬁnition 4.45:
• Setting ws = 0 for |s| > 1 gives the bag-of-characters kernel. This takes
bag-of-characters
the feature vector for a string x to be the number of times that each
character in A appears in x.
• In text analysis we may wish to consider the frequencies of word occurbag-of-words
rence. If we require s to be bordered by whitespace then a “bag-of-words”
representation is obtained. Although this is a very simple model of text
(which ignores word order) it can be surprisingly eﬀective for document
classiﬁcation and retrieval tasks, see e.g. Hand et al. [2001, sec. 14.3].
The weights can be set diﬀerently for diﬀerent words, e.g. using the “term
frequency inverse document frequency” (TF-IDF) weighting scheme developed in the information retrieval area [Salton and Buckley, 1988].
• If we only consider substrings of length k, then we obtain the k-spectrum
kernel [Leslie et al., 2003].
k-spectrum kernel
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.4 Kernels for Non-vectorial Inputs
Importantly, there are eﬃcient methods using suﬃx trees that can compute
a string kernel k(x, x′) in time linear in |x| + |x′| (with some restrictions on the
weights {ws}) [Leslie et al., 2003, Vishwanathan and Smola, 2003].
Work on string kernels was started by Watkins and Haussler .
There are many further developments of the methods we have described above;
for example Lodhi et al. go beyond substrings to consider subsequences
of x which are not necessarily contiguous, and Leslie et al. describe
mismatch string kernels which allow substrings s and s′ of x and x′ respectively
to match if there are at most m mismatches between them. We expect further
developments in this area, tailoring (or engineering) the string kernels to have
properties that make sense in a particular domain.
The idea of string kernels, where we consider matches of substrings, can
easily be extended to trees, e.g. by looking at matches of subtrees [Collins and
Duﬀy, 2002].
Leslie et al. have applied string kernels to the classiﬁcation of protein
domains into SCOP12 superfamilies. The results obtained were signiﬁcantly
better than methods based on either PSI-BLAST13 searches or a generative
hidden Markov model classiﬁer. Similar results were obtained by Jaakkola et al.
 using a Fisher kernel (described in the next section). Saunders et al.
 have also described the use of string kernels on the problem of classifying
natural language newswire stories from the Reuters-2157814 database into ten
Fisher Kernels
As explained above, our problem is that the input x is a structured object of
arbitrary size e.g. a string, and we wish to extract features from it. The Fisher
kernel does this by taking a generative
model p(x|θ), where θ is a vector of parameters, and computing the feature
vector φθ(x) = ∇θ log p(x|θ). φθ(x) is sometimes called the score vector.
score vector
Take, for example, a Markov model for strings. Let xk be the kth symbol
in string x. Then a Markov model gives p(x|θ) = p(x1|π)Q|x|−1
i=1 p(xi+1|xi, A),
where θ = (π, A). Here (π)j gives the probability that x1 will be the jth symbol
in the alphabet A, and A is a |A| × |A| stochastic matrix, with ajk giving the
probability that p(xi+1 = k|xi = j). Given such a model it is straightforward
to compute the score vector for a given x.
It is also possible to consider other generative models p(x|θ). For example
we might try a kth-order Markov model where xi is predicted by the preceding
k symbols. See Leslie et al. and Saunders et al. for an interesting
discussion of the similarities of the features used in the k-spectrum kernel and
the score vector derived from an order k −1 Markov model; see also exercise
12Structural classiﬁcation of proteins database, 
13Position-Speciﬁc Iterative Basic Local Alignment Search Tool, see
 
14 
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
4.5.12. Another interesting choice is to use a hidden Markov model (HMM) as
the generative model, as discussed by Jaakkola et al. . See also exercise
4.5.11 for a linear kernel derived from an isotropic Gaussian model for x ∈RD.
We deﬁne a kernel k(x, x′) based on the score vectors for x and x′. One
simple choice is to set
k(x, x′) = φ⊤
θ (x)M −1φθ(x′),
where M is a strictly positive deﬁnite matrix. Alternatively we might use the
squared exponential kernel k(x, x′) = exp(−α|φθ(x)−φθ(x′)|2) for some α > 0.
The structure of p(x|θ) as θ varies has been studied extensively in information geometry . It can be shown that the manifold of
log p(x|θ) is Riemannian with a metric tensor which is the inverse of the Fisher
information matrix F, where
Fisher information
F = Ex[φθ(x)φ⊤
Setting M = F in eq. (4.46) gives the Fisher kernel . If F is diﬃcult to compute
Fisher kernel
then one might resort to setting M = I. The advantage of using the Fisher
information matrix is that it makes arc length on the manifold invariant to
reparameterizations of θ.
The Fisher kernel uses a class-independent model p(x|θ).
Tsuda et al.
 have developed the tangent of posterior odds (TOP) kernel based on
TOP kernel
∇θ(log p(y = +1|x, θ)−log p(y = −1|x, θ)), which makes use of class-conditional
distributions for the C+ and C−classes.
1. The OU process with covariance function k(x −x′) = exp(−|x −x′|/ℓ)
is the unique stationary ﬁrst-order Markovian Gaussian process (see Appendix B for further details).
Consider training inputs x1 < x2 . . . <
xn−1 < xn on R with corresponding function values f = (f(x1), . . . , f(xn))⊤.
Let xl denote the nearest training input to the left of a test point x∗, and
similarly let xu denote the nearest training input to the right of x∗. Then
the Markovian property means that p(f(x∗)|f) = p(f(x∗)|f(xl), f(xu)).
Demonstrate this by choosing some x-points on the line and computing
the predictive distribution p(f(x∗)|f) using eq. (2.19), and observing that
non-zero contributions only arise from xl and xu. Note that this only
occurs in the noise-free case; if one allows the training points to be corrupted by noise (equations 2.23 and 2.24) then all points will contribute
in general.
2. Computer exercise: write code to draw samples from the neural network
covariance function, eq. (4.29) in 1-d and 2-d. Consider the cases when
var(u0) is either 0 or non-zero. Explain the form of the plots obtained
when var(u0) = 0.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
4.5 Exercises
3. Consider the random process f(x) = erf(u0 + PD
i=1ujxj), where u ∼
N(0, Σ). Show that this non-linear transform of a process with an inhomogeneous linear covariance function has the same covariance function as
the erf neural network. However, note that this process is not a Gaussian
process. Draw samples from the given process and compare them to your
results from exercise 4.5.2.
4. Derive Gibbs’ non-stationary covariance function, eq. (4.32).
5. Computer exercise: write code to draw samples from Gibbs’ non-stationary
covariance function eq. (4.32) in 1-d and 2-d. Investigate various forms of
length-scale function ℓ(x).
6. Show that the SE process is inﬁnitely MS diﬀerentiable and that the OU
process is not MS diﬀerentiable.
7. Prove that the eigenfunctions of a symmetric kernel are orthogonal w.r.t. the
measure µ.
8. Let ˜k(x, x′) = p1/2(x)k(x, x′)p1/2(x′), and assume p(x) > 0 for all x.
Show that the eigenproblem
R ˜k(x, x′)˜φi(x)dx = ˜λi ˜φi(x′) has the same
eigenvalues as
k(x, x′)p(x)φi(x)dx = λiφi(x′), and that the eigenfunctions are related by ˜φi(x) = p1/2(x)φi(x). Also give the matrix version
of this problem (Hint: introduce a diagonal matrix P to take the rˆole of
p(x)). The signiﬁcance of this connection is that it can be easier to ﬁnd
eigenvalues of symmetric matrices than general matrices.
9. Apply the construction in the previous exercise to the eigenproblem for
the SE kernel and Gaussian density given in section 4.3.1, with p(x) =
2a/π exp(−2ax2). Thus consider the modiﬁed kernel given by ˜k(x, x′) =
exp(−ax2) exp(−b(x−x′)2) exp(−a(x′)2). Using equation 7.374.8 in Gradshteyn and Ryzhik :
 −(x −y)2
Hn(αx) dx = √π(1 −α2)n/2Hn
(1 −α2)1/2
verify that ˜φk(x) = exp(−cx2)Hk(
2cx), and thus conﬁrm equations 4.39
10. Computer exercise: The analytic form of the eigenvalues and eigenfunctions for the SE kernel and Gaussian density are given in section 4.3.1.
Compare these exact results to those obtained by the Nystr¨om approximation for various values of n and choice of samples.
11. Let x ∼N(µ, σ2I). Consider the Fisher kernel derived from this model
with respect to variation of µ (i.e. regard σ2 as a constant). Show that:
∂log p(x|µ)
and that F = σ−2I. Thus the Fisher kernel for this model with µ = 0 is
the linear kernel k(x, x′) =
σ2 x · x′.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Covariance Functions
12. Consider a k −1 order Markov model for strings on a ﬁnite alphabet. Let
this model have parameters θt|s1,...,sk−1 denoting the probability p(xi =
t|xi−1 = s1, . . . , xk−1 = sk−1). Of course as these are probabilities they
obey the constraint that P
t′ θt′|s1,...,sk−1 = 1. Enforcing this constraint
can be achieved automatically by setting
θt|s1,...,sk−1 =
θt,s1,...,sk−1
t′ θt′,s1,...,sk−1
where the θt,s1,...,sk−1 parameters are now independent, as suggested in
[Jaakkola et al., 2000].
The current parameter values are denoted θ0.
Let the current values of θ0
t,s1,...,sk−1 be set so that P
t′,s1,...,sk−1 = 1,
i.e. that θ0
t,s1,...,sk−1 = θ0
t|s1,...,sk−1.
Show that log p(x|θ) = P nt,s1,...,sk−1 log θt|s1,...,sk−1 where nt,s1,...,sk−1 is
the number of instances of the substring sk−1 . . . s1t in x. Thus, following
Leslie et al. , show that
∂log p(x|θ)
∂θt,s1,...,sk−1
= nt,s1,...,sk−1
t|s1,...,sk−1
−ns1,...,sk−1,
where ns1,...,sk−1 is the number of instances of the substring sk−1 . . . s1 in
x. As ns1,...,sk−1θ0
t|s1,...,sk−1 is the expected number of occurrences of the
string sk−1 . . . s1t given the count ns1,...,sk−1, the Fisher score captures the
degree to which this string is over- or under-represented relative to the
model. For the k-spectrum kernel the relevant feature is φsk−1...,s1,t(x) =
nt,s1,...,sk−1.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and
Adaptation of
Hyperparameters
In chapters 2 and 3 we have seen how to do regression and classiﬁcation using
a Gaussian process with a given ﬁxed covariance function. However, in many
practical applications, it may not be easy to specify all aspects of the covariance function with conﬁdence. While some properties such as stationarity of
the covariance function may be easy to determine from the context, we typically
have only rather vague information about other properties, such as the value
of free (hyper-) parameters, e.g. length-scales. In chapter 4 several examples
of covariance functions were presented, many of which have large numbers of
parameters. In addition, the exact form and possible free parameters of the
likelihood function may also not be known in advance. Thus in order to turn
Gaussian processes into powerful practical tools it is essential to develop methods that address the model selection problem. We interpret the model selection
model selection
problem rather broadly, to include all aspects of the model including the discrete choice of the functional form for the covariance function as well as values
for any hyperparameters.
In section 5.1 we outline the model selection problem. In the following sections diﬀerent methodologies are presented: in section 5.2 Bayesian principles
are covered, and in section 5.3 cross-validation is discussed, in particular the
leave-one-out estimator. In the remaining two sections the diﬀerent methodologies are applied speciﬁcally to learning in GP models, for regression in section
5.4 and classiﬁcation in section 5.5.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
The Model Selection Problem
In order for a model to be a practical tool in an application, one needs to make
decisions about the details of its speciﬁcation. Some properties may be easy to
specify, while we typically have only vague information available about other
aspects. We use the term model selection to cover both discrete choices and the
setting of continuous (hyper-) parameters of the covariance functions. In fact,
model selection can help both to reﬁne the predictions of the model, and give
a valuable interpretation to the user about the properties of the data, e.g. that
enable interpretation
a non-stationary covariance function may be preferred over a stationary one.
A multitude of possible families of covariance functions exists, including
squared exponential, polynomial, neural network, etc., see section 4.2 for an
overview. Each of these families typically have a number of free hyperparameters
hyperparameters
whose values also need to be determined. Choosing a covariance function for a
particular application thus comprises both setting of hyperparameters within a
family, and comparing across diﬀerent families. Both of these problems will be
treated by the same methods, so there is no need to distinguish between them,
and we will use the term “model selection” to cover both meanings. We will
refer to the selection of a covariance function and its parameters as training of
a Gaussian process.1 In the following paragraphs we give example choices of
parameterizations of distance measures for stationary covariance functions.
Covariance functions such as the squared exponential can be parameterized
in terms of hyperparameters. For example
k(xp, xq) = σ2
2(xp −xq)⊤M(xp −xq)
where θ = ({M}, σ2
n)⊤is a vector containing all the hyperparameters,2 and
{M} denotes the parameters in the symmetric matrix M. Possible choices for
the matrix M include
M1 = ℓ−2I,
M2 = diag(ℓ)−2,
M3 = ΛΛ⊤+ diag(ℓ)−2,
where ℓis a vector of positive values, and Λ is a D × k matrix, k < D. The
properties of functions with these covariance functions depend on the values of
the hyperparameters. For many covariance functions it is easy to interpret the
meaning of the hyperparameters, which is of great importance when trying to
understand your data. For the squared exponential covariance function eq. (5.1)
with distance measure M2 from eq. (5.2), the ℓ1, . . . , ℓD hyperparameters play
the rˆole of characteristic length-scales; loosely speaking, how far do you need
characteristic
length-scale
to move (along a particular axis) in input space for the function values to become uncorrelated. Such a covariance function implements automatic relevance
automatic relevance
determination
determination (ARD) [Neal, 1996], since the inverse of the length-scale determines how relevant an input is: if the length-scale has a very large value, the
1This contrasts the use of the word in the SVM literature, where “training” usually refers
to ﬁnding the support vectors for a ﬁxed kernel.
2Sometimes the noise level parameter, σ2
n is not considered a hyperparameter; however it
plays an analogous role and is treated in the same way, so we simply consider it a hyperparameter.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.1 The Model Selection Problem
Figure 5.1: Functions with two dimensional input drawn at random from noise free
squared exponential covariance function Gaussian processes, corresponding to the
three diﬀerent distance measures in eq. (5.2) respectively. The parameters were: (a)
ℓ= 1, (b) ℓ= (1, 3)⊤, and (c) Λ = (1, −1)⊤, ℓ= (6, 6)⊤. In panel (a) the two inputs
are equally important, while in (b) the function varies less rapidly as a function of x2
than x1. In (c) the Λ column gives the direction of most rapid variation .
covariance will become almost independent of that input, eﬀectively removing
it from the inference. ARD has been used successfully for removing irrelevant
input by several authors, e.g. Williams and Rasmussen . We call the parameterization of M3 in eq. (5.2) the factor analysis distance due to the analogy
factor analysis distance
with the (unsupervised) factor analysis model which seeks to explain the data
through a low rank plus diagonal decomposition. For high dimensional datasets
the k columns of the Λ matrix could identify a few directions in the input space
with specially high “relevance”, and their lengths give the inverse characteristic
length-scale for those directions.
In Figure 5.1 we show functions drawn at random from squared exponential
covariance function Gaussian processes, for diﬀerent choices of M. In panel
(a) we get an isotropic behaviour. In panel (b) the characteristic length-scale
is diﬀerent along the two input axes; the function varies rapidly as a function
of x1, but less rapidly as a function of x2. In panel (c) the direction of most
rapid variation is perpendicular to the direction (1, 1). As this ﬁgure illustrates,
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
there is plenty of scope for variation even inside a single family of covariance
functions. Our task is, based on a set of training data, to make inferences about
the form and parameters of the covariance function, or equivalently, about the
relationships in the data.
It should be clear from the above example that model selection is essentially
open ended. Even for the squared exponential covariance function, there is a
huge variety of possible distance measures. However, this should not be a cause
for despair, rather seen as a possibility to learn. It requires, however, a systematic and practical approach to model selection. In a nutshell we need to be
able to compare two (or more) methods diﬀering in values of particular parameters, or the shape of the covariance function, or compare a Gaussian process
model to any other kind of model. Although there are endless variations in the
suggestions for model selection in the literature three general principles cover
most: (1) compute the probability of the model given the data, (2) estimate
the generalization error and (3) bound the generalization error. We use the
term generalization error to mean the average error on unseen test examples
(from the same distribution as the training cases). Note that the training error
is usually a poor proxy for the generalization error, since the model may ﬁt
the noise in the training set (over-ﬁt), leading to low training error but poor
generalization performance.
In the next section we describe the Bayesian view on model selection, which
involves the computation of the probability of the model given the data, based
on the marginal likelihood.
In section 5.3 we cover cross-validation, which
estimates the generalization performance.
These two paradigms are applied
to Gaussian process models in the remainder of this chapter. The probably
approximately correct (PAC) framework is an example of a bound on the generalization error, and is covered in section 7.4.2.
Bayesian Model Selection
In this section we give a short outline description of the main ideas in Bayesian
model selection. The discussion will be general, but focusses on issues which will
be relevant for the speciﬁc treatment of Gaussian process models for regression
in section 5.4 and classiﬁcation in section 5.5.
It is common to use a hierarchical speciﬁcation of models. At the lowest level
hierarchical models
are the parameters, w. For example, the parameters could be the parameters
in a linear model, or the weights in a neural network model. At the second level
are hyperparameters θ which control the distribution of the parameters at the
bottom level. For example the “weight decay” term in a neural network, or the
“ridge” term in ridge regression are hyperparameters. At the top level we may
have a (discrete) set of possible model structures, Hi, under consideration.
We will ﬁrst give a “mechanistic” description of the computations needed
for Bayesian inference, and continue with a discussion providing the intuition
about what is going on. Inference takes place one level at a time, by applying
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.2 Bayesian Model Selection
the rules of probability theory, see e.g. MacKay [1992b] for this framework and
MacKay [1992a] for the context of neural networks. At the bottom level, the
level 1 inference
posterior over the parameters is given by Bayes’ rule
p(w|y, X, θ, Hi) = p(y|X, w, Hi)p(w|θ, Hi)
p(y|X, θ, Hi)
where p(y|X, w, Hi) is the likelihood and p(w|θ, Hi) is the parameter prior.
The prior encodes as a probability distribution our knowledge about the parameters prior to seeing the data.
If we have only vague prior information
about the parameters, then the prior distribution is chosen to be broad to
reﬂect this. The posterior combines the information from the prior and the
data (through the likelihood). The normalizing constant in the denominator of
eq. (5.3) p(y|X, θ, Hi) is independent of the parameters, and called the marginal
likelihood (or evidence), and is given by
p(y|X, θ, Hi) =
p(y|X, w, Hi)p(w|θ, Hi) dw.
At the next level, we analogously express the posterior over the hyperparameters, where the marginal likelihood from the ﬁrst level plays the rˆole of the
level 2 inference
likelihood
p(θ|y, X, Hi) = p(y|X, θ, Hi)p(θ|Hi)
p(y|X, Hi)
where p(θ|Hi) is the hyper-prior (the prior for the hyperparameters).
normalizing constant is given by
p(y|X, Hi) =
p(y|X, θ, Hi)p(θ|Hi)dθ.
At the top level, we compute the posterior for the model
level 3 inference
p(Hi|y, X) = p(y|X, Hi)p(Hi)
where p(y|X) = P
i p(y|X, Hi)p(Hi).
We note that the implementation of
Bayesian inference calls for the evaluation of several integrals. Depending on the
details of the models, these integrals may or may not be analytically tractable
and in general one may have to resort to analytical approximations or Markov
chain Monte Carlo (MCMC) methods. In practice, especially the evaluation
of the integral in eq. (5.6) may be diﬃcult, and as an approximation one may
shy away from using the hyperparameter posterior in eq. (5.5), and instead
maximize the marginal likelihood in eq. (5.4) w.r.t. the hyperparameters, θ.
This approximation is known as type II maximum likelihood (ML-II). Of course,
one should be careful with such an optimization step, since it opens up the
possibility of overﬁtting, especially if there are many hyperparameters. The
integral in eq. (5.6) can then be approximated using a local expansion around
the maximum (the Laplace approximation). This approximation will be good
if the posterior for θ is fairly well peaked, which is more often the case for the
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
marginal likelihood, p(y|X,Hi)
all possible data sets
intermediate
Figure 5.2: The marginal likelihood p(y|X, Hi) is the probability of the data, given
the model. The number of data points n and the inputs X are ﬁxed, and not shown.
The horizontal axis is an idealized representation of all possible vectors of targets y.
The marginal likelihood for models of three diﬀerent complexities are shown. Note,
that since the marginal likelihood is a probability distribution, it must normalize
For a particular dataset indicated by y and a dotted line, the marginal
likelihood prefers a model of intermediate complexity over too simple or too complex
alternatives.
hyperparameters than for the parameters themselves, see MacKay for an
illuminating discussion. The prior over models Hi in eq. (5.7) is often taken to
be ﬂat, so that a priori we do not favour one model over another. In this case,
the probability for the model is proportional to the expression from eq. (5.6).
It is primarily the marginal likelihood from eq. (5.4) involving the integral
over the parameter space which distinguishes the Bayesian scheme of inference
from other schemes based on optimization. It is a property of the marginal
likelihood that it automatically incorporates a trade-oﬀbetween model ﬁt and
model complexity. This is the reason why the marginal likelihood is valuable
in solving the model selection problem.
In Figure 5.2 we show a schematic of the behaviour of the marginal likelihood
for three diﬀerent model complexities. Let the number of data points n and
the inputs X be ﬁxed; the horizontal axis is an idealized representation of all
possible vectors of targets y, and the vertical axis plots the marginal likelihood
p(y|X, Hi). A simple model can only account for a limited range of possible sets
of target values, but since the marginal likelihood is a probability distribution
over y it must normalize to unity, and therefore the data sets which the model
does account for have a large value of the marginal likelihood. Conversely for
a complex model: it is capable of accounting for a wider range of data sets,
and consequently the marginal likelihood doesn’t attain such large values as
for the simple model. For example, the simple model could be a linear model,
and the complex model a large neural network. The ﬁgure illustrates why the
marginal likelihood doesn’t simply favour the models that ﬁt the training data
the best. This eﬀect is called Occam’s razor after William of Occam 1285-1349,
Occam’s razor
whose principle: “plurality should not be assumed without necessity” he used
to encourage simplicity in explanations. See also Rasmussen and Ghahramani
 for an investigation into Occam’s razor in statistical models.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.3 Cross-validation
Notice that the trade-oﬀbetween data-ﬁt and model complexity is automatic;
automatic trade-oﬀ
there is no need to set a parameter externally to ﬁx the trade-oﬀ. Do not confuse
the automatic Occam’s razor principle with the use of priors in the Bayesian
method. Even if the priors are “ﬂat” over complexity, the marginal likelihood
will still tend to favour the least complex model able to explain the data. Thus,
a model complexity which is well suited to the data can be selected using the
marginal likelihood.
In the preceding paragraphs we have thought of the speciﬁcation of a model
as the model structure as well as the parameters of the priors, etc.
unclear how to set some of the parameters of the prior, one can treat these as
hyperparameters, and do model selection to determine how to set them. At
the same time it should be emphasized that the priors correspond to (probabilistic) assumptions about the data. If the priors are grossly at odds with the
distribution of the data, inference will still take place under the assumptions
encoded by the prior, see the step-function example in section 5.4.3. To avoid
this situation, one should be careful not to employ priors which are too narrow,
ruling out reasonable explanations of the data.3
Cross-validation
In this section we consider how to use methods of cross-validation (CV) for
cross-validation
model selection. The basic idea is to split the training set into two disjoint sets,
one which is actually used for training, and the other, the validation set, which
is used to monitor performance. The performance on the validation set is used
as a proxy for the generalization error and model selection is carried out using
this measure.
In practice a drawback of hold-out method is that only a fraction of the
full data set can be used for training, and that if the validation set it small,
the performance estimate obtained may have large variance. To minimize these
problems, CV is almost always used in the k-fold cross-validation setting: the
k-fold cross-validation
data is split into k disjoint, equally sized subsets; validation is done on a single
subset and training is done using the union of the remaining k −1 subsets, the
entire procedure being repeated k times, each time with a diﬀerent subset for
validation. Thus, a large fraction of the data can be used for training, and all
cases appear as validation cases. The price is that k models must be trained
instead of one. Typical values for k are in the range 3 to 10.
An extreme case of k-fold cross-validation is obtained for k = n, the number
of training cases, also known as leave-one-out cross-validation (LOO-CV). Ofleave-one-out
cross-validation
ten the computational cost of LOO-CV (“training” n models) is prohibitive, but
in certain cases, such as Gaussian process regression, there are computational
shortcuts.
3This is known as Cromwell’s dictum [Lindley, 1985] after Oliver Cromwell who on August
5th, 1650 wrote to the synod of the Church of Scotland: “I beseech you, in the bowels of
Christ, consider it possible that you are mistaken.”
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
Cross-validation can be used with any loss function. Although the squared
error loss is by far the most common for regression, there is no reason not to
allow other loss functions. For probabilistic models such as Gaussian processes
other loss functions
it is natural to consider also cross-validation using the negative log probability loss. Craven and Wahba describe a variant of cross-validation using
squared error known as generalized cross-validation which gives diﬀerent weightings to diﬀerent datapoints so as to achieve certain invariance properites. See
Wahba [1990, sec. 4.3] for further details.
Model Selection for GP Regression
We apply Bayesian inference in section 5.4.1 and cross-validation in section 5.4.2
to Gaussian process regression with Gaussian noise. We conclude in section
5.4.3 with some more detailed examples of how one can use the model selection
principles to tailor covariance functions.
Marginal Likelihood
Bayesian principles provide a persuasive and consistent framework for inference.
Unfortunately, for most interesting models for machine learning, the required
computations (integrals over parameter space) are analytically intractable, and
good approximations are not easily derived. Gaussian process regression models with Gaussian noise are a rare exception: integrals over the parameters are
analytically tractable and at the same time the models are very ﬂexible. In this
section we ﬁrst apply the general Bayesian inference principles from section
5.2 to the speciﬁc Gaussian process model, in the simpliﬁed form where hyperparameters are optimized over. We derive the expressions for the marginal
likelihood and interpret these.
Since a Gaussian process model is a non-parametric model, it may not be
immediately obvious what the parameters of the model are.
Generally, one
model parameters
may regard the noise-free latent function values at the training inputs f as the
parameters. The more training cases there are, the more parameters. Using
the weight-space view, developed in section 2.1, one may equivalently think
of the parameters as being the weights of the linear model which uses the
basis-functions φ, which can be chosen as the eigenfunctions of the covariance
function. Of course, we have seen that this view is inconvenient for nondegenerate covariance functions, since these would then have an inﬁnite number of
We proceed by applying eq. (5.3) and eq. (5.4) for the 1st level of inference—
which we ﬁnd that we have already done back in chapter 2! The predictive distribution from eq. (5.3) is given for the weight-space view in eq. (2.11) and
eq. (2.12) and equivalently for the function-space view in eq. (2.22).
marginal likelihood (or evidence) from eq. (5.4) was computed in eq. (2.30),
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.4 Model Selection for GP Regression
log probability
characteristic lengthscale
minus complexity penalty
marginal likelihood
Characteristic lengthscale
log marginal likelihood
95% conf int
Figure 5.3:
Panel (a) shows a decomposition of the log marginal likelihood into
its constituents: data-ﬁt and complexity penalty, as a function of the characteristic
length-scale. The training data is drawn from a Gaussian process with SE covariance
function and parameters (ℓ, σf, σn) = (1, 1, 0.1), the same as in Figure 2.5, and we are
ﬁtting only the length-scale parameter ℓ(the two other parameters have been set in
accordance with the generating process). Panel (b) shows the log marginal likelihood
as a function of the characteristic length-scale for diﬀerent sizes of training sets. Also
shown, are the 95% conﬁdence intervals for the posterior length-scales.
and we re-state the result here
log p(y|X, θ) = −1
2 log |Ky| −n
where Ky = Kf + σ2
nI is the covariance matrix for the noisy targets y (and Kf
is the covariance matrix for the noise-free latent f), and we now explicitly write
the marginal likelihood conditioned on the hyperparameters (the parameters of
the covariance function) θ. From this perspective it becomes clear why we call
eq. (5.8) the log marginal likelihood, since it is obtained through marginalizamarginal likelihood
tion over the latent function. Otherwise, if one thinks entirely in terms of the
function-space view, the term “marginal” may appear a bit mysterious, and
similarly the “hyper” from the θ parameters of the covariance function.4
The three terms of the marginal likelihood in eq. (5.8) have readily interinterpretation
pretable rˆoles: the only term involving the observed targets is the data-ﬁt
y y/2; log |Ky|/2 is the complexity penalty depending only on the covariance function and the inputs and n log(2π)/2 is a normalization constant.
In Figure 5.3(a) we illustrate this breakdown of the log marginal likelihood.
The data-ﬁt decreases monotonically with the length-scale, since the model becomes less and less ﬂexible. The negative complexity penalty increases with the
length-scale, because the model gets less complex with growing length-scale.
The marginal likelihood itself peaks at a value close to 1. For length-scales
somewhat longer than 1, the marginal likelihood decreases rapidly (note the
4Another reason that we like to stick to the term “marginal likelihood” is that it is the
likelihood of a non-parametric model, i.e. a model which requires access to all the training
data when making predictions; this contrasts the situation for a parametric model, which
“absorbs” the information from the training data into its (posterior) parameter (distribution).
This diﬀerence makes the two “likelihoods” behave quite diﬀerently as a function of θ.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
characteristic lengthscale
noise standard deviation
Figure 5.4: Contour plot showing the log marginal likelihood as a function of the
characteristic length-scale and the noise level, for the same data as in Figure 2.5 and
Figure 5.3. The signal variance hyperparameter was set to σ2
f = 1. The optimum is
close to the parameters used when generating the data. Note, the two ridges, one
for small noise and length-scale ℓ= 0.4 and another for long length-scale and noise
n = 1. The contour lines spaced 2 units apart in log probability density.
log scale!), due to the poor ability of the model to explain the data, compare to
Figure 2.5(c). For smaller length-scales the marginal likelihood decreases somewhat more slowly, corresponding to models that do accommodate the data,
but waste predictive mass at regions far away from the underlying function,
compare to Figure 2.5(b).
In Figure 5.3(b) the dependence of the log marginal likelihood on the characteristic length-scale is shown for diﬀerent numbers of training cases. Generally,
the more data, the more peaked the marginal likelihood. For very small numbers
of training data points the slope of the log marginal likelihood is very shallow
as when only a little data has been observed, both very short and intermediate
values of the length-scale are consistent with the data. With more data, the
complexity term gets more severe, and discourages too short length-scales.
To set the hyperparameters by maximizing the marginal likelihood, we seek
marginal likelihood
the partial derivatives of the marginal likelihood w.r.t. the hyperparameters.
Using eq. (5.8) and eq. (A.14-A.15) we obtain
log p(y|X, θ) = 1
(αα⊤−K−1)∂K
where α = K−1y.
The complexity of computing the marginal likelihood in eq. (5.8) is dominated
by the need to invert the K matrix (the log determinant of K is easily computed as a by-product of the inverse). Standard methods for matrix inversion of
positive deﬁnite symmetric matrices require time O(n3) for inversion of an n by
n matrix. Once K−1 is known, the computation of the derivatives in eq. (5.9)
requires only time O(n2) per hyperparameter.5 Thus, the computational over-
5Note that matrix-by-matrix products in eq. (5.9) should not be computed directly: in the
ﬁrst term, do the vector-by-matrix multiplications ﬁrst; in the trace term, compute only the
diagonal terms of the product.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.4 Model Selection for GP Regression
head of computing derivatives is small, so using a gradient based optimizer is
advantageous.
Estimation of θ by optimzation of the marginal likelihood has a long history
in spatial statistics, see e.g. Mardia and Marshall . As n increases, one
would hope that the data becomes increasingly informative about θ. However,
it is necessary to contrast what Stein [1999, sec. 3.3] calls ﬁxed-domain asymptotics (where one gets increasingly dense observations within some region) with
increasing-domain asymptotics (where the size of the observation region grows
with n). Increasing-domain asymptotics are a natural choice in a time-series
context but ﬁxed-domain asymptotics seem more natural in spatial (and machine learning) settings. For further discussion see Stein [1999, sec. 6.4].
Figure 5.4 shows an example of the log marginal likelihood as a function
of the characteristic length-scale and the noise standard deviation hyperparameters for the squared exponential covariance function, see eq. (5.1). The
signal variance σ2
f was set to 1.0. The marginal likelihood has a clear maximum
around the hyperparameter values which were used in the Gaussian process
from which the data was generated.
Note that for long length-scales and a
noise level of σ2
n = 1, the marginal likelihood becomes almost independent of
the length-scale; this is caused by the model explaining everything as noise,
and no longer needing the signal covariance. Similarly, for small noise and a
length-scale of ℓ= 0.4, the marginal likelihood becomes almost independent of
the noise level; this is caused by the ability of the model to exactly interpolate
the data at this short length-scale. We note that although the model in this
hyperparameter region explains all the data-points exactly, this model is still
disfavoured by the marginal likelihood, see Figure 5.2.
There is no guarantee that the marginal likelihood does not suﬀer from mulmultiple local maxima
tiple local optima. Practical experience with simple covariance functions seem
to indicate that local maxima are not a devastating problem, but certainly they
do exist. In fact, every local maximum corresponds to a particular interpretation of the data. In Figure 5.5 an example with two local optima is shown,
together with the corresponding (noise free) predictions of the model at each
of the two local optima. One optimum corresponds to a relatively complicated
model with low noise, whereas the other corresponds to a much simpler model
with more noise. With only 7 data points, it is not possible for the model to
conﬁdently reject either of the two possibilities. The numerical value of the
marginal likelihood for the more complex model is about 60% higher than for
the simple model. According to the Bayesian formalism, one ought to weight
predictions from alternative explanations according to their posterior probabilities. In practice, with data sets of much larger sizes, one often ﬁnds that one
local optimum is orders of magnitude more probable than other local optima,
so averaging together alternative explanations may not be necessary. However,
care should be taken that one doesn’t end up in a bad local optimum.
Above we have described how to adapt the parameters of the covariance
function given one dataset. However, it may happen that we are given several
datasets all of which are assumed to share the same hyperparameters; this
is known as multi-task learning, see e.g. Caruana . In this case one can
multi-task learning
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
characteristic lengthscale
noise standard deviation
Figure 5.5: Panel (a) shows the marginal likelihood as a function of the hyperparameters ℓ(length-scale) and σ2
n (noise standard deviation), where σ2
f = 1 (signal standard
deviation) for a data set of 7 observations (seen in panels (b) and (c)). There are
two local optima, indicated with ’+’: the global optimum has low noise and a short
length-scale; the local optimum has a high noise and a long length scale. In (b) and (c)
the inferred underlying functions (and 95% conﬁdence intervals) are shown for each
of the two solutions. In fact, the data points were generated by a Gaussian process
with (ℓ, σ2
n) = (1, 1, 0.1) in eq. (5.1).
simply sum the log marginal likelihoods of the individual problems and optimize
this sum w.r.t. the hyperparameters [Minka and Picard, 1999].
Cross-validation
The predictive log probability when leaving out training case i is
negative log validation
density loss
log p(yi|X, y−i, θ) = −1
i −(yi −µi)2
where the notation y−i means all targets except number i, and µi and σ2
computed according to eq. (2.23) and (2.24) respectively, in which the training
sets are taken to be (X−i, y−i). Accordingly, the LOO log predictive probability
LLOO(X, y, θ) =
log p(yi|X, y−i, θ),
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.4 Model Selection for GP Regression
see [Geisser and Eddy, 1979] for a discussion of this and related approaches.
LLOO in eq. (5.11) is sometimes called the log pseudo-likelihood. Notice, that
pseudo-likelihood
in each of the n LOO-CV rotations, inference in the Gaussian process model
(with ﬁxed hyperparameters) essentially consists of computing the inverse covariance matrix, to allow predictive mean and variance in eq. (2.23) and (2.24)
to be evaluated (i.e. there is no parameter-ﬁtting, such as there would be in a
parametric model). The key insight is that when repeatedly applying the prediction eq. (2.23) and (2.24), the expressions are almost identical: we need the
inverses of covariance matrices with a single column and row removed in turn.
This can be computed eﬃciently from the inverse of the complete covariance
matrix using inversion by partitioning, see eq. (A.11-A.12). A similar insight
has also been used for spline models, see e.g. Wahba [1990, sec. 4.2]. The approach was used for hyperparameter selection in Gaussian process models in
Sundararajan and Keerthi . The expressions for the LOO-CV predictive
mean and variance are
µi = yi −[K−1y]i/[K−1]ii,
i = 1/[K−1]ii,
where careful inspection reveals that the mean µi is in fact independent of yi as
indeed it should be. The computational expense of computing these quantities
is O(n3) once for computing the inverse of K plus O(n2) for the entire LOO-
CV procedure (when K−1 is known). Thus, the computational overhead for
the LOO-CV quantities is negligible. Plugging these expressions into eq. (5.10)
and (5.11) produces a performance estimator which we can optimize w.r.t. hyperparameters to do model selection. In particular, we can compute the partial
derivatives of LLOO w.r.t. the hyperparameters (using eq. (A.14)) and use conjugate gradient optimization. To this end, we need the partial derivatives of
the LOO-CV predictive mean and variances from eq. (5.12) w.r.t. the hyperparameters
−αi[ZjK−1]ii
= [ZjK−1]ii
where α = K−1y and Zj = K−1 ∂K
∂θj . The partial derivatives of eq. (5.11) are
obtained by using the chain-rule and eq. (5.13) to give
∂log p(yi|X, y−i, θ)
+ ∂log p(yi|X, y−i, θ)
αi[Zjα]i −1
The computational complexity is O(n3) for computing the inverse of K, and
O(n3) per hyperparameter 6 for the derivative eq. (5.14). Thus, the computational burden of the derivatives is greater for the LOO-CV method than for the
method based on marginal likelihood, eq. (5.9).
6Computation of the matrix-by-matrix product K−1 ∂K
∂θj for each hyperparameter is unavoidable.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
In eq. (5.10) we have used the log of the validation density as a crossvalidation measure of ﬁt (or equivalently, the negative log validation density as
a loss function). One could also envisage using other loss functions, such as the
commonly used squared error. However, this loss function is only a function
LOO-CV with squared
error loss
of the predicted mean and ignores the validation set variances. Further, since
the mean prediction eq. (2.23) is independent of the scale of the covariances
(i.e. you can multiply the covariance of the signal and noise by an arbitrary
positive constant without changing the mean predictions), one degree of freedom
is left undetermined7 by a LOO-CV procedure based on squared error loss (or
any other loss function which depends only on the mean predictions). But, of
course, the full predictive distribution does depend on the scale of the covariance
function. Also, computation of the derivatives based on the squared error loss
has similar computational complexity as the negative log validation density loss.
In conclusion, it seems unattractive to use LOO-CV based on squared error loss
for hyperparameter selection.
Comparing the pseudo-likelihood for the LOO-CV methodology with the
marginal likelihood from the previous section, it is interesting to ask under
which circumstances each method might be preferable. Their computational
demands are roughly identical. This issue has not been studied much empirically. However, it is interesting to note that the marginal likelihood tells us
the probability of the observations given the assumptions of the model. This
contrasts with the frequentist LOO-CV value, which gives an estimate for the
(log) predictive probability, whether or not the assumptions of the model may
be fulﬁlled. Thus Wahba [1990, sec. 4.8] has argued that CV procedures should
be more robust against model mis-speciﬁcation.
Examples and Discussion
In the following we give three examples of model selection for regression models.
We ﬁrst describe a 1-d modelling task which illustrates how special covariance
functions can be designed to achieve various useful eﬀects, and can be evaluated
using the marginal likelihood. Secondly, we make a short reference to the model
selection carried out for the robot arm problem discussed in chapter 2 and again
in chapter 8. Finally, we discuss an example where we deliberately choose a
covariance function that is not well-suited for the problem; this is the so-called
mis-speciﬁed model scenario.
Mauna Loa Atmospheric Carbon Dioxide
We will use a modelling problem concerning the concentration of CO2 in the
atmosphere to illustrate how the marginal likelihood can be used to set multiple
hyperparameters in hierarchical Gaussian process models. A complex covariance function is derived by combining several diﬀerent kinds of simple covariance
functions, and the resulting model provides an excellent ﬁt to the data as well
7In the special case where we know either the signal or the noise variance there is no
indeterminancy.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.4 Model Selection for GP Regression
CO2 concentration, ppm
Figure 5.6: The 545 observations of monthly averages of the atmospheric concentration of CO2 made between 1958 and the end of 2003, together with 95% predictive
conﬁdence region for a Gaussian process regression model, 20 years into the future.
Rising trend and seasonal variations are clearly visible. Note also that the conﬁdence
interval gets wider the further the predictions are extrapolated.
as insights into its properties by interpretation of the adapted hyperparameters. Although the data is one-dimensional, and therefore easy to visualize, a
total of 11 hyperparameters are used, which in practice rules out the use of
cross-validation for setting parameters, except for the gradient-based LOO-CV
procedure from the previous section.
The data [Keeling and Whorf, 2004] consists of monthly average atmospheric
CO2 concentrations (in parts per million by volume (ppmv)) derived from in situ
air samples collected at the Mauna Loa Observatory, Hawaii, between 1958 and
2003 (with some missing values).8 The data is shown in Figure 5.6. Our goal is
the model the CO2 concentration as a function of time x. Several features are
immediately apparent: a long term rising trend, a pronounced seasonal variation
and some smaller irregularities. In the following we suggest contributions to a
combined covariance function which takes care of these individual properties.
This is meant primarily to illustrate the power and ﬂexibility of the Gaussian
process framework—it is possible that other choices would be more appropriate
for this data set.
To model the long term smooth rising trend we use a squared exponential
smooth trend
(SE) covariance term, with two hyperparameters controlling the amplitude θ1
and characteristic length-scale θ2
k1(x, x′) = θ2
Note that we just use a smooth trend; actually enforcing the trend a priori to
be increasing is probably not so simple and (hopefully) not desirable. We can
use the periodic covariance function from eq. (4.31) with a period of one year to
seasonal component
model the seasonal variation. However, it is not clear that the seasonal trend is
8The data is available from 
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
1960 1970 1980 1990 2000 2010 2020
CO2 concentration, ppm
CO2 concentration, ppm
CO2 concentration, ppm
Figure 5.7: Panel (a): long term trend, dashed, left hand scale, predicted by the
squared exponential contribution; superimposed is the medium term trend, full line,
right hand scale, predicted by the rational quadratic contribution; the vertical dashdotted line indicates the upper limit of the training data. Panel (b) shows the seasonal
variation over the year for three diﬀerent years. The concentration peaks in mid May
and has a low in the beginning of October. The seasonal variation is smooth, but
not of exactly sinusoidal shape. The peak-to-peak amplitude increases from about 5.5
ppm in 1958 to about 7 ppm in 2003, but the shape does not change very much. The
characteristic decay length of the periodic component is inferred to be 90 years, so
the seasonal trend changes rather slowly, as also suggested by the gradual progression
between the three years shown.
exactly periodic, so we modify eq. (4.31) by taking the product with a squared
exponential component (using the product construction from section 4.2.4), to
allow a decay away from exact periodicity
k2(x, x′) = θ2
−2 sin2(π(x −x′))
where θ3 gives the magnitude, θ4 the decay-time for the periodic component,
and θ5 the smoothness of the periodic component; the period has been ﬁxed
to one (year).
The seasonal component in the data is caused primarily by
diﬀerent rates of CO2 uptake for plants depending on the season, and it is
probably reasonable to assume that this pattern may itself change slowly over
time, partially due to the elevation of the CO2 level itself; if this eﬀect turns
out not to be relevant, then it can be eﬀectively removed at the ﬁtting stage by
allowing θ4 to become very large.
To model the (small) medium term irregularities a rational quadratic term
medium term
irregularities
is used, eq. (4.19)
k3(x, x′) = θ2
1 + (x −x′)2
where θ6 is the magnitude, θ7 is the typical length-scale and θ8 is the shape parameter determining diﬀuseness of the length-scales, see the discussion on page
87. One could also have used a squared exponential form for this component,
but it turns out that the rational quadratic works better (gives higher marginal
likelihood), probably because it can accommodate several length-scales.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.4 Model Selection for GP Regression
Figure 5.8: The time course of the seasonal eﬀect, plotted in a months vs. year plot
(with wrap-around continuity between the edges). The labels on the contours are in
ppmv of CO2. The training period extends up to the dashed line. Note the slow
development: the height of the May peak may have started to recede, but the low in
October may currently be deepening further. The seasonal eﬀects from three
particular years were also plotted in Figure 5.7(b).
Finally we specify a noise model as the sum of a squared exponential connoise terms
tribution and an independent component
k4(xp, xq) = θ2
−(xp −xq)2
where θ9 is the magnitude of the correlated noise component, θ10 is its lengthscale and θ11 is the magnitude of the independent noise component. Noise in
the series could be caused by measurement inaccuracies, and by local short-term
weather phenomena, so it is probably reasonable to assume at least a modest
amount of correlation in time. Notice that the correlated noise component, the
ﬁrst term of eq. (5.18), has an identical expression to the long term component
in eq. (5.15). When optimizing the hyperparameters, we will see that one of
these components becomes large with a long length-scale (the long term trend),
while the other remains small with a short length-scale (noise). The fact that
we have chosen to call one of these components ‘signal’ and the other one ‘noise’
is only a question of interpretation. Presumably we are less interested in very
short-term eﬀect, and thus call it noise; if on the other hand we were interested
in this eﬀect, we would call it signal.
The ﬁnal covariance function is
k(x, x′) = k1(x, x′) + k2(x, x′) + k3(x, x′) + k4(x, x′),
with hyperparameters θ = (θ1, . . . , θ11)⊤. We ﬁrst subtract the empirical mean
of the data (341 ppm), and then ﬁt the hyperparameters by optimizing the
parameter estimation
marginal likelihood using a conjugate gradient optimizer. To avoid bad local
minima (e.g. caused by swapping rˆoles of the rational quadratic and squared
exponential terms) a few random restarts are tried, picking the run with the
best marginal likelihood, which was log p(y|X, θ) = −108.5.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
We now examine and interpret the hyperparameters which optimize the
marginal likelihood. The long term trend has a magnitude of θ1 = 66 ppm
and a length scale of θ2 = 67 years. The mean predictions inside the range
of the training data and extending for 20 years into the future are depicted in
Figure 5.7 (a). In the same plot (with right hand axis) we also show the medium
term eﬀects modelled by the rational quadratic component with magnitude
θ6 = 0.66 ppm, typical length θ7 = 1.2 years and shape θ8 = 0.78. The very
small shape value allows for covariance at many diﬀerent length-scales, which
is also evident in Figure 5.7 (a). Notice that beyond the edge of the training
data the mean of this contribution smoothly decays to zero, but of course it
still has a contribution to the uncertainty, see Figure 5.6.
The hyperparameter values for the decaying periodic contribution are: magnitude θ3 = 2.4 ppm, decay-time θ4 = 90 years, and the smoothness of the
periodic component is θ5 = 1.3.
The quite long decay-time shows that the
data have a very close to periodic component in the short term. In Figure 5.7
(b) we show the mean periodic contribution for three years corresponding to
the beginning, middle and end of the training data. This component is not
exactly sinusoidal, and it changes its shape slowly over time, most notably the
amplitude is increasing, see Figure 5.8.
For the noise components, we get the amplitude for the correlated component θ9 = 0.18 ppm, a length-scale of θ10 = 1.6 months and an independent
noise magnitude of θ11 = 0.19 ppm. Thus, the correlation length for the noise
component is indeed inferred to be short, and the total magnitude of the noise
11 = 0.26 ppm, indicating that the data can be explained very
well by the model. Note also in Figure 5.6 that the model makes relatively
conﬁdent predictions, the 95% conﬁdence region being 16 ppm wide at a 20
year prediction horizon.
In conclusion, we have seen an example of how non-trivial structure can be
inferred by using composite covariance functions, and that the ability to leave
hyperparameters to be determined by the data is useful in practice. Of course
a serious treatment of such data would probably require modelling of other
eﬀects, such as demographic and economic indicators too. Finally, one may
want to use a real time-series approach (not just a regression from time to CO2
level as we have done here), to accommodate causality, etc. Nevertheless, the
ability of the Gaussian process to avoid simple parametric assumptions and still
build in a lot of structure makes it, as we have seen, a very attractive model in
many application domains.
Robot Arm Inverse Dynamics
We have discussed the use of GPR for the SARCOS robot arm inverse dynamics
problem in section 2.5. This example is also further studied in section 8.3.7
where a variety of approximation methods are compared, because the size of
the training set (44, 484 examples) precludes the use of simple GPR due to its
O(n2) storage and O(n3) time complexity.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.4 Model Selection for GP Regression
Figure 5.9: Mis-speciﬁcation example. Fit to 64 datapoints drawn from a step function with Gaussian noise with standard deviation σn = 0.1. The Gaussian process
models are using a squared exponential covariance function. Panel (a) shows the mean
and 95% conﬁdence interval for the noisy signal in grey, when the hyperparameters are
chosen to maximize the marginal likelihood. Panel (b) shows the resulting model when
the hyperparameters are chosen using leave-one-out cross-validation (LOO-CV). Note
that the marginal likelihood chooses a high noise level and long length-scale, whereas
LOO-CV chooses a smaller noise level and shorter length-scale. It is not immediately
obvious which ﬁt it worse.
One of the techniques considered in section 8.3.7 is the subset of datapoints
(SD) method, where we simply discard some of the data and only make use
of m < n training examples. Given a subset of the training data of size m
selected at random, we adjusted the hyperparameters by optimizing either the
marginal likelihood or LLOO. As ARD was used, this involved adjusting D +
2 = 23 hyperparameters. This process was repeated 10 times with diﬀerent
random subsets of the data selected for both m = 1024 and m = 2048. The
results show that the predictive accuracy obtained from the two optimization
methods is very similar on both standardized mean squared error (SMSE) and
mean standardized log loss (MSLL) criteria, but that the marginal likelihood
optimization is much quicker.
Step function example illustrating mis-speciﬁcation
In this section we discuss the mis-speciﬁed model scenario, where we attempt
to learn the hyperparameters for a covariance function which is not very well
suited to the data. The mis-speciﬁcation arises because the data comes from a
function which has either zero or very low probability under the GP prior. One
could ask why it is interesting to discuss this scenario, since one should surely
simply avoid choosing such a model in practice. While this is true in theory,
for practical reasons such as the convenience of using standard forms for the
covariance function or because vague prior information, one inevitably ends up
in a situation which resembles some level of mis-speciﬁcation.
As an example, we use data from a noisy step function and ﬁt a GP model
with a squared exponential covariance function, Figure 5.9.
There is misspeciﬁcation because it would be very unlikely that samples drawn from a GP
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
Figure 5.10: Same data as in Figure 5.9.
Panel (a) shows the result of using a
covariance function which is the sum of two squared-exponential terms. Although this
is still a stationary covariance function, it gives rise to a higher marginal likelihood
than for the squared-exponential covariance function in Figure 5.9(a), and probably
also a better ﬁt. In panel (b) the neural network covariance function eq. (4.29) was
used, providing a much larger marginal likelihood and a very good ﬁt.
with the stationary SE covariance function would look like a step function. For
short length-scales samples can vary quite quickly, but they would tend to vary
rapidly all over, not just near the step. Conversely a stationary SE covariance
function with a long length-scale could model the ﬂat parts of the step function
but not the rapid transition. Note that Gibbs’ covariance function eq. (4.32)
would be one way to achieve the desired eﬀect. It is interesting to note the differences between the model optimized with marginal likelihood in Figure 5.9(a),
and one optimized with LOO-CV in panel (b) of the same ﬁgure. See exercise
5.6.2 for more on how these two criteria weight the inﬂuence of the prior.
For comparison, we show the predictive distribution for two other covariance functions in Figure 5.10. In panel (a) a sum of two squared exponential
terms were used in the covariance. Notice that this covariance function is still
stationary, but it is more ﬂexible than a single squared exponential, since it has
two magnitude and two length-scale parameters. The predictive distribution
looks a little bit better, and the value of the log marginal likelihood improves
from −37.7 in Figure 5.9(a) to −26.1 in Figure 5.10(a). We also tried the neural
network covariance function from eq. (4.29), which is ideally suited to this case,
since it allows saturation at diﬀerent values in the positive and negative directions of x. As shown in Figure 5.10(b) the predictions are also near perfect,
and the log marginal likelihood is much larger at 50.2.
Model Selection for GP Classiﬁcation
In this section we compute the derivatives of the approximate marginal likelihood for the Laplace and EP methods for binary classiﬁcation which are needed
for training. We also give the detailed algorithms for these, and brieﬂy discuss
the possible use of cross-validation and other methods for training binary GP
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.5 Model Selection for GP Classiﬁcation
classiﬁers.
Derivatives of the Marginal Likelihood for Laplace’s ∗
Approximation
Recall from section 3.4.4 that the approximate log marginal likelihood was given
in eq. (3.32) as
log q(y|X, θ) = −1
ˆf ⊤K−1ˆf + log p(y|ˆf) −1
2 log |B|,
where B = I + W
2 and ˆf is the maximum of the posterior eq. (3.12)
found by Newton’s method in Algorithm 3.1, and W is the diagonal matrix
W = −∇∇log p(y|ˆf). We can now optimize the approximate marginal likelihood q(y|X, θ) w.r.t. the hyperparameters, θ. To this end we seek the partial
derivatives of ∂q(y|X, θ)/∂θj. The covariance matrix K is a function of the hyperparameters, but ˆf and therefore W are also implicitly functions of θ, since
when θ changes, the optimum of the posterior ˆf also changes. Thus
∂log q(y|X, θ)
= ∂log q(y|X, θ)
∂log q(y|X, θ)
by the chain rule. Using eq. (A.14) and eq. (A.15) the explicit term is given by
∂log q(y|X, θ)
ˆf ⊤K−1 ∂K
(W −1+K)−1 ∂K
When evaluating the remaining term from eq. (5.21), we utilize the fact that
ˆf is the maximum of the posterior, so that ∂Ψ(f)/∂f = 0 at f = ˆf, where the
(un-normalized) log posterior Ψ(f) is deﬁned in eq. (3.12); thus the implicit
derivatives of the two ﬁrst terms of eq. (5.20) vanish, leaving only
∂log q(y|X, θ)
(K−1 + W)−1 ∂W
(K−1 + W)−1
log p(y|ˆf).
In order to evaluate the derivative ∂ˆf/∂θj, we diﬀerentiate the self-consistent
eq. (3.17) ˆf = K∇log p(y|ˆf) to obtain
∇log p(y|ˆf)+K ∂∇log p(y|ˆf)
= (I +KW)−1 ∂K
∇log p(y|ˆf),
where we have used the chain rule ∂/∂θj = ∂ˆf/∂θj · ∂/∂ˆf and the identity
∂∇log p(y|ˆf)/∂ˆf = −W.
The desired derivatives are obtained by plugging
eq. (5.22-5.24) into eq. (5.21).
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Model Selection and Adaptation of Hyperparameters
input: X (inputs), y (±1 targets), θ (hypers), p(y|f) (likelihood function)
2: compute K
compute covariance matrix from X and θ
(f, a) := mode
 K, y, p(y|f)
locate posterior mode using Algorithm 3.1
4: W := −∇∇log p(y|f)
L := cholesky(I + W
solve LL⊤= B = I + W
6: log Z := −1
2a⊤f + log p(y|f) −P log(diag(L))
eq. (5.20)
8: C := L\(W
 diag(K) −diag(C⊤C)
∇3 log p(y|f)
eq. (5.23)
10: for j := 1 . . . dim(θ) do
C := ∂K/∂θj
compute derivative matrix from X and θ
eq. (5.22)
b := C∇log p(y|f)
s3 := b −KRb
eq. (5.24)
∇j log Z := s1 + s⊤
eq. (5.21)
16: end for
return: log Z (log marginal likelihood), ∇log Z (partial derivatives)
Algorithm 5.1: Compute the approximate log marginal likelihood and its derivatives
w.r.t. the hyperparameters for binary Laplace GPC for use by an optimization routine,
such as conjugate gradient optimization. In line 3 Algorithm 3.1 on page 46 is called
to locate the posterior mode. In line 12 only the diagonal elements of the matrix
product should be computed. In line 15 the notation ∇j means the partial derivative
w.r.t. the j’th hyperparameter. An actual implementation may also return the value
of f to be used as an initial guess for the subsequent call (as an alternative the zero
initialization in line 2 of Algorithm 3.1).
Details of the Implementation
The implementation of the log marginal likelihood and its partial derivatives
w.r.t. the hyperparameters is shown in Algorithm 5.1. It is advantageous to rewrite the equations from the previous section in terms of well-conditioned symmetric positive deﬁnite matrices, whose solutions can be obtained by Cholesky
factorization, combining numerical stability with computational speed.
In detail, the matrix of central importance turns out to be
R = (W −1 + K)−1 = W
where the right hand side is suitable for numerical evaluation as in line 7 of
Algorithm 5.1, reusing the Cholesky factor L from the Newton scheme above.
Remember that W is diagonal so eq. (5.25) does not require any real matrix-bymatrix products. Rewriting eq. (5.22-5.23) is straightforward, and for eq. (5.24)
we apply the matrix inversion lemma (eq. (A.9)) to (I + KW)−1 to obtain
I −KR, which is used in the implementation.
The computational complexity is dominated by the Cholesky factorization
in line 5 which takes n3/6 operations per iteration of the Newton scheme. In
addition the computation of R in line 7 is also O(n3), all other computations
being at most O(n2) per hyperparameter.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
5.5 Model Selection for GP Classiﬁcation
input: X (inputs), y (±1 targets), θ (hyperparameters)
2: compute K
compute covariance matrix from X and θ
(˜ν, ˜τ, log ZEP) := EP
run the EP Algorithm 3.5
4: L := cholesky(I + ˜S
solve LL⊤= B = I + ˜S
b := ˜ν −˜S
2 L\(L⊤\ ˜S
b from under eq. (5.27)
6: R := bb⊤−˜S
2 L⊤\(L\ ˜S
R = bb⊤−˜S
for j := 1 . . . dim(θ) do
C := ∂K/∂θj
compute derivative matrix from X and θ
∇j log ZEP := 1
eq. (5.27)
10: end for
return: log ZEP (log marginal likelihood), ∇log ZEP (partial derivatives)
Algorithm 5.2: Compute the log marginal likelihood and its derivatives w.r.t. the
hyperparameters for EP binary GP classiﬁcation for use by an optimization routine,
such as conjugate gradient optimization. ˜S is a diagonal precision matrix with entries
˜Sii = ˜τi. In line 3 Algorithm 3.5 on page 58 is called to compute parameters of the EP
approximation. In line 9 only the diagonal of the matrix product should be computed
and the notation ∇j means the partial derivative w.r.t. the j’th hyperparameter. The
computational complexity is dominated by the Cholesky factorization in line 4 and
the solution in line 6, both of which are O(n3).
Derivatives of the Marginal Likelihood for EP
Optimization of the EP approximation to the marginal likelihood w.r.t. the
hyperparameters of the covariance function requires evaluation of the partial
derivatives from eq. (3.65).
Luckily, it turns out that implicit terms in the
derivatives caused by the solution of EP being a function of the hyperparameters is exactly zero. We will not present the proof here, see Seeger .
Consequently, we only have to take account of the explicit dependencies
2 ˜µ⊤(K + ˜Σ)−1 ˜µ −1
2 log |K + ˜Σ|
2 ˜µ⊤(K + ˜S−1)−1 ∂K
(K + ˜S−1)−1 ˜µ −1
 (K + ˜S−1)−1 ∂K
In Algorithm 5.2 the derivatives from eq. (5.26) are implemented using
where b = , this eﬀect is probably very small and indeed Opper and Winther
[2000, sec. 8] report very high precision for these LOO-CV estimates. As an
alternative k-fold CV could be used explicitly for some moderate value of k.
Other Methods for Setting Hyperparameters
Above we have considered setting hyperparameters by optimizing the marginal
likelihood or cross-validation criteria. However, some other criteria have been
proposed in the literature.
For example Cristianini et al. deﬁne the
alignment between a Gram matrix K and the corresponding +1/−1 vector of
targets y as
where ∥K∥F denotes the Frobenius norm of the matrix K, as deﬁned in eq. (A.16).
Lanckriet et al. show that if K is a convex combination of Gram matrices Ki so that K = P
i νiKi with νi ≥0 for all i then the optimization of
the alignment score w.r.t. the νi’s can be achieved by solving a semideﬁnite
programming problem.
For an example of model selection, refer to section 3.7.
Although the experiments there were done by exhaustively evaluating the marginal likelihood for a
whole grid of hyperparameter values, the techniques described in this chapter
could be used to locate the same solutions more eﬃciently.
1. The optimization of the marginal likelihood w.r.t. the hyperparameters
is generally not possible in closed form. Consider, however, the situation
where one hyperparameter, θ0 gives the overall scale of the covariance
ky(x, x′) = θ0˜ky(x, x′),
where ky is the covariance function for the noisy targets (i.e. including
noise contributions) and ˜ky(x, x′) may depend on further hyperparameters, θ1, θ2, . . ..
Show that the marginal likelihood can be optimized
w.r.t. θ0 in closed form.
2. Consider the diﬀerence between the log marginal likelihood given by:
i log p(yi|{yj, j < i}), and the LOO-CV using log probability which is
given by P
i log p(yi|{yj, j ̸= i}).
From the viewpoint of the marginal
likelihood the LOO-CV conditions too much on the data. Show that the
expected LOO-CV loss is greater than the expected marginal likelihood.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs
and Other Models
In this chapter we discuss a number of concepts and models that are related to
Gaussian process prediction. In section 6.1 we cover reproducing kernel Hilbert
spaces (RKHSs), which deﬁne a Hilbert space of suﬃciently-smooth functions
corresponding to a given positive semideﬁnite kernel k.
As we discussed in chapter 1, there are many functions that are consistent
with a given dataset D.
We have seen how the GP approach puts a prior
over functions in order to deal with this issue. A related viewpoint is provided
by regularization theory (described in section 6.2) where one seeks a trade-oﬀ
between data-ﬁt and the RKHS norm of function. This is closely related to the
MAP estimator in GP prediction, and thus omits uncertainty in predictions
and also the marginal likelihood. In section 6.3 we discuss splines, a special
case of regularization which is obtained when the RKHS is deﬁned in terms of
diﬀerential operators of a given order.
There are a number of other families of kernel machines that are related
to Gaussian process prediction. In section 6.4 we describe support vector machines, in section 6.5 we discuss least-squares classiﬁcation (LSC), and in section
6.6 we cover relevance vector machines (RVMs).
Reproducing Kernel Hilbert Spaces
Here we present a brief introduction to reproducing kernel Hilbert spaces. The
theory was developed by Aronszajn ; a more recent treatise is Saitoh
 . Information can also be found in Wahba , Sch¨olkopf and Smola
 and Wegman . The collection of papers edited by Weinert 
provides an overview of the uses of RKHSs in statistical signal processing.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
We start with a formal deﬁnition of a RKHS, and then describe two speciﬁc
bases for a RKHS, ﬁrstly through Mercer’s theorem and the eigenfunctions of
k, and secondly through the reproducing kernel map.
Deﬁnition 6.1 (Reproducing kernel Hilbert space). Let H be a Hilbert space
of real functions f deﬁned on an index set X. Then H is called a reproducing
kernel Hilbert space endowed with an inner product ⟨·, ·⟩H (and norm ∥f∥H =
⟨f, f⟩H) if there exists a function k : X ×X →R with the following properties:
1. for every x, k(x, x′) as a function of x′ belongs to H, and
2. k has the reproducing property ⟨f(·), k(·, x)⟩H = f(x).
reproducing property
See e.g. Sch¨olkopf and Smola and Wegman . Note also that as
k(x, ·) and k(x′, ·) are in H we have that ⟨k(x, ·), k(x′, ·)⟩H = k(x, x′).
The RKHS uniquely determines k, and vice versa, as stated in the following
Theorem 6.1 (Moore-Aronszajn theorem, Aronszajn ). Let X be an index set. Then for every positive deﬁnite function k(·, ·) on X × X there exists
a unique RKHS, and vice versa.
The Hilbert space L2 (which has the dot product ⟨f, g⟩L2 =
f(x)g(x)dx)
contains many non-smooth functions. In L2 (which is not a RKHS) the delta
function is the representer of evaluation, i.e. f(x) =
f(x′)δ(x−x′)dx′. Kernels
are the analogues of delta functions within the smoother RKHS. Note that the
delta function is not itself in L2; in contrast for a RKHS the kernel k is the
representer of evaluation and is itself in the RKHS.
The above description is perhaps rather abstract. For our purposes the key
intuition behind the RKHS formalism is that the squared norm ∥f∥2
thought of as a generalization to functions of the n-dimensional quadratic form
f ⊤K−1f we have seen in earlier chapters.
Consider a real positive semideﬁnite kernel k(x, x′) with an eigenfunction
expansion k(x, x′) = PN
i=1λiφi(x)φi(x′) relative to a measure µ. Recall from
Mercer’s theorem that the eigenfunctions are orthonormal w.r.t. µ, i.e. we have
φi(x)φj(x) dµ(x) = δij. We now consider a Hilbert space comprised of linear
combinations of the eigenfunctions, i.e. f(x) = PN
i=1fiφi(x) with PN
We assert that the inner product ⟨f, g⟩H in the Hilbert space between
inner product
functions f(x) and g(x) = PN
i=1giφi(x) is deﬁned as
Thus this Hilbert space is equipped with a norm ∥f∥H where ∥f∥2
H = ⟨f, f⟩H =
i /λi. Note that for ∥f∥H to be ﬁnite the sequence of coeﬃcients {fi}
must decay quickly; eﬀectively this imposes a smoothness condition on the
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.1 Reproducing Kernel Hilbert Spaces
We now need to show that this Hilbert space is the RKHS corresponding to
the kernel k, i.e. that it has the reproducing property. This is easily achieved
⟨f(·), k(·, x)⟩H =
⟨k(x, ·), k(x′, ·)⟩H =
λiφi(x)λiφi(x′)
= k(x, x′).
Notice also that k(x, ·) is in the RKHS as it has norm PN
i=1(λiφi(x))2/λi =
k(x, x) < ∞. We have now demonstrated that the Hilbert space comprised of
linear combinations of the eigenfunctions with the restriction PN
fulﬁls the two conditions given in Deﬁnition 6.1. As there is a unique RKHS
associated with k(·, ·), this Hilbert space must be that RKHS.
The advantage of the abstract formulation of the RKHS is that the eigenbasis
will change as we use diﬀerent measures µ in Mercer’s theorem. However, the
RKHS norm is in fact solely a property of the kernel and is invariant under
this change of measure. This can be seen from the fact that the proof of the
RKHS properties above is not dependent on the measure; see also Kailath
[1971, sec. II.B]. A ﬁnite-dimensional example of this measure invariance is
explored in exercise 6.7.1.
Notice the analogy between the RKHS norm ∥f∥2
H = ⟨f, f⟩H = PN
and the quadratic form f ⊤K−1f; if we express K and f in terms of the eigenvectors of K we obtain exactly the same form (but the sum has only n terms if
f has length n).
If we sample the coeﬃcients fi in the eigenexpansion f(x) = PN
i=1fiφi(x)
from N(0, λi) then
Thus if N is inﬁnite the sample functions are not in H (with probability 1)
as the expected value of the RKHS norm is inﬁnite; see Wahba [1990, p. 5]
and Kailath [1971, sec. II.B] for further details. However, note that although
sample functions of this Gaussian process are not in H, the posterior mean after
observing some data will lie in the RKHS, due to the smoothing properties of
averaging.
Another view of the RKHS can be obtained from the reproducing kernel
map construction. We consider the space of functions f deﬁned as
αik(x, xi) : n ∈N, xi ∈X, αi ∈R
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
Now let g(x) = Pn′
j). Then we deﬁne the inner product
Clearly condition 1 of Deﬁnition 6.1 is fulﬁlled under the reproducing kernel
map construction. We can also demonstrate the reproducing property, as
⟨k(·, x), f(·)⟩H =
αik(x, xi) = f(x).
Regularization
The problem of inferring an underlying function f(x) from a ﬁnite (and possibly
noisy) dataset without any additional assumptions is clearly “ill posed”. For
example, in the noise-free case, any function that passes through the given data
points is acceptable. Under a Bayesian approach our assumptions are characterized by a prior over functions, and given some data, we obtain a posterior
over functions. The problem of bringing prior assumptions to bear has also
been addressed under the regularization viewpoint, where these assumptions
are encoded in terms of the smoothness of f.
We consider the functional
H + Q(y, f),
where y is the vector of targets we are predicting and f = (f(x1), . . . , f(xn))⊤
is the corresponding vector of function values, and λ is a scaling parameter that
trades oﬀthe two terms. The ﬁrst term is called the regularizer and represents
regularizer
smoothness assumptions on f as encoded by a suitable RKHS, and the second
term is a data-ﬁt term assessing the quality of the prediction f(xi) for the
observed datum yi, e.g. the negative log likelihood.
Ridge regression (described in section 2.1) can be seen as a particular case
(kernel) ridge regression
of regularization. Indeed, recalling that ∥f∥2
i /λi where fi is the
coeﬃcient of eigenfunction φi(x), we see that we are penalizing the weighted
squared coeﬃcients. This is taking place in feature space, rather than simply in
input space, as per the standard formulation of ridge regression (see eq. (2.4)),
so it corresponds to kernel ridge regression.
The representer theorem shows that each minimizer f ∈H of J[f] has the
representer theorem
form f(x) = Pn
i=1 αik(x, xi).1
The representer theorem was ﬁrst stated by
Kimeldorf and Wahba for the case of squared error.2 O’Sullivan et al.
 showed that the representer theorem could be extended to likelihood
1If the RKHS contains a null space of unpenalized functions then the given form is correct
modulo a term that lies in this null space. This is explained further in section 6.3.
2Schoenberg proved the representer theorem for the special case of cubic splines and
squared error. This was result extended to general RKHSs in Kimeldorf and Wahba .
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.2 Regularization
functions arising from generalized linear models. The representer theorem can
be generalized still further, see e.g. Sch¨olkopf and Smola [2002, sec. 4.2]. If the
data-ﬁt term is convex (see section A.9) then there will be a unique minimizer
ˆf of J[f].
For Gaussian process prediction with likelihoods that involve the values of
f at the n training points only (so that Q(y, f) is the negative log likelihood
up to some terms not involving f), the analogue of the representer theorem is
obvious. This is because the predictive distribution of f(x∗) ≜f∗at test point
x∗given the data y is p(f∗|y) =
p(f∗|f)p(f|y) df. As derived in eq. (3.22) we
E[f∗|y] = k(x∗)⊤K−1E[f|y]
due to the formulae for the conditional distribution of a multivariate Gaussian.
Thus E[f∗|y] = Pn
i=1αik(x∗, xi), where α = K−1E[f|y].
The regularization approach has a long tradition in inverse problems, dating back at least as far as Tikhonov ; see also Tikhonov and Arsenin
 . For the application of this approach in the machine learning literature
see e.g. Poggio and Girosi .
In section 6.2.1 we consider RKHSs deﬁned in terms of diﬀerential operators.
In section 6.2.2 we demonstrate how to solve the regularization problem in the
speciﬁc case of squared error, and in section 6.2.3 we compare and contrast the
regularization approach with the Gaussian process viewpoint.
Regularization Deﬁned by Diﬀerential Operators
For x ∈RD deﬁne
j1+...+jD=m
1 . . . xjD
For example for m = 2 and D = 2
Now set ∥Pf∥2 = PM
m=0 am∥Omf∥2 with non-negative coeﬃcients am. Notice
that ∥Pf∥2 is translation and rotation invariant.
In this section we assume that a0 > 0; if this is not the case and ak is
the ﬁrst non-zero coeﬃcient, then there is a null space of functions that are
null space
unpenalized. For example if k = 2 then constant and linear functions are in the
null space. This case is dealt with in section 6.3.
∥Pf∥2 penalizes f in terms of the variability of its function values and
derivatives up to order M. How does this correspond to the RKHS formulation
of section 6.1? The key is to recognize that the complex exponentials exp(2πis·
x) are eigenfunctions of the diﬀerential operator if X = RD. In this case
am(4π2s · s)m| ˜f(s)|2ds,
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
where ˜f(s) is the Fourier transform of f(x). Comparing eq. (6.12) with eq. (6.1)
we see that the kernel has the power spectrum
m=0 am(4π2s · s)m ,
and thus by Fourier inversion we obtain the stationary kernel
m=0 am(4π2s · s)m ds.
A slightly diﬀerent approach to obtaining the kernel is to use calculus of
variations to minimize J[f] with respect to f. The Euler-Lagrange equation
αiG(x −xi),
(−1)mam∇2mG = δ(x −x′),
where G(x, x′) is known as a Green’s function. Notice that the Green’s func-
Green’s function
tion also depends on the boundary conditions. For the case of X = RD by
Fourier transforming eq. (6.16) we recognize that G is in fact the kernel k. The
diﬀerential operator PM
m=0(−1)mam∇2m and the integral operator k(·, ·) are in
fact inverses, as shown by eq. (6.16). See Poggio and Girosi for further
details. Arfken provides an introduction to calculus of variations and
Green’s functions. RKHSs for regularizers deﬁned by diﬀerential operators are
Sobolev spaces; see e.g. Adams for further details on Sobolev spaces.
We now give two speciﬁc examples of kernels derived from diﬀerential operators.
Example 1. Set a0 = α2, a1 = 1 and am = 0 for m ≥2 in D = 1. Using
the Fourier pair e−α|x| ↔2α/(α2 + 4π2s2) we obtain k(x −x′) =
2αe−α|x−x′|.
Note that this is the covariance function of the Ornstein-Uhlenbeck process, see
section 4.2.1.
Example 2. By setting am =
m!2m and using the power series ey = P∞
k(x −x′) =
exp(2πis · (x −x′)) exp(−σ2
2 (4π2s · s))ds
(2πσ2)D/2 exp(−1
2σ2 (x −x′)⊤(x −x′)),
as shown by Yuille and Grzywacz . This is the squared exponential covariance function that we have seen earlier.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.2 Regularization
Obtaining the Regularized Solution
The representer theorem tells us the general form of the solution to eq. (6.8).
We now consider a speciﬁc functional
(yi −f(xi))2,
which uses a squared error data-ﬁt term (corresponding to the negative log
likelihood of a Gaussian noise model with variance σ2
n). Substituting f(x) =
i=1αik(x, xi) and using ⟨k(·, xi), k(·, xj)⟩H = k(xi, xj) we obtain
Minimizing J by diﬀerentiating w.r.t. the vector of coeﬃcients α we obtain
ˆα = (K + σ2
nI)−1y, so that the prediction for a test point x∗is ˆf(x∗) =
k(x∗)⊤(K + σ2
nI)−1y. This should look very familiar—it is exactly the form of
the predictive mean obtained in eq. (2.23). In the next section we compare and
contrast the regularization and GP views of the problem.
The solution f(x) = Pn
i=1αik(x, xi) that minimizes eq. (6.19) was called a
regularization network
regularization network in Poggio and Girosi .
The Relationship of the Regularization View to Gaussian Process Prediction
The regularization method returns ˆf = argminf J[f]. For a Gaussian process
predictor we obtain a posterior distribution over functions. Can we make a
connection between these two views? In fact we shall see in this section that ˆf
can be viewed as the maximum a posteriori (MAP) function under the posterior.
Following Szeliski and Poggio and Girosi we consider
exp (−J[f]) = exp
× exp (−Q(y, f)) .
The ﬁrst term on the RHS is a Gaussian process prior on f, and the second
is proportional to the likelihood. As ˆf is the minimizer of J[f], it is the MAP
To get some intuition for the Gaussian process prior, imagine f(x) being
represented on a grid in x-space, so that f is now an (inﬁnite dimensional) vector
f. Thus we obtain ∥Pf∥2 ≃PM
m=0 am(Dmf)⊤(Dmf) = f ⊤(P
where Dm is an appropriate ﬁnite-diﬀerence approximation of the diﬀerential
operator Om. Observe that this prior term is a quadratic form in f.
To go into more detail concerning the MAP relationship we consider three
cases: (i) when Q(y, f) is quadratic (corresponding to a Gaussian likelihood);
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
(ii) when Q(y, f) is not quadratic but convex and (iii) when Q(y, f) is not
In case (i) we have seen in chapter 2 that the posterior mean function can
be obtained exactly, and the posterior is Gaussian. As the mean of a Gaussian
is also its mode this is the MAP solution. The correspondence between the GP
posterior mean and the solution of the regularization problem ˆf was made in
Kimeldorf and Wahba .
In case (ii) we have seen in chapter 3 for classiﬁcation problems using the
logistic, probit or softmax response functions that Q(y, f) is convex. Here the
MAP solution can be found by ﬁnding ˆf (the MAP solution to the n-dimensional
problem deﬁned at the training points) and then extending it to other x-values
through the posterior mean conditioned on ˆf.
In case (iii) there will be more than one local minimum of J[f] under the
regularization approach. One could check these minima to ﬁnd the deepest one.
However, in this case the argument for MAP is rather weak (especially if there
are multiple optima of similar depth) and suggests the need for a fully Bayesian
treatment.
While the regularization solution gives a part of the Gaussian process solution, there are the following limitations:
1. It does not characterize the uncertainty in the predictions, nor does it
handle well multimodality in the posterior.
2. The analysis is focussed at approximating the ﬁrst level of Bayesian inference, concerning predictions for f. It is not usually extended to the next
level, e.g. to the computation of the marginal likelihood. The marginal
likelihood is very useful for setting any parameters of the covariance function, and for model comparison (see chapter 5).
In addition, we ﬁnd the speciﬁcation of smoothness via the penalties on derivatives to be not very intuitive. The regularization viewpoint can be thought of
as directly specifying the inverse covariance rather than the covariance. As
marginalization is achieved for a Gaussian distribution directly from the covariance (and not the inverse covariance) it seems more natural to us to specify
the covariance function. Also, while non-stationary covariance functions can
be obtained from the regularization viewpoint, e.g. by replacing the Lebesgue
measure in eq. (6.10) with a non-uniform measure µ(x), calculation of the corresponding covariance function can then be very diﬃcult.
Spline Models
In section 6.2 we discussed regularizers which had a0 > 0 in eq. (6.12). We now
consider the case when a0 = 0; in particular we consider the regularizer to be
of the form ∥Omf∥2, as deﬁned in eq. (6.10). In this case polynomials of degree
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.3 Spline Models
up to m −1 are in the null space of the regularization operator, in that they
are not penalized at all.
In the case that X = RD we can again use Fourier techniques to obtain the Green’s function G corresponding to the Euler-Lagrange equation
(−1)m∇2mG(x) = δ(x). The result, as shown by Duchon and Meinguet
cm,D|x −x′|2m−D log |x −x′|
if 2m > D and D even
cm,D|x −x′|2m−D
otherwise,
where cm,D is a constant . Note that
the constraint 2m > D has to be imposed to avoid having a Green’s function
that is singular at the origin. Explicit calculation of the Green’s function for
other domains X is sometimes possible; for example see Wahba [1990, sec. 2.2]
for splines on the sphere.
Because of the null space, a minimizer of the regularization functional has
αiG(x, xi) +
where h1(x), . . . , hk(x) are polynomials that span the null space. The exact
values of the coeﬃcients α and β for a speciﬁc problem can be obtained in
an analogous manner to the derivation in section 6.2.2; in fact the solution is
equivalent to that given in eq. (2.42).
To gain some more insight into the form of the Green’s function we consider
the equation (−1)m∇2mG(x) = δ(x) in Fourier space, leading to ˜G(s) = (4π2s·
s)−m. ˜G(s) plays a rˆole like that of the power spectrum in eq. (6.13), but notice
R ˜G(s)ds is inﬁnite, which would imply that the corresponding process has
inﬁnite variance. The problem is of course that the null space is unpenalized; for
example any arbitrary constant function can be added to f without changing
the regularizer.
Because of the null space we have seen that one cannot obtain a simple
connection between the spline solution and a corresponding Gaussian process
problem. However, by introducing the notion of an intrinsic random function
(IRF) one can deﬁne a generalized covariance; see Cressie [1993, sec. 5.4] and
Stein [1999, section 2.9] for details. The basic idea is to consider linear combinations of f(x) of the form g(x) = Pk
i=1 aif(x+δi) for which g(x) is second-order
stationary and where (hj(δ1), . . . , hj(δk))a = 0 for j = 1, . . . , k. A careful description of the equivalence of spline and IRF prediction is given in Kent and
Mardia .
The power-law form of ˜G(s) = (4π2s·s)−m means that there is no characteristic length-scale for random functions drawn from this (improper) prior. Thus
we obtain the self-similar property characteristic of fractals; for further details
see Szeliski and Mandelbrot . Some authors argue that the lack
of a characteristic length-scale is appealing. This may sometimes be the case,
but if we believe there is an appropriate length-scale (or set of length-scales)
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
for a given problem but this is unknown in advance, we would argue that a
hierarchical Bayesian formulation of the problem (as described in chapter 5)
would be more appropriate.
Splines were originally introduced for one-dimensional interpolation and
smoothing problems, and then generalized to the multivariate setting. Schoenberg considered the problem of ﬁnding the function that minimizes
spline interpolation
(f (m)(x))2 dx,
where f (m) denotes the m’th derivative of f, subject to the interpolation constraints f(xi) = fi, xi ∈(a, b) for i = 1, . . . , n and for f in an appropriate
Sobolev space. He showed that the solution is the natural polynomial spline,
natural polynomial
which is a piecewise polynomial of order 2m −1 in each interval [xi, xi+1],
i = 1, . . . , n −1, and of order m −1 in the two outermost intervals. The pieces
are joined so that the solution has 2m −2 continuous derivatives.
Schoenberg also proved that the solution to the univariate smoothing problem (see
smoothing spline
eq. (6.19)) is a natural polynomial spline. A common choice is m = 2, leading
to the cubic spline. One possible way of writing this solution is
αi(x −xi)3
where (x)+ =
x if x > 0
0 otherwise.
It turns out that the coeﬃcients α and β can be computed in time O(n) using
an algorithm due to Reinsch; see Green and Silverman [1994, sec. 2.3.3] for
Splines were ﬁrst used in regression problems. However, by using generalized linear modelling [McCullagh and Nelder, 1983] they can be extended to
classiﬁcation problems and other non-Gaussian likelihoods, as we did for GP
classiﬁcation in section 3.3. Early references in this direction include Silverman
 and O’Sullivan et al. .
There is a vast literature in relation to splines in both the statistics and
numerical analysis literatures; for entry points see citations in Wahba 
and Green and Silverman .
A 1-d Gaussian Process Spline Construction
In this section we will further clarify the relationship between splines and Gaussian processes by giving a GP construction for the solution of the univariate
cubic spline smoothing problem whose cost functional is
 f(xi) −yi
where the observed data are {(xi, yi)|i = 1, . . . , n, 0 < x1 < · · · < xn < 1} and
λ is a smoothing parameter controlling the trade-oﬀbetween the ﬁrst term, the
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.3 Spline Models
data-ﬁt, and the second term, the regularizer, or complexity penalty. Recall
that the solution is a piecewise polynomial as in eq. (6.25).
Following Wahba , we consider the random function
βjxj + f(x)
where β ∼N(0, σ2
β I) and f(x) is a Gaussian process with covariance σ2
fksp(x, x′),
ksp(x, x′) ≜
(x −u)+(x′ −u)+ du = |x −x′|v2
and v = min(x, x′).
To complete the analogue of the regularizer in eq. (6.26), we need to remove
any penalty on polynomial terms in the null space by making the prior vague,
i.e. by taking the limit σ2
β →∞. Notice that the covariance has the form of
contributions from explicit basis functions, h(x) = (1, x)⊤and a regular covariance function ksp(x, x′), a problem which we have already studied in section 2.7.
Indeed we have computed the limit where the prior becomes vague σ2
the result is given in eq. (2.42).
Plugging into the mean equation from eq. (2.42), we get the predictive mean
¯f(x∗) = k(x∗)⊤K−1
y (y −H⊤¯β) + h(x∗)⊤¯β,
where Ky is the covariance matrix corresponding to σ2
fksp(xi, xj) + σ2
nδij evaluated at the training points, H is the matrix that collects the h(xi) vectors at
all training points, and ¯β = (HK−1
y H⊤)−1HK−1
y y is given below eq. (2.42).
It is not diﬃcult to show that this predictive mean function is a piecewise cubic polynomial, since the elements of k(x∗) are piecewise3 cubic polynomials.
Showing that the mean function is a ﬁrst order polynomial in the outer intervals
[0, x1] and [xn, 1] is left as exercise 6.7.3.
So far ksp has been produced rather mysteriously “from the hat”; we now
provide some explanation. Shepp deﬁned the l-fold integrated Wiener
process as
l = 0, 1, . . .
where Z(u) denotes the Gaussian white noise process with covariance δ(u−u′).
Note that W0 is the standard Wiener process. It is easy to show that ksp(x, x′)
is the covariance of the once-integrated Wiener process by writing W1(x) and
W1(x′) using eq. (6.30) and taking the expectation using the covariance of the
white noise process. Note that Wl is the solution to the stochastic diﬀerential
equation (SDE) X(l+1) = Z; see Appendix B for further details on SDEs. Thus
3The pieces are joined at the datapoints, the points where the min(x, x′) from the covariance function is non-diﬀerentiable.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
(a), spline covariance
(b), squared exponential cov.
Figure 6.1:
Panel (a) shows the application of the spline covariance to a simple
dataset. The full line shows the predictive mean, which is a piecewise cubic polynomial, and the grey area indicates the 95% conﬁdence area. The two thin dashed and
dash-dotted lines are samples from the posterior. Note that the posterior samples
are not as smooth as the mean. For comparison a GP using the squared exponential
covariance function is shown in panel (b). The hyperparameters in both cases were
optimized using the marginal likelihood.
for the cubic spline we set l = 1 to obtain the SDE X′′ = Z, corresponding to
the regularizer
(f ′′(x))2dx.
We can also give an explicit basis-function construction for the covariance
function ksp. Consider the family of random functions given by
where γ is a vector of parameters with γ ∼N(0, I). Note that the sum has
the form of evenly spaced “ramps” whose magnitudes are given by the entries
in the γ vector. Thus
E[fN(x)fN(x′)] =
N )+(x′ −i
Taking the limit N →∞, we obtain eq. (6.28), a derivation which is also found
in [Vapnik, 1998, sec. 11.6].
Notice that the covariance function ksp given in eq. (6.28) corresponds to a
Gaussian process which is MS continuous but only once MS diﬀerentiable. Thus
samples from the prior will be quite “rough”, although (as noted in section 6.1)
the posterior mean, eq. (6.25), is smoother.
The constructions above can be generalized to the regularizer
(f (m)(x))2 dx
by replacing (x −u)+ with (x −u)m−1
/(m −1)! in eq. (6.28) and similarly in
eq. (6.32), and setting h(x) = (1, x, . . . , xm−1)⊤.
Thus, we can use a Gaussian process formulation as an alternative to the
usual spline ﬁtting procedure. Note that the trade-oﬀparameter λ from eq. (6.26)
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.4 Support Vector Machines
w · x + w0 < 0
w · x + w0 > 0
Figure 6.2: Panel (a) shows a linearly separable binary classiﬁcation problem, and a
separating hyperplane. Panel (b) shows the maximum margin hyperplane.
is now given as the ratio σ2
f. The hyperparameters σ2
n can be set
using the techniques from section 5.4.1 by optimizing the marginal likelihood
given in eq. (2.45). Kohn and Ansley give details of an O(n) algorithm
(based on Kalman ﬁltering) for the computation of the spline and the marginal
likelihood. In addition to the predictive mean the GP treatment also yields an
explicit estimate of the noise level and predictive error bars. Figure 6.1 shows
a simple example. Notice that whereas the mean function is a piecewise cubic
polynomial, samples from the posterior are not smooth. In contrast, for the
squared exponential covariance functions shown in panel (b), both the mean
and functions drawn from the posterior are inﬁnitely diﬀerentiable.
Support Vector Machines
Since the mid 1990’s there has been an explosion of interest in kernel machines,
and in particular the support vector machine (SVM). The aim of this section
is to provide a brief introduction to SVMs and in particular to compare them
to Gaussian process predictors. We consider SVMs for classiﬁcation and regression problems in sections 6.4.1 and 6.4.2 respectively. More comprehensive
treatments can be found in Vapnik , Cristianini and Shawe-Taylor 
and Sch¨olkopf and Smola .
Support Vector Classiﬁcation
For support vector classiﬁers, the key notion that we need to introduce is that
of the maximum margin hyperplane for a linear classiﬁer. Then by using the
“kernel trick” this can be lifted into feature space. We consider ﬁrst the separable case and then the non-separable case. We conclude this section with a
comparison between GP classiﬁers and SVMs.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
The Separable Case
Figure 6.2(a) illustrates the case where the data is linearly separable. For a
linear classiﬁer with weight vector w and oﬀset w0, let the decision boundary
be deﬁned by w · x + w0 = 0, and let ˜w = (w, w0). Clearly, there is a whole
version space of weight vectors that give rise to the same classiﬁcation of the
training points. The SVM algorithm chooses a particular weight vector, that
gives rise to the “maximum margin” of separation.
Let the training set be pairs of the form (xi, yi) for i = 1, . . . , n, where yi =
±1. For a given weight vector we can compute the quantity ˜γi = yi(w ·x+w0),
which is known as the functional margin. Notice that ˜γi > 0 if a training point
functional margin
is correctly classiﬁed.
If the equation f(x) = w · x + w0 deﬁnes a discriminant function (so that
the output is sgn(f(x))), then the hyperplane cw · x + cw0 deﬁnes the same
discriminant function for any c > 0. Thus we have the freedom to choose the
scaling of ˜w so that mini ˜γi = 1, and in this case ˜w is known as the canonical
form of the hyperplane.
The geometrical margin is deﬁned as γi = ˜γi/|w|. For a training point xi
geometrical margin
that is correctly classiﬁed this is simply the distance from xi to the hyperplane.
To see this, let c = 1/|w| so that ˆw = w/|w| is a unit vector in the direction
of w, and ˆw0 is the corresponding oﬀset.
Then ˆw · x computes the length
of the projection of x onto the direction orthogonal to the hyperplane and
ˆw·x+ ˆw0 computes the distance to the hyperplane. For training points that are
misclassiﬁed the geometrical margin is the negative distance to the hyperplane.
The geometrical margin for a dataset D is deﬁned as γD = mini γi. Thus
for a canonical separating hyperplane the margin is 1/|w|. We wish to ﬁnd the
maximum margin hyperplane, i.e. the one that maximizes γD.
By considering canonical hyperplanes, we are thus led to the following optimization problem to determine the maximum margin hyperplane:
optimization problem
minimize 1
over w, w0
subject to yi(w · xi + w0) ≥1
for all i = 1, . . . , n.
It is clear by considering the geometry that for the maximum margin solution
there will be at least one data point in each class for which yi(w·xi+w0) = 1, see
Figure 6.2(b). Let the hyperplanes that pass through these points be denoted
H+ and H−respectively.
This constrained optimization problem can be set up using Lagrange multipliers, and solved using numerical methods for quadratic programming4 (QP)
problems. The form of the solution is
4A quadratic programming problem is an optimization problem where the objective function is quadratic and the constraints are linear in the unknowns.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.4 Support Vector Machines
where the λi’s are non-negative Lagrange multipliers. Notice that the solution
is a linear combination of the xi’s.
The key feature of equation 6.34 is that λi is zero for every xi except those
which lie on the hyperplanes H+ or H−; these points are called the support
The fact that not all of the training points contribute to the ﬁnal
support vectors
solution is referred to as the sparsity of the solution.
The support vectors
lie closest to the decision boundary.
Note that if all of the other training
points were removed (or moved around, but not crossing H+ or H−) the same
maximum margin hyperplane would be found.
The quadratic programming
problem for ﬁnding the λi’s is convex, i.e. there are no local minima. Notice
the similarity of this to the convexity of the optimization problem for Gaussian
process classiﬁers, as described in section 3.4.
To make predictions for a new input x∗we compute
sgn(w · x∗+ w0) = sgn
λiyi(xi · x∗) + w0
In the QP problem and in eq. (6.35) the training points {xi} and the test point
x∗enter the computations only in terms of inner products. Thus by using the
kernel trick we can replace occurrences of the inner product by the kernel to
kernel trick
obtain the equivalent result in feature space.
The Non-Separable Case
For linear classiﬁers in the original x space there will be some datasets that
are not linearly separable. One way to generalize the SVM problem in this
case is to allow violations of the constraint yi(w · xi + w0) ≥1 but to impose a
penalty when this occurs. This leads to the soft margin support vector machine
soft margin
problem, the minimization of
(1 −yifi)+
with respect to w and w0, where fi = f(xi) = w · xi + w0 and (z)+ = z if
z > 0 and 0 otherwise. Here C > 0 is a parameter that speciﬁes the relative
importance of the two terms. This convex optimization problem can again be
solved using QP methods and yields a solution of the form given in eq. (6.34). In
this case the support vectors (those with λi ̸= 0) are not only those data points
which lie on the separating hyperplanes, but also those that incur penalties.
This can occur in two ways (i) the data point falls in between H+ and H−but
on the correct side of the decision surface, or (ii) the data point falls on the
wrong side of the decision surface.
In a feature space of dimension N, if N > n then there will always be
separating hyperplane. However, this hyperplane may not give rise to good
generalization performance, especially if some of the labels are incorrect, and
thus the soft margin SVM formulation is often used in practice.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
log(1 + exp(−z))
max(1−z, 0)
Figure 6.3: (a) A comparison of the hinge error, gλ and gΦ. (b) The ϵ-insensitive
error function used in SVR.
For both the hard and soft margin SVM QP problems a wide variety of
algorithms have been developed for their solution; see Sch¨olkopf and Smola
[2002, ch. 10] for details. Basic interior point methods involve inversions of n×n
matrices and thus scale as O(n3), as with Gaussian process prediction. However,
there are other algorithms, such as the sequential minimal optimization (SMO)
algorithm due to Platt , which often have better scaling in practice.
Above we have described SVMs for the two-class (binary) classiﬁcation problem. There are many ways of generalizing SVMs to the multi-class problem,
see Sch¨olkopf and Smola [2002, sec. 7.6] for further details.
Comparing Support Vector and Gaussian Process Classiﬁers
For the soft margin classiﬁer we obtain a solution of the form w = P
(with αi = λiyi) and thus |w|2 = P
i,j αiαj(xi · xj). Kernelizing this we obtain
|w|2 = α⊤Kα = f ⊤K−1f, as5 Kα = f.
Thus the soft margin objective
function can be written as
2f ⊤K−1f + C
(1 −yifi)+.
For the binary GP classiﬁer, to obtain the MAP value ˆf of p(f|y) we minimize
the quantity
2f ⊤K−1f −
log p(yi|fi),
cf. eq. (3.12). (The ﬁnal two terms in eq. (3.12) are constant if the kernel is
For log-concave likelihoods (such as those derived from the logistic or probit response functions) there is a strong similarity between the two optimization problems in that they are both convex. Let gλ(z) ≜log(1 + e−z), gΦ =
5Here the oﬀset w0 has been absorbed into the kernel so it is not an explicit extra parameter.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.4 Support Vector Machines
−log Φ(z), and ghinge(z) ≜(1 −z)+ where z = yifi. We refer to ghinge as the
hinge error function, due to its shape. As shown in Figure 6.3(a) all three data
hinge error function
ﬁt terms are monotonically decreasing functions of z. All three functions tend
to inﬁnity as z →−∞and decay to zero as z →∞. The key diﬀerence is that
the hinge function takes on the value 0 for z ≥1, while the other two just decay
slowly. It is this ﬂat part of the hinge function that gives rise to the sparsity of
the SVM solution.
Thus there is a close correspondence between the MAP solution of the GP
classiﬁer and the SVM solution. Can this correspondence be made closer by
considering the hinge function as a negative log likelihood? The answer to this
is no [Seeger, 2000, Sollich, 2002]. If Cghinge(z) deﬁned a negative log likelihood,
then exp(−Cghinge(f)) + exp(−Cghinge(−f)) should be a constant independent
of f, but this is not the case. To see this, consider the quantity
ν(f; C) = κ(C)[exp(−C(1 −f)+) + exp(−C(1 + f)+)].
κ(C) cannot be chosen so as to make ν(f; C) = 1 independent of the value
of f for C > 0.
By comparison, for the logistic and probit likelihoods the
analogous expression is equal to 1. Sollich suggests choosing κ(C) =
1/(1 + exp(−2C)) which ensures that ν(f, C) ≤1 (with equality only when
f = ±1). He also gives an ingenious interpretation (involving a “don’t know”
class to soak up the unassigned probability mass) that does yield the SVM
solution as the MAP solution to a certain Bayesian problem, although we ﬁnd
this construction rather contrived. Exercise 6.7.2 invites you to plot ν(f; C) as
a function of f for various values of C.
One attraction of the GP classiﬁer is that it produces an output with a
clear probabilistic interpretation, a prediction for p(y = +1|x). One can try
to interpret the function value f(x) output by the SVM probabilistically, and
Platt suggested that probabilistic predictions can be generated from the
SVM by computing σ(af(x) + b) for some constants a, b that are ﬁtted using
some “unbiased version” of the training set (e.g. using cross-validation). One
disadvantage of this rather ad hoc procedure is that unlike the GP classiﬁers
it does not take into account the predictive variance of f(x) (cf. eq. (3.25)).
Seeger [2003, sec. 4.7.2] shows that better error-reject curves can be obtained
on an experiment using the MNIST digit classiﬁcation problem when the eﬀect
of this uncertainty is taken into account.
Support Vector Regression
The SVM was originally introduced for the classiﬁcation problem, then extended
to deal with the regression case. The key concept is that of the ϵ-insensitive
error function. This is deﬁned as
if |z| ≥ϵ,
otherwise.
This function is plotted in Figure 6.3(b).
As in eq. (6.21) we can interpret
exp(−gϵ(z)) as a likelihood model for the regression residuals .
However, we note that
this is quite an unusual choice of model for the distribution of residuals and
is basically motivated by the desire to obtain a sparse solution (see below)
as in support vector classiﬁer. If ϵ = 0 then the error model is a Laplacian
distribution, which corresponds to least absolute values regression (Edgeworth
 , cited in Rousseeuw ); this is a heavier-tailed distribution than the
Gaussian and provides some protection against outliers. Girosi showed
that the Laplacian distribution can be viewed as a continuous mixture of zeromean Gaussians with a certain distribution over their variances. Pontil et al.
 extended this result by allowing the means to uniformly shift in [−ϵ, ϵ]
in order to obtain a probabilistic model corresponding to the ϵ-insensitive error
function. See also section 9.3 for work on robustiﬁcation of the GP regression
For the linear regression case with an ϵ-insensitive error function and a
Gaussian prior on w, the MAP value of w is obtained by minimizing
gϵ(yi −fi)
w.r.t. w. The solution6 is f(x∗) = Pn
i=1 αixi · x∗where the coeﬃcients α are
obtained from a QP problem. The problem can also be kernelized to give the
solution f(x∗) = Pn
i=1 αik(xi, x∗).
As for support vector classiﬁcation, many of the coeﬃcients αi are zero. The
data points which lie inside the ϵ-“tube” have αi = 0, while those on the edge
or outside have non-zero αi.
Least-squares Classiﬁcation
In chapter 3 we have argued that the use of logistic or probit likelihoods provides the natural route to develop a GP classiﬁer, and that it is attractive in
that the outputs can be interpreted probabilistically. However, there is an even
simpler approach which treats classiﬁcation as a regression problem.
Our starting point is binary classiﬁcation using the linear predictor f(x) =
w⊤x. This is trained using linear regression with a target y+ for patterns that
have label +1, and target y−for patterns that have label −1. (Targets y+, y−
give slightly more ﬂexibility than just using targets of ±1.) As shown in Duda
and Hart [1973, section 5.8], choosing y+, y−appropriately allows us to obtain
the same solution as Fisher’s linear discriminant using the decision criterion
f(x) ≷0. Also, they show that using targets y+ = +1, y−= −1 with the
least-squares error function gives a minimum squared-error approximation to
the Bayes discriminant function p(C+|x)−p(C−|x) as n →∞. Following Rifkin
and Klautau we call such methods least-squares classiﬁcation (LSC). Note
that under a probabilistic interpretation the squared-error criterion is rather an
6Here we have assumed that the constant 1 is included in the input vector x.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.5 Least-squares Classiﬁcation
odd choice as it implies a Gaussian noise model, yet only two values of the
target (y+ and y−) are observed.
It is natural to extend the least-squares classiﬁer using the kernel trick.
This has been suggested by a number of authors including Poggio and Girosi
 and Suykens and Vanderwalle . Experimental results reported in
Rifkin and Klautau indicate that performance comparable to SVMs can
be obtained using kernel LSC (or as they call it the regularized least-squares
classiﬁer, RLSC).
Consider a single random variable y which takes on the value +1 with probability p and value −1 with probability 1−p. Then the value of f which minimizes
the squared error function E = p(f −1)2 + (1 −p)(f + 1)2 is ˆf = 2p −1, which
is a linear rescaling of p to the interval [−1, 1]. (Equivalently if the targets are
1 and 0, we obtain ˆf = p.) Hence we observe that LSC will estimate p correctly
in the large data limit. If we now consider not just a single random variable,
but wish to estimate p(C+|x) (or a linear rescaling of it), then as long as the
approximating function f(x) is suﬃciently ﬂexible, we would expect that in the
limit n →∞it would converge to p(C+|x). (For more technical detail on this
issue, see section 7.2.1 on consistency.) Hence LSC is quite a sensible procedure
for classiﬁcation, although note that there is no guarantee that f(x) will be
constrained to lie in the interval [y−, y+]. If we wish to guarantee a probabilistic interpretation, we could “squash” the predictions through a sigmoid, as
suggested for SVMs by Platt and described on page 145.
When generalizing from the binary to multi-class situation there is some
freedom as to how to set the problem up. Sch¨olkopf and Smola [2002, sec. 7.6]
identify four methods, namely one-versus-rest (where C binary classiﬁers are
trained to classify each class against all the rest), all pairs (where C(C −1)/2
binary classiﬁers are trained), error-correcting output coding (where each class
is assigned a binary codeword, and binary classiﬁers are trained on each bit
separately), and multi-class objective functions (where the aim is to train C
classiﬁers simultaneously rather than creating a number of binary classiﬁcation
problems). One also needs to specify how the outputs of the various classiﬁers
that are trained are combined so as to produce an overall answer.
one-versus-rest7 method one simple criterion is to choose the classiﬁer which
produces the most positive output. Rifkin and Klautau performed extensive experiments and came to the conclusion that the one-versus-rest scheme
using either SVMs or RLSC is as accurate as any other method overall, and
has the merit of being conceptually simple and straightforward to implement.
Probabilistic Least-squares Classiﬁcation
The LSC algorithm discussed above is attractive from a computational point
of view, but to guarantee a valid probabilistic interpretation one may need
to use a separate post-processing stage to “squash” the predictions through a
sigmoid. However, it is not so easy to enforce a probabilistic interpretation
7This method is also sometimes called one-versus-all.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
during the training stage.
One possible solution is to combine the ideas of
training using leave-one-out cross-validation, covered in section 5.4.2, with the
use of a (parameterized) sigmoid function, as in Platt . We will call this
method the probabilistic least-squares classiﬁer (PLSC).
In section 5.4.2 we saw how to compute the Gaussian leave-one-out (LOO)
predictive probabilities, and that training of hyperparameters can be based
on the sum of the log LOO probabilities. Using this idea, we express the LOO
probability by squashing a linear function of the Gaussian predictive probability
through a cumulative Gaussian
p(yi|X, y−i, θ) =
 yi(αfi + β)
N(fi|µi, σ2
yi(αµi + β)
where the integral is given in eq. (3.82) and the leave-one-out predictive mean µi
and variance σ2
i are given in eq. (5.12). The objective function is the sum of the
log LOO probabilities, eq. (5.11) which can be used to set the hyperparameters
as well as the two additional parameters of the linear transformation, α and β in
eq. (6.42). Introducing the likelihood in eq. (6.42) into the objective eq. (5.11)
and taking derivatives we obtain
∂log p(yi|X, y−i, θ)
+ ∂log p(yi|X, y−i, θ)
−α(αµi + β)
2(1 + α2σ2
where ri = (αµi + β)/
i and the partial derivatives of the Gaussian
LOO parameters ∂µi/∂θj and ∂σ2
i /∂θj are given in eq. (5.13). Finally, for the
linear transformation parameters we have
These partial derivatives can be used to train the parameters of the GP. There
are several options on how to do predictions, but the most natural would seem
to be to compute predictive mean and variance and squash it through the
sigmoid, parallelling eq. (6.42). Applying this model to the USPS 3s vs. 5s
binary classiﬁcation task discussed in section 3.7.3, we get a test set error rate
of 12/773 = 0.0155%, which compares favourably with the results reported for
other methods in Figure 3.10. However, the test set information is only 0.77
bits,8 which is very poor.
8The test information is dominated by a single test case, which is predicted conﬁdently
to belong to the wrong class. Visual inspection of the digit reveals that indeed it looks as
though the testset label is wrong for this case. This observation highlights the danger of not
explicitly allowing for data mislabelling in the model for this kind of data.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
6.6 Relevance Vector Machines
Relevance Vector Machines
Although usually not presented as such, the relevance vector machine (RVM)
introduced by Tipping is actually a special case of a Gaussian process.
The covariance function has the form
k(x, x′) =
φj(x)φj(x′),
where αj are hyperparameters and the N basis functions φj(x) are usually, but
not necessarily taken to be Gaussian-shaped basis functions centered on each
of the n training data points
φj(x) = exp
where ℓis a length-scale hyperparameter controlling the width of the basis
function. Notice that this is simply the construction for the covariance function
corresponding to an N-dimensional set of basis functions given in section 2.1.2,
with Σp = diag(α−1
1 , . . . , α−1
The covariance function in eq. (6.45) has two interesting properties: ﬁrstly,
it is clear that the feature space corresponding to the covariance function is
ﬁnite dimensional, i.e. the covariance function is degenerate, and secondly the
covariance function has the odd property that it depends on the training data.
This dependency means that the prior over functions depends on the data, a
property which is at odds with a strict Bayesian interpretation. Although the
usual treatment of the model is still possible, this dependency of the prior on
the data may lead to some surprising eﬀects, as discussed below.
Training the RVM is analogous to other GP models: optimize the marginal
likelihood w.r.t. the hyperparameters. This optimization often leads to a signiﬁcant number of the αj hyperparameters tending towards inﬁnity, eﬀectively
removing, or pruning, the corresponding basis function from the covariance
function in eq. (6.45). The basic idea is that basis functions that are not signiﬁcantly contributing to explaining the data should be removed, resulting in
a sparse model. The basis functions that survive are called relevance vectors.
relevance vectors
Empirically it is often observed that the number of relevance vectors is smaller
than the number of support vectors on the same problem [Tipping, 2001].
The original RVM algorithm [Tipping, 2001] was not able to exploit the
sparsity very eﬀectively during model ﬁtting as it was initialized with all of the
αis set to ﬁnite values, meaning that all of the basis functions contributed to
the model. However, careful analysis of the RVM marginal likelihood by Faul
and Tipping showed that one can carry out optimization w.r.t. a single
αi analytically. This has led to the accelerated training algorithm described
in Tipping and Faul which starts with an empty model (i.e. all αis set
to inﬁnity) and adds basis functions sequentially. As the number of relevance
vectors is (usually much) less than the number of training cases it will often
be much faster to train and make predictions using a RVM than a non-sparse
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Relationships between GPs and Other Models
GP. Also note that the basis functions can include additional hyperparameters,
e.g. one could use an automatic relevance determination (ARD) form of basis
function by using diﬀerent length-scales on diﬀerent dimensions in eq. (6.46).
These additional hyperparameters could also be set by optimizing the marginal
likelihood.
The use of a degenerate covariance function which depends on the data
has some undesirable eﬀects.
Imagine a test point, x∗, which lies far away
from the relevance vectors. At x∗all basis functions will have values close to
zero, and since no basis function can give any appreciable signal, the predictive
distribution will be a Gaussian with a mean close to zero and variance close
to zero (or to the inferred noise level).
This behaviour is undesirable, and
could lead to dangerously false conclusions. If the x∗is far from the relevance
vectors, then the model shouldn’t be able to draw strong conclusions about
the output (we are extrapolating), but the predictive uncertainty becomes very
small—this is the opposite behaviour of what we would expect from a reasonable
model. Here, we have argued that for localized basis functions, the RVM has
undesirable properties, but as argued in Rasmussen and Qui˜nonero-Candela
 it is actually the degeneracy of the covariance function which is the
core of the problem. Although the work of Rasmussen and Qui˜nonero-Candela
 goes some way towards ﬁxing the problem, there is an inherent conﬂict:
degeneracy of the covariance function is good for computational reasons, but
bad for modelling reasons.
1. We motivate the fact that the RKHS norm does not depend on the density p(x) using a ﬁnite-dimensional analogue. Consider the n-dimensional
vector f, and let the n×n matrix Φ be comprised of non-colinear columns
φ1, . . . , φn. Then f can be expressed as a linear combination of these basis vectors f = Pn
i=1 ciφi = Φc for some coeﬃcients {ci}. Let the φs
be eigenvectors of the covariance matrix K w.r.t. a diagonal matrix P
with non-negative entries, so that KPΦ = ΦΛ, where Λ is a diagonal
matrix containing the eigenvalues. Note that Φ⊤PΦ = In. Show that
i /λi = c⊤Λ−1c = f ⊤K−1f, and thus observe that f ⊤K−1f can be
expressed as c⊤Λ−1c for any valid P and corresponding Φ. Hint: you
may ﬁnd it useful to set ˜Φ = P 1/2Φ, ˜K = P 1/2KP 1/2 etc.
2. Plot eq. (6.39) as a function of f for diﬀerent values of C. Show that
there is no value of C and κ(C) which makes ν(f; C) equal to 1 for all
values of f. Try setting κ(C) = 1/(1 + exp(−2C)) as suggested in Sollich
 and observe what eﬀect this has.
3. Show that the predictive mean for the spline covariance GP in eq. (6.29)
is a linear function of x∗when x∗is located either to the left or to the
right of all training points. Hint: consider the eigenvectors corresponding
to the two largest eigenvalues of the training set covariance matrix from
eq. (2.40) in the vague limit.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
This chapter covers a number of more theoretical issues relating to Gaussian
processes. In section 2.6 we saw how GPR carries out a linear smoothing of the
datapoints using the weight function. The form of the weight function can be
understood in terms of the equivalent kernel, which is discussed in section 7.1.
As one gets more and more data, one would hope that the GP predictions
would converge to the true underlying predictive distribution. This question
of consistency is reviewed in section 7.2, where we also discuss the concepts of
equivalence and orthogonality of GPs.
When the generating process for the data is assumed to be a GP it is particularly easy to obtain results for learning curves which describe how the accuracy
of the predictor increases as a function of n, as described in section 7.3. An
alternative approach to the analysis of generalization error is provided by the
PAC-Bayesian analysis discussed in section 7.4. Here we seek to relate (with
high probability) the error observed on the training set to the generalization
error of the GP predictor.
Gaussian processes are just one of the many methods that have been developed for supervised learning problems. In section 7.5 we compare and contrast
GP predictors with other supervised learning methods.
The Equivalent Kernel
In this section we consider regression problems. We have seen in section 6.2
that the posterior mean for GP regression can be obtained as the function which
minimizes the functional
 yi −f(xi)
where ∥f∥H is the RKHS norm corresponding to kernel k. Our goal is now to
understand the behaviour of this solution as n →∞.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
Let µ(x, y) be the probability measure from which the data pairs (xi, yi) are
generated. Observe that
 yi −f(xi)
Z  y −f(x)
2 dµ(x, y).
Let η(x) = E[y|x] be the regression function corresponding to the probability
measure µ. The variance around η(x) is denoted σ2(x) =
(y −η(x))2dµ(y|x).
Then writing y −f = (y −η) + (η −f) we obtain
Z  y −f(x)
2 dµ(x, y) =
Z  η(x) −f(x)
2 dµ(x) +
σ2(x) dµ(x),
as the cross term vanishes due to the deﬁnition of η(x).
As the second term on the right hand side of eq. (7.3) is independent of f,
an idealization of the regression problem consists of minimizing the functional
Z  η(x) −f(x)
2 dµ(x) + 1
The form of the minimizing solution is most easily understood in terms of the
eigenfunctions {φi(x)} of the kernel k w.r.t. to µ(x), where
φi(x)φj(x)dµ(x) =
δij, see section 4.3. Assuming that the kernel is nondegenerate so that the φs
form a complete orthonormal basis, we write f(x) = P∞
i=1 fiφi(x). Similarly,
i=1 ηiφi(x), where ηi =
η(x)φi(x)dµ(x). Thus
(ηi −fi)2 + 1
This is readily minimized by diﬀerentiation w.r.t. each fi to obtain
λi + σ2n/nηi.
Notice that the term σ2
n/n →0 as n →∞so that in this limit we would
expect that f(x) will converge to η(x). There are two caveats: (1) we have
assumed that η(x) is suﬃciently well-behaved so that it can be represented by
the generalized Fourier series P∞
i=1 ηiφi(x), and (2) we assumed that the kernel
is nondegenerate. If the kernel is degenerate (e.g. a polynomial kernel) then f
should converge to the best µ-weighted L2 approximation to η within the span
of the φ’s. In section 7.2.1 we will say more about rates of convergence of f to
η; clearly in general this will depend on the smoothness of η, the kernel k and
the measure µ(x, y).
From a Bayesian perspective what is happening is that the prior on f is
being overwhelmed by the data as n →∞. Looking at eq. (7.6) we also see
that if σ2
n ≫nλi then fi is eﬀectively zero. This means that we cannot ﬁnd
out about the coeﬃcients of eigenfunctions with small eigenvalues until we get
suﬃcient amounts of data. Ferrari Trecate et al. demonstrated this by
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
7.1 The Equivalent Kernel
showing that regression performance of a certain nondegenerate GP could be
approximated by taking the ﬁrst m eigenfunctions, where m was chosen so that
n/n. Of course as more data is obtained then m has to be increased.
Using the fact that ηi =
η(x′)φi(x′)dµ(x′) and deﬁning σ2
λiφi(x)φi(x′)
η(x′) dµ(x′).
The term in square brackets in eq. (7.7) is the equivalent kernel for the smoothing problem; we denote it by hn(x, x′). Notice the similarity to the vector-valued
equivalent kernel
weight function h(x) deﬁned in section 2.6. The diﬀerence is that there the prediction was obtained as a linear combination of a ﬁnite number of observations
yi with weights given by hi(x) while here we have a noisy function y(x) instead,
with ¯f(x′) =
hn(x, x′)y(x)dµ(x). Notice that in the limit n →∞(so that
eﬀ→0) the equivalent kernel tends towards the delta function.
The form of the equivalent kernel given in eq. (7.7) is not very useful in
practice as it requires knowledge of the eigenvalues/functions for the combination of k and µ. However, in the case of stationary kernels we can use Fourier
methods to compute the equivalent kernel. Consider the functional
(y(x) −f(x))2 dx + 1
where ρ has dimensions of the number of observations per unit of x-space
(length/area/volume etc. as appropriate). Using a derivation similar to eq. (7.6)
Sf(s) + σ2n/ρ =
f (s)σ2n/ρ,
where Sf(s) is the power spectrum of the kernel k. The term σ2
n/ρ corresponds
to the power spectrum of a white noise process, as the delta function covariance function of white noise corresponds to a constant in the Fourier domain.
This analysis is known as Wiener ﬁltering; see, e.g. Papoulis [1991, sec. 14-1].
Wiener ﬁltering
Equation (7.9) is the same as eq. (7.6) except that the discrete eigenspectrum
has been replaced by a continuous one.
As can be observed in Figure 2.6, the equivalent kernel essentially gives a
weighting to the observations locally around x. Thus identifying ρ with np(x)
we can obtain an approximation to the equivalent kernel for stationary kernels
when the width of the kernel is smaller than the length-scale of variations in
p(x). This form of analysis was used by Silverman for splines in one
dimension.
Some Speciﬁc Examples of Equivalent Kernels
We ﬁrst consider the OU process in 1-d. This has k(r) = exp(−α|r|) (setting
α = 1/ℓrelative to our previous notation and r = x −x′), and power spectrum
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
S(s) = 2α/(4π2s2 + α2). Let vn ≜σ2
n/ρ. Using eq. (7.9) we obtain
vn(4π2s2 + β2),
where β2 = α2 + 2α/vn. This again has the form of Fourier transform of an
OU covariance function1 and can be inverted to obtain h(r) =
vnβ e−β|r|. In
particular notice that as n increases (and thus vn decreases) the inverse lengthscale β of h(r) increases; asymptotically β ∼n1/2 for large n. This shows that
the width of equivalent kernel for the OU covariance function will scale as n−1/2
asymptotically. Similarly the width will scale as p(x)−1/2 asymptotically.
A similar analysis can be carried out for the AR(2) Gaussian process in 1-d
(see section B.2) which has a power spectrum ∝(4π2s2 + α2)−2 (i.e. it is in
the Mat´ern class with ν = 3/2). In this case we can show that the width of the equivalent
kernel scales as n−1/4 asymptotically.
Analysis of the equivalent kernel has also been carried out for spline models.
Silverman gives the explicit form of the equivalent kernel in the case
of a one-dimensional cubic spline (corresponding to the regularizer ∥Pf∥2 =
′′)2dx). Thomas-Agnan gives a general expression for the equivalent
kernel for the spline regularizer ∥Pf∥2 =
(f (m))2dx in one dimension and also
analyzes end-eﬀects if the domain of interest is a bounded open interval. For
the regularizer ∥Pf∥2 =
(∇2f)2dx in two dimensions, the equivalent kernel is
given in terms of the Kelvin function kei .
Silverman has also shown that for splines of order m in 1-d (corresponding to a roughness penalty of
(f (m))2 dx) the width of the equivalent
kernel will scale as n−1/2m asymptotically. In fact it can be shown that this is
true for splines in D > 1 dimensions too, see exercise 7.7.1.
Another interesting case to consider is the squared exponential kernel, where
S(s) = (2πℓ2)D/2 exp(−2π2ℓ2|s|2). Thus
1 + b exp(2π2ℓ2|s|2),
where b = σ2
n/ρ(2πℓ2)D/2. We are unaware of an exact result in this case, but
the following approximation due to Sollich and Williams is simple but
eﬀective. For large ρ (i.e. large n) b will be small. Thus for small s = |s| we
have that ˜hSE ≃1, but for large s it is approximately 0. The change takes
place around the point sc where b exp(2π2ℓ2s2
c) = 1, i.e. s2
c = log(1/b)/2π2ℓ2.
As exp(2π2ℓ2s2) grows quickly with s, the transition of ˜hSE between 1 and 0
can be expected to be rapid, and thus be well-approximated by a step function.
By using the standard result for the Fourier transform of the step function we
hSE(x) = 2scsinc(2πscx)
1The fact that ˜h(s) has the same form as Sf(s) is particular to the OU covariance function
and is not generally the case.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
7.2 Asymptotic Analysis
for D = 1, where sinc(z) = sin(z)/z. A similar calculation in D > 1 using
eq. (4.7) gives
JD/2(2πscr).
Notice that sc scales as (log(n))1/2 so that the width of the equivalent kernel
will decay very slowly as n increases. Notice that the plots in Figure 2.6 show
the sinc-type shape, although the sidelobes are not quite as large as would be
predicted by the sinc curve (because the transition is smoother than a step
function in Fourier space so there is less “ringing”).
Asymptotic Analysis
In this section we consider two asymptotic properties of Gaussian processes,
consistency and equivalence/orthogonality.
Consistency
In section 7.1 we have analyzed the asymptotics of GP regression and have
seen how the minimizer of the functional eq. (7.4) converges to the regression
function as n →∞. We now broaden the focus by considering loss functions
other than squared loss, and the case where we work directly with eq. (7.1)
rather than the smoothed version eq. (7.4).
The set up is as follows: Let L(·, ·) be a pointwise loss function. Consider
a procedure that takes training data D and this loss function, and returns a
function fD(x). For a measurable function f, the risk (expected loss) is deﬁned
L(y, f(x)) dµ(x, y).
L denote the function that minimizes this risk. For squared loss f ∗
E[y|x]. For 0/1 loss with classiﬁcation problems, we choose f ∗
L(x) to be the
class c at x such that p(Cc|x) > p(Cj|x) for all j ̸= c (breaking ties arbitrarily).
Deﬁnition 7.1 We will say that a procedure that returns fD is consistent for
consistency
a given measure µ(x, y) and loss function L if
RL(fD) →RL(f ∗
where convergence is assessed in a suitable manner, e.g. in probability. If fD(x)
is consistent for all Borel probability measures µ(x, y) then it is said to be universally consistent.
A simple example of a consistent procedure is the kernel regression method.
As described in section 2.6 one obtains a prediction at test point x∗by computing ˆf(x∗) = Pn
i=1 wiyi where wi = κi/Pn
j=1κj (the Nadaraya-Watson estimator). Let h be the width of the kernel κ and D be the dimension of the input
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
space. It can be shown that under suitable regularity conditions if h →0 and
nhD →∞as n →∞then the procedure is consistent; see e.g. [Gy¨orﬁet al.,
2002, Theorem 5.1] for the regression case with squared loss and Devroye et al.
[1996, Theorem 10.1] for the classiﬁcation case using 0/1 loss.
An intuitive
understanding of this result can be obtained by noting that h →0 means that
only datapoints very close to x∗will contribute to the prediction (eliminating
bias), while the condition nhD →∞means that a large number of datapoints
will contribute to the prediction (eliminating noise/variance).
It will ﬁrst be useful to consider why we might hope that GPR and GPC
should be universally consistent. As discussed in section 7.1, the key property
is that a non-degenerate kernel will have an inﬁnite number of eigenfunctions
forming an orthonormal set. Thus from generalized Fourier analysis a linear
combination of eigenfunctions P∞
i=1 ciφi(x) should be able to represent a suf-
ﬁciently well-behaved target function f ∗
L. However, we have to estimate the
inﬁnite number of coeﬃcients {ci} from the noisy observations. This makes it
clear that we are playing a game involving inﬁnities which needs to be played
with care, and there are some results [Diaconis and Freedman, 1986, Freedman,
1999, Gr¨unwald and Langford, 2004] which show that in certain circumstances
Bayesian inference in inﬁnite-dimensional objects can be inconsistent.
However, there are some positive recent results on the consistency of GPR
and GPC. Choudhuri et al. show that for the binary classiﬁcation case
under certain assumptions GPC is consistent. The assumptions include smoothness on the mean and covariance function of the GP, smoothness on E[y|x] and
an assumption that the domain is a bounded subset of RD. Their result holds
for the class of response functions which are c.d.f.s of a unimodal symmetric
density; this includes the probit and logistic functions.
For GPR, Choi and Schervish show that for a one-dimensional input
space of ﬁnite length under certain assumptions consistency holds. Here the
assumptions again include smoothness of the mean and covariance function of
the GP and smoothness of E[y|x]. An additional assumption is that the noise
has a normal or Laplacian distribution (with an unknown variance which is
inferred).
There are also some consistency results relating to the functional
Jλn[f] = λn
 yi, f(xi)
where λn →0 as n →∞. Note that to agree with our previous formulations
we would set λn = 1/n, but other decay rates on λn are often considered.
In the splines literature, Cox showed that for regression problems using the regularizer ∥f∥2
k=0 ∥Okf∥2 (using the deﬁnitions in eq. (6.10))
consistency can be obtained under certain technical conditions. Cox and O’Sullivan considered a wide range of problems (including regression problems
with squared loss and classiﬁcation using logistic loss) where the solution is
obtained by minimizing the regularized risk using a spline smoothness term.
They showed that if f ∗
L ∈H then as n →∞and λn →0 at an appropriate rate, one gets
convergence of fD to f ∗
More recently, Zhang [2004, Theorem 4.4] has shown that for the classiﬁcation problem with a number of diﬀerent loss functions (including logistic loss,
hinge loss and quadratic loss) and for general RKHSs with a nondegenerate
kernel, that if λn →0, λnn →∞and µ(x, y) is suﬃciently regular then the
classiﬁcation error of fD will converge to the Bayes optimal error in probability
as n →∞. Similar results have also been obtained by Steinwart with
various rates on the decay of λn depending on the smoothness of the kernel.
Bartlett et al. have characterized the loss functions that lead to universal
consistency.
Above we have focussed on regression and classiﬁcation problems. However,
similar analyses can also be given for other problems such as density estimation
and deconvolution; see Wahba [1990, chs. 8, 9] for references. Also we have
discussed consistency using a ﬁxed decay rate for λn. However, it is also possible
to analyze the asymptotics of methods where λn is set in a data-dependent way,
e.g. by cross-validation;2 see Wahba [1990, sec. 4.5] and references therein for
further details.
Consistency is evidently a desirable property of supervised learning procedures. However, it is an asymptotic property that does not say very much about
how a given prediction procedure will perform on a particular problem with a
given dataset. For instance, note that we only required rather general properties of the kernel function (e.g. non-degeneracy) for some of the consistency
results. However, the choice of the kernel can make a huge diﬀerence to how a
procedure performs in practice. Some analyses related to this issue are given in
section 7.3.
Equivalence and Orthogonality
The presentation in this section is based mainly on Stein [1999, ch. 4]. For
two probability measures µ0 and µ1 deﬁned on a measurable space (Ω, F),3
µ0 is said to be absolutely continuous w.r.t. µ1 if for all A ∈F, µ1(A) = 0
implies µ0(A) = 0. If µ0 is absolutely continuous w.r.t. µ1 and µ1 is absolutely
continuous w.r.t. µ0 the two measures are said to be equivalent, written µ0 ≡µ1.
µ0 and µ1 are said to be orthogonal, written µ0 ⊥µ1, if there exists an A ∈F
such that µ0(A) = 1 and µ1(A) = 0. (Note that in this case we have µ0(Ac) = 0
and µ1(Ac) = 1, where Ac is the complement of A.) The dichotomy theorem for
Gaussian processes (due to Hajek and, independently, Feldman )
states that two Gaussian processes are either equivalent or orthogonal.
Equivalence and orthogonality for Gaussian measures µ0, µ1 with corresponding probability densities p0, p1, can be characterized in terms of the
2Cross validation is discussed in section 5.3.
3See section A.7 for background on measurable spaces.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
symmetrized Kullback-Leibler divergence KLsym between them, given by
KLsym(p0, p1) =
(p0(f) −p1(f)) log p0(f)
The measures are equivalent if KLsym < ∞and orthogonal otherwise. For two
ﬁnite-dimensional Gaussian distributions N(µ0, K0) and N(µ1, K1) we have
[Kullback, 1959, sec. 9.1]
2 tr(K0 −K1)(K−1
0 )(µ0 −µ1)(µ0 −µ1)⊤.
This expression can be simpliﬁed considerably by simultaneously diagonalizing
K0 and K1. Two ﬁnite-dimensional Gaussian distributions are equivalent if the
null spaces of their covariance matrices coincide, and are orthogonal otherwise.
Things can get more interesting if we consider inﬁnite-dimensional distributions, i.e. Gaussian processes. Consider some closed subset R ∈RD. Choose
some ﬁnite number n of x-points in R and let f = (f1, . . . , fn)⊤denote the
values corresponding to these inputs.
We consider the KLsym-divergence as
above, but in the limit n →∞. KLsym can now diverge if the rates of decay of
the eigenvalues of the two processes are not the same. For example, consider
zero-mean periodic processes with period 1 where the eigenvalue λi
j indicates
the amount of power in the sin/cos terms of frequency 2πj for process i = 0, 1.
Then using eq. (7.18) we have
KLsym = .
Some corresponding results for the equivalence or orthogonality of non-periodic Gaussian processes are given in Stein
[1999, pp. 119-122]. Stein (p. 109) gives an example of two equivalent Gaussian
processes on R, those with covariance functions exp(−r) and 1/2 exp(−2r). (It
is easy to check that for large s these have the same power spectrum.)
We now turn to the consequences of equivalence for the model selection
problem. Suppose that we know that either GP0 or GP1 is the correct model.
Then if GP0 ≡GP1 then it is not possible to determine which model is correct
with probability 1. However, under a Bayesian setting all this means is if we
have prior probabilities π0 and π1 = 1 −π0 on these two hypotheses, then after
observing some data D the posterior probabilities p(GPi|D) (for i = 0, 1) will
not be 0 or 1, but could be heavily skewed to one model or the other.
The other important observation is to consider the predictions made by GP0
or GP1. Consider the case where GP0 is the correct model and GP1 ≡GP0.
Then Stein [1999, sec. 4.3] shows that the predictions of GP1 are asymptotically
optimal, in the sense that the expected relative prediction error between GP1
and GP0 tends to 0 as n →∞under some technical conditions. Stein’s Corollary 9 (p. 132) shows that this conclusion remains true under additive noise if
the un-noisy GPs are equivalent. One caveat about equivalence is although the
predictions of GP1 are asymptotically optimal when GP0 is the correct model
and GP0 ≡GP1, one would see diﬀering predictions for ﬁnite n.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
7.3 Average-case Learning Curves
Average-case Learning Curves
In section 7.2 we have discussed the asymptotic properties of Gaussian process
predictors and related methods. In this section we will say more about the
speed of convergence under certain speciﬁc assumptions. Our goal will be to
obtain a learning curve describing the generalization error as a function of the
training set size n. This is an average-case analysis, averaging over the choice
of target functions (drawn from a GP) and over the x locations of the training
In more detail, we ﬁrst consider a target function f drawn from a Gaussian
process. n locations are chosen to make observations at, giving rise to the training set D = (X, y). The yis are (possibly) noisy observations of the underlying
function f. Given a loss function L(·, ·) which measures the diﬀerence between
the prediction for f and f itself, we obtain an estimator fD for f. Below we
will use the squared loss, so that the posterior mean ¯fD(x) is the estimator.
Then the generalization error (given f and D) is given by
generalization error
L(f(x∗), ¯fD(x∗))p(x∗) dx∗.
As this is an expected loss it is technically a risk, but the term generalization
error is commonly used.
D(f) depends on both the choice of f and on X. (Note that y depends on
the choice of f, and also on the noise, if present.) The ﬁrst level of averaging
we consider is over functions f drawn from a GP prior, to obtain
D(f)p(f) df.
It will turn out that for regression problems with Gaussian process priors and
predictors this average can be readily calculated. The second level of averaging
assumes that the x-locations of the training set are drawn i.i.d. from p(x) to
Eg(X)p(x1) . . . p(xn) dx1 . . . dxn.
A plot of Eg(n) against n is known as a learning curve.
learning curve
Rather than averaging over X, an alternative is to minimize Eg(X) w.r.t. X.
This gives rise to the optimal experimental design problem. We will not say
more about this problem here, but it has been subject to a large amount of
investigation. An early paper on this subject is by Ylvisaker . These
questions have been addressed both in the statistical literature and in theoretical
numerical analysis; for the latter area the book by Ritter provides a useful
We now proceed to develop the average-case analysis further for the speciﬁc
case of GP predictors and GP priors for the regression case using squared loss.
Let f be drawn from a zero-mean GP with covariance function k0 and noise
0. Similarly the predictor assumes a zero-mean process, but covariance
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
function k1 and noise level σ2
1. At a particular test location x∗, averaging over
E[(f(x∗) −k1(x∗)⊤K−1
= E[f 2(x∗)] −2k1(x∗)⊤K−1
1,yE[f(x∗)y] + k1(x∗)⊤K−1
1,yE[yy⊤]K−1
= k0(x∗, x∗) −2k1(x∗)⊤K−1
1,yk0(x∗) + k1(x∗)⊤K−1
1,yK0,yK−1
where Ki,y = Ki,f + σ2
i for i = 0, 1, i.e. the covariance matrix including the
assumed noise.
If k1 = k0 so that the predictor is correctly speciﬁed then
the above expression reduces to k0(x∗, x∗)−k0(x∗)⊤K−1
0,yk0(x∗), the predictive
variance of the GP.
Averaging the error over p(x∗) we obtain
E[(f(x∗) −k1(x∗)⊤K−1
1,yy)2]p(x∗) dx∗
k0(x∗, x∗)p(x∗) dx∗−2 tr
k0(x∗)k1(x∗)⊤p(x∗) dx∗
1,yK0,yK−1
k1(x∗)k1(x)⊤p(x∗) dx∗
For some choices of p(x∗) and covariance functions these integrals will be analytically tractable, reducing the computation of Eg(X) to a n × n matrix
computation.
To obtain Eg(n) we need to perform a ﬁnal level of averaging over X. In
general this is diﬃcult even if Eg(X) can be computed exactly, but it is sometimes possible, e.g. for the noise-free OU process on the real line, see section
The form of Eg(X) can be simpliﬁed considerably if we express the covariance functions in terms of their eigenfunction expansions. In the case that k0 =
k1 we use the deﬁnition k(x, x′) = P
i λiφi(x)φi(x′) and
k(x, x′)φi(x)p(x) dx =
λiφi(x′). Let Λ be a diagonal matrix of the eigenvalues and Φ be the N × n
design matrix, as deﬁned in section 2.1.2. Then from eq. (7.24) we obtain
Eg(X) = tr(Λ) −tr((σ2
nI + Φ⊤ΛΦ)−1Φ⊤Λ2Φ)
= tr(Λ−1 + σ−2
where the second line follows through the use of the matrix inversion lemma
eq. (A.9) (or directly if we use eq. (2.11)), as shown in Sollich or Opper
and Vivarelli . Using the fact that EX[ΦΦ⊤] = nI, a na¨ıve approximation
would replace ΦΦ⊤inside the trace with its expectation; in fact Opper and
Vivarelli showed that this gives a lower bound, so that
Eg(n) ≥tr(Λ−1 + nσ−2
n I)−1 = σ2
Examining the asymptotics of eq. (7.26), we see that for each eigenvalue where
n/n we add σ2
n/n onto the bound on the generalization error. As we saw
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
7.4 PAC-Bayesian Analysis
in section 7.1, more eigenfunctions “come into play” as n increases, so the rate
of decay of Eg(n) is slower than 1/n. Sollich derives a number of more
accurate approximations to the learning curve than eq. (7.26).
For the noiseless case with k1 = k0, there is a simple lower bound Eg(n) ≥
i=n+1 λi due to Micchelli and Wahba .
This bound is obtained by
demonstrating that the optimal n pieces of information are the projections of the
random function f onto the ﬁrst n eigenfunctions. As observations which simply
consist of function evaluations will not in general provide such information this
is a lower bound. Plaskota generalized this result to give a bound on the
learning curve if the observations are noisy.
Some asymptotic results for the learning curves are known. For example, in
Ritter [2000, sec. V.2] covariance functions obeying Sacks-Ylvisaker conditions4
of order r in 1-d are considered. He shows that for an optimal sampling of the
input space the generalization error goes as O(n−(2r+1)/(2r+2)) for the noisy
problem. Similar rates can also be found in Sollich for random designs.
For the noise-free case Ritter [2000, p. 103] gives the rate as O(n−(2r+1)).
One can examine the learning curve not only asymptotically but also for
small n, where typically the curve has a roughly linear decrease with n. Williams
and Vivarelli explained this behaviour by observing that the introduction
of a datapoint x1 reduces the variance locally around x1 (assuming a stationary
covariance function). The addition of another datapoint at x2 will also create
a “hole” there, and so on. With only a small number of datapoints it is likely
that these holes will be far apart so their contributions will add, thus explaining
the initial linear trend.
Sollich has also investigated the mismatched case where k0 ̸= k1.
This can give rise to a rich variety of behaviours in the learning curves, including plateaux. Stein [1999, chs. 3, 4] has also carried out some analysis of the
mismatched case.
Although we have focused on GP regression with squared loss, we note that
Malzahn and Opper have developed more general techniques that can be
used to analyze learning curves for other situations such as GP classiﬁcation.
PAC-Bayesian Analysis
In section 7.3 we gave an average-case analysis of generalization, taking the
average with respect to a GP prior over functions. In this section we present
a diﬀerent kind of analysis within the probably approximately correct (PAC)
framework due to Valiant . Seeger [2002; 2003] has presented a PAC-
Bayesian analysis of generalization in Gaussian process classiﬁers and we get
to this in a number of stages; we ﬁrst present an introduction to the PAC
framework (section 7.4.1), then describe the PAC-Bayesian approach (section
4Roughly speaking, a stochastic process which possesses r MS derivatives but not r + 1
is said to satisfy Sacks-Ylvisaker conditions of order r; in 1-d this gives rise to a spectrum
λi ∝i−(2r+2) asymptotically. The OU process obeys Sacks-Ylvisaker conditions of order 0.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
7.4.2) and then ﬁnally the application to GP classiﬁcation (section 7.4.3). Our
presentation is based mainly on Seeger .
The PAC Framework
Consider a ﬁxed measure µ(x, y). Given a loss function L there exists a function
η(x) which minimizes the expected risk. By running a learning algorithm on
a data set D of size n drawn i.i.d. from µ(x, y) we obtain an estimate fD of η
which attains an expected risk RL(fD). We are not able to evaluate RL(fD) as
we do not know µ. However, we do have access to the empirical distribution of
the training set ˆµ(x, y) = 1
i δ(x−xi)δ(y−yi) and can compute the empirical
risk ˆRL(fD) = 1
i L(yi, fD(xi)). Because the training set had been used to
compute fD we would expect ˆRL(fD) to underestimate RL(fD),5 and the aim
of the PAC analysis is to provide a bound on RL(fD) based on ˆRL(fD).
A PAC bound has the following format
pD{RL(fD) ≤ˆRL(fD) + gap(fD, D, δ)} ≥1 −δ,
where pD denotes the probability distribution of datasets drawn i.i.d. from
µ(x, y), and δ ∈(0, 1) is called the conﬁdence parameter. The bound states
that, averaged over draws of the dataset D from µ(x, y), RL(fD) does not
exceed the sum of ˆRL(fD) and the gap term with probability of at least 1 −δ.
The δ accounts for the “probably” in PAC, and the “approximately” derives
from the fact that the gap term is positive for all n. It is important to note that
PAC analyses are distribution-free, i.e. eq. (7.27) must hold for any measure µ.
There are two kinds of PAC bounds, depending on whether gap(fD, D, δ)
actually depends on the particular sample D (rather than on simple statistics
like n). Bounds that do depend on D are called data dependent, and those that
do not are called data independent. The PAC-Bayesian bounds given below are
data dependent.
It is important to understand the interpretation of a PAC bound and to
clarify this we ﬁrst consider a simpler case of statistical inference.
given a dataset D = {x1, . . . , xn} drawn i.i.d. from a distribution µ(x) that
has mean m. An estimate of m is given by the sample mean ¯x = P
Under certain assumptions we can obtain (or put bounds on) the sampling
distribution p(¯x|m) which relates to the choice of dataset D. However, if we
wish to perform probabilistic inference for m we need to combine p(¯x|m) with
a prior distribution p(m) and use Bayes’ theorem to obtain the posterior.6
The situation is similar (although somewhat more complex) for PAC bounds as
these concern the sampling distribution of the expected and empirical risks of
fD w.r.t. D.
5It is also possible to consider PAC analyses of other empirical quantities such as the
cross-validation error (see section 5.3) which do not have this bias.
6In introductory treatments of frequentist statistics the logical hiatus of going from the
sampling distribution to inference on the parameter of interest is often not well explained.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
7.4 PAC-Bayesian Analysis
We might wish to make a conditional statement like
pD{RL(fD) ≤r + gap(fD, D, δ)| ˆRL(fD) = r} ≥1 −δ,
where r is a small value, but such a statement cannot be inferred directly from
the PAC bound. This is because the gap might be heavily anti-correlated with
ˆRL(fD) so that the gap is large when the empirical risk is small.
PAC bounds are sometimes used to carry out model selection—given a learning machine which depends on a (discrete or continuous) parameter vector θ,
one can seek to minimize the generalization bound as a function of θ. However,
this procedure may not be well-justiﬁed if the generalization bounds are loose.
Let the slack denote the diﬀerence between the value of the bound and the
generalization error. The danger of choosing θ to minimize the bound is that
if the slack depends on θ then the value of θ that minimizes the bound may be
very diﬀerent from the value of θ that minimizes the generalization error. See
Seeger [2003, sec. 2.2.4] for further discussion.
PAC-Bayesian Analysis
We now consider a Bayesian set up, with a prior distribution p(w) over the parameters w, and a “posterior” distribution q(w). (Strictly speaking the analysis
does not require q(w) to be the posterior distribution, just some other distribution, but in practice we will consider q to be an (approximate) posterior distribution.) We also limit our discussion to binary classiﬁcation with labels {−1, 1},
although more general cases can be considered, see Seeger [2003, sec. 3.2.2].
The predictive distribution for f∗at a test point x∗given q(w) is q(f∗|x∗) =
q(f∗|w, x∗)q(w)dw, and the predictive classiﬁer outputs sgn(q(f∗|x∗) −1/2).
predictive classiﬁer
The Gibbs classiﬁer has also been studied in learning theory; given a test point
Gibbs classiﬁer
x∗one draws a sample ˜w from q(w) and predicts the label using sgn(f(x∗; ˜w)).
The main reason for introducing the Gibbs classiﬁer here is that the PAC-
Bayesian theorems given below apply to Gibbs classiﬁers.
For a given parameter vector w giving rise to a classiﬁer c(x; w), the expected risk and empirical risk are given by
L(y, c(x; w)) dµ(x, y),
ˆRL(w) = 1
L(yi, c(xi; w)). (7.29)
As the Gibbs classiﬁer draws samples from q(w) we consider the averaged risks
RL(w)q(w) dw,
ˆRL(w)q(w) dw.
Theorem 7.1 (McAllester’s PAC-Bayesian theorem) For any probability mea-
McAllester’s
PAC-Bayesian theorem
sures p and q over w and for any bounded loss function L for which L(y, c(x)) ∈
 for any classiﬁer c and input x we have
RL(q) ≤ˆRL(q) +
KL(q||p) + log 1
δ + log n + 2
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
The proof can be found in McAllester . The Kullback-Leibler (KL) divergence KL(q||p) is deﬁned in section A.5. An example of a loss function which
obeys the conditions of the theorem is the 0/1 loss.
For the special case of 0/1 loss, Seeger gives the following tighter
Theorem 7.2 (Seeger’s PAC-Bayesian theorem) For any distribution over X ×
Seeger’s PAC-
Bayesian theorem
{−1, +1} and for any probability measures p and q over w the following bound
holds for i.i.d. samples drawn from the data distribution
KLBer( ˆRL(q)||RL(q)) ≤1
n(KL(q||p) + log n + 1
Here KLBer(·||·) is the KL divergence between two Bernoulli distributions (de-
ﬁned in eq. (A.22)).
Thus the theorem bounds (with high probability) the KL
divergence between ˆRL(q) and RL(q).
The PAC-Bayesian theorems above refer to a Gibbs classiﬁer.
interested in the predictive classiﬁer sgn(q(f∗|x∗) −1/2) then Seeger 
shows that if q(f∗|x∗) is symmetric about its mean then the expected risk
of the predictive classiﬁer is less than twice the expected risk of the Gibbs
classiﬁer. However, this result is based on a simple bounding argument and in
practice one would expect that the predictive classiﬁer will usually give better
performance than the Gibbs classiﬁer. Recent work by Meir and Zhang 
provides some PAC bounds directly for Bayesian algorithms (like the predictive
classiﬁer) whose predictions are made on the basis of a data-dependent posterior
distribution.
PAC-Bayesian Analysis of GP Classiﬁcation
To apply this bound to the Gaussian process case we need to compute the
KL divergence KL(q||p) between the posterior distribution q(w) and the prior
distribution p(w). Although this could be considered w.r.t. the weight vector
w in the eigenfunction expansion, in fact it turns out to be more convenient
to consider the latent function value f(x) at every possible point in the input
space X as the parameter. We divide this (possibly inﬁnite) vector into two
parts, (1) the values corresponding to the training points x1, . . . , xn, denoted
f, and (2) those at the remaining points in x-space (the test points) f∗.
The key observation is that all methods we have described for dealing with
GP classiﬁcation problems produce a posterior approximation q(f|y) which is
deﬁned at the training points. (This is an approximation for Laplace’s method
and for EP; MCMC methods sample from the exact posterior.) This posterior
over f is then extended to the test points by setting q(f, f∗|y) = q(f|y)p(f∗|f).
Of course for the prior distribution we have a similar decomposition p(f, f∗) =
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
7.5 Comparison with Other Supervised Learning Methods
p(f)p(f∗|f). Thus the KL divergence is given by
KL(q||p) =
q(f|y)p(f∗|f) log q(f|y)p(f∗|f)
p(f)p(f∗|f) dfdf∗
q(f|y) log q(f|y)
as shown e.g. in Seeger .
Notice that this has reduced a rather scary
inﬁnite-dimensional integration to a more manageable n-dimensional integration; in the case that q(f|y) is Gaussian (as for the Laplace and EP approximations), this KL divergence can be computed using eq. (A.23). For the Laplace
approximation with p(f) = N(0, K) and q(f|y) = N(ˆf, A−1) this gives
KL(q||p) =
2 log |K| + 1
2 log |A| + 1
 A−1(K−1 −A)
2ˆf ⊤K−1ˆf. (7.34)
Seeger has evaluated the quality of the bound produced by the PAC-
Bayesian method for a Laplace GPC on the task of discriminating handwritten
2s and 3s from the MNIST handwritten digits database.7 He reserved a test set
of 1000 examples and used training sets of size 500, 1000, 2000, 5000 and 9000.
The classiﬁcations were replicated ten times using draws of the training sets
from a pool of 12089 examples. We quote example results for n = 5000 where
the training error was 0.0187 ± 0.0016, the test error was 0.0195 ± 0.0011 and
the PAC-Bayesian bound on the generalization error (evaluated for δ = 0.01)
was 0.076 ± 0.002.
(The ± ﬁgures denote a 95% conﬁdence interval.)
classiﬁcation results are for the Gibbs classiﬁer; for the predictive classiﬁer the
test error rate was 0.0171±0.0016. Thus the generalization error is around 2%,
while the PAC bound is 7.6%. Many PAC bounds struggle to predict error rates
below 100%(!), so this is an impressive and highly non-trivial result. Further
details and experiments can be found in Seeger .
Comparison with Other Supervised Learning Methods
The focus of this book is on Gaussian process methods for supervised learning.
However, there are many other techniques available for supervised learning such
as linear regression, logistic regression, decision trees, neural networks, support
vector machines, kernel smoothers, k-nearest neighbour classiﬁers, etc., and we
need to consider the relative strengths and weaknesses of these approaches.
Supervised learning is an inductive process—given a ﬁnite training set we
wish to infer a function f that makes predictions for all possible input values.
The additional assumptions made by the learning algorithm are known as its
inductive bias . Sometimes these assumptions
inductive bias
are explicit, but for other algorithms (e.g. for decision tree induction) they can
be rather more implicit.
7See 
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
However, for all their variety, supervised learning algorithms are based on
the idea that similar input patterns will usually give rise to similar outputs (or
output distributions), and it is the precise notion of similarity that diﬀerentiates
the algorithms.
For example some algorithms may do feature selection and
decide that there are input dimensions that are irrelevant to the predictive task.
Some algorithms may construct new features out of those provided and measure
similarity in this derived space. As we have seen, many regression techniques
can be seen as linear smoothers (see section 2.6) and these techniques vary in
the deﬁnition of the weight function that is used.
One important distinction between diﬀerent learning algorithms is how they
relate to the question of universal consistency (see section 7.2.1). For example
a linear regression model will be inconsistent if the function that minimizes the
risk cannot be represented by a linear function of the inputs. In general a model
with a ﬁnite-dimensional parameter vector will not be universally consistent.
Examples of such models are linear regression and logistic regression with a
ﬁnite-dimensional feature vector, and neural networks with a ﬁxed number of
hidden units. In contrast to these parametric models we have non-parametric
models (such as k-nearest neighbour classiﬁers, kernel smoothers and Gaussian
processes and SVMs with nondegenerate kernels) which do not compress the
training data into a ﬁnite-dimensional parameter vector. An intermediate position is taken by semi-parametric models such as neural networks where the
number of hidden units k is allowed to increase as n increases. In this case universal consistency results can be obtained [Devroye et al., 1996, ch. 30] under
certain technical conditions and growth rates on k.
Although universal consistency is a “good thing”, it does not necessarily
mean that we should only consider procedures that have this property; for
example if on a speciﬁc problem we knew that a linear regression model was
consistent for that problem then it would be very natural to use it.
In the 1980’s there was a large surge in interest in artiﬁcial neural networks
neural networks
(ANNs), which are feedforward networks consisting of an input layer, followed
by one or more layers of non-linear transformations of weighted combinations of
the activity from previous layers, and an output layer. One reason for this surge
of interest was the use of the backpropagation algorithm for training ANNs.
Initial excitement centered around that fact that training non-linear networks
was possible, but later the focus came onto the generalization performance of
ANNs, and how to deal with questions such as how many layers of hidden
units to use, how many units there should be in each layer, and what type of
non-linearities should be used, etc.
For a particular ANN the search for a good set of weights for a given training
set is complicated by the fact that there can be local optima in the optimization
problem; this can cause signiﬁcant diﬃculties in practice. In contrast for Gaussian process regression and classiﬁcation the posterior for the latent variables
is convex.
One approach to the problems raised above was to put ANNs in a Bayesian
Bayesian neural
framework, as developed by MacKay [1992a] and Neal . This gives rise
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
7.5 Comparison with Other Supervised Learning Methods
to posterior distributions over weights for a given architecture, and the use of
the marginal likelihood (see section 5.2) for model comparison and selection.
In contrast to Gaussian process regression the marginal likelihood for a given
ANN model is not analytically tractable, and thus approximation techniques
such as the Laplace approximation [MacKay, 1992a] and Markov chain Monte
Carlo methods [Neal, 1996] have to be used. Neal’s observation that
certain ANNs with one hidden layer converge to a Gaussian process prior over
functions (see section 4.2.3) led us to consider GPs as alternatives to ANNs.
MacKay [2003, sec. 45.7] raises an interesting question whether in moving
from neural networks to Gaussian processes we have “thrown the baby out with
the bathwater?”. This question arises from his statements that “neural networks
were meant to be intelligent models that discovered features and patterns in
data”, while “Gaussian processes are simply smoothing devices”. Our answer
to this question is that GPs give us a computationally attractive method for
dealing with the smoothing problem for a given kernel, and that issues of feature
discovery etc. can be addressed through methods to select the kernel function
(see chapter 5 for more details on how to do this). Note that using a distance
function r2(x, x′) = (x −x′)⊤M(x −x′) with M having a low-rank form M =
ΛΛ⊤+Ψ as in eq. (4.22), features are described by the columns of Λ. However,
some of the non-convexity of the neural network optimization problem now
returns, as optimizing the marginal likelihood in terms of the parameters of M
may well have local optima.
As we have seen from chapters 2 and 3 linear regression and logistic regreslinear and logistic
regression
sion with Gaussian priors on the parameters are a natural starting point for
the development of Gaussian process regression and Gaussian process classiﬁcation. However, we need to enhance the ﬂexibility of these models, and the
use of non-degenerate kernels opens up the possibility of universal consistency.
Kernel smoothers and classiﬁers have been described in sections 2.6 and
kernel smoothers and
classiﬁers
7.2.1. At a high level there are similarities between GP prediction and these
methods as a kernel is placed on every training example and the prediction is
obtained through a weighted sum of the kernel functions, but the details of
the prediction and the underlying logic diﬀer. Note that the GP prediction
view gives us much more, e.g. error bars on the predictions and the use of the
marginal likelihood to set parameters in the kernel (see section 5.2). On the
other hand the computational problem that needs to be solved to carry out GP
prediction is more demanding than that for simple kernel-based methods.
Kernel smoothers and classiﬁers are non-parametric methods, and consistency can often be obtained under conditions where the width h of the kernel
tends to zero while nhD →∞. The equivalent kernel analysis of GP regression
(section 7.1) shows that there are quite close connections between the kernel
regression method and GPR, but note that the equivalent kernel automatically
reduces its width as n grows; in contrast the decay of h has to be imposed for
kernel regression. Also, for some kernel smoothing and classiﬁcation algorithms
the width of the kernel is increased in areas of low observation density; for example this would occur in algorithms that consider the k nearest neighbours of
a test point. Again notice from the equivalent kernel analysis that the width
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
of the equivalent kernel is larger in regions of low density, although the exact
dependence on the density will depend on the kernel used.
The similarities and diﬀerences between GP prediction and regularization
regularization networks,
splines, SVMs and
networks, splines, SVMs and RVMs have been discussed in chapter 6.
Appendix: Learning Curve for the Ornstein-
Uhlenbeck Process
We now consider the calculation of the learning curve for the OU covariance
function k(r) = exp(−α|r|) on the interval , assuming that the training x’s
are drawn from the uniform distribution U(0, 1). Our treatment is based on
Williams and Vivarelli .8 We ﬁrst calculate Eg(X) for a ﬁxed design, and
then integrate over possible designs to obtain Eg(n).
In the absence of noise the OU process is Markovian (as discussed in Appendix B and exercise 4.5.1). We consider the interval with points x1 <
x2 . . . < xn−1 < xn placed on this interval. Also let x0 = 0 and xn+1 = 1. Due
to the Markovian nature of the process the prediction at a test point x depends
only on the function values of the training points immediately to the left and
right of x. Thus in the i-th interval (counting from 0) the bounding points are
xi and xi+1. Let this interval have length δi.
Using eq. (7.24) we have
f(x) is the predictive variance at input x. Using the Markovian property
we have in interval i (for i = 1, . . . , n −1) that σ2
f(x) = k(0) −k(x)⊤K−1k(x)
where K is the 2 × 2 Gram matrix
and k(x) is the corresponding vector of length 2. Thus
where ∆i = k2(0) −k2(δi) and
f(x) = k(0)−1
[k(0)(k2(xi+1−x)+k2(x−xi))−2k(δi)k(x−xi)k(xi+1−x)].
f(x)dx = δik(0) −2
(I1(δi) −I2(δi))
8CW thanks Manfred Opper for pointing out that the upper bound developed in Williams
and Vivarelli is exact for the noise-free OU process.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
7.7 Exercises
I1(δ) = k(0)
I2(δ) = k(δ)
k(z)k(δ −z)dz.
For k(r) = exp(−α|r|) these equations reduce to I1(δ) = (1 −e−2αδ)/(2α),
I2(δ) = δe−2αδ and ∆= 1 −e−2αδ. Thus
f(x)dx = δi −1
α + 2δie−2αδi
1 −e−2αδi .
This calculation is not correct in the ﬁrst and last intervals where only x1
and xn are relevant (respectively). For the 0th interval we have that σ2
k(0) −k2(x1 −x)/k(0) and thus
f(x) = δ0k(0) −
k2(x1 −x)dx
2α(1 −e−2αδ0),
and a similar result holds for
Putting this all together we obtain
Eg(X) = 1 −n
2α(e−2αδ0 + e−2αδn) +
1 −e−2αδi .
Choosing a regular grid so that δ0 = δn = 1/2n and δi = 1/n for i =
1, . . . , n −1 it is straightforward to show (see exercise 7.7.4) that Eg scales as
O(n−1), in agreement with the general Sacks-Ylvisaker result [Ritter, 2000, p.
103] when it is recalled that the OU process obeys Sacks-Ylvisaker conditions
of order 0. A similar calculation is given in Plaskota [1996, sec. 3.8.2] for the
Wiener process on (note that this is also Markovian, but non-stationary).
We have now worked out the generalization error for a ﬁxed design X.
However to compute Eg(n) we need to average Eg(X) over draws of X from the
uniform distribution. The theory of order statistics David [1970, eq. 2.3.4] tells
us that p(δ) = n(1−δ)n−1 for all the δi, i = 0, . . . , n. Taking the expectation of
Eg(X) then turns into the problem of evaluating the one-dimensional integrals
e−2αδp(δ)dδ and
δe−2αδ(1 −e−2αδ)−1p(δ)dδ.
Exercise 7.7.5 asks you to
compute these integrals numerically.
1. Consider a spline regularizer with Sf(s) = c−1|s|−2m. (As we noted in
section 6.3 this is not strictly a power spectrum as the spline is an improper prior, but it can be used as a power spectrum in eq. (7.9) for the
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Theoretical Perspectives
purposes of this analysis.) The equivalent kernel corresponding to this
spline is given by
Z exp(2πis · x)
1 + γ|s|2m
where γ = cσ2
By changing variables in the integration to |t| =
γ1/2m|s| show that the width of h(x) scales as n−1/2m.
2. Equation 7.45 gives the form of the equivalent kernel for a spline regularizer. Show that h(0) is only ﬁnite if 2m > D. (Hint: transform the integration to polar coordinates.) This observation was made by P. Whittle
in the discussion of Silverman , and shows the need for the condition
2m > D for spline smoothing.
3. Computer exercise: Space n + 1 points out evenly along the interval
(−1/2, 1/2). (Take n to be even so that one of the sample points falls at 0.)
Calculate the weight function (see section 2.6) corresponding to Gaussian
process regression with a particular covariance function and noise level,
and plot this for the point x = 0. Now compute the equivalent kernel corresponding to the covariance function (see, e.g. the examples in section
7.1.1), plot this on the same axes and compare results. Hint 1: Recall
that the equivalent kernel is deﬁned in terms of integration (see eq. (7.7))
so that there will be a scaling factor of 1/(n + 1). Hint 2: If you wish to
use large n (say > 1000), use the ngrid method described in section 2.6.
4. Consider Eg(X) as given in eq. (7.44) and choose a regular grid design X
so that δ0 = δn = 1/2n and δi = 1/n for i = 1, . . . , n−1. Show that Eg(X)
scales as O(n−1) asymptotically. Hint: when expanding 1 −exp(−2αδi),
be sure to extend the expansion to suﬃcient order.
5. Compute numerically the expectation of Eg(X) eq. (7.44) over random
designs for the OU process example discussed in section 7.6. Make use
of the fact [David, 1970, eq. 2.3.4] that p(δ) = n(1 −δ)n−1 for all the δi,
i = 0, . . . , n. Investigate the scaling behaviour of Eg(n) w.r.t. n.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Approximation Methods for
Large Datasets
As we have seen in the preceding chapters a signiﬁcant problem with Gaussian process prediction is that it typically scales as O(n3). For large problems
(e.g. n > 10, 000) both storing the Gram matrix and solving the associated
linear systems are prohibitive on modern workstations (although this boundary
can be pushed further by using high-performance computers).
An extensive range of proposals have been suggested to deal with this problem. Below we divide these into ﬁve parts: in section 8.1 we consider reducedrank approximations to the Gram matrix; in section 8.2 a general strategy for
greedy approximations is described; in section 8.3 we discuss various methods
for approximating the GP regression problem for ﬁxed hyperparameters; in section 8.4 we describe various methods for approximating the GP classiﬁcation
problem for ﬁxed hyperparameters; and in section 8.5 we describe methods to
approximate the marginal likelihood and its derivatives. Many (although not
all) of these methods use a subset of size m < n of the training examples.
Reduced-rank Approximations of the Gram
In the GP regression problem we need to invert the matrix K +σ2
nI (or at least
to solve a linear system (K + σ2
nI)v = y for v). If the matrix K has rank q (so
that it can be represented in the form K = QQ⊤where Q is an n × q matrix)
then this matrix inversion can be speeded up using the matrix inversion lemma
eq. (A.9) as (QQ⊤+σ2
nIn)−1 = σ−2
nIq +Q⊤Q)−1Q⊤. Notice that
the inversion of an n × n matrix has now been transformed to the inversion of
a q × q matrix.1
1For numerical reasons this is not the best way to solve such a linear system but it does
illustrate the savings that can be obtained with reduced-rank representations.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Approximation Methods for Large Datasets
In the case that the kernel is derived from an explicit feature expansion with
N features, then the Gram matrix will have rank min(n, N) so that exploitation
of this structure will be beneﬁcial if n > N. Even if the kernel is non-degenerate
it may happen that it has a fast-decaying eigenspectrum (see e.g. section 4.3.1)
so that a reduced-rank approximation will be accurate.
If K is not of rank < n, we can still consider reduced-rank approximations to
K. The optimal reduced-rank approximation of K w.r.t. the Frobenius norm
(see eq. (A.16)) is UqΛqU ⊤
q , where Λq is the diagonal matrix of the leading
q eigenvalues of K and Uq is the matrix of the corresponding orthonormal
eigenvectors [Golub and Van Loan, 1989, Theorem 8.1.9]. Unfortunately, this
is of limited interest in practice as computing the eigendecomposition is an
O(n3) operation. However, it does suggest that if we can more cheaply obtain
an approximate eigendecomposition then this may give rise to a useful reducedrank approximation to K.
We now consider selecting a subset I of the n datapoints; set I has size
m < n. The remaining n −m datapoints form the set R. (As a mnemonic, I is
for the included datapoints and R is for the remaining points.) We sometimes
call the included set the active set. Without loss of generality we assume that
the datapoints are ordered so that set I comes ﬁrst. Thus K can be partitioned
K(n−m)(n−m)
The top m × n block will also be referred to as Kmn and its transpose as Knm.
In section 4.3.2 we saw how to approximate the eigenfunctions of a kernel
using the Nystr¨om method. We can now apply the same idea to approximating
the eigenvalues/vectors of K. We compute the eigenvectors and eigenvalues of
Kmm and denote them {λ(m)
i=1 and {u(m)
i=1. These are extended to all n
points using eq. (4.44) to give
i = 1, . . . , m
i = 1, . . . , m
where the scaling of ˜u(n)
has been chosen so that |˜u(n)
| ≃1. In general we have
a choice of how many of the approximate eigenvalues/vectors to include in our
approximation of K; choosing the ﬁrst p we get ˜K = Pp
Below we will set p = m to obtain
˜K = KnmK−1
using equations 8.2 and 8.3, which we call the Nystr¨om approximation to K.
Nystr¨om approximation
Computation of ˜K takes time O(m2n) as the eigendecomposition of Kmm is
O(m3) and the computation of each ˜u(n)
is O(mn). Fowlkes et al. have
applied the Nystr¨om method to approximate the top few eigenvectors in a
computer vision problem where the matrices in question are larger than 106×106
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
8.1 Reduced-rank Approximations of the Gram Matrix
The Nystr¨om approximation has been applied above to approximate the
elements of K.
However, using the approximation for the ith eigenfunction
˜φi(x) = (√m/λ(m)
)km(x)⊤u(m)
, where km(x) = (k(x, x1), . . . , k(x, xm))⊤(a
restatement of eq. (4.44) using the current notation) and λi ≃λ(m)
easy to see that in general we obtain an approximation for the kernel k(x, x′) =
i=1 λiφi(x)φi(x′) as
˜k(x, x′) =
˜φi(x)˜φi(x′)
)2 km(x)⊤u(m)
= km(x)⊤K−1
Clearly eq. (8.4) is obtained by evaluating eq. (8.7) for all pairs of datapoints
in the training set.
By multiplying out eq. (8.4) using Kmn = [KmmKm(n−m)] it is easy to
show that Kmm = ˜Kmm, Km(n−m) = ˜Km(n−m), K(n−m)m = ˜K(n−m)m, but
that ˜K(n−m)(n−m) = K(n−m)mK−1
mmKm(n−m). The diﬀerence
K(n−m)(n−m) −˜K(n−m)(n−m) is in fact the Schur complement of Kmm [Golub
and Van Loan, 1989, p. 103]. It is easy to see that K(n−m)(n−m) −˜K(n−m)(n−m)
is positive semi-deﬁnite; if a vector f is partitioned as f ⊤= (f ⊤
n−m) and f
has a Gaussian distribution with zero mean and covariance K then fn−m|fm
has the Schur complement as its covariance matrix, see eq. (A.6).
The Nystr¨om approximation was derived in the above fashion by Williams
and Seeger for application to kernel machines. An alternative view which
gives rise to the same approximation is due to Smola and Sch¨olkopf . Here the starting point is that we
wish to approximate the kernel centered on point xi as a linear combination of
kernels from the active set, so that
k(xi, x) ≃
cijk(xj, x) ≜ˆk(xi, x)
for some coeﬃcients {cij} that are to be determined so as to optimize the
approximation. A reasonable criterion to minimize is
∥k(xi, x) −ˆk(xi, x)∥2
= tr K −2 tr(CKmn) + tr(CKmmC⊤),
where the coeﬃcients are arranged into a n × m matrix C. Minimizing E(C)
w.r.t. C gives Copt = KnmK−1
mm; thus we obtain the approximation ˆK =
mmKmn in agreement with eq. (8.4). Also, it can be shown that E(Copt) =
tr(K −ˆK).
Smola and Sch¨olkopf suggest a greedy algorithm to choose points to
include into the active set so as to minimize the error criterion. As it takes
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Approximation Methods for Large Datasets
O(mn) operations to evaluate the change in E due to including one new datapoint (see exercise 8.7.2) it is infeasible to consider all members of set R for
inclusion on each iteration; instead Smola and Sch¨olkopf suggest ﬁnding the best point to include from a randomly chosen subset of set R on each
iteration.
Recent work by Drineas and Mahoney analyzes a similar algorithm
to the Nystr¨om approximation, except that they use biased sampling with replacement (choosing column i of K with probability ∝k2
ii) and a pseudoinverse
of the inner m × m matrix. For this algorithm they are able to provide probabilistic bounds on the quality of the approximation. Earlier work by Frieze
et al. had developed an approximation to the singular value decomposition (SVD) of a rectangular matrix using a weighted random subsampling of its
rows and columns, and probabilistic error bounds. However, this is rather diﬀerent from the Nystr¨om approximation; see Drineas and Mahoney [2005, sec. 5.2]
for details.
Fine and Scheinberg suggest an alternative low-rank approximation
to K using the incomplete Cholesky factorization . The idea here is that when computing the Cholesky decomposition of K pivots below a certain threshold are skipped.2 If the number
of pivots greater than the threshold is k the incomplete Cholesky factorization
takes time O(nk2).
Greedy Approximation
Many of the methods described below use an active set of training points of size
m selected from the training set of size n > m. We assume that it is impossible
to search for the optimal subset of size m due to combinatorics. The points
in the active set could be selected randomly, but in general we might expect
better performance if the points are selected greedily w.r.t. some criterion. In
the statistics literature greedy approaches are also known as forward selection
strategies.
A general recipe for greedy approximation is given in Algorithm 8.1. The
algorithm starts with the active set I being empty, and the set R containing the
indices of all training examples. On each iteration one index is selected from R
and added to I. This is achieved by evaluating some criterion ∆and selecting
the data point that optimizes this criterion. For some algorithms it can be too
expensive to evaluate ∆on all points in R, so some working set J ⊂R can be
chosen instead, usually at random from R.
Greedy selection methods have been used with the subset of regressors (SR),
subset of datapoints (SD) and the projected process (PP) methods described
2As a technical detail, symmetric permutations of the rows and columns are required to
stabilize the computations.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
8.3 Approximations for GPR with Fixed Hyperparameters
input: m, desired size of active set
2: Initialization I = ∅, R = {1, . . . , n}
for j := 1 . . . m do
Create working set J ⊆R
Compute ∆j for all j ∈J
i = argmaxj∈J∆j
Update model to include data from example i
I ←I ∪{i}, R ←R\{i}
10: return: I
Algorithm 8.1: General framework for greedy subset selection. ∆j is the criterion
function evaluated on data point j.
Approximations for GPR with Fixed Hyperparameters
We present six approximation schemes for GPR below, namely the subset of
regressors (SR), the Nystr¨om method, the subset of datapoints (SD), the projected process (PP) approximation, the Bayesian committee machine (BCM)
and the iterative solution of linear systems. Section 8.3.7 provides a summary
of these methods and a comparison of their performance on the SARCOS data
which was introduced in section 2.5.
Subset of Regressors
Silverman [1985, sec. 6.1] showed that the mean GP predictor can be obtained from a ﬁnite-dimensional generalized linear regression model f(x∗) =
i=1 αik(x∗, xi) with a prior α ∼N(0, K−1). To see this we use the mean
prediction for linear regression model in feature space given by eq. (2.11),
i.e. ¯f(x∗) = σ−2
n φ(x∗)⊤A−1Φy with A = Σ−1
n ΦΦ⊤. Setting φ(x∗) =
k(x∗), Φ = Φ⊤= K and Σ−1
= K we obtain
¯f(x∗) = σ−2
n k⊤(x∗)[σ−2
n K(K + σ2
= k⊤(x∗)(K + σ2
in agreement with eq. (2.25). Note, however, that the predictive (co)variance
of this model is diﬀerent from full GPR.
A simple approximation to this model is to consider only a subset of regressors, so that
αik(x∗, xi),
αm ∼N we obtain
¯fSR(x∗) = km(x∗)⊤(KmnKnm + σ2
nKmm)−1Kmny,
V[fSR(x∗)] = σ2
nkm(x∗)⊤(KmnKnm + σ2
nKmm)−1km(x∗).
Thus the posterior mean for αm is given by
¯αm = (KmnKnm + σ2
nKmm)−1Kmny.
This method has been proposed, for example, in Wahba [1990, chapter 7], and
in Poggio and Girosi [1990, eq. 25] via the regularization framework. The name
“subset of regressors” (SR) was suggested to us by G. Wahba. The computations for equations 8.14 and 8.15 take time O(m2n) to carry out the necessary
matrix computations. After this the prediction of the mean for a new test point
takes time O(m), and the predictive variance takes O(m2).
Under the subset of regressors model we have f ∼N(0, ˜K) where ˜K is
SR marginal likelihood
deﬁned as in eq. (8.4). Thus the log marginal likelihood under this model is
log pSR(y|X) = −1
2 log | ˜K + σ2
2y⊤( ˜K + σ2
nIn)−1y −n
2 log(2π). (8.17)
Notice that the covariance function deﬁned by the SR model has the form
˜k(x, x′) = k(x)⊤K−1
mmk(x′), which is exactly the same as that from the Nystr¨om
approximation for the covariance function eq. (8.7). In fact if the covariance
function k(x, x′) in the predictive mean and variance equations 2.25 and 2.26
is replaced systematically with ˜k(x, x′) we obtain equations 8.14 and 8.15, as
shown in Appendix 8.6.
If the kernel function decays to zero for |x| →∞for ﬁxed x′, then ˜k(x, x)
will be near zero when x is distant from points in the set I. This will be the case
even when the kernel is stationary so that k(x, x) is independent of x. Thus
we might expect that using the approximate kernel will give poor predictions,
especially underestimates of the predictive variance, when x is far from points
in the set I.
An interesting idea suggested by Rasmussen and Qui˜nonero-Candela 
to mitigate this problem is to deﬁne the SR model with m + 1 basis functions, where the extra basis function is centered on the test point x∗, so that
ySR∗(x∗) = Pm
i=1 αik(x∗, xi) + α∗k(x∗, x∗). This model can then be used to
make predictions, and it can be implemented eﬃciently using the partitioned
matrix inverse equations A.11 and A.12. The eﬀect of the extra basis function
centered on x∗is to maintain predictive variance at the test point.
So far we have not said how the subset I should be chosen.
One simple method is to choose it randomly from X, another is to run clustering on
i=1 to obtain centres. Alternatively, a number of greedy forward selection
algorithms for I have been proposed. Luo and Wahba choose the next
kernel so as to minimize the residual sum of squares (RSS) |y −Knmαm|2 after
optimizing αm. Smola and Bartlett take a similar approach, but choose
as their criterion the quadratic form
|y −Knm ¯αm|2 + ¯α⊤
mKmm ¯αm = y⊤ and the matrix inversion
lemma. Alternatively, Qui˜nonero-Candela suggests using the approximate log marginal likelihood log pSR(y|X) (see eq. (8.17)) as the selection criterion. In fact the quadratic term from eq. (8.18) is one of the terms comprising
log pSR(y|X).
For all these suggestions the complexity of evaluating the criterion on a new
example is O(mn), by making use of partitioned matrix equations. Thus it is
likely to be too expensive to consider all points in R on each iteration, and we
are likely to want to consider a smaller working set, as described in Algorithm
Note that the SR model is obtained by selecting some subset of the datapoints of size m in a random or greedy manner. The relevance vector machine
(RVM) described in section 6.6 has a similar ﬂavour in that it automatically
comparison with RVM
selects (in a greedy fashion) which datapoints to use in its expansion. However,
note one important diﬀerence which is that the RVM uses a diagonal prior on
the α’s, while for the SR method we have αm ∼N(0, K−1
The Nystr¨om Method
Williams and Seeger suggested approximating the GPR equations by
replacing the matrix K by ˜K in the mean and variance prediction equations
2.25 and 2.26, and called this the Nystr¨om method for approximate GPR. Notice
that in this proposal the covariance function k is not systematically replaced
by ˜k, it is only occurrences of the matrix K that are replaced.
As for the
SR model the time complexity is O(m2n) to carry out the necessary matrix
computations, and then O(n) for the predictive mean of a test point and O(mn)
for the predictive variance.
Experimental evidence in Williams et al. suggests that for large m
the SR and Nystr¨om methods have similar performance, but for small m the
Nystr¨om method can be quite poor. Also the fact that k is not systematically
replaced by ˜k means that embarrassments can occur like the approximated
predictive variance being negative. For these reasons we do not recommend the
Nystr¨om method over the SR method. However, the Nystr¨om method can be
eﬀective when λm+1, the (m + 1)th eigenvalue of K, is much smaller than σ2
Subset of Datapoints
The subset of regressors method described above approximated the form of the
predictive distribution, and particularly the predictive mean. Another simple
approximation to the full-sample GP predictor is to keep the GP predictor,
but only on a smaller subset of size m of the data. Although this is clearly
wasteful of data, it can make sense if the predictions obtained with m points
are suﬃciently accurate for our needs.
Clearly it can make sense to select which points are taken into the active set
I, and typically this is achieved by greedy algorithms. However, one has to be
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Approximation Methods for Large Datasets
wary of the amount of computation that is needed, especially if one considers
each member of R at each iteration.
Lawrence et al. suggest choosing as the next point (or site) for inclusion into the active set the one that maximizes the diﬀerential entropy score
∆j ≜H[p(fj)] −H[pnew(fj)], where H[p(fj)] is the
entropy of the Gaussian at site j ∈R (which is a function of the variance at site j as the posterior is Gaussian, see eq. (A.20)), and H[pnew(fj)] is the
entropy at this site
once the observation at site j has been included. Let the posterior variance
of fj before inclusion be vj. As p(fj|yI, yj) ∝p(fj|yI)N(yj|fj, σ2) we have
+ σ−2. Using the fact that the entropy of a Gaussian with
variance v is log(2πev)/2 we obtain
2 log(1 + vj/σ2).
∆j is a monotonic function of vj so that it is maximized by choosing the site with
the largest variance. Lawrence et al. call their method the informative
vector machine (IVM)
If coded na¨ıvely the complexity of computing the variance at all sites in R
on a single iteration is O(m3 + (n −m)m2) as we need to evaluate eq. (2.26) at
each site (and the matrix inversion of Kmm + σ2
nI can be done once in O(m3)
then stored).
However, as we are incrementally growing the matrices Kmm
and Km(n−m) in fact the cost is O(mn) per inclusion, leading to an overall
complexity of O(m2n) when using a subset of size m. For example, once a site
has been chosen for inclusion the matrix Kmm + σ2
nI is grown by including an
extra row and column. The inverse of this expanded matrix can be found using
eq. (A.12) although it would be better practice numerically to use a Cholesky
decomposition approach as described in Lawrence et al. . The scheme
evaluates ∆j over all j ∈R at each step to choose the inclusion site. This
makes sense when m is small, but as it gets larger it can make sense to select
candidate inclusion sites from a subset of R. Lawrence et al. call this the
randomized greedy selection method and give further ideas on how to choose
the subset.
The diﬀerential entropy score ∆j is not the only criterion that can be used for
site selection. For example the information gain criterion KL(pnew(fj)||p(fj))
can also be used . The use of greedy selection heuristics
here is similar to the problem of active learning, see e.g. MacKay [1992c].
Projected Process Approximation
The SR method has the unattractive feature that it is based on a degenerate
GP, the ﬁnite-dimensional model given in eq. (8.13). The SD method is a nondegenerate process model but it only makes use of m datapoints. The projected
process (PP) approximation is also a non-degenerate process model but it can
make use of all n datapoints.
We call it a projected process approximation
as it represents only m < n latent function values, but computes a likelihood
involving all n datapoints by projecting up the m latent points to n dimensions.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
8.3 Approximations for GPR with Fixed Hyperparameters
One problem with the basic GPR algorithm is the fact that the likelihood
term requires us to have f-values for the n training points. However, say we only
represent m of these values explicitly, and denote these as fm. Then the remaining f-values in R denoted fn−m have a conditional distribution p(fn−m|fm), the
mean of which is given by E[fn−m|fm] = K(n−m)mK−1
mmfm.3 Say we replace the
true likelihood term for the points in R by N(yn−m|E[fn−m|fm], σ2
nI). Including
also the likelihood contribution of the points in set I we have
q(y|fm) = N(y|KnmK−1
which can also be written as q(y|fm) = N(y|E[f|fm], σ2
nI). The key feature here
is that we have absorbed the information in all n points of D into the m points
The form of q(y|fm) in eq. (8.20) might seem rather arbitrary, but in fact
it can be shown that if we consider minimizing KL(q(f|y)||p(f|y)), the KLdivergence between the approximating distribution q(f|y) and the true posterior
p(f|y) over all q distributions of the form q(f|y) ∝p(f)R(fm) where R is positive
and depends on fm only, this is the form we obtain. See Seeger [2003, Lemma 4.1
and sec. C.2.1] for detailed derivations, and also Csat´o [2002, sec. 3.3].
To make predictions we ﬁrst have to compute the posterior distribution
q(fm|y). Deﬁne the shorthand P = K−1
mmKmn so that E[f|fm] = P ⊤fm. Then
q(y|fm) ∝exp
(y −P ⊤fm)⊤(y −P ⊤fm)
Combining this with the prior p(fm) ∝exp(−f ⊤
mmfm/2) we obtain
q(fm|y) ∝exp
PP ⊤)fm + 1
which can be recognized as a Gaussian N(µ, A) with
mm + PP ⊤) = σ−2
nKmm + KmnKnm)K−1
n APy = Kmm(σ2
nKmm + KmnKnm)−1Kmny.
Thus the predictive mean is given by
Eq[f(x∗)] = km(x∗)⊤K−1
= km(x∗)⊤(σ2
nKmm + KmnKnm)−1Kmny,
which turns out to be just the same as the predictive mean under the SR
model, as given in eq. (8.14). However, the predictive variance is diﬀerent. The
argument is the same as in eq. (3.23) and yields
Vq[f(x∗)] = k(x∗, x∗) −km(x∗)⊤K−1
+ km(x∗)⊤K−1
mmcov(fm|y)K−1
= k(x∗, x∗) −km(x∗)⊤K−1
nkm(x∗)⊤(σ2
nKmm + KmnKnm)−1km(x∗).
3There is no a priori reason why the m points chosen have to be a subset of the n points
in D—they could be disjoint from the training set. However, for our derivations below we
will consider them to be a subset.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Approximation Methods for Large Datasets
Notice that predictive variance is the sum of the predictive variance under the
SR model (last term in eq. (8.27)) plus k(x∗, x∗)−km(x∗)⊤K−1
mmkm(x∗) which
is the predictive variance at x∗given fm. Thus eq. (8.27) is never smaller than
the SR predictive variance and will become close to k(x∗, x∗) when x∗is far
away from the points in set I.
As for the SR model it takes time O(m2n) to carry out the necessary matrix
computations. After this the prediction of the mean for a new test point takes
time O(m), and the predictive variance takes O(m2).
We have q(y|fm) = N(y|P ⊤fm, σ2
nI) and p(fm) = N(0, Kmm). By integrating out fm we ﬁnd that y ∼N(0, ˜K + σ2
nIn). Thus the marginal likelihood
for the projected process approximation is the same as that for the SR model
eq. (8.17).
Again the question of how to choose which points go into the set I arises.
Csat´o and Opper present a method in which the training examples are
presented sequentially (in an “on-line” fashion). Given the current active set I
one can compute the novelty of a new input point; if this is large, then this point
is added to I, otherwise the point is added to R. To be precise, the novelty of
an input x is computed as k(x, x)−km(x)⊤K−1
mmk(x), which can be recognized
as the predictive variance at x given non-noisy observations at the points in I.
If the active set gets larger than some preset maximum size, then points can
be deleted from I, as speciﬁed in section 3.3 of Csat´o and Opper . Later
work by Csat´o et al. replaced the dependence of the algorithm described
above on the input sequence by an expectation-propagation type algorithm (see
section 3.6).
As an alternative method for selecting the active set, Seeger et al. 
suggest using a greedy subset selection method as per Algorithm 8.1. Computation of the information gain criterion after incorporating a new site takes
O(mn) and is thus too expensive to use as a selection criterion. However, an approximation to the information gain can be computed cheaply and this allows the
greedy subset algorithm to be run on all points in R on each iteration.
Bayesian Committee Machine
Tresp introduced the Bayesian committee machine (BCM) as a way of
speeding up Gaussian process regression. Let f∗be the vector of function values at the test locations. Under GPR we obtain a predictive Gaussian distribution for p(f∗|D). For the BCM we split the dataset into p parts D1, . . . , Dp
where Di = (Xi, yi) and make the approximation that p(y1, . . . , yp|f∗, X) ≃
i=1 p(yi|f∗, Xi). Under this approximation we have
q(f∗|D1, . . . , Dp) ∝p(f∗)
p(yi|f∗, Xi) = c
i=1 p(f∗|Di)
where c is a normalization constant.
Using the fact that the terms in the
numerator and denomination are all Gaussian distributions over f∗it is easy
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
8.3 Approximations for GPR with Fixed Hyperparameters
to show (see exercise 8.7.1) that the predictive mean and covariance for f∗are
Eq[f∗|D] = [covq(f∗|D)]
[cov(f∗|Di)]−1E[f∗|Di],
[covq(f∗|D)]−1 = −(p −1)K−1
[cov(f∗|Di)]−1,
where K∗∗is the covariance matrix evaluated at the test points. Here E[f∗|Di]
and cov(f∗|Di) are the mean and covariance of the predictions for f∗given Di,
as given in eqs. (2.23) and (2.24). Note that eq. (8.29) has an interesting form
in that the predictions from each part of the dataset are weighted by the inverse
predictive covariance.
We are free to choose how to partition the dataset D. This has two aspects,
the number of partitions and the assignment of data points to the partitions.
If we wish each partition to have size m, then p = n/m. Tresp used
a random assignment of data points to partitions but Schwaighofer and Tresp
 recommend that clustering the data (e.g. with p-means clustering) can
lead to improved performance. However, note that compared to the greedy
schemes used above clustering does not make use of the target y values, only
the inputs x.
Although it is possible to make predictions for any number of test points
n∗, this slows the method down as it involves the inversion of n∗× n∗matrices.
Schwaighofer and Tresp recommend making test predictions on blocks of
size m so that all matrices are of the same size. In this case the computational
complexity of BCM is O(pm3) = O(m2n) for predicting m test points, or
O(mn) per test point.
The BCM approach is transductive [Vapnik, 1995] rather than inductive, in
the sense that the method computes a test-set dependent model making use
of the test set input locations. Note also that if we wish to make a prediction
at just one test point, it would be necessary to “hallucinate” some extra test
points as eq. (8.28) generally becomes a better approximation as the number of
test points increases.
Iterative Solution of Linear Systems
One straightforward method to speed up GP regression is to note that the linear system (K + σ2
nI)v = y can be solved by an iterative method, for example
conjugate gradients (CG). Conjugate gradients gives the exact solution
(ignoring round-oﬀerrors) if run for n iterations, but it will give an approximate solution if terminated earlier, say after k iterations, with time complexity
O(kn2). This method has been suggested by Wahba et al. (in the context
of numerical weather prediction) and by Gibbs and MacKay (in the context of general GP regression). CG methods have also been used in the context
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Approximation Methods for Large Datasets
mean runtime (s)
0.0813 ± 0.0198
-1.4291 ± 0.0558
0.0532 ± 0.0046
-1.5834 ± 0.0319
0.0398 ± 0.0036
-1.7149 ± 0.0293
0.0290 ± 0.0013
-1.8611 ± 0.0204
0.0200 ± 0.0008
-2.0241 ± 0.0151
0.0351 ± 0.0036
-1.6088 ± 0.0984
0.0259 ± 0.0014
-1.8185 ± 0.0357
0.0193 ± 0.0008
-1.9728 ± 0.0207
0.0150 ± 0.0005
-2.1126 ± 0.0185
0.0110 ± 0.0004
-2.2474 ± 0.0204
0.0351 ± 0.0036
-1.6940 ± 0.0528
0.0259 ± 0.0014
-1.8423 ± 0.0286
0.0193 ± 0.0008
-1.9823 ± 0.0233
0.0150 ± 0.0005
-2.1125 ± 0.0202
0.0110 ± 0.0004
-2.2399 ± 0.0160
0.0314 ± 0.0046
-1.7066 ± 0.0550
0.0281 ± 0.0055
-1.7807 ± 0.0820
0.0180 ± 0.0010
-2.0081 ± 0.0321
0.0136 ± 0.0007
-2.1364 ± 0.0266
Table 8.1: Test results on the inverse dynamics problem for a number of diﬀerent
methods. Ten repetitions were used, the mean loss is shown ± one standard deviation.
of Laplace GPC, where linear systems are solved repeatedly to obtain the MAP
solution ˜f (see sections 3.4 and 3.5 for details).
One way that the CG method can be speeded up is by using an approximate
rather than exact matrix-vector multiplication. For example, recent work by
Yang et al. uses the improved fast Gauss transform for this purpose.
Comparison of Approximate GPR Methods
Above we have presented six approximation methods for GPR. Of these, we
retain only those methods which scale linearly with n, so the iterative solution of linear systems must be discounted. Also we discount the Nystr¨om approximation in preference to the SR method, leaving four alternatives: subset
of regressors (SR), subset of data (SD), projected process (PP) and Bayesian
committee machine (BCM).
Table 8.1 shows results of the four methods on the robot arm inverse dynamics problem described in section 2.5 which has D = 21 input variables,
44,484 training examples and 4,449 test examples. As in section 2.5 we used
the squared exponential covariance function with a separate length-scale parameter for each of the 21 input dimensions.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
8.3 Approximations for GPR with Fixed Hyperparameters
Initialization
Table 8.2:
A comparison of the space and time complexity of the four methods
using random selection of subsets. Initialization gives the time needed to carry out
preliminary matrix computations before the test point x∗is known.
Mean (resp.
variance) refers to the time needed to compute the predictive mean (variance) at x∗.
For the SD method a subset of the training data of size m was selected at
random, and the hyperparameters were set by optimizing the marginal likelihood on this subset. As ARD was used, this involved the optimization of D +2
hyperparameters. This process was repeated 10 times, giving rise to the mean
and standard deviation recorded in Table 8.1. For the SR, PP and BCM methods, the same subsets of the data and hyperparameter vectors were used as had
been obtained from the SD experiments.4 Note that the m = 4096 result is not
available for BCM as this gave an out-of-memory error.
These experiments were conducted on a 2.0 GHz twin processor machine
with 3.74 GB of RAM. The code for all four methods was written in Matlab.5
A summary of the time complexities for the four methods are given in Table
8.2. Thus for a test set of size n∗and using full (mean and variance) predictions
we ﬁnd that the SD method has time complexity O(m3) + O(m2n∗), for the
SR and PP methods it is O(m2n) + O(m2n∗), and for the BCM method it
is O(mnn∗). Assuming that n∗≥m these reduce to O(m2n∗), O(m2n) and
O(mnn∗) respectively.
These complexities are in broad agreement with the
timings in Table 8.1.
The results from Table 8.1 are plotted in Figure 8.1. As we would expect,
the general trend is that as m increases the SMSE and MSLL scores decrease.
Notice that it is well worth doing runs with small m so as to obtain a learning
curve with respect to m; this helps in getting a feeling of how useful runs at
large m will be. Both in terms of SMSE and MSLL we see (not surprisingly)
that SD is inferior to the other methods, all of which have similar performance.
These results were obtained using a random selection of the active set. Some
experiments were also carried out using active selection for the SD method
(IVM) and for the SR method but these did not lead to signiﬁcant improvements in performance. For BCM we also experimented with the use of p-means
clustering instead of random assignment to partitions; again this did not lead
to signiﬁcant improvements in performance. Overall on this dataset our con-
4In the BCM case it was only the hyperparameters that were re-used; the data was partitioned randomly into blocks of size m.
5We thank Anton Schwaighofer for making his BCM code available to us.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Approximation Methods for Large Datasets
Figure 8.1: Panel(a): plot of SMSE against m. Panel(b) shows the MSLL for the four
methods. The error bars denote one standard deviation. For clarity in both panels
the BCM results are slightly displaced horizontally w.r.t. the SR results.
clusion is that for ﬁxed m SR or PP are the methods of choice, as BCM has
longer running times for similar performance. However, notice that if we compare on runtime, then SD for m = 4096 is competitive with the SR, PP and
BCM results for m = 1024 on both time and performance.
In the above experiments the hyperparameters for all methods were set by
optimizing the marginal likelihood of the SD model of size m. This means that
we get a direct comparison of the diﬀerent methods using the same hyperparameters and subsets. However, one could alternatively optimize the (approximate)
marginal likelihood for each method (see section 8.5) and then compare results.
Notice that the hyperparameters which optimize the approximate marginal likelihood may depend on the method.
For example Figure 5.3(b) shows that
the maximum in the marginal likelihood occurs at shorter length-scales as the
amount of data increases. This eﬀect has also been observed by V. Tresp and
A. Schwaighofer when comparing the SD marginal likelihood eq. (8.31) with the full marginal likelihood computed on all n datapoints
eq. (5.8).
Schwaighofer and Tresp report some experimental comparisons between the BCM method and some other approximation methods for a number
of synthetic regression problems. In these experiments they optimized the kernel hyperparameters for each method separately. Their results are that for ﬁxed
m BCM performs as well as or better than the other methods. However, these
results depend on factors such as the noise level in the data generating process; they report that for relatively large noise levels BCM
no longer displays an advantage.
Based on the evidence currently available
we are unable to provide ﬁrm recommendations for one approximation method
over another; further research is required to understand the factors that aﬀect
performance.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
8.4 Approximations for GPC with Fixed Hyperparameters
Approximations for GPC with Fixed Hyperparameters
The approximation methods for GPC are similar to those for GPR, but need
to deal with the non-Gaussian likelihood as well, either by using the Laplace
approximation, see section 3.4, or expectation propagation (EP), see section
3.6. In this section we focus mainly on binary classiﬁcation tasks, although
some of the methods can also be extended to the multi-class case.
For the subset of regressors (SR) method we again use the model fSR(x∗) =
i=1 αik(x∗, xi) with αm ∼N(0, K−1
mm). The likelihood is non-Gaussian but
the optimization problem to ﬁnd the MAP value of αm is convex and can be
obtained using a Newton iteration. Using the MAP value ˆαm and the Hessian
at this point we obtain a predictive mean and variance for f(x∗) which can be
fed through the sigmoid function to yield probabilistic predictions. As usual
the question of how to choose a subset of points arises; Lin et al. select
these using a clustering method, while Zhu and Hastie propose a forward
selection strategy.
The subset of datapoints (SD) method for GPC was proposed in Lawrence
et al. , using an EP-style approximation of the posterior, and the diﬀerential entropy score (see section 8.3.3) to select new sites for inclusion. Note
that the EP approximation lends itself very naturally to sparsiﬁcation: a sparse
model results when some site precisions (see eq. (3.51)) are zero, making the corresponding likelihood term vanish. A computational gain can thus be achieved
by ignoring likelihood terms whose site precisions are very small.
The projected process (PP) approximation can also be used with non-
Gaussian likelihoods.
Csat´o and Opper present an “online” method
where the examples are processed sequentially, while Csat´o et al. give
an expectation-propagation type algorithm where multiple sweeps through the
training data are permitted.
The Bayesian committee machine (BCM) has also been generalized to deal
with non-Gaussian likelihoods in Tresp . As in the GPR case the dataset
is broken up into blocks, but now approximate inference is carried out using the
Laplace approximation in each block to yield an approximate predictive mean
Eq[f∗|Di] and approximate predictive covariance covq(f∗|Di). These predictions
are then combined as before using equations 8.29 and 8.30.
Approximating the Marginal Likelihood and ∗
its Derivatives
We consider approximations ﬁrst for GP regression, and then for GP classiﬁcation. For GPR, both the SR and PP methods give rise to the same approximate
marginal likelihood as given in eq. (8.17). For the SD method, a very simple
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Approximation Methods for Large Datasets
approximation (ignoring the datapoints not in the active set) is given by
log pSD(ym|Xm) = −1
2 log |Kmm +σ2I|−1
m(Kmm +σ2I)−1ym −m
2 log(2π),
where ym is the subvector of y corresponding to the active set; eq. (8.31) is
simply the log marginal likelihood under the model ym ∼N(0, Kmm + σ2I).
For the BCM, a simple approach would be to sum eq. (8.31) evaluated on
each partition of the dataset. This ignores interactions between the partitions.
Tresp and Schwaighofer have suggested a more sophisticated BCM-based method which approximately takes these interactions into
For GPC under the SR approximation, one can simply use the Laplace or EP
approximations on the ﬁnite-dimensional model. For SD one can again ignore all
datapoints not in the active set and compute an approximation to log p(ym|Xm)
using either Laplace or EP. For the projected process (PP) method, Seeger
[2003, p. 162] suggests the following lower bound
log p(y|X) = log
p(y|f)p(f) df = log
q(f)p(y|f)p(f)
p(y|f)p(f)
q(f) log q(y|f) df −KL(q(f)||p(f))
q(fi) log p(yi|fi) dfi −KL(q(fm)||p(fm)),
where q(f) is a shorthand for q(f|y) and eq. (8.32) follows from the equation
on the previous line using Jensen’s inequality. The KL divergence term can
be readily evaluated using eq. (A.23), and the one-dimensional integrals can be
tackled using numerical quadrature.
We are not aware of work on extending the BCM approximations to the
marginal likelihood to GPC.
Given the various approximations to the marginal likelihood mentioned
above, we may also want to compute derivatives in order to optimize it. Clearly
it will make sense to keep the active set ﬁxed during the optimization, although
note that this clashes with the fact that methods that select the active set
might choose a diﬀerent set as the covariance function parameters θ change.
For the classiﬁcation case the derivatives can be quite complex due to the fact
that site parameters (such as the MAP values ˆf, see section 3.4.1) change as
θ changes. (We have already seen an example of this in section 5.5 for the
non-sparse Laplace approximation.) Seeger [2003, sec. 4.8] describes some experiments comparing SD and PP methods for the optimization of the marginal
likelihood on both regression and classiﬁcation problems.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
8.6 Appendix: Equivalence of SR and GPR Using the Nystr¨om Approximate Kernel 187
Appendix: Equivalence of SR and GPR Us- ∗
ing the Nystr¨om Approximate Kernel
In section 8.3 we derived the subset of regressors predictors for the mean and
variance, as given in equations 8.14 and 8.15. The aim of this appendix is to
show that these are equivalent to the predictors that are obtained by replacing
k(x, x′) systematically with ˜k(x, x′) in the GPR prediction equations 2.25 and
First for the mean. The GPR predictor is E[f(x∗)] = k(x∗)⊤(K +σ2
Replacing all occurrences of k(x, x′) with ˜k(x, x′) we obtain
E[ ˜f(x∗)] = ˜k(x∗)⊤( ˜K + σ2
= km(x∗)⊤K−1
mmKmn(KnmK−1
mmKmn + σ2
n km(x∗)⊤K−1
In −KnmQ−1Kmn
n km(x∗)⊤K−1
Im −KmnKnmQ−1
n km(x∗)⊤K−1
= km(x∗)⊤Q−1Kmny,
where Q = σ2
nKmm + KmnKnm, which agrees with eq. (8.14). Equation (8.35)
follows from eq. (8.34) by use of the matrix inversion lemma eq. (A.9) and
eq. (8.37) follows from eq. (8.36) using Im = (σ2
nKmm + KmnKnm)Q−1. For
the predictive variance we have
V[ ˜f∗] = ˜k(x∗, x∗) −˜k(x∗)⊤( ˜K + σ2
nI)−1˜k(x∗)
= km(x∗)⊤K−1
km(x∗)⊤K−1
mmKmn(KnmK−1
mmKmn + σ2
nI)−1KnmK−1
= km(x∗)⊤K−1
mmkm(x∗) −km(x∗)⊤Q−1KmnKnmK−1
mmkm(x∗) (8.41)
= km(x∗)⊤
Im −Q−1KmnKnm
= km(x∗)⊤Q−1σ2
nkm(x∗)⊤Q−1km(x∗),
in agreement with eq. (8.15). The step between eqs. (8.40) and (8.41) is obtained
from eqs. (8.34) and (8.38) above, and eq. (8.43) follows from eq. (8.42) using
nKmm + KmnKnm)Q−1.
1. Verify that the mean and covariance of the BCM predictions (equations
8.29 and 8.30) are correct. If you are stuck, see Tresp for details.
2. Using eq. (8.10) and the fact that Copt = KnmK−1
mm show that E(Copt) =
tr(K −˜K), where ˜K = KnmK−1
mmKmn. Now consider adding one datapoint into set I, so that Kmm grows to K(m+1)(m+1). Using eq. (A.12)
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Approximation Methods for Large Datasets
show that the change in E due to adding the extra datapoint can be
computed in time O(mn).
If you need help, see Sch¨olkopf and Smola
[2002, sec. 10.2.2] for further details.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Further Issues and
Conclusions
In the previous chapters of the book we have concentrated on giving a solid
grounding in the use of GPs for regression and classiﬁcation problems, including model selection issues, approximation methods for large datasets, and connections to related models. In this chapter we provide some short descriptions
of other issues relating to Gaussian process prediction, with pointers to the
literature for further reading.
So far we have mainly discussed the case when the output target y is a single
label, but in section 9.1 we describe how to deal with the case that there are
multiple output targets. Similarly, for the regression problem we have focussed
on i.i.d. Gaussian noise; in section 9.2 we relax this condition to allow the
noise process to have correlations. The classiﬁcation problem is characterized
by a non-Gaussian likelihood function; however, there are other non-Gaussian
likelihoods of interest, as described in section 9.3.
We may not only have observations of function values, by also on derivatives
of the target function. In section 9.4 we discuss how to make use of this information in the GPR framework. Also it may happen that there is noise on the
observation of the input variable x; in section 9.5 we explain how this can be
handled. In section 9.6 we mention how more ﬂexible models can be obtained
using mixtures of Gaussian process models.
As well as carrying out prediction for test inputs, one might also wish to try
to ﬁnd the global optimum of a function within some compact set. Approaches
based on Gaussian processes for this problem are described in section 9.7. The
use of Gaussian processes to evaluate integrals is covered in section 9.8.
By using a scale mixture of Gaussians construction one can obtain a multivariate Student’s t distribution. This construction can be extended to give a
Student’s t process, as explained in section 9.9. One key aspect of the Bayesian
framework relates to the incorporation of prior knowledge into the problem
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Further Issues and Conclusions
formulation. In some applications we not only have the dataset D but also additional information. For example, for an optical character recognition problem
we know that translating the input pattern by one pixel will not change the
label of the pattern. Approaches for incorporating this knowledge are discussed
in section 9.10.
In this book we have concentrated on supervised learning problems. However, GPs can be used as components in unsupervised learning models, as described in section 9.11. Finally, we close with some conclusions and an outlook
to the future in section 9.12.
Multiple Outputs
Throughout this book we have concentrated on the problem of predicting a
single output variable y from an input x. However, it can happen that one
may wish to predict multiple output variables (or channels) simultaneously.
For example in the robot inverse dynamics problem described in section 2.5
there are really seven torques to be predicted. A simple approach is to model
each output variable as independent from the others and treat them separately.
However, this may lose information and be suboptimal.
One way in which correlation can occur is through a correlated noise process.
Even if the output channels are a priori independent, if the noise process is
correlated then this will induce correlations in the posterior processes. Such
a situation is easily handled in the GP framework by considering the joint,
block-diagonal, prior over the function values of each channel.
Another way that correlation of multiple channels can occur is if the prior
already has this structure. For example in geostatistical situations there may be
correlations between the abundances of diﬀerent ores, e.g. silver and lead. This
situation requires that the covariance function models not only the correlation
structure of each channel, but also the cross-correlations between channels.
Some work on this topic can be found in the geostatistics literature under
the name of cokriging, see e.g. Cressie [1993, sec. 3.2.3]. One way to induce
correlations between a number of output channels is to obtain them as linear
combinations of a number of latent channels, as described in Teh et al. ;
see also Micchelli and Pontil . A related approach is taken by Boyle and
Frean who introduce correlations between two processes by deriving them
as diﬀerent convolutions of the same underlying white noise process.
Noise Models with Dependencies
The noise models used so far have almost exclusively assumed Gaussianity and
independence. Non-Gaussian likelihoods are mentioned in section 9.3 below.
Inside the family of Gaussian noise models, it is not diﬃcult to model depencoloured noise
dencies. This may be particularly useful in models involving time. We simply
add terms to the noise covariance function with the desired structure, including
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
9.3 Non-Gaussian Likelihoods
hyperparameters. In fact, we already used this approach for the atmospheric
carbon dioxide modelling task in section 5.4.3. Also, Murray-Smith and Girard
 have used an autoregressive moving-average (ARMA) noise model (see
also eq. (B.51)) in a GP regression task.
Non-Gaussian Likelihoods
Our main focus has been on regression with Gaussian noise, and classiﬁcation
using the logistic or probit response functions. However, Gaussian processes can
be used as priors with other likelihood functions. For example, Diggle et al.
 were concerned with modelling count data measured geographically using
a Poisson likelihood with a spatially varying rate. They achieved this by placing
a GP prior over the log Poisson rate.
Goldberg et al. stayed with a Gaussian noise model, but introduced
heteroscedasticity, i.e. allowing the noise variance to be a function of x. This
was achieved by placing a GP prior on the log variance function. Neal 
robustiﬁed GP regression by using a Student’s t-distributed noise model rather
than Gaussian noise. Chu and Ghahramani have described how to use
GPs for the ordinal regression problem, where one is given ranked preference
information as the target data.
Derivative Observations
Since diﬀerentiation is a linear operator, the derivative of a Gaussian process
is another Gaussian process. Thus we can use GPs to make predictions about
derivatives, and also to make inference based on derivative information.
general, we can make inference based on the joint Gaussian distribution of
function values and partial derivatives. A covariance function k(·, ·) on function
values implies the following (mixed) covariance between function values and
partial derivatives, and between partial derivatives
= ∂k(xi, xj)
= ∂2k(xi, xj)
see e.g. Papoulis [1991, ch. 10] or Adler [1981, sec. 2.2]. With n datapoints in
D dimensions, the complete joint distribution of f and its D partial derivatives
involves n(D+1) quantities, but in a typical application we may only have access
to or interest in a subset of these; we simply remove the rows and columns
from the joint matrix which are not needed.
Observed function values and
derivatives may often have diﬀerent noise levels, which are incorporated by
adding a diagonal contribution with diﬀering hyperparameters. Inference and
predictions are done as usual. This approach was used in the context of learning
in dynamical systems by Solak et al. . In Figure 9.1 the posterior process
with and without derivative observations are compared. Noise-free derivatives
may be a useful way to enforce known constraints in a modelling problem.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Further Issues and Conclusions
output, y(x)
output, y(x)
Figure 9.1: In panel (a) we show four data points in a one dimensional noise-free
regression problem, together with three functions sampled from the posterior and the
95% conﬁdence region in light grey. In panel (b) the same observations have been
augmented by noise-free derivative information, indicated by small tangent segments
at the data points.
The covariance function is the squared exponential with unit
process variance and unit length-scale.
Prediction with Uncertain Inputs
It can happen that the input values to a prediction problem can be uncertain. For example, for a discrete time series one can perform multi-step-ahead
predictions by iterating one-step-ahead predictions. However, if the one-stepahead predictions include uncertainty, then it is necessary to propagate this
uncertainty forward to get the proper multi-step-ahead predictions. One simple approach is to use sampling methods. Alternatively, it may be possible to
use analytical approaches. Girard et al. showed that it is possible to
compute the mean and variance of the output analytically when using the SE
covariance function and Gaussian input noise.
More generally, the problem of regression with uncertain inputs has been
studied in the statistics literature under the name of errors-in-variables regression.
See Dellaportas and Stephens for a Bayesian treatment of the
problem and pointers to the literature.
Mixtures of Gaussian Processes
In chapter 4 we have seen many ideas for making the covariance functions
more ﬂexible. Another route is to use a mixture of diﬀerent Gaussian process
models, each one used in some local region of input space. This kind of model
is generally known as a mixture of experts model and is due to Jacobs et al.
 . In addition to the local expert models, the model has a manager that
(probabilistically) assigns points to the experts. Rasmussen and Ghahramani
 used Gaussian process models as local experts, and based their manager
on another type of stochastic process: the Dirichlet process. Inference in this
model required MCMC methods.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
9.7 Global Optimization
Global Optimization
Often one is faced with the problem of being able to evaluate a continuous
function g(x), and wishing to ﬁnd the global optimum (maximum or minimum)
of this function within some compact set A ⊂RD.
There is a very large
literature on the problem of global optimization; see Neumaier for a
useful overview.
Given a dataset D = {(xi, g(xi))|i=1, . . . , n}, one appealing approach is to
ﬁt a GP regression model to this data. This will give a mean prediction and
predictive variance for every x ∈A. Jones examines a number of criteria
that have been suggested for where to make the next function evaluation based
on the predictive mean and variance. One issue with this approach is that one
may need to search to ﬁnd the optimum of the criterion, which may itself be
multimodal optimization problem. However, if evaluations of g are expensive
or time-consuming, it can make sense to work hard on this new optimization
For historical references and further work in this area see Jones and
Ritter [2000, sec. VIII.2].
Evaluation of Integrals
Another interesting and unusual application of Gaussian processes is for the
evaluation of the integrals of a deterministic function f.
One evaluates the
function at a number of locations, and then one can use a Gaussian process as
a posterior over functions. This posterior over functions induces a posterior over
the value of the integral (since each possible function from the posterior would
give rise to a particular value of the integral). For some covariance functions
(e.g. the squared exponential), one can compute the expectation and variance of
the value of the integral analytically. It is perhaps unusual to think of the value
of the integral as being random (as it does have one particular deterministic
value), but it is perfectly in line of Bayesian thinking that you treat all kinds
of uncertainty using probabilities. This idea was proposed under the name of
Bayes-Hermite quadrature by O’Hagan , and later under the name of
Bayesian Monte Carlo in Rasmussen and Ghahramani .
Another approach is related to the ideas of global optimization in the section
combining GPs
9.7 above. One can use a GP model of a function to aid an MCMC sampling
procedure, which may be advantageous if the function of interest is computationally expensive to evaluate. Rasmussen combines Hybrid Monte Carlo
with a GP model of the log of the integrand, and also uses derivatives of the
function (discussed in section 9.4) to get an accurate model of the integrand
with very few evaluations.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Further Issues and Conclusions
Student’s t Process
A Student’s t process can be obtained by applying the scale mixture of Gausscale mixture
sians construction of a Student’s t distribution to a Gaussian process [O’Hagan,
1991, O’Hagan et al., 1999]. We divide the covariances by the scalar τ and put
a gamma distribution on τ with shape α and mean β so that
˜k(x, x′) = τ −1k(x, x′),
p(τ|α, β) =
βαΓ(α)τ α−1 exp
where k is any valid covariance function. Now the joint prior distribution of
any ﬁnite number n of function values y becomes
p(y|α, β, θ) =
N(y|0, τ −1Ky)p(τ|α, β)dτ
= Γ(α + n/2)(2πα)−n/2
Γ(α)|β−1Ky|−1/2
1 + βy⊤K−1
which is recognized as the zero mean, multivariate Student’s t distribution
with 2α degrees of freedom: p(y|α, β, θ) = T (0, β−1Ky, 2α). We could state a
deﬁnition analogous to deﬁnition 2.1 on page 13 for the Gaussian process, and
f ∼T P(0, β−1K, 2α),
cf. eq. (2.14). The marginal likelihood can be directly evaluated using eq. (9.3),
and training can be achieved using the methods discussed in chapter 5 regarding
α and β as hyperparameters. The predictive distribution for test cases are also
t distributions, the derivation of which is left as an exercise below.
Notice that the above construction is clear for noise-free processes, but that
the interpretation becomes more complicated if the covariance function k(x, x′)
contains a noise contribution. The noise and signal get entangled by the comnoise entanglement
mon factor τ, and the observations can no longer be written as the sum of
independent signal and noise contributions.
Allowing for independent noise
contributions removes analytic tractability, which may reduce the usefulness of
the t process.
Exercise Using the scale mixture representation from eq. (9.3) derive the posterior predictive distribution for a Student’s t process.
Exercise Consider the generating process implied by eq. (9.2), and write a program to draw functions at random. Characterize the diﬀerence between the
Student’s t process and the corresponding Gaussian process (obtained in the
limit α →∞), and explain why the t process is perhaps not as exciting as one
might have hoped.
Invariances
It can happen that the input is apparently in vector form but in fact it has
additional structure. A good example is a pixelated image, where the 2-d array
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
9.10 Invariances
of pixels can be arranged into a vector (e.g. in raster-scan order). Imagine that
the image is of a handwritten digit; then we know that if the image is translated
by one pixel it will remain the same digit. Thus we have knowledge of certain
invariances of the input pattern. In this section we describe a number of ways
in which such invariances can be exploited. Our discussion is based on Sch¨olkopf
and Smola [2002, ch. 11].
Prior knowledge about the problem tells us that certain transformations of
the input would leave the class label invariant—these include simple geometric
transformations such as translations, rotations,1 rescalings, and rather less obvious ones such as line thickness transformations.2 Given enough data it should
be possible to learn the correct input-output mapping, but it would make sense
to try to make use of these known invariances to reduce the amount of training
data needed. There are at least three ways in which this prior knowledge has
been used, as described below.
The ﬁrst approach is to generate synthetic training examples by applying
synthetic training
valid transformations to the examples we already have. This is simple but it
does have the disadvantage of creating a larger training set. As kernel-machine
training algorithms typically scale super-linearly with n this can be problematic.
A second approach is to make the predictor invariant to small transformations of each training case; this method was ﬁrst developed by Simard et al.
tangent prop
 for neural networks under the name of “tangent prop”.
For a single
training image we consider the manifold of images that are generated as various
transformations are applied to it. This manifold will have a complex structure,
but locally we can approximate it by a tangent space. The idea in “tangent
prop” is that the output should be invariant to perturbations of the training
example in this tangent space. For neural networks it is quite straightforward
to modify the training objective function to penalize deviations from this invariance, see Simard et al. for details. Section 11.4 in Sch¨olkopf and
Smola describes some ways in which these ideas can be extended to
kernel machines.
The third approach to dealing with invariances is to develop a representation
invariant representation
of the input which is invariant to some or all of the transformations.
example, binary images of handwritten digits are sometimes “skeletonized” to
remove the eﬀect of line thickness. If an invariant representation can be achieved
for all transformations it is the most desirable, but it can be diﬃcult or perhaps
impossible to achieve. For example, if a given training pattern can belong to
more than one class (e.g. an ambiguous handwritten digit) then it is clearly not
possible to ﬁnd a new representation which is invariant to transformations yet
leaves the classes distinguishable.
1The digit recognition problem is only invariant to small rotations; we must avoid turning
a 6 into a 9.
2i.e. changing the thickness of the pen we write with within reasonable bounds does not
change the digit we write.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Further Issues and Conclusions
Latent Variable Models
Our main focus in this book has been on supervised learning. However, GPs
have also been used as components for models carrying out non-linear dimensionality reduction, a form of unsupervised learning. The key idea is that data
which is apparently high-dimensional (e.g. a pixelated image) may really lie on
a low-dimensional non-linear manifold which we wish to model.
Let z ∈RL be a latent (or hidden) variable, and let x ∈RD be a visible
variable. We suppose that our visible data is generated by picking a point in
z-space and mapping this point into the data space through a (possibly nonlinear) mapping, and then optionally adding noise. Thus p(x) =
p(x|z)p(z)dz.
If the mapping from z to x is linear and z has a Gaussian distribution then
this is the factor analysis model, and the mean and covariance of the Gaussian
in x-space can easily be determined. However, if the mapping is non-linear
then the integral cannot be computed exactly. In the generative topographic
mapping (GTM) model [Bishop et al., 1998b] the integral was approximated
using a grid of points in z-space. In the original GTM paper the non-linear
mapping was taken to be a linear combination of non-linear basis functions,
but in Bishop et al. [1998a] this was replaced by a Gaussian process mapping
between the latent and visible spaces.
More recently Lawrence has introduced a rather diﬀerent model known
as the Gaussian process latent variable model (GPLVM). Instead of having a
prior (and thus a posterior) distribution over the latent space, we consider that
each data point xi is derived from a corresponding latent point zi through
a non-linear mapping (with added noise).
If a Gaussian process is used for
this non-linear mapping, then one can easily write down the joint distribution
p(X|Z) of the visible variables conditional on the latent variables. Optimization
routines can then be used to ﬁnd the locations of the latent points that optimize p(X|Z). This has some similarities to the work on regularized principal
manifolds [Sch¨olkopf and Smola, 2002, ch. 17] except that in the GPLVM one
integrates out the latent-to-visible mapping rather than optimizing it.
Conclusions and Future Directions
In this section we brieﬂy wrap up some of the threads we have developed
throughout the book, and discuss possible future directions of work on Gaussian
processes.
In chapter 2 we saw how Gaussian process regression is a natural extension
of Bayesian linear regression to a more ﬂexible class of models. For Gaussian
noise the model can be treated analytically, and is simple enough that the GP
model could be often considered as a replacement for the traditional linear
analogue. We have also seen that historically there have been numerous ideas
along the lines of Gaussian process models, although they have only gained a
sporadic following.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
9.12 Conclusions and Future Directions
One may indeed speculate, why are GPs not currently used more widely in
applications? We see three major reasons: (1) Firstly, that the application of
Gaussian processes requires the handling (inversion) of large matrices. While
these kinds of computations were tedious 20 years ago, and impossible further
in the past, even na¨ıve implementations suﬃce for moderate sized problems on
an anno 2005 PC. (2) Another possibility is that most of the historical work
on GPs was done using ﬁxed covariance functions, with very little guide as
to how to choose such functions.
The choice was to some degree arbitrary,
and the idea that one should be able to infer the structure or parameters of
the covariance function as we discuss in chapter 5 is not so well known. This
is probably a very important step in turning GPs into an interesting method
for practitioners. (3) The viewpoint of placing Gaussian process priors over
functions is a Bayesian one. Although the adoption of Bayesian methods in the
machine learning community is quite widespread, these ideas have not always
been appreciated more widely in the statistics community.
Although modern computers allow simple implementations for up to a few
thousand training cases, the computational constraints are still a signiﬁcant
limitation for applications where the datasets are signiﬁcantly larger than this.
In chapter 8 we have given an overview of some of the recent work on approximations for large datasets. Although there are many methods and a lot of
work is currently being undertaken, both the theoretical and practical aspects
of these approximations need to be understood better in order to be a useful
tool to the practitioner.
The computations required for the Gaussian process classiﬁcation models
developed in chapter 3 are a lot more involved than for regression. Although
the theoretical foundations of Gaussian process classiﬁcation are well developed,
it is not yet clear under which circumstances one would expect the extra work
and approximations associated with treating a full probabilistic latent variable
model to pay oﬀ.
The answer may depend heavily on the ability to learn
meaningful covariance functions.
The incorporation of prior knowledge through the choice and parameterization of the covariance function is another prime target for future work on
GPs. In chapter 4 we have presented many families of covariance functions with
widely diﬀering properties, and in chapter 5 we presented principled methods
for choosing between and adapting covariance functions. Particularly in the
machine learning community, there has been a tendency to view Gaussian processes as a “black box”—what exactly goes on in the box is less important, as
long as it gives good predictions. To our mind, we could perhaps learn something from the statisticians here, and ask how and why the models work. In fact
the hierarchical formulation of the covariance functions with hyperparameters,
the testing of diﬀerent hypotheses and the adaptation of hyperparameters gives
an excellent opportunity to understand more about the data.
We have attempted to illustrate this line of thinking with the carbon dioxide
prediction example developed at some length in section 5.4.3. Although this
problem is comparatively simple and very easy to get an intuitive understanding
of, the principles of trying out diﬀerent components in the covariance structure
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Further Issues and Conclusions
and adapting their parameters could be used universally. Indeed, the use of
the isotropic squared exponential covariance function in the digit classiﬁcation
examples in chapter 3 is not really a choice which one would expect to provide
very much insight to the classiﬁcation problem. Although some of the results
presented are as good as other current methods in the literature, one could
indeed argue that the use of the squared exponential covariance function for this
task makes little sense, and the low error rate is possibly due to the inherently
low diﬃculty of the task. There is a need to develop more sensible covariance
functions which allow for the incorporation of prior knowledge and help us to
gain real insight into the data.
Going beyond a simple vectorial representation of the input data to take
into account structure in the input domain is also a theme which we see as very
important. Examples of this include the invariances described in section 9.10
arising from the structure of images, and the kernels described in section 4.4
which encode structured objects such as strings and trees.
As this brief discussion shows, we see the current level of development of
Gaussian process models more as a rich, principled framework for supervised
learning than a fully-developed set of tools for applications. We ﬁnd the Gaussian process framework very appealing and are conﬁdent that the near future
will show many important developments, both in theory, methodology and practice. We look forward very much to following these developments.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Appendix A
Mathematical Background
Joint, Marginal and Conditional Probability
Let the n (discrete or continuous) random variables y1, . . . , yn have a joint
joint probability
probability p(y1, . . . , yn), or p(y) for short.1 Technically, one ought to distinguish between probabilities (for discrete variables) and probability densities for
continuous variables. Throughout the book we commonly use the term “probability” to refer to both. Let us partition the variables in y into two groups, yA
and yB, where A and B are two disjoint sets whose union is the set {1, . . . , n},
so that p(y) = p(yA, yB). Each group may contain one or more variables.
The marginal probability of yA is given by
marginal probability
p(yA, yB) dyB.
The integral is replaced by a sum if the variables are discrete valued. Notice
that if the set A contains more than one variable, then the marginal probability
is itself a joint probability—whether it is referred to as one or the other depends
on the context. If the joint distribution is equal to the product of the marginals,
independence
then the variables are said to be independent, otherwise they are dependent.
The conditional probability function is deﬁned as
conditional probability
p(yA|yB) = p(yA, yB)
deﬁned for p(yB) > 0, as it is not meaningful to condition on an impossible
event. If yA and yB are independent, then the marginal p(yA) and the conditional p(yA|yB) are equal.
1One can deal with more general cases where the density function does not exist by using
the distribution function.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Mathematical Background
Using the deﬁnitions of both p(yA|yB) and p(yB|yA) we obtain Bayes’
Bayes’ rule
p(yA|yB) = p(yA)p(yB|yA)
Since conditional distributions are themselves probabilities, one can use all of
the above also when further conditioning on other variables. For example, in
supervised learning, one often conditions on the inputs throughout, which would
lead e.g. to a version of Bayes’ rule with additional conditioning on X in all
four probabilities in eq. (A.3); see eq. (2.5) for an example of this.
Gaussian Identities
The multivariate Gaussian (or Normal) distribution has a joint probability den-
Gaussian deﬁnition
sity given by
p(x|m, Σ) = (2π)−D/2|Σ|−1/2 exp
2(x −m)⊤Σ−1(x −m)
where m is the mean vector (of length D) and Σ is the (symmetric, positive
deﬁnite) covariance matrix (of size D × D).
As a shorthand we write x ∼
Let x and y be jointly Gaussian random vectors
then the marginal distribution of x and the conditional distribution of x given
conditioning and
marginalizing
x ∼N(µx, A),
and x|y ∼N
 µx + CB−1(y −µy), A −CB−1C⊤
 µx −˜A−1 ˜C(y −µy), ˜A−1
See, e.g. von Mises [1964, sec. 9.3], and eqs. (A.11 - A.13).
The product of two Gaussians gives another (un-normalized) Gaussian
N(x|a, A)N(x|b, B) = Z−1N(x|c, C)
where c = C(A−1a + B−1b) and C = (A−1 + B−1)−1.
Notice that the resulting Gaussian has a precision (inverse variance) equal to
the sum of the precisions and a mean equal to the convex sum of the means,
weighted by the precisions. The normalizing constant looks itself like a Gaussian
(in a or b)
Z−1 = (2π)−D/2|A + B|−1/2 exp
2(a −b)⊤(A + B)−1(a −b)
To prove eq. (A.7) simply write out the (lengthy) expressions by introducing
eq. (A.4) and eq. (A.8) into eq. (A.7), and expand the terms inside the exp to
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
A.3 Matrix Identities
verify equality. Hint: it may be helpful to expand C using the matrix inversion
lemma, eq. (A.9), C = (A−1+B−1)−1 = A−A(A+B)−1A = B−B(A+B)−1B.
To generate samples x ∼N(m, K) with arbitrary mean m and covariance
generating multivariate
Gaussian samples
matrix K using a scalar Gaussian generator (which is readily available in many
programming environments) we proceed as follows: ﬁrst, compute the Cholesky
decomposition (also known as the “matrix square root”) L of the positive definite symmetric covariance matrix K = LL⊤, where L is a lower triangular
matrix, see section A.4. Then generate u ∼N(0, I) by multiple separate calls
to the scalar Gaussian generator. Compute x = m + Lu, which has the desired
distribution with mean m and covariance LE[uu⊤]L⊤= LL⊤= K (by the
independence of the elements of u).
In practice it may be necessary to add a small multiple of the identity
matrix ϵI to the covariance matrix for numerical reasons. This is because the
eigenvalues of the matrix K can decay very rapidly (see section 4.3.1 for a
closely related analytical result) and without this stabilization the Cholesky
decomposition fails. The eﬀect on the generated samples is to add additional
independent noise of variance ϵ. From the context ϵ can usually be chosen to
have inconsequential eﬀects on the samples, while ensuring numerical stability.
Matrix Identities
The matrix inversion lemma, also known as the Woodbury, Sherman & Morrimatrix inversion lemma
son formula states that
(Z + UWV ⊤)−1 = Z−1 −Z−1U(W −1 + V ⊤Z−1U)−1V ⊤Z−1,
assuming the relevant inverses all exist. Here Z is n×n, W is m×m and U and V
are both of size n×m; consequently if Z−1 is known, and a low rank (i.e. m < n)
perturbation is made to Z as in left hand side of eq. (A.9), considerable speedup
can be achieved. A similar equation exists for determinants
determinants
|Z + UWV ⊤| = |Z| |W| |W −1 + V ⊤Z−1U|.
Let the invertible n × n matrix A and its inverse A−1 be partitioned into
inversion of a
partitioned matrix
where P and ˜P are n1 × n1 matrices and S and ˜S are n2 × n2 matrices with
n = n1 + n2. The submatrices of A−1 are given in Press et al. [1992, p. 77] as
˜P = P −1 + P −1QMRP −1
˜Q = −P −1QM
˜R = −MRP −1
where M = (S −RP −1Q)−1,
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Mathematical Background
or equivalently
˜Q = −NQS−1
˜R = −S−1RN
˜S = S−1 + S−1RNQS−1
where N = (P −QS−1R)−1.
Matrix Derivatives
Derivatives of the elements of an inverse matrix:
derivative of inverse
∂θK−1 = −K−1 ∂K
∂θ is a matrix of elementwise derivatives. For the log determinant of a
derivative of log
determinant
positive deﬁnite symmetric matrix we have
∂θ log |K| = tr
Matrix Norms
The Frobenius norm ∥A∥F of a n1 × n2 matrix A is deﬁned as
|aij|2 = tr(AA⊤),
[Golub and Van Loan, 1989, p. 56].
Cholesky Decomposition
The Cholesky decomposition of a symmetric, positive deﬁnite matrix A decomposes A into a product of a lower triangular matrix L and its transpose
where L is called the Cholesky factor. The Cholesky decomposition is useful
for solving linear systems with symmetric, positive deﬁnite coeﬃcient matrix
A. To solve Ax = b for x, ﬁrst solve the triangular system Ly = b by forward
solving linear systems
substitution and then the triangular system L⊤x = y by back substitution.
Using the backslash operator, we write the solution as x = L⊤\(L\b), where
the notation A\b is the vector x which solves Ax = b. Both the forward and
backward substitution steps require n2/2 operations, when A is of size n × n.
computational cost
The computation of the Cholesky factor L is considered numerically extremely
stable and takes time n3/6, so it is the method of choice when it can be applied.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
A.5 Entropy and Kullback-Leibler Divergence
Note also that the determinant of a positive deﬁnite symmetric matrix can be
determinant
calculated eﬃciently by
log |A| = 2
where L is the Cholesky factor from A.
Entropy and Kullback-Leibler Divergence
The entropy H[p(x)] of a distribution p(x) is a non-negative measure of the
amount of “uncertainty” in the distribution, and is deﬁned as
H[p(x)] = −
p(x) log p(x) dx.
The integral is substituted by a sum for discrete variables. Entropy is measured
in bits if the log is to the base 2 and in nats in the case of the natural log. The
entropy of a Gaussian in D dimensions, measured in nats is
H[N(µ, Σ)] =
2 log |Σ| + D
2 (log 2πe).
The Kullback-Leibler (KL) divergence (or relative entropy) KL(p||q) between two distributions p(x) and q(x) is deﬁned as
KL(p||q) =
p(x) log p(x)
It is easy to show that KL(p||q) ≥0, with equality if p = q (almost everywhere).
For the case of two Bernoulli random variables p and q this reduces to
divergence of Bernoulli
random variables
KLBer(p||q) = p log p
q + (1 −p) log (1 −p)
where we use p and q both as the name and the parameter of the Bernoulli
distributions.
For two Gaussian distributions N(µ0, Σ0) and N(µ1, Σ1) we
divergence of Gaussians
have [Kullback, 1959, sec. 9.1]
KL(N0||N1) = 1
2 log |Σ1Σ−1
 (µ0 −µ1)(µ0 −µ1)⊤+ Σ0 −Σ1
Consider a general distribution p(x) on RD and a Gaussian distribution q(x) =
minimizing KL(p||q)
divergence leads to
moment matching
N(µ, Σ). Then
KL(p||q) =
2(x −µ)⊤Σ−1(x −µ)p(x) dx +
2 log |Σ| + D
2 log 2π +
p(x) log p(x) dx.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Mathematical Background
Equation (A.24) can be minimized w.r.t. µ and Σ by diﬀerentiating w.r.t. these
parameters and setting the resulting expressions to zero. The optimal q is the
one that matches the ﬁrst and second moments of p.
The KL divergence can be viewed as the extra number of nats needed on
average to code data generated from a source p(x) under the distribution q(x)
as opposed to p(x).
The limit of a rational quadratic is a squared exponential
Measure and Integration
Here we sketch some deﬁnitions concerning measure and integration; fuller
treatments can be found e.g. in Doob and Bartle .
Let Ωbe the set of all possible outcomes of an experiment. For example, for
a D-dimensional real-valued variable, Ω= RD. Let F be a σ-ﬁeld of subsets
of Ωwhich contains all the events in whose occurrences we may be interested.2
Then µ is a countably additive measure if it is real and non-negative and for
all mutually disjoint sets A1, A2, . . . ∈F we have
If µ(Ω) < ∞then µ is called a ﬁnite measure and if µ(Ω) = 1 it is called
ﬁnite measure
a probability measure. The Lebesgue measure deﬁnes a uniform measure over
probability measure
Lebesgue measure
subsets of Euclidean space. Here an appropriate σ-algebra is the Borel σ-algebra
BD, where B is the σ-algebra generated by the open subsets of R. For example
on the line R the Lebesgue measure of the interval (a, b) is b −a.
We now restrict Ωto be RD and wish to give meaning to integration of a
function f : RD →R with respect to a measure µ
f(x) dµ(x).
We assume that f is measurable, i.e. that for any Borel-measurable set A ∈R,
f −1(A) ∈BD.
There are two cases that will interest us (i) when µ is the
Lebesgue measure and (ii) when µ is a probability measure. For the ﬁrst case
expression (A.27) reduces to the usual integral notation
2The restriction to a σ-ﬁeld of subsets is important technically to avoid paradoxes such as
the Banach-Tarski paradox. Informally, we can think of the σ-ﬁeld as restricting consideration
to “reasonable” subsets.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
A.8 Fourier Transforms
For a probability measure µ on x, the non-negative function p(x) is called
the density of the measure if for all A ∈BD we have
If such a density exists it is uniquely determined almost everywhere, i.e. except
for sets with measure zero. Not all probability measures have densities—only
distributions that assign zero probability to individual points in x-space can
have densities.3 If p(x) exists then we have
f(x) dµ(x) =
f(x)p(x) dx.
If µ does not have a density expression (A.27) still has meaning by the standard
construction of the Lebesgue integral.
For Ω= RD the probability measure µ can be related to the distribution
function F : RD → which is deﬁned as F(z) = µ(x1 ≤z1, . . . xD ≤
zD). The distribution function is more general than the density as it is always
deﬁned for a given probability measure. A simple example of a random variable
“point mass” example
which has a distribution function but no density is obtained by the following
construction: a coin is tossed and with probability p it comes up heads; if it
comes up heads x is chosen from U(0, 1) (the uniform distribution on ),
otherwise (with probability 1−p) x is set to 1/2. This distribution has a “point
mass” (or atom) at x = 1/2.
Let µ be a measure on an input set X. For some function f : X →R and
1 ≤p < ∞, we deﬁne
∥f∥Lp(X,µ) ≜
|f(x)|p dµ(x)
if the integral exists. For p = ∞we deﬁne
∥f∥L∞(X,µ) = ess sup
where ess sup denotes the essential supremum, i.e. the smallest number that
upper bounds |f(x)| almost everywhere. The function space Lp(X, µ) is deﬁned
for any p in 1 ≤p ≤∞as the space of functions for which ∥f∥Lp(X,µ) < ∞.
Fourier Transforms
For suﬃciently well-behaved functions on RD we have
˜f(s)e2πis·x ds,
f(x)e−2πis·x dx,
3A measure µ has a density if and only if it is absolutely continuous with respect to
Lebesgue measure on RD, i.e. every set that has Lebesgue measure zero also has µ-measure
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Mathematical Background
where ˜f(s) is called the Fourier transform of f(x), see e.g. Bracewell .
We refer to the equation on the left as the synthesis equation, and the equation
on the right as the analysis equation. There are other conventions for Fourier
transforms, particularly those involving ω = 2πs. However, this tends to destroy symmetry between the analysis and synthesis equations so we use the
deﬁnitions given above.
Here we have deﬁned Fourier transforms for f(x) being a function on RD.
For related transforms for periodic functions, functions deﬁned on the integer
lattice and on the regular N-polygon see section B.1.
Below we state some deﬁnitions and properties of convex sets and functions
taken from Boyd and Vandenberghe .
A set C is convex if the line segment between any two points in C lies in C,
convex sets
i.e. if for any x1, x2 ∈C and for any θ with 0 ≤θ ≤1, we have
θx1 + (1 −θ)x2 ∈C.
A function f : X →R is convex if its domain X is a convex set and if for all
convex function
x1, x2 ∈X and θ with 0 ≤θ ≤1, we have:
f(θx1 + (1 −θ)x2) ≤θf(x1) + (1 −θ)f(x2),
where X is a (possibly improper) subset of RD. f is concave if −f is convex.
A function f is convex if and only if its domain X is a convex set and its
Hessian is positive semideﬁnite for all x ∈X.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Appendix B
Gaussian Markov Processes
Particularly when the index set for a stochastic process is one-dimensional such
as the real line or its discretization onto the integer lattice, it is very interesting
to investigate the properties of Gaussian Markov processes (GMPs). In this
Appendix we use X(t) to deﬁne a stochastic process with continuous time parameter t. In the discrete time case the process is denoted . . . , X−1, X0, X1, . . .
etc. We assume that the process has zero mean and is, unless otherwise stated,
stationary.
A discrete-time autoregressive (AR) process of order p can be written as
AR process
akXt−k + b0Zt,
where Zt ∼N(0, 1) and all Zt’s are i.i.d. . Notice the order-p Markov property
that given the history Xt−1, Xt−2, . . ., Xt depends only on the previous p X’s.
This relationship can be conveniently expressed as a graphical model; part of
an AR(2) process is illustrated in Figure B.1. The name autoregressive stems
from the fact that Xt is predicted from the p previous X’s through a regression
equation. If one stores the current X and the p −1 previous values as a state
vector, then the AR(p) scalar process can be written equivalently as a vector
AR(1) process.
Figure B.1: Graphical model illustrating an AR(2) process.
Moving from the discrete time to the continuous time setting, the question
arises as to how generalize the Markov notion used in the discrete-time AR
process to deﬁne a continuoous-time AR process. It turns out that the correct
generalization uses the idea of having not only the function value but also p of
its derivatives at time t giving rise to the stochastic diﬀerential equation (SDE)1
SDE: stochastic
diﬀerential equation
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Gaussian Markov Processes
apX(p)(t) + ap−1X(p−1)(t) + . . . + a0X(t) = b0Z(t),
where X(i)(t) denotes the ith derivative of X(t) and Z(t) is a white Gaussian noise process with covariance δ(t −t′). This white noise process can be
considered the derivative of the Wiener process. To avoid redundancy in the
coeﬃcients we assume that ap = 1.
A considerable amount of mathematical machinery is required to make rigorous the meaning of such equations, see
e.g. Øksendal . As for the discrete-time case, one can write eq. (B.2) as
a ﬁrst-order vector SDE by deﬁning the state to be X(t) and its ﬁrst p −1
derivatives.
We begin this chapter with a summary of some Fourier analysis results in
section B.1. Fourier analysis is important to linear time invariant systems such
as equations (B.1) and (B.2) because e2πist is an eigenfunction of the corresponding diﬀerence (resp diﬀerential) operator. We then move on in section
B.2 to discuss continuous-time Gaussian Markov processes on the real line and
their relationship to the same SDE on the circle. In section B.3 we describe
discrete-time Gaussian Markov processes on the integer lattice and their relationship to the same diﬀerence equation on the circle.
In section B.4 we
explain the relationship between discrete-time GMPs and the discrete sampling
of continuous-time GMPs.
Finally in section B.5 we discuss generalizations
of the Markov concept in higher dimensions. Much of this material is quite
standard, although the relevant results are often scattered through diﬀerent
sources, and our aim is to provide a uniﬁed treatment. The relationship between the second-order properties of the SDEs on the real line and the circle,
and diﬀerence equations on the integer lattice and the regular polygon is, to
our knowledge, novel.
Fourier Analysis
We follow the treatment given by Kammler . We consider Fourier analysis
of functions on the real line R, of periodic functions of period l on the circle
Tl, of functions deﬁned on the integer lattice Z, and of functions on PN, the
regular N-polygon, which is a discretization of Tl.
For suﬃciently well-behaved functions on R we have
˜f(s)e2πisx ds,
f(x)e−2πisx dx.
We refer to the equation on the left as the synthesis equation, and the equation
on the right as the analysis equation.
For functions on Tl we obtain the Fourier series representations
˜f[k]e2πikx/l,
f(x)e−2πikx/l dx,
1The ak coeﬃcients in equations (B.1) and (B.2) are not intended to have a close relationship. An approximate relationship might be established through the use of ﬁnite-diﬀerence
approximations to derivatives.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
B.1 Fourier Analysis
where ˜f[k] denotes the coeﬃcient of e2πikx/l in the expansion. We use square
brackets [ ] to denote that the argument is discrete, so that Xt and X[t] are
equivalent notations.
Similarly for Z we obtain
˜f(s)e2πisn/l ds,
f[n]e−2πisn/l.
Note that ˜f(s) is periodic with period l and so is deﬁned only for 0 ≤s < l to
avoid aliasing. Often this transform is deﬁned for the special case l = 1 but the
general case emphasizes the duality between equations (B.4) and (B.5).
Finally, for functions on PN we have the discrete Fourier transform
˜f[k]e2πikn/N,
f[n]e−2πikn/N.
Note that there are other conventions for Fourier transforms, particularly those
involving ω = 2πs.
However, this tends to destroy symmetry between the
analysis and synthesis equations so we use the deﬁnitions given above.
In the case of stochastic processes, the most important Fourier relationship
is between the covariance function and the power spectrum; this is known as
the Wiener-Khintchine theorem, see e.g. Chatﬁeld .
Sampling and Periodization
We can obtain relationships between functions and their transforms on R, Tl,
Z, PN through the notions of sampling and periodization.
Deﬁnition B.1 h-sampling: Given a function f on R and a spacing parameter
h-sampling
h > 0, we construct a corresponding discrete function φ on Z using
φ[n] = f(nh),
Similarly we can discretize a function deﬁned on Tl onto PN, but in this case
we must take h = l/N so that N steps of size h will equal the period l.
Deﬁnition B.2 Periodization by summation: Let f(x) be a function on R that
periodization by
rapidly approaches 0 as x →±∞. We can sum translates of the function to
produce the l-periodic function
for l > 0. Analogously, when φ is deﬁned on Z and φ[n] rapidly approaches 0
as n →±∞we can construct a function γ on PN by N-summation by setting
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Gaussian Markov Processes
Let φ[n] be obtained by h-sampling from f(x), with corresponding Fourier
transforms ˜φ(s) and ˜f(s). Then we have
φ[n] = f(nh) =
˜f(s)e2πisnh ds,
˜φ(s)e2πisn/l ds.
By breaking up the domain of integration in eq. (B.10) we obtain
˜f(s)e2πisnh ds
˜f(s′ + ml)e2πinh(s′+ml) ds′,
using the change of variable s′ = s −ml. Now set hl = 1 and use e2πinm = 1
for n, m integers to obtain
˜f(s + ml)
e2πisn/l ds,
which implies that
˜f(s + ml),
with l = 1/h. Alternatively setting l = 1 one obtains ˜φ(s) = 1
m=−∞˜f( s+m
Similarly if f is deﬁned on Tl and φ[n] = f( nl
N ) is obtained by sampling then
˜f[n + mN].
Thus we see that sampling in x-space causes periodization in Fourier space.
Now consider the periodization of a function f(x) with x ∈R to give the lperiodic function g(x) ≜P∞
m=−∞f(x−ml). Let ˜g[k] be the Fourier coeﬃcients
of g(x). We obtain
g(x)e−2πikx/l dx = 1
f(x −ml)e−2πikx/l dx
f(x)e−2πikx/l dx = 1
assuming that f(x) is suﬃciently well-behaved that the summation and integration operations can be exchanged. A similar relationship can be obtained
for the periodization of a function deﬁned on Z. Thus we see that periodization
in x-space gives rise to sampling in Fourier space.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
B.2 Continuous-time Gaussian Markov Processes
Continuous-time Gaussian Markov Processes
We ﬁrst consider continuous-time Gaussian Markov processes on the real line,
and then relate the covariance function obtained to that for the stationary
solution of the SDE on the circle. Our treatment of continuous-time GMPs on
R follows Papoulis [1991, ch. 10].
Continuous-time GMPs on R
We wish to ﬁnd the power spectrum and covariance function for the stationary
process corresponding to the SDE given by eq. (B.2). Recall that the covariance
function of a stationary process k(t) and the power spectrum S(s) form a Fourier
transform pair.
The Fourier transform of the stochastic process X(t) is a stochastic process
˜X(s) given by
X(t)e−2πist dt,
˜X(s)e2πist ds,
where the integrals are interpreted as a mean-square limit. Let ∗denote complex
conjugation and ⟨. . .⟩denote expectation with respect to the stochastic process.
Then for a stationary Gaussian process we have
⟨˜X(s1) ˜X∗(s2)⟩=
⟨X(t)X∗(t′)⟩e−2πis1te2πis2t′ dt dt′
dt′e−2πi(s1−s2)t′ Z ∞
dτk(τ)e−2πis1τ
= S(s1)δ(s1 −s2),
using the change of variables τ = t −t′ and the integral representation of
the delta function
e−2πistdt = δ(s). This shows that ˜X(s1) and ˜X(s2) are
uncorrelated for s1 ̸= s2, i.e. that the Fourier basis are eigenfunctions of the
diﬀerential operator. Also from eq. (B.19) we obtain
(2πis)k ˜X(s)e2πist ds.
Now if we Fourier transform eq. (B.2) we obtain
ak(2πis)k ˜X(s) = b0 ˜Z(s),
where ˜Z(s) denotes the Fourier transform of the white noise. Taking the product
of equation B.24 with its complex conjugate and taking expectations we obtain
ak(2πis1)k
ak(−2πis2)k
⟨˜X(s1) ˜X∗(s2)⟩= b2
0⟨˜Z(s1) ˜Z∗(s2)⟩.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Gaussian Markov Processes
Let A(z) = Pp
k=0 akzk. Then using eq. (B.22) and the fact that the power
spectrum of white noise is 1, we obtain
|A(2πis)|2 .
Note that the denominator is a polynomial of order p in s2. The relationship
of stationary solutions of pth-order SDEs to rational spectral densities can be
traced back at least as far as Doob .
Above we have assumed that the process is stationary. However, this depends on the coeﬃcients a0, . . . , ap. To analyze this issue we assume a solution
of the form Xt ∝eλt when the driving term b0 = 0. This leads to the condition
for stationarity that the roots of the polynomial Pp
k=0 akλk must lie in the left
half plane [Arat´o, 1982, p. 127].
Example: AR(1) process. In this case we have the SDE
AR(1) process
X′(t) + a0X(t) = b0Z(t),
where a0 > 0 for stationarity. This gives rise to the power spectrum
(2πis + a0)(−2πis + a0) =
(2πs)2 + a2
Taking the Fourier transform we obtain
This process is known as the Ornstein-Uhlenbeck (OU) process [Uhlenbeck and
Ornstein, 1930] and was introduced as a mathematical model of the velocity of
a particle undergoing Brownian motion. It can be shown that the OU process
is the unique stationary ﬁrst-order Gaussian Markov process.
Example: AR(p) process.
In general the covariance transform corresponding
AR(p) process
to the power spectrum S(s) = ([Pp
k=0 ak(2πis)k][Pp
k=0 ak(−2πis)k])−1 can be
quite complicated. For example, Papoulis [1991, p. 326] gives three forms of
the covariance function for the AR(2) process depending on whether a2
greater than, equal to or less than 0. However, if the coeﬃcients a0, a1, . . . , ap
are chosen in a particular way then one can obtain
(4π2s2 + α2)p
for some α.
It can be shown [Stein, 1999, p. 31] that the corresponding covariance function is of the form Pp−1
k=0 βk|t|ke−α|t| for some coeﬃcients β0, . . . , βp−1.
For p = 1 we have already seen that k(t) =
2αe−α|t| for the OU process. For
p = 2 we obtain k(t) =
4α3 e−α|t|(1+α|t|). These are special cases of the Mat´ern
class of covariance functions described in section 4.2.1.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
B.2 Continuous-time Gaussian Markov Processes
Example: Wiener process. Although our derivations have focussed on stationary
Wiener process
Gaussian Markov processes, there are also several important non-stationary
processes. One of the most important is the Wiener process that satisﬁes the
SDE X′(t) = Z(t) for t ≥0 with the initial condition X(0) = 0. This process
has covariance function k(t, s) = min(t, s). An interesting variant of the Wiener
process known as the Brownian bridge (or tied-down Wiener process) is obtained
by conditioning on the Wiener process passing through X(1) = 0. This has
covariance k(t, s) = min(t, s) −st for 0 ≤s, t ≤1. See e.g. Grimmett and
Stirzaker for further information on these processes.
Markov processes derived from SDEs of order p are p−1 times MS diﬀerentiable. This is easy to see heuristically from eq. (B.2); given that a process gets
rougher the more times it is diﬀerentiated, eq. (B.2) tells us that X(p)(t) is like
the white noise process, i.e. not MS continuous. So, for example, the OU process
(and also the Wiener process) are MS continuous but not MS diﬀerentiable.
The Solution of the Corresponding SDE on the Circle
The analogous analysis to that on the real line is carried out on Tl using
˜X[n]e2πint/l,
X(t)e−2πint/ldt.
As X(t) is assumed stationary we obtain an analogous result to eq. (B.22),
i.e. that the Fourier coeﬃcients are independent
⟨˜X[m] ˜X∗[n]⟩=
otherwise.
Similarly, the covariance function on the cirle is given by k(t−s) = ⟨X(t)X∗(s)⟩=
n=−∞S[n]e2πin(t−s)/l.
Let ωl = 2π/l.
Then plugging in the expression
X(k)(t) = P∞
n=−∞(inωl)k ˜X[n]einωlt into the SDE eq. (B.2) and equating terms
in [n] we obtain
ak(inωl)k ˜X[n] = b0 ˜Z[n].
As in the real-line case we form the product of equation B.33 with its complex
conjugate and take expectations to give
|A(inωl)|2 .
Note that ST[n] is equal to SR
, i.e. that it is a sampling of SR at intervals
1/l, where SR(s) is the power spectrum of the continuous process on the real
line given in equation B.26. Let kT(h) denote the covariance function on the
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Gaussian Markov Processes
circle and kR(h) denote the covariance function on the real line for the SDE.
Then using eq. (B.15) we ﬁnd that
kR(t −ml).
Example: 1st-order SDE. On R for the OU process we have kR(t) =
2a0 e−a0|t|.
1st order SDE
By summing the series (two geometric progressions) we obtain
2a0(1 −e−a0l)
e−a0|t| + e−a0(l−|t|)
cosh[a0( l
for −l ≤t ≤l. Eq. (B.36) is also given (up to scaling factors) in Grenander
et al. [1991, eq. 2.15], where it is obtained by a limiting argument from the
discrete-time GMP on Pn, see section B.3.2.
Discrete-time Gaussian Markov Processes
We ﬁrst consider discrete-time Gaussian Markov processes on Z, and then relate the covariance function obtained to that of the stationary solution of the
diﬀerence equation on PN.
Chatﬁeld and Diggle provide good
coverage of discrete-time ARMA models on Z.
Discrete-time GMPs on Z
Assuming that the process is stationary the covariance function k[i] denotes
⟨XtXt+i⟩∀t ∈Z. (Note that because of stationarity k[i] = k[−i].)
We ﬁrst use a Fourier approach to derive the power spectrum and hence the
covariance function of the AR(p) process. Deﬁning a0 = −1, we can rewrite
eq. (B.1) as Pp
k=0 akXt−k + b0Zt = 0. The Fourier pair for X[t] is
˜X(s)e2πist/l ds,
X[t]e−2πist/l.
Plugging this into Pp
k=0 akXt−k + b0Zt = 0 we obtain
ake−iωlsk
+ b0 ˜Z(s) = 0,
where ωl = 2π/l. As above, taking the product of eq. (B.38) with its complex
conjugate and taking expectations we obtain
|A(eiωls)|2 .
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
B.3 Discrete-time Gaussian Markov Processes
Above we have assumed that the process is stationary. However, this depends on the coeﬃcients a0, . . . , ap. To analyze this issue we assume a solution
of the form Xt ∝zt when the driving term b0 = 0. This leads to the condition
for stationarity that the roots of the polynomial Pp
k=0 akzp−k must lie inside
the unit circle. See Hannan [1970, Theorem 5, p. 19] for further details.
As well as deriving the covariance function from the Fourier transform of
the power spectrum it can also be obtained by solving a set of linear equations.
Our ﬁrst observation is that Xs is independent of Zt for s < t. Multiplying
equation B.1 through by Zt and taking expectations, we obtain ⟨XtZt⟩= b0
and ⟨Xt−iZt⟩= 0 for i > 0. By multiplying equation B.1 through by Xt−j for
j = 0, 1, . . . and taking expectations we obtain the Yule-Walker equations
Yule-Walker equations
aik[i] + b2
The ﬁrst p+1 of these equations form a linear system that can be used to solve
for k , . . . , k[p] in terms of b0 and a1, . . . , ap, and eq. (B.41) can be used to
obtain k[j] for j > p recursively.
Example: AR(1) process. The simplest example of an AR process is the AR(1)
AR(1) process
process deﬁned as Xt = a1Xt−1 + b0Zt. This gives rise to the Yule-Walker
k −a1k = b2
and k −a1k = 0.
The linear system for k , k can easily be solved to give k[j] = a|j|
1) is the variance of the process. Notice that for the process to
be stationary we require |a1| < 1. The corresponding power spectrum obtained
from equation B.39 is
1 −2a1 cos(ωls) + a2
Similarly to the continuous case, the covariance function for the discrete-time
AR(2) process has three diﬀerent forms depending on a2
described in Diggle [1990, Example 3.6].
The Solution of the Corresponding Diﬀerence Equation on PN
We now consider variables X = X0, X1, . . . , XN−1 arranged around the circle
with N ≥p. By appropriately modifying eq. (B.1) we obtain
akXmod(t−k,N) + b0Zt.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Gaussian Markov Processes
The Zt’s are i.i.d. and ∼N(0, 1).
Thus Z = Z0, Z1, . . . , ZN−1 has density
p(Z) ∝exp −1
t . Equation (B.44) shows that X and Z are related by
a linear transformation and thus
akXmod(t−k,N)
This is an N-dimensional multivariate Gaussian.
For an AR(p) process the
inverse covariance matrix has a circulant structure [Davis, 1979] consisting of
a diagonal band (2p + 1) entries wide and appropriate circulant entries in the
corners. Thus p(Xt|X\Xt) = p(Xt|Xmod(t−1,N), . . . , Xmod(t−p,N), Xmod(t+1,N),
. . . , Xmod(t+p,N)), which Geman and Geman call the “two-sided” Markov
Notice that it is the zeros in the inverse covariance matrix that
indicate the conditional independence structure; see also section B.5.
The properties of eq. (B.44) have been studied by a number of authors,
e.g. Whittle (under the name of circulant processes), Kashyap and Chellappa (under the name of circular autoregressive models) and Grenander
et al. (as cyclic Markov process).
As above, we deﬁne the Fourier transform pair
˜X[m]e2πinm/N,
X[n]e−2πinm/N.
By similar arguments to those above we obtain
ak ˜X[m](e2πim/N)k + b0 ˜Z[m] = 0,
where a0 = −1, and thus
|A(e2πim/N)|2 .
As in the continuous-time case, we see that SP[m] is obtained by sampling
the power spectrum of the corresponding process on the line, so that SP[m] =
. Thus using eq. (B.16) we have
kZ[n + mN].
Example: AR(1) process.
For this process Xt = a1Xmod(t−1,n) + b0Zt, the
AR(1) process
diagonal entries in the inverse covariance are and oﬀ-diagonal entries of
1)(a1 + a2
The inverse covariance matrix has the structure described above. Multiplying
these two matrices together we do indeed obtain the identity matrix.
The Relationship Between Discrete-time and
Sampled Continuous-time GMPs
We now consider the relationship between continuous-time and discrete-time
GMPs. In particular we ask the question, is a regular sampling of a continuoustime AR(p) process a discrete-time AR(p) process? It turns out that the answer
will, in general, be negative. First we deﬁne a generalization of AR processes
known as autoregressive moving-average (ARMA) processes.
ARMA processes
The AR(p) process deﬁned above is a special case of the
more general ARMA(p, q) process which is deﬁned as
Observe that the AR(p) process is in fact also an ARMA(p, 0) process.
spectral analysis of equation B.51 similar to that performed in section B.3.1
S(s) = |B(eiωls)|2
|A(eiωls)|2 ,
where B(z) = Pq
j=0 bjzj. In continuous time a process with a rational spectral
density of the form
S(s) = |B(2πis)|2
|A(2πis)|2
is known as a ARMA(p, q) process. For this to deﬁne a valid covariance function
we require q < p as k(0) =
S(s)ds < ∞.
Discrete-time observation of a continuous-time process
Let X(t) be
a continuous-time process having covariance function k(t) and power spectrum
S(s). Let Xh be the discrete-time process obtained by sampling X(t) at interval
h, so that Xh[n] = X(nh) for n ∈Z. Clearly the covariance function of this
process is given by kh[n] = k(nh). By eq. (B.15) this means that
where Sh(s) is deﬁned using l = 1/h.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Gaussian Markov Processes
Theorem B.1 Let X be a continuous-time stationary Gaussian process and
Xh be the discretization of this process. If X is an ARMA process then Xh
is also an ARMA process. However, if X is an AR process then Xh is not
necessarily an AR process.
The proof is given in Ihara [1993, Theorem 2.7.1]. It is easy to see using the
covariance functions given in sections B.2.1 and B.3.1 that the discretization
of a continuous-time AR(1) process is indeed a discrete-time AR(1) process.
However, Ihara shows that, in general, the discretization of a continuous-time
AR(2) process is not a discrete-time AR(2) process.
Markov Processes in Higher Dimensions
We have concentrated above on the case where t is one-dimensional. In higher
dimensions it is interesting to ask how the Markov property might be generalized. Let ∂S be an inﬁnitely diﬀerentiable closed surface separating RD into a
bounded part S−and an unbounded part S+. Loosely speaking2 a random ﬁeld
X(t) is said to be quasi-Markovian if X(t) for t ∈S−and X(u) for u ∈S+ are
independent given X(s) for s ∈∂S. Wong showed that the only isotropic
quasi-Markov Gaussian ﬁeld with a continuous covariance function is the degenerate case X(t) = X(0), where X(0) is a Gaussian variate. However, if instead
of conditioning on the values that the ﬁeld takes on in ∂S, one conditions on
a somewhat larger set, then Gaussian random ﬁelds with non-trivial Markovtype structure can be obtained. For example, random ﬁelds with an inverse
power spectrum of the form P
k ak1,...,kDsk1
1 · · · skd
with k⊤1 = PD
j=1 kj ≤2p
and C(s · s)p ≤
k⊤1=2p ak1,...,kDsk1
1 · · · skd
for some C > 0 are said to be
pseudo-Markovian of order p. For example, the D-dimensional tensor-product
of the OU process k(t) = QD
i=1 e−αi|ti| is pseudo-Markovian of order D. For
further discussion of Markov properties of random ﬁelds see the Appendix in
Adler .
If instead of RD we wish to deﬁne a Markov random ﬁeld (MRF) on a graphical structure (for example the lattice ZD) things become more straightforward.
We follow the presentation in Jordan . Let G = (X, E) be a graph where
X is a set of nodes that are in one-to-one correspondence with a set of random variables, and E be the set of undirected edges of the graph. Let C be
the set of all maximal cliques of G. A potential function ψC(xC) is a function
on the possible realizations xC of the maximal clique XC. Potential functions
are assumed to be (strictly) positive, real-valued functions. The probability
distribution p(x) corresponding to the Markov random ﬁeld is given by
where Z is a normalization factor (known in statistical physics as the partition
function) obtained by summing/integrating Q
C∈C ψC(xC) over all possible as-
2For a precise formulation of this deﬁnition involving σ-ﬁelds see Adler [1981, p. 256].
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
B.5 Markov Processes in Higher Dimensions
signments of values to the nodes X. Under this deﬁnition it is easy to show
that a local Markov property holds, i.e. that for any variable x the conditional
distribution of x given all other variables in X depends only on those variables
that are neighbours of x. A useful reference on Markov random ﬁelds is Winkler
A simple example of a Gaussian Markov random ﬁeld has the form
i,j:j∈N(i)
(xi −xj)2
where N(i) denotes the set of neighbours of node xi and α1, α2 > 0. On Z2
one might choose a four-connected neighbourhood, i.e. those nodes to the north,
south, east and west of a given node.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Appendix C
Datasets and Code
The datasets used for experiments in this book and implementations of the
algorithms presented are available for download at the website of the book:
 
The programs are short stand-alone implementations and not part of a larger
package. They are meant to be simple to understand and modify for a desired
purpose. Some of the programs allow speciﬁcation of covariance functions from
a selection provided, or to link in user deﬁned covariance code. For some of
the plots, code is provided which produces a similar plot, as this may be a
convenient way of conveying the details.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Abrahamsen, P. .
A Review of Gaussian Random Fields and Correlation Functions.
Technical Report 917, Norwegian Computing Center, Oslo, Norway.
 
917 Rapport.pdf.
Abramowitz, M. and Stegun, I. A. . Handbook of Mathematical Functions. Dover, New York.
pp. 84, 85
Adams, R. . Sobolev Spaces. Academic Press, New York.
Adler, R. J. . The Geometry of Random Fields. Wiley, Chichester.
pp. 80, 81, 83, 191, 218
Amari, S. . Diﬀerential-Geometrical Methods in Statistics. Springer-Verlag, Berlin.
Ansley, C. F. and Kohn, R. . Estimation, Filtering, and Smoothing in State Space Models with
Incompletely Speciﬁed Initial Conditions. Annals of Statistics, 13(4):1286–1316.
Arat´o, M. . Linear Stochastic Systems with Constant Coeﬃcients. Springer-Verlag, Berlin. Lecture
Notes in Control and Information Sciences 45.
Arfken, G. . Mathematical Methods for Physicists. Academic Press, San Diego.
pp. xv, 134
Aronszajn, N. .
Theory of Reproducing Kernels.
Trans. Amer. Math. Soc., 68:337–404.
pp. 129, 130
Bach, F. R. and Jordan, M. I. . Kernel Independent Component Analysis. Journal of Machine
Learning Research, 3(1):1–48.
Baker, C. T. H. . The Numerical Treatment of Integral Equations. Clarendon Press, Oxford.
pp. 98, 99
Barber, D. and Saad, D. . Does Extra Knowledge Necessarily Improve Generalisation?
Computation, 8:202–214.
Bartle, R. G. . The Elements of Integration and Lebesgue Measure. Wiley, New York.
Bartlett, P. L., Jordan, M. I., and McAuliﬀe, J. D. . Convexity, Classiﬁcation and Risk Bounds.
Technical Report 638, Department of Statistics, University of California, Berkeley. Available from
 Accepted for publication in Journal of the
American Statistical Association.
Berger, J. O. . Statistical Decision Theory and Bayesian Analysis. Springer, New York. Second
pp. 22, 35
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Bishop, C. M. . Neural Networks for Pattern Recognition. Clarendon Press, Oxford.
Bishop, C. M., Svensen, M., and Williams, C. K. I. . Developments of the Generative Topographic
Mapping. Neurocomputing, 21:203–224.
Bishop, C. M., Svensen, M., and Williams, C. K. I. .
GTM: The Generative Topographic
Mapping. Neural Computation, 10(1):215–234.
Blake, I. F. and Lindsey, W. C. . Level-Crossing Problems for Random Processes. IEEE Trans
Information Theory, 19(3):295–315.
Blight, B. J. N. and Ott, L. . A Bayesian approach to model inadequacy for polynomial regression.
Biometrika, 62(1):79–88.
Boyd, S. and Vandenberghe, L. . Convex Optimization. Cambridge University Press, Cambridge,
Boyle, P. and Frean, M. . Dependent Gaussian Processes. In Saul, L. K., Weiss, Y., and Bottou,
L., editors, Advances in Neural Information Processing Systems 17, pages 217–224. MIT Press. p. 190
Bracewell, R. N. . The Fourier Transform and Its Applications. McGraw-Hill, Singapore, international edition.
pp. 83, 206
Caruana, R. . Multitask Learning. Machine Learning, 28(1):41–75.
Chatﬁeld, C. . The Analysis of Time Series: An Introduction. Chapman and Hall, London, 4th
pp. 82, 209, 214
Choi, T. and Schervish, M. J. .
Posterior Consistency in Nonparametric Regression Problems Under Gaussian Process Priors.
Technical Report 809, Department of Statistics, CMU.
 
Choudhuri, N., Ghosal, S., and Roy, A. . Nonparametric Binary Regression Using a Gaussian
Process Prior. Unpublished. 
Chu, W. and Ghahramani, Z. . Gaussian Processes for Ordinal Regression. Journal of Machine
Learning Research, 6:1019–1041.
Collins, M. and Duﬀy, N. . Convolution Kernels for Natural Language. In Diettrich, T. G., Becker,
S., and Ghahramani, Z., editors, Advances in Neural Information Processing Systems 14. MIT Press.
Collobert, R. and Bengio, S. .
Support Vector Machines for Large-Scale Regression Problems.
Journal of Machine Learning Research, 1:143–160.
 
∼bengio/projects/SVMTorch.html.
pp. 69, 72
Cornford, D., Nabney, I. T., and Williams, C. K. I. . Modelling Frontal Discontinuities in Wind
Fields. Journal of Nonparameteric Statsitics, 14(1-2):43–58.
Cox, D. D. . Multivariate Smoothing Spline Functions. SIAM Journal on Numerical Analysis,
21(4):789–813.
Cox, D. D. and O’Sullivan, F. . Asymptotic Analysis of Penalized Likelihood and Related Estimators. Annals of Statistics, 18(4):1676–1695.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Craven, P. and Wahba, G. . Smoothing Noisy Data with Spline Functions. Numer. Math., 31:377–
Cressie, N. A. C. . Statistics for Spatial Data. Wiley, New York.
pp. 30, 137, 190
Cristianini, N. and Shawe-Taylor, J. . An Introduction to Support Vector Machines. Cambridge
University Press.
Cristianini, N., Shawe-Taylor, J., Elisseeﬀ, A., and Kandola, J. . On Kernel-Target Alignment. In
Diettrich, T. G., Becker, S., and Ghahramani, Z., editors, Advances in Neural Information Processing
Systems 14. MIT Press.
Csat´o, L. . Gaussian Processes—Iterative Sparse Approximations. PhD thesis, Aston University,
Csat´o, L. and Opper, M. . Sparse On-Line Gaussian Processes. Neural Computation, 14(3):641–
pp. 180, 185
Csat´o, L., Opper, M., and Winther, O. . TAP Gibbs Free Energy, Belief Propagation and Sparsity. In Diettrich, T. G., Becker, S., and Ghahramani, Z., editors, Advances in Neural Information
Processing Systems 14, pages 657–663. MIT Press.
pp. 180, 185
Daley, R. . Atmospheric Data Analysis. Cambridge University Press, Cambridge, UK.
David, H. A. . Order Statistics. Wiley, New York.
pp. 169, 170
Davis, P. J. . Circulant Matrices. Wiley, New York.
Dawid, A. P. . Properties of Diagnostic Data Distributions. Biometrics, 32:647–658.
Dellaportas, P. and Stephens, D. A. . Bayesian Analysis of Errors-in-Variables Regression Models.
Biometrics, 51:1085–1095.
Devroye, L., Gy¨orﬁ, L., and Lugosi, G. . A Probabilistic Theory of Pattern Recognition. Springer,
pp. 156, 166
Diaconis, P. and Freedman, D. . On the Consistency of Bayes Estimates. Annals of Statistics,
14(1):1–26.
Diggle, P. J. . Time Series: A Biostatistical Introduction. Clarendon Press, Oxford. pp. 214, 215
Diggle, P. J., Tawn, J. A., and Moyeed, R. A. . Model-based Geostatistics (with discussion).
Applied Statistics, 47:299–350.
Doob, J. L. . The Elementary Gaussian Processes. Annals of Mathematical Statistics, 15(3):229–
Doob, J. L. . Measure Theory. Springer-Verlag, New York.
Drineas, P. and Mahoney, M. W. . On the Nystr¨om Method for Approximating a Gram Matrix for Improved Kernel-Based Learning. Technical Report YALEU/DCS/TR-1319, Yale University.
 
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Duchon, J. . Splines Minimizing Rotation-Invariant Semi-norms in Sobolev Spaces. In Schempp,
W. and Zeller, K., editors, Constructive Theory of Functions of Several Variables, pages 85–100.
Springer-Verlag.
Duda, R. O. and Hart, P. E. . Pattern Classiﬁcation and Scene Analysis. John Wiley, New York.
Edgeworth, F. Y. (1887). On Observations Relating to Several Quantities. Hermathena, 6:279–285.
Faul, A. C. and Tipping, M. E. . Analysis of Sparse Bayesian Learning. In Dietterich, T. G.,
Becker, S., and Ghahramani, Z., editors, Advances in Neural Information Processing Systems 14,
pages 383–389, Cambridge, Massachussetts. MIT Press.
Feldman, J. . Equivalence and Perpendicularity of Gaussian Processes. Paciﬁc J. Math., 8:699–
708. Erratum in Paciﬁc J. Math. 9, 1295-1296 .
Ferrari Trecate, G., Williams, C. K. I., and Opper, M. . Finite-dimensional Approximation of
Gaussian Processes. In Kearns, M. S., Solla, S. A., and Cohn, D. A., editors, Advances in Neural
Information Processing Systems 11, pages 218–224. MIT Press.
Fine, S. and Scheinberg, K. . Eﬃcient SVM Training Using Low-Rank Kernel Representations.
Journal of Machine Learning Research, 2(2):243–264.
pp. 47, 174
Fowlkes, C., Belongie, S., and Malik, J. . Eﬃcient Spatiotemporal Grouping Using the Nystr¨om
Method. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, CVPR
Freedman, D. .
On the Bernstein-Von Mises Theorem with Inﬁnite-Dimensional Parameters.
Annals of Statistics, 27(4):1119–1140.
Frieze, A., Kannan, R., and Vempala, S. . Fast Monte-Carlo Algorithms for Finding Low-Rank
Approximations. In 39th Conference on the Foundations of Computer Science, pages 370–378. p. 174
Geisser, S. and Eddy, W. F. . A Predictive Approach to Model Selection. Journal of the Americal
Statistical Association, 74(365):153–160.
Geman, S. and Geman, D. . Stochastic Relaxation, Gibbs Distributions, and the Bayesian Restoration of Images. IEEE Trans. Pattern Analysis and Machine Intellligence, 6(6):721–741.
Gibbs, M. N. .
Bayesian Gaussian Processes for Regression and Classiﬁcation.
PhD thesis,
Department of Physics, University of Cambridge.
Gibbs, M. N. and MacKay, D. J. C. . Eﬃcient Implementation of Gaussian Processes. Unpublished manuscript. Cavendish Laboratory, Cambridge, UK. 
mackay/BayesGP.html.
Gibbs, M. N. and MacKay, D. J. C. . Variational Gaussian Process Classiﬁers. IEEE Transactions
on Neural Networks, 11(6):1458–1464.
Gihman, I. I. and Skorohod, A. V. . The Theory of Stochastic Processes, volume 1. Springer
Verlag, Berlin.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Girard, A., Rasmussen, C. E., Qui˜nonero-Candela, J., and Murray-Smith, R. . Gaussian Process
Priors With Uncertain Inputs: Application to Multiple-Step Ahead Time Series Forecasting. In Becker,
S., Thrun, S., and Obermayer, K., editors, Advances in Neural Information Processing Systems 15.
MIT Press.
Girosi, F. . Models of Noise and Robust Estimates. Technical Report AI Memo 1287, MIT AI
Laboratory.
Girosi, F., Jones, M., and Poggio, T. . Regularization Theory and Neural Networks Architectures.
Neural Computation, 7(2):219–269.
Goldberg, P. W., Williams, C. K. I., and Bishop, C. M. . Regression with Input-dependent Noise:
A Gaussian Process Treatment. In Jordan, M. I., Kearns, M. J., and Solla, S. A., editors, Advances
in Neural Information Processing Systems 10. MIT Press, Cambridge, MA.
Golub, G. H. and Van Loan, C. F. . Matrix Computations. Johns Hopkins University Press,
Baltimore. Second edition.
pp. 172, 173, 174, 181, 202
Gradshteyn, I. S. and Ryzhik, I. M. . Tables of Integrals, Series and Products. Academic Press.
Corrected and enlarged edition prepared by A. Jeﬀrey.
pp. 98, 103
Green, P. J. and Silverman, B. W. . Nonparametric Regression and Generalized Linear Models.
Chapman and Hall, London.
Grenander, U., Chow, Y., and Keenan, D. M. . Hands: A Pattern Theoretic Study of Biological
Shapes. Springer-Verlag, New York.
pp. 214, 216
Grimmett, G. R. and Stirzaker, D. R. . Probability and Random Processes. Oxford University
Press, Oxford, England, second edition.
pp. 94, 213
Gr¨unwald, P. D. and Langford, J. . Suboptimal Behaviour of Bayes and MDL in Classiﬁcation
Under Misspeciﬁcation. In Proc. Seventeenth Annual Conference on Computational Learning Theory
 .
Gy¨orﬁ, L., Kohler, M., Krzy˙zak, A., and Walk, H. . A Distribution-Free Theory of Nonparametric
Regression. Springer, New York.
Hajek, J. .
On a Property of Normal Distributions of Any Stochastic Process (In Russian).
Czechoslovak Math. J., 8:610–618.
Translated in Selected Trans. Math. Statist. Probab. 1 245-252
 . Also available in Collected Works of Jaroslav Hajek, eds. M. Huˇskov´a, R. Beran, V. Dupaˇc,
Wiley, .
Hand, D. J., Mannila, H., and Smyth, P. . Principles of Data Mining. MIT Press.
Hannan, E. J. . Multiple Time Series. Wiley, New York.
Hansen, L. K., Liisberg, C., and Salamon, P. . The Error-Reject Tradeoﬀ. Open Sys. & Information
Dyn., 4:159–184.
Hastie, T. J. and Tibshirani, R. J. . Generalized Additive Models. Chapman and Hall. pp. 24, 25, 95
Haussler, D. . Convolution Kernels on Discrete Structures. Technical Report UCSC-CRL-99-10,
Dept of Computer Science, University of California at Santa Cruz.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Hawkins, D. L. . Some Practical Problems in Implementing a Certain Sieve Estimator of the
Gaussian Mean Function. Communications in Statistics—Simulation and Computation, 18(2):481–
Hoerl, A. E. and Kennard, R. W. .
Ridge Regression: Biased Estimation for Nonorthogonal
Problems. Technometrics, 12(1):55–67.
Hornik, K. . Some New Results on Neural Network Approximation. Neural Networks, 6(8):1069–
Ihara, S. . Information Theory for Continuous Systems. World Scientiﬁc, Singapore.
Jaakkola, T. S., Diekhans, M., and Haussler, D. . A Discriminative Framework for Detecting
Remote Protein Homologies. Journal of Computational Biology, 7:95–114.
pp. 101, 102, 104
Jaakkola, T. S. and Haussler, D. . Probabilistic Kernel Regression Models. In Heckerman, D. and
Whittaker, J., editors, Workshop on Artiﬁcial Intelligence and Statistics 7. Morgan Kaufmann. p. 41
Jacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. . Adaptive Mixtures of Local
Experts. Neural Computation, 3:79–87.
Johnson, N. L., Kotz, S., and Balakrishnan, N. . Continuous Univariate Distributions volume 2.
John Wiley and Sons, New York, second edition.
Jones, D. R. . A Taxonomy of Global Optimization Methods Based on Response Surfaces. J.
Global Optimization, 21:345–383.
Jordan, M. I. . An Introduction to Probabilistic Graphical Models. Draft book.
Journel, A. G. and Huijbregts, C. J. . Mining Geostatistics. Academic Press.
Kailath, T. .
RKHS Approach to Detection and Estimation Problems—Part I: Deterministic
Signals in Gaussian Noise. IEEE Trans. Information Theory, 17(5):530–549.
Kammler, D. W. . A First Course in Fourier Analysis. Prentice-Hall, Upper Saddle River, NJ.
Kashyap, R. L. and Chellappa, R. . Stochastic Models for Closed Boundary Analysis: Representation and Reconstruction. IEEE Trans. on Information Theory, 27(5):627–637.
Keeling, C. D. and Whorf, T. P. . Atmospheric CO2 Records from Sites in the SIO Air Sampling
Network. In Trends: A Compendium of Data on Global Change. Carbon Dioxide Information Analysis
Center, Oak Ridge National Laboratory, Oak Ridge, Tenn., U.S.A.
Kent, J. T. and Mardia, K. V. . The Link Between Kriging and Thin-plate Splines. In Kelly,
F. P., editor, Probability, Statsitics and Optimization, pages 325–339. Wiley.
Kimeldorf, G. and Wahba, G. . A Correspondence between Bayesian Estimation of Stochastic
Processes and Smoothing by Splines. Annals of Mathematical Statistics, 41:495–502.
Kimeldorf, G. and Wahba, G. . Some Results on Tchebycheﬃan Spline Functions. J. Mathematical
Analysis and Applications, 33(1):82–95.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Kohn, R. and Ansley, C. F. . A New Algorithm for Spline Smoothing based on Smoothing a
Stochastic Process. SIAM J. Sci. Stat. Comput., 8(1):33–48.
Kolmogorov, A. N. . Interpolation und Extrapolation von station¨aren zuf¨aligen Folgen. Izv. Akad.
Nauk SSSR, 5:3–14.
K¨onig, H. . Eigenvalue Distribution of Compact Operators. Birkh¨auser.
Kullback, S. . Information Theory and Statistics. Dover, New York.
pp. 158, 203
Kuss, M. and Rasmussen, C. E. . Assessing Approximations for Gaussian Process Classiﬁcation.
In Weiss, Y., Sch¨olkopf, B., and Platt, J., editors, Advances in Neural Information Processing Systems
18. MIT Press.
pp. 72, 73
Lanckriet, G. R. G., Cristianini, N., Bartlett, P. L., El Ghaoui, L., and Jordan, M. I. . Learning the
Kernel Matrix with Semideﬁnite Programming. Journal of Machine Learning Research, 5(1):27–72.
Lauritzen, S. L. .
Time Series Analysis in 1880:
A Discussion of Contributions Made by
T. N. Thiele. International Statistical Review, 49:319–333.
Lawrence, N. . Gaussian Process Latent Variable Models for Visualization of High Dimensional
Data. In Thrun, S., Saul, L., and Sch¨olkopf, B., editors, Advances in Neural Information Processing
Systems 16, pages 329–336. MIT Press.
Lawrence, N., Seeger, M., and Herbrich, R. . Fast Sparse Gaussian Process Methods: The Informative Vector Machine. In Becker, S., Thrun, S., and Obermayer, K., editors, Advances in Neural
Information Processing Systems 15, pages 625–632. MIT Press.
pp. 178, 185
Leslie, C., Eskin, E., Weston, J., and Staﬀord Noble, W. . Mismatch String Kernels for SVM
Protein Classiﬁcation. In Becker, S., Thrun, S., and Obermayer, K., editors, Advances in Neural
Information Processing Systems 15. MIT Press.
pp. 100, 101, 104
Lin, X., Wahba, G., Xiang, D., Gao, F., Klein, R., and Klein, B. . Smoothing Spline ANOVA
Models for Large Data Sets With Bernoulli Observations and the Randomized GACV. Annals of
Statistics, 28:1570–1600.
Lindley, D. V. . Making Decisions. John Wiley and Sons, London, UK, second edition.
Lodhi, H., Shawe-Taylor, J., Cristianini, N., and Watkins, C. J. C. H. . Text Classiﬁcation using
String Kernels. In Leen, T. K., Diettrich, T. G., and Tresp, V., editors, Advances in Neural Information
Processing Systems 13. MIT Press.
Luo, Z. and Wahba, G. . Hybrid Adaptive Splines. J. Amer. Statist. Assoc., 92:107–116.
MacKay, D. J. C. . A Practical Bayesian Framework for Backpropagation Networks. Neural
Computation, 4(3):448–472.
pp. 109, 166, 167
MacKay, D. J. C. . Bayesian Interpolation. Neural Computation, 4(3):415–447. pp. xiii, xvi, 109
MacKay, D. J. C. . Information-Based Objective Functions for Active Data Selection. Neural
Computation, 4(4):590–604.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
MacKay, D. J. C. . The Evidence Framework Applied to Classiﬁcation Networks. Neural Computation, 4(5):720–736.
MacKay, D. J. C. . Introduction to Gaussian Processes. In Bishop, C. M., editor, Neural Networks
and Machine Learning. Springer-Verlag.
pp. 84, 92
MacKay, D. J. C. . Comparison of Approximate Methods for Handling Hyperparameters. Neural
Computation, 11(5):1035–1068.
MacKay, D. J. C. . Information Theory, Inference, and Learning Algorithms. Cambridge University Press, Cambridge, UK.
pp. xiv, 167
Malzahn, D. and Opper, M. . A Variational Approach to Learning Curves. In Diettrich, T. G.,
Becker, S., and Ghahramani, Z., editors, Advances in Neural Information Processing Systems 14. MIT
Mandelbrot, B. B. . The Fractal Geometry of Nature. W. H. Freeman, San Francisco.
Mardia, K. V. and Marshall, R. J. . Maximum Likelihood Estimation for Models of Residual
Covariance in Spatial Regression. Biometrika, 71(1):135–146.
Mat´ern, B. .
Spatial Variation.
Meddelanden fr˚an Statens Skogsforskningsinstitut, 49, No.5.
Alm¨anna F¨orlaget, Stockholm. Second edition , Springer-Verlag, Berlin.
pp. 85, 87, 89
Matheron, G. . The Intrinsic Random Functions and Their Applications. Advances in Applied
Probability, 5:439–468.
Maxwell, J. C. (1850). Letter to Lewis Campbell; reproduced in L. Campbell and W. Garrett, The Life
of James Clerk Maxwell, Macmillan, 1881.
McAllester, D. . PAC-Bayesian Stochastic Model Selection. Machine Learning, 51(1):5–21. p. 164
McCullagh, P. and Nelder, J. . Generalized Linear Models. Chapman and Hall.
pp. 37, 38, 138
Meinguet, J. . Multivariate Interpolation at Arbitrary Points Made Simple. Journal of Applied
Mathematics and Physics (ZAMP), 30:292–304.
Meir, R. and Zhang, T. . Generalization Error Bounds for Bayesian Mixture Algorithms. Journal
of Machine Learning Research, 4(5):839–860.
Micchelli, C. A. and Pontil, M. . Kernels for Multi-task Learning. In Saul, L. K., Weiss, Y.,
and Bottou, L., editors, Advances in Neural Information Processing Systems 17, pages 921–928. MIT
Micchelli, C. A. and Wahba, G. . Design Problems for Optimal Surface Interpolation. In Ziegler,
Z., editor, Approximation Theory and Applications, pages 329–348. Academic Press.
Minka, T. P. . A Family of Algorithms for Approximate Bayesian Inference. PhD thesis, Massachusetts Institute of Technology.
pp. 41, 52
Minka, T. P. . A Comparison of Numerical Optimizers for Logistic Regression.
 
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Minka, T. P. and Picard, R. W. . Learning How to Learn is Learning With Point Sets.
 
Mitchell, T. M. . Machine Learning. McGraw-Hill, New York.
pp. 2, 165
Murray-Smith, R. and Girard, A. .
Gaussian Process priors with ARMA noise models.
Irish Signals and Systems Conference, pages 147–153, Maynooth. 
publications/MurGir01.pdf.
Neal, R. M. . Bayesian Learning for Neural Networks. Springer, New York. Lecture Notes in
Statistics 118.
pp. xiii, 30, 90, 91, 106, 166, 167
Neal, R. M. . Monte Carlo Implementation of Gaussian Process Models for Bayesian Regression and Classiﬁcation.
Technical Report 9702, Department of Statistics, University of Toronto.
 
Neal, R. M. . Regression and Classiﬁcation using Gaussian Process Priors. In Bernardo, J. M.,
Berger, J. O., Dawid, A. P., and Smith, A. F. M., editors, Bayesian Statistics 6, pages 475–501. Oxford
University Press. (with discussion).
pp. 41, 47
Neal, R. M. . Annealed Importance Sampling. Statistics and Computing, 11:125–139.
Neumaier, A. . Introduction to Global Optimization. 
glopt/intro.html.
O’Hagan, A. . Curve Fitting and Optimal Design for Prediction. Journal of the Royal Statistical
Society B, 40:1–42. (with discussion).
pp. 28, 30, 94
O’Hagan, A. . Bayes-Hermite Quadrature. Journal of Statistical Planning and Inference, 29:245–
pp. 193, 194
O’Hagan, A., Kennedy, M. C., and Oakley, J. E. . Uncertainty Analysis and other Inference Tools
for Complex Computer Codes. In Bernardo, J. M., Berger, J. O., Dawid, A. P., and Smith, A. F. M.,
editors, Bayesian Statistics 6, pages 503–524. Oxford University Press. (with discussion).
Øksendal, B. . Stochastic Diﬀerential Equations. Springer-Verlag, Berlin.
Opper, M. and Vivarelli, F. . General Bounds on Bayes Errors for Regression with Gaussian
Processes. In Kearns, M. S., Solla, S. A., and Cohn, D. A., editors, Advances in Neural Information
Processing Systems 11, pages 302–308. MIT Press.
Opper, M. and Winther, O. .
Gaussian Processes for Classiﬁcation: Mean-Field Algorithms.
Neural Computation, 12(11):2655–2684.
pp. 41, 44, 52, 127, 128
O’Sullivan, F., Yandell, B. S., and Raynor, W. J. . Automatic Smoothing of Regression Functions
in Generalized Linear Models. Journal of the American Statistical Association, 81:96–103. pp. 132, 138
Paciorek, C. and Schervish, M. J. . Nonstationary Covariance Functions for Gaussian Process Regression. In Thrun, S., Saul, L., and Sch¨olkopf, B., editors, Advances in Neural Information Processing
Systems 16. MIT Press.
pp. 93, 94
Papoulis, A. . Probability, Random Variables, and Stochastic Processes. McGraw-Hill, New York.
Third Edition.
pp. 79, 153, 154, 191, 211, 212
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Plaskota, L. . Noisy Information and Computational Complexity. Cambridge University Press,
Cambridge.
pp. 161, 169
Plate, T. A. . Accuarcy versus Interpretability in Flexible Modeling: Implementing a Tradeoﬀ
using Gaussian Process Models. Behaviourmetrika, 26(1):29–50.
Platt, J. C. . Fast Training of Support Vector Machines Using Sequential Minimal Optimization.
In Sch¨olkopf, B., Burges, C. J. C., and Smola, A. J., editors, Advances in Kernel Methods, pages
185–208. MIT Press.
Platt, J. C. .
Probabilities for SV Machines.
In Smola, A., Bartlett, P., Sch¨olkopf, B.,
and Schuurmans, D., editors, Advances in Large Margin Classiﬁers, pages 61–74. MIT Press.
pp. 69, 70, 145, 147, 148
Poggio, T. and Girosi, F. . Networks for Approximation and Learning. Proceedings of IEEE,
78:1481–1497.
pp. 89, 133, 134, 135, 147, 176
Poggio, T., Voorhees, H., and Yuille, A. . A Regularized Solution to Edge Detection. Technical
Report AI Memo 833, MIT AI Laboratory.
Pontil, M., Mukherjee, S., and Girosi, F. .
On the Noise Model of Support Vector Machine
Regression. Technical Report AI Memo 1651, MIT AI Laboratory.
Press, W. H., Teukolsky, S. A., Vetterling, W. T., and Flannery, B. P. . Numerical Recipes in C.
Cambridge University Press, Second edition.
pp. 96, 99, 201
Qui˜nonero-Candela, J. . Learning with Uncertainty—Gaussian Processes and Relevance Vector
Machines. PhD thesis, Informatics and Mathematical Modelling, Technical Univeristy of Denmark.
Rasmussen, C. E. .
Evaluation of Gaussian Processes and Other Methods for Non-linear Regression. PhD thesis, Dept. of Computer Science, University of Toronto. 
publications/pss/ps2304.ps.
Rasmussen, C. E. . Gaussian Processes to Speed up Hybrid Monte Carlo for Expensive Bayesian
Integrals. In Bernardo, J. M., Bayarri, M. J., Berger, J. O., Dawid, A. P., Heckerman, D., Smith, A.
F. M., and West, M., editors, Bayesian Statistics 7, pages 651–659. Oxford University Press.
Rasmussen, C. E. and Ghahramani, Z. . Occam’s Razor. In Leen, T., Dietterich, T. G., and Tresp,
V., editors, Advances in Neural Information Processing Systems 13, pages 294–300. MIT Press. p. 110
Rasmussen, C. E. and Ghahramani, Z. .
Inﬁnite Mixtures of Gaussian Process Experts.
Diettrich, T. G., Becker, S., and Ghahramani, Z., editors, Advances in Neural Information Processing
Systems 14. MIT Press.
Rasmussen, C. E. and Ghahramani, Z. . Bayesian Monte Carlo. In Suzanna Becker, S. T. and
Obermayer, K., editors, Advances in Neural Information Processing Systems 15, pages 489–496. MIT
Rasmussen, C. E. and Qui˜nonero-Candela, J. . Healing the Relevance Vector Machine through
Augmentation. In Proc. 22nd International Conference on Machine Learning.
pp. 150, 176
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Rifkin, R. and Klautau, A. . In Defense of One-Vs-All Classiﬁcation. Journal of Machine Learning
Research, 5:101–141.
pp. 146, 147
Ripley, B. . Spatial Statistics. Wiley, New York.
Ripley, B. . Pattern Recognition and Neural Networks. Cambridge University Press, Cambridge,
Ritter, K. . Average-Case Analysis of Numerical Problems. Springer Verlag. pp. 159, 161, 169, 193
Ritter, K., Wasilkowski, G. W., and Wo´zniakowski, H. . Multivariate Integration and Approximation of Random Fields Satisfying Sacks-Ylvisaker Conditions. Annals of Applied Probability, 5:518–540.
Rousseeuw, P. J. .
Least Median of Squares Regression.
Journal of the American Statistical
Association, 79:871–880.
Sacks, J., Welch, W. J., Mitchell, T. J., and Wynn, H. P. . Design and Analysis of Computer
Experiments. Statistical Science, 4(4):409–435.
pp. 16, 30
Saitoh, S. . Theory of Reproducing Kernels and its Applications. Longman, Harlow, England.
Salton, G. and Buckley, C. . Term-weighting Approaches in Automatic Text Retrieval. Information
Processing and Management, 24:513–523.
Sampson, P. D. and Guttorp, P. . Nonparametric Estimation of Nonstationary Covariance Structure. Journal of the American Statistical Association, 87:108–119.
Santner, T. J., Williams, B. J., and Notz, W. . The Design and Analysis of Computer Experiments.
Springer, New York.
Saunders, C., Gammerman, A., and Vovk, V. . Ridge Regression Learning Algorithm in Dual
Variables. In Shavlik, J., editor, Proceedings of the Fifteenth International Conference on Machine
Learning . Morgan Kaufmann.
Saunders, C., Shawe-Taylor, J., and Vinokourov, A. . String Kernels, Fisher Kernels and Finite
State Automata. In Becker, S., Thrun, S., and Obermayer, K., editors, Advances in Neural Information
Processing Systems 15. MIT Press.
Schoenberg, I. J. . Metric Spaces and Positive Deﬁnite Functions. Trans. American Mathematical
Society, 44(3):522–536.
Schoenberg, I. J. . Spline Functions and the Problem of Graduation. Proc. Nat. Acad. Sci. USA,
52:947–950.
pp. 132, 138
Sch¨olkopf, B. and Smola, A. J. . Learning with Kernels. MIT Press.
pp. xvi, 73, 89, 90, 91, 129, 130, 133, 141, 144, 147, 173, 188, 195, 196
Sch¨olkopf, B., Smola, A. J., and M¨uller, K.-R. .
Nonlinear Component Analysis as a Kernel
Eigenvalue Problem. Neural Computation, 10:1299–1319.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Schwaighofer, A. and Tresp, V. . Transductive and Inductive Methods for Approximate Gaussian Process Regression. In Becker, S., Thrun, S., and Obermayer, K., editors, Advances in Neural
Information Processing Systems 15. MIT Press.
pp. 181, 184
Scott, D. W. . Multivariate Density Estimation. Wiley, New York.
Seeger, M. . Bayesian Model Selection for Support Vector Machines, Gaussian Processes and
Other Kernel Classiﬁers. In Solla, S. A., Leen, T. K., and M¨uller, K.-R., editors, Advances in Neural
Information Processing Systems 12. MIT Press, Cambridge, MA.
pp. 41, 54, 145
Seeger, M. .
PAC-Bayesian Generalisation Error Bounds for Gaussian Process Classiﬁcation.
Journal of Machine Learning Research, 3:322–269.
pp. 161, 164, 165
M. .
Bayesian Gaussian Process Models:
PAC-Bayesian Generalisation Error
Bounds and Sparse Approximations.
PhD thesis, School of Informatics, University of Edinburgh.
 
pp. 46, 145, 161, 162, 163, 179, 180, 186
Seeger, M. . Expectation Propagation for Exponential Families. 
∼mseeger/papers/epexpfam.ps.gz.
Seeger, M. and Jordan, M. I. . Sparse Gaussian Process Classiﬁcation With Multiple Classes.
Technical Report TR 661, Department of Statistics, University of California at Berkeley.
Seeger, M., Williams, C. K. I., and Lawrence, N. . Fast Forward Selection to Speed Up Sparse
Gaussian Process Regression. In Bishop, C. and Frey, B. J., editors, Proceedings of the Ninth International Workshop on Artiﬁcial Intelligence and Statistics. Society for Artiﬁcial Intelligence and
Statistics.
pp. 178, 180
Shawe-Taylor, J. and Williams, C. K. I. . The Stability of Kernel Principal Components Analysis
and its Relation to the Process Eigenspectrum. In Becker, S., Thrun, S., and Obermayer, K., editors,
Advances in Neural Information Processing Systems 15. MIT Press.
Shepp, L. A. . Radon-Nikodym Derivatives of Gaussian Measures. Annals of Mathematical Statistics, 37(2):321–354.
Silverman, B. W. .
Density Ratios, Empirical Likelihood and Cot Death.
Applied Statistics,
27(1):26–33.
Silverman, B. W. .
Spline Smoothing: The Equivalent Variable Kernel Method.
Statistics, 12(3):898–916.
pp. 25, 153, 154
Silverman, B. W. . Some Aspects of the Spline Smoothing Approach to Non-parametric Regression
Curve Fitting (with discussion). J. Roy. Stat. Soc. B, 47(1):1–52.
pp. 170, 175
Simard, P., Victorri, B., Le Cun, Y., and Denker, J. . Tangent Prop—A Formalism for Specifying
Selected Invariances in an Adaptive Network. In Moody, J. E., Hanson, S. J., and Lippmann, R. P.,
editors, Advances in Neural Information Processing Systems 4, pages 895–903. Morgan Kaufmann.
pp. 73, 195
Smola, A. J. and Bartlett, P. L. . Sparse Greedy Gaussian Process Regression. In Leen, T. K.,
Diettrich, T. G., and Tresp, V., editors, Advances in Neural Information Processing Systems 13, pages
619–625. MIT Press.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Smola, A. J. and Sch¨olkopf, B. . Sparse Greedy Matrix Approximation for Machine Learning. In
Proceedings of the Seventeenth International Conference on Machine Learning. Morgan Kaufmann.
pp. 173, 174
Solak, E., Murray-Smith, R., Leithead, W. E., Leith, D., and Rasmussen, C. E. . Derivative
Observations in Gaussian Process Models of Dynamic Systems. In Becker, S., S. T. and Obermayer,
K., editors, Advances in Neural Information Processing Systems 15, pages 1033–1040. MIT Press.
Sollich, P. . Learning Curves for Gaussian Processes. In Kearns, M. S., Solla, S. A., and Cohn,
D. A., editors, Neural Information Processing Systems, Vol. 11. MIT Press.
pp. 160, 161
Sollich, P. .
Bayesian Methods for Support Vector Machines: Evidence and Predictive Class
Probabilities. Machine Learning, 46:21–52.
pp. 145, 150, 161
Sollich, P. and Williams, C. K. I. . Using the Equivalent Kernel to Understand Gaussian Process
Regression.
In Saul, L. K., Weiss, Y., and Bottou, L., editors, Advances in Neural Information
Processing Systems 17. MIT Press.
Stein, M. L. . A Kernel Approximation to the Kriging Predictor of a Spatial Process. Ann. Inst.
Statist. Math, 43(1):61–75.
Stein, M. L. . Interpolation of Spatial Data. Springer-Verlag, New York.
pp. 82, 83, 85, 86, 87, 115, 137, 157, 158, 161, 212
Steinwart, I. . Consistency of Support Vector Machines and Other Regularized Kernel Classiﬁers.
IEEE Trans. on Information Theory, 51(1):128–142.
Stitson, M. O., Gammerman, A., Vapnik, V. N., Vovk, V., Watkins, C. J. C. H., and Weston, J. .
Support Vector Regression with ANOVA Decomposition Kernels. In Sch¨olkopf, B., Burges, C. J. C.,
and Smola, A. J., editors, Advances in Kernel Methods. MIT Press.
Sundararajan, S. and Keerthi, S. S. . Predictive Approaches for Choosing Hyperparameters in
Gaussian Processes. Neural Computation, 13:1103–1118.
Suykens, J. A. K. and Vanderwalle, J. . Least Squares Support Vector Machines. Neural Processing
Letters, 9:293–300.
Szeliski, R. . Regularization uses Fractal Priors. In Proceedings of the 6th National Conference
on Artiﬁcial Intelligence (AAAI-87).
pp. 135, 137
Teh, Y. W., Seeger, M., and Jordan, M. I. . Semiparametric Latent Factor Models. In Cowell,
R. G. and Ghahramani, Z., editors, Proceedings of Tenth International Workshop on Artiﬁcial Inte
lligence and Statistics, pages 333–340. Society for Artiﬁcial Intelligence and Statistics.
Thomas-Agnan, C. . Computing a Family of Reproducing Kernels for Statistical Applications.
Numerical Algorithms, 13:21–32.
Thompson, P. D. . Optimum Smoothing of Two-Dimensional Fields. Tellus, 8:384–393.
Tikhonov, A. N. . Solution of Incorrectly Formulated Problems and the Regularization Method.
Soviet. Math. Dokl., 5:1035–1038.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Tikhonov, A. N. and Arsenin, V. Y. . Solutions of Ill-posed Problems. W. H. Winston, Washington,
Tipping, M. E. . Sparse Bayesian Learning and the Relevance Vector Machine. Journal of Machine
Learning Research, 1:211–244.
Tipping, M. E. and Faul, A. C. . Fast Marginal Likelihood Maximisation for Sparse Bayesian
Models. In Bishop, C. M. and Frey, B. J., editors, Proceedings of Ninth International Workshop on
Artiﬁcial Intelligence and Statistics. Society for Artiﬁcial Intelligence and Statistics.
Tresp, V. . A Bayesian Committee Machine. Neural Computation, 12(11):2719–2741.
pp. 180, 181, 185, 187
Tsuda, K., Kawanabe, M., R¨atsch, G., Sonnenburg, S., and M¨uller, K.-R. . A New Discriminative
Kernel from Probabilistic Models. Neural Computation, 14(10):2397–2414.
Uhlenbeck, G. E. and Ornstein, L. S. . On the Theory of Brownian Motion. Phys. Rev., 36:823–841.
pp. 86, 212
Valiant, L. G. . A Theory of the Learnable. Communications of the ACM, 27(11):1134–1142.
Vapnik, V. N. . The Nature of Statistical Learning Theory. Springer Verlag, New York.
pp. 36, 141, 181
Vapnik, V. N. . Statistical Learning Theory. John Wiley and Sons.
Vijayakumar, S., D’Souza, A., and Schaal, S. . Incremental Online Learning in High Dimensions.
Accepted for publication in Neural Computation.
pp. 22, 24
Vijayakumar, S., D’Souza, A., Shibata, T., Conradt, J., and Schaal, S. . Statistical Learning for
Humanoid Robots. Autonomous Robot, 12(1):55–69.
Vijayakumar, S. and Schaal, S. . LWPR: An O(n) Algorithm for Incremental Real Time Learning
in High Dimensional Space. In Proc. of the Seventeenth International Conference on Machine Learning
 , pages 1079–1086.
Vishwanathan, S. V. N. and Smola, A. J. . Fast Kernels for String and Tree Matching. In Becker,
S., Thrun, S., and Obermayer, K., editors, Advances in Neural Information Processing Systems 15.
MIT Press.
Vivarelli, F. and Williams, C. K. I. .
Discovering Hidden Features with Gaussian Processes
Regression. In Kearns, M. S., Solla, S. A., and Cohn, D. A., editors, Advances in Neural Information
Processing Systems 11. MIT Press.
von Mises, R. . Mathematical Theory of Probability and Statistics. Academic Press.
Wahba, G. . Improper Priors, Spline Smoothing and the Problem of Guarding Against Model
Errors in Regression. Journal of the Royal Statistical Society B, 40(3):364–372.
Wahba, G. . A Comparison of GCV and GML for Choosing the Smoothing Parameter in the
Generalized Spline Smoothing Problem. Annals of Statistics, 13:1378–1402.
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml
Bibliography
Wahba, G. .
Spline Models for Observational Data.
Society for Industrial and Applied
Mathematics, Philadelphia, PA.
CBMS-NSF Regional Conference series in applied mathematics.
pp. 95, 112, 117, 118, 129, 131, 137, 138, 157, 176
Wahba, G., Johnson, D. R., Gao, F., and Gong, J. . Adaptive Tuning of Numerical Weather
Prediction Models: Randomized GCV in Three-and Four-Dimensional Data Assimilation. Monthly
Weather Review, 123:3358–3369.
Watkins, C. J. C. H. . Dynamic Alignment Kernels. Technical Report CSD-TR-98-11, Dept of
Computer Science, Royal Holloway, University of London.
Watkins, C. J. C. H. . Dynamic Alignment Kernels. In Smola, A. J., Bartlett, P. L., and Sch¨olkopf,
B., editors, Advances in Large Margin Classiﬁers, pages 39–50. MIT Press, Cambridge, MA.
Wegman, E. J. . Reproducing Kernel Hilbert Spaces. In Kotz, S. and Johnson, N. L., editors,
Encyclopedia of Statistical Sciences, volume 8, pages 81–84. Wiley, New York.
pp. 129, 130
Weinert, H. L., editor .
Reproducing Kernel Hilbert Spaces.
Hutchinson Ross, Stroudsburg,
Pennsylvania.
Wendland, H. . Scattered Data Approximation. Cambridge Monographs on Applied and Computational Mathematics. Cambridge University Press.
Whittle, P. . Prediction and Regulation by Linear Least-square Methods. English Universities
pp. 30, 216
Widom, H. . Asymptotic Behavior of the Eigenvalues of Certain Integral Equations. Trans. of the
American Mathematical Society, 109(2):278–295.
Widom, H. . Asymptotic Behavior of the Eigenvalues of Certain Integral Equations II. Archive
for Rational Mechanics and Analysis, 17:215–229.
Wiener, N. . Extrapolation, Interpolation and Smoothing of Stationary Time Series. MIT Press,
Cambridge, Mass.
Williams, C. K. I. . Computation with Inﬁnite Neural Networks. Neural Computation, 10(5):1203–
Williams, C. K. I. and Barber, D. .
Bayesian Classiﬁcation with Gaussian Processes.
Transactions on Pattern Analysis and Machine Intelligence, 20(12):1342–1351.
pp. 41, 45, 48, 49
Williams, C. K. I. and Rasmussen, C. E. . Gaussian Processes for Regression. In Touretzky, D. S.,
Mozer, M. C., and Hasselmo, M. E., editors, Advances in Neural Information Processing Systems 8,
pages 514–520. MIT Press.
pp. 30, 107
Williams, C. K. I., Rasmussen, C. E., Schwaighofer, A., and Tresp, V. .
Observations on
the Nystr¨om Method for Gaussian Process Prediction. Technical report, University of Edinburgh.
 pubs.html.
Williams, C. K. I. and Seeger, M. . Using the Nystr¨om Method to Speed Up Kernel Machines.
In Leen, T. K., Diettrich, T. G., and Tresp, V., editors, Advances in Neural Information Processing
Systems 13, pages 682–688. MIT Press.
pp. 173, 177
C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
ISBN 026218253X.
c⃝2006 Massachusetts Institute of Technology.
www.GaussianProcess.org/gpml