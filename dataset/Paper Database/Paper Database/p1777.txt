An Energy-Efﬁcient Mobile Recommender System
Yong Ge1, Hui Xiong1, Alexander Tuzhilin2, Keli Xiao1,
Marco Gruteser3, Michael J.Pazzani 4
1 Rutgers Business School, Rutgers University
 ,{yongge,keli}@pegasus.rutgers.edu
2 Leonard N. Stern School of Business, NYU, 
3 Elect & Comp Engineering,Rutgers University, 
4 Computer Science,Rutgers University, 
The increasing availability of large-scale location traces creates unprecedent opportunities to change the paradigm for
knowledge discovery in transportation systems.
A particularly promising area is to extract energy-eﬃcient transportation patterns (green knowledge), which can be used as
guidance for reducing ineﬃciencies in energy consumption
of transportation sectors. However, extracting green knowledge from location traces is not a trivial task. Conventional
data analysis tools are usually not customized for handling
the massive quantity, complex, dynamic, and distributed nature of location traces. To that end, in this paper, we provide
a focused study of extracting energy-eﬃcient transportation
patterns from location traces. Speciﬁcally, we have the initial focus on a sequence of mobile recommendations. As a
case study, we develop a mobile recommender system which
has the ability in recommending a sequence of pick-up points
for taxi drivers or a sequence of potential parking positions.
The goal of this mobile recommendation system is to maximize the probability of business success. Along this line,
we provide a Potential Travel Distance (PTD) function for
evaluating each candidate sequence. This PTD function possesses a monotone property which can be used to eﬀectively
prune the search space. Based on this PTD function, we
develop two algorithms, LCP and SkyRoute, for ﬁnding the
recommended routes.
Finally, experimental results show
that the proposed system can provide eﬀective mobile sequential recommendation and the knowledge extracted from
location traces can be used for coaching drivers and leading
to the eﬃcient use of energy.
Categories and Subject Descriptors
H.2.8 [Database Management]: Database Applications—
Data Mining
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
KDD’10, July 25–28, 2010, Washington, DC, USA.
Copyright 2010 ACM 978-1-4503-0055-110/07 ...$10.00.
General Terms
Algorithms, Design,Experimentation
Mobile Recommender System, Trajectory Data Analysis
INTRODUCTION
Advances in sensor, wireless communication, and information infrastructures such as GPS, WiFi and RFID have
enabled us to collect large amounts of location traces (trajectory data) of individuals or objects. Such a large number
of trajectories provide us unprecedented opportunity to automatically discover useful knowledge, which in turn deliver
intelligence for real-time decision making in various ﬁelds,
such as mobile recommendations. Indeed, a mobile recommender system promises to provide mobile users access to
personalized recommendations anytime, anywhere. To this
end, an important task is to understand the unique features
that distinguish pervasive personalized recommendation systems from classic recommender systems.
Recommender systems address the information overloaded problem by identifying user interests and providing
personalized suggestions. In general, there are three ways
to develop recommender systems. The ﬁrst one is contentbased . It suggests items which are similar to those a
given user has liked in the past. The second way is based
on collaborative ﬁltering. In other words, recommendations
are made according to the tastes of other users that are similar to the target user. Finally, a third way is to combine
the above and have a hybrid solution . However, the development of personalized recommender systems in mobile
and pervasive environments is much more challenging than
developing recommender systems from traditional domains
due to the complexity of spatial data and intrinsic spatiotemporal relationships, the unclear roles of context-aware
information, and the increasing availability of environment
sensing capabilities.
Recommender systems in the mobile environments have
been studied before . For instance,
the work in targets the development of mobil tourist
guides. Also, Heijden et al. have discussed some technological opportunities associated with mobile recommendation
systems . In addition, Averjanova et al. have developed
a map-based mobile recommender system that can provide
users with some personalized recommendations .
However, this prior work is mostly based on user ratings and is
only exploratory in nature, and the problem of leveraging
unique features distinguishing mobile recommender systems
remains pretty much open.
In this paper, we exploit the knowledge extracted from
location traces and develop a mobile recommender system
based on business success metrics instead of predictive performance measures based on user ratings. Indeed, the key
idea is to leverage the business knowledge from the historical
data of successful taxi drivers for helping other taxi drivers
improve their business performance. Along this line, we provide a pilot feasibility study of extracting business-success
knowledge from location traces by taxi drivers and exploiting
this business information for guiding taxis’ driving routes.
Speciﬁcally, we ﬁrst extract a group of successful taxi drivers
based on their past performances in terms of revenue per energy use. Then, we can cluster the pick-up points of these
taxi drivers for a certain time period. The centroids of these
clusters can be used as the recommended pick-up points with
a certain probability of success for new taxi drivers in these
This problem can be formally deﬁned as a mobile
sequential recommendation problem, which recommends sequential pick-up points for a taxi driver to maximize his/her
business success. Essentially, a key challenge of this problem is that the computational cost can be dramatically increased as the number of pick-up points increases, since this
is a combinatorial problem in nature.
To that end, we provide a Potential Travel Distance (PTD)
function for evaluating each candidate route.
function possesses a monotone property which can be used
to eﬀectively prune the search space and generate a small set
of candidate routes. Indeed, we have developed a route recommendation algorithm, named LCP, which exploits the
monotone property of the PTD function. In addition, we
observe that many candidate routes can be dominated by
skyline routes , and thus can be pruned by skyline computing. However, traditional skyline computing algorithms
are not eﬃcient for querying skyline of all candidate routes
because it leads to an expensive network traversal process.
Thus, we propose a SkyRoute algorithm to compute the skyline for candidate routes. An advantage of searching optimal
drive route through skyline computing is that it will save the
total online processing time when we try to provide diﬀerent
optimal drive routes deﬁned by diﬀerent business needs.
Finally, the extensive experiments on real-world location
traces of 500 taxi drivers show that both LCP and SkyRoute
algorithms outperform the brute-force method with a signiﬁcant margin.
Also, SkyRoute has a much better performance than traditional skyline computing methods .
Moreover, we show that, if there is an online demand for different evaluation criteria, SkyRoute results in better performances than LCP. However, if there is only one evaluation
criterion, the performance of LCP is the best.
PROBLEM FORMULATION
In this section, we formulate the problem of mobile sequential recommendation (MSR).
A General Problem Formulation
Consider a scenario that a large number of GPS traces
of taxi drivers have been collected for a period of time. In
this collection of location traces, we also have the information when a cab is empty or occupied. In this data set, it
is possible to ﬁrst identify a group of taxi drivers who are
very successful in business. Then, we can cluster the pick-up
points of these taxi drivers for a certain time period. The
centroids of these clusters can be used as the recommended
pick-up points with a certain probability of success for new
taxi drivers in these areas. Then, a mobile sequential recommendation problem can be formulated as follows.
Assume that a set of N potential pick-up points, C={C1,
C2, · · · , CN}, is available. Also, the estimated probability
that a pick-up event could happen at each pick-up point
is known as P(Ci), where P(Ci)(i = 1, · · · , N) is assumed
to be independently distributed. Let P = {P(C1), P(C2),
· · · , P(CN)} denote the probability set.
In addition, let
R2, · · · , −−→
RM} be the set of all the directed sequences (potential driving routes) generated from C and
R| = M is the size of −→
R - the number of all possible
driving routes.
Note that the pick-up points in each directed sequence are assumed to be diﬀerent from each other.
Next, let L−→
Ri be the length of route −→
Ri(1 ≤i ≤M), where
Ri ≤N. Finally, for a directed sequence −→
Ri, Let P−→
be the route probability set which are the probabilities of all
pick-up points containing in −→
Ri, where P−→
Ri is a subset of P.
The objective of this MSR problem is to recommend a
travel route for a cab driver in a way such that the potential travel distance before having customer is minimized.
Let F be the function for computinging the Potential Travel
Distance (PTD) before having a customer. The PTD can
be denoted as F(PoCab, −→
R, P). In other words, the computation of PTD depends on the current position of a cab
(PoCab), a suggested sequential pick-up points (−→
the corresponding probabilities associated with all recommended pick-up points.
Based on the above deﬁnitions and notations, we can formally deﬁne the problem as:
The MSR Problem
Given: A set of potential pick-up points C with |C| =
N, a probability set P = {P(C1), P(C2), · · · , P(CN)}, a
directed sequence set −→
R with |−→
R| = M and the current
position (PoCab) of a cab driver, who needs the service.
Objective: Recommending an optimal driving route −→
R). The goal is to minimize the PTD:
F(PoCab, −→
Figure 1: An Illustration Example.
The MSR problem involves the recommendation of a sequence of pick-up points and has combinatorial complexity
in nature. However, this problem is practically important
and interesting, since it helps to improve the business performances of taxi companies, the eﬃcient use of energy, the
productivity of taxi drivers, and the user experiences.
The MSR problem is diﬀerent from traditional Traveling
Salesman Problem (TSP) , which ﬁnds a shortest path
that visits each given location exactly once. The reason is
that TSP evaluates a combination of exact N given locations. In other words, all N locations have to be involved.
In contrast, the proposed MSR problem is to ﬁnd a subset
locations of given N locations for recommendation. Also,
the MSR problem is diﬀerent from the traditional scheduling problem , which selects a set of duties for vehicle
drivers. The reason is that all these duties are determined in
advance, such as delivering the packages to determined locations, while the MSR problem consists of uncertain pick-up
jobs among several locations.
Figure 1 shows an illustration example. In the ﬁgure, for a cab T, the closest pick-up
point is C1. However, we cannot simply recommend C1 as
the ﬁrst stop in the recommended sequence even if the probability of having a customer at C1 is greater than C4 which
is the second closest to T. The reason is that there is still
probability that this cab drive cannot ﬁnd a customer at
C1 and then it will cost much more to go to a next pick-up
point. Instead, if T goes to C4 ﬁrst, T might be able to
exploit a sequence of pick-up opportunities.
For the MSR problem, there are two major challenges.
First, how to ﬁnd reliable pick-up points from the historical
data and how to estimate the successful probability at each
pick-up point? Second, there is a computational challenge
to search an optimal route.
Analysis of Computational Complexity
Here, we analyze the computational complexity of the
MSR problem. A brute-force method for searching the optimal recommended route has to check all possible sequences
R. If we assume the cost for computing the function F
once is 1 ( Cox(F) = 1), the complexity of searching a given
set C with N pick-up points is as follows.
Lemma 1. Given a set of pick-up points C, where |C| =
Ri ≤N and Cox(F) = 1, the complexity of searching an optimal directed sequence from −→
R is O(N!)
Proof. The complexity of searching an optimal sequence
is equal to the total number M of all possible sequences
generated from C.
Since every directed sequence is actually a permutation of pick-up points which form the subset
of C, we decompose the checking process into two steps:
enumeration of non-empty subset B from C and the permutation of pick-up points belonging to the subset B.
a subset B with i diﬀerent pick-up points, there are totally
diﬀerent subsets.
And the range of integer i is
1 ≤i ≤N. For each subset B of i diﬀerent element, there
are totally i! diﬀerent permutations. Thus the total number of all possible directed sequences generated from C is
· i! < N!(1 + 1 + 1/2) = 5
2 · N!. Thus, we
can have 2 · N! < M < 5
2 · N!. Therefore, the complexity of
search optimal directed sequence is O(N!).
The MSR Problem with Constraints
As illustrated above, it is computationally prohibited to
search for the optimal solution of the general MSR problem.
Therefore, from a practical perspective, we consider a simpliﬁed version of the MSR problem. Speciﬁcally, we put a
constraint on the length of a recommended route L−→
other words, the length of a recommended route is set to be
a constant; that is, L−→
Ri = L. To simplify the discussion,
i denote the recommended route with a length of L.
Based on this constraint, we can simplify the original objective function of the MSR problem as follows.
The MSR Problem with a Length Constraint
Objective:
Recommending
R). The goal is to minimize the PTD:
The computational complexity of this simpliﬁed MSR problem is analyzed as follows.
Lemma 2. Given |C| = N,L−→
Ri = L and Cox(F) = 1, the
computational complexity of searching an optimal directed
sequence with a length of L from −→
R is O(N L)
Proof. Since the length of the recommended route has
been ﬁxed, the computational complexity can actually be
obtained through modifying equation in proof of Lemma
· L!, where M is the number of all the
sequences with a length as L.
M can be transformed as
N(N −1) · · · (N −L + 1). Thus, the computational complexity of this problem is O(N L).
The above shows that the computational cost of this simpliﬁed MSR problem will dramatically increase as the number of pick-up points N increases. In this paper, we focus
on studying the MSR problem with a length constraint.
RECOMMENDING POINT GENERATION
In this section, we show how to generate the recommending points and compute the probability of pick-up events at
each recommending point from location traces of cab drivers.
High-Performance Drivers
In real world, there are always high-performance experienced cab drivers, who typically have suﬃcient driving hours
and higher customer occupancy rates - the percentage of
driving time with customers. For example, Figure 2 (a) and
(b) show the distributions of driving hours and occupancy
rates of more than 500 drivers in San Francisco over a period of about 30 days. In the ﬁgure, we can clearly see that
the drivers have diﬀerent performances in terms of occupancy rates. Based on this observation, we will ﬁrst extract
a group of high-performance drivers with suﬃcient driving
hours and high occupancy rates. The past pick-up records
of these selected drivers will be used for the generation of
potential pick-up points for recommendation.
Clustering Based on Driving Distance
After carefully observing historical pick-up points of highperformance drivers, we notice that there are relative more
pick-up events in some places than others. In other words,
there are the cluster eﬀect of historical pick-up points. Therefore, we propose to cluster historical pick-up points of highperformance drivers into N clusters. The centroids of these
clusters will be used for recommending pick-up points. For
Driving Hours
Frequency of Driving Hours
(a) Driving Hours
Occupancy Rate
Frequency of Occupancy Rates
(b) Occupancy Rates
Figure 2: Some Statistics of the Cab Data.
Figure 3: A Recommended Driving Route.
this clustering algorithm, we use driving distance rather
than Euclidean distance as the distance measure.
study, we perform clustering based on driving distance during diﬀerent time periods in order to have recommending
pick-up pointers for diﬀerent time periods. Another bene-
ﬁt of clustering historical pick-up points is to dramatically
reduce the computational cost of the MRS problem.
Probability Calculation
For each recommended pick-up point (the centroid of historical pick-up cluster), the probability of a pick-up event
can be computed based on historical pick-up data.
idea is to measure how frequent pick-up events can happen when cabs travel across each pick-up cluster. Specifically, we ﬁrst obtain the spatial coverage of each cluster.
Then, let #T denote the number of cabs which have no customer before passing a cluster. For these #T empty cabs,
the number of pick-up events #P is counted in this cluster. Finally, the probability of pick-up event for each cluster (each recommended pick-up point) can be estimated as
P(Ci)1≤i≤N = #P
#T , where #P and #T are recorded for each
historical pick-up cluster at diﬀerent time periods.
SEQUENTIAL RECOMMENDATION
In this section, we design mobile sequential algorithms for
searching the optimal route for recommendation.
The Potential Travel Distance Function
First, we introduce the Potential Travel Distance (PTD)
function, which will be exploited for algorithm design. To
simplify the discussion, we illustrate the PTD function via
an example.
Speciﬁcally, Figure 3 shows a recommended
driving route PoCab →C1 →C2 →C3 →C4 for the cab
PoCab, where the length of suggested driving route L = 4.
When a cab driver follows this route
RL, he/she may
pick up customers at each pick-up point with a probability P(Ci). For example, a pick-up event may happen at C1
with the probability P(C1), or at C2 with the probability
P(C1)P(C2), where P(Ci) = 1 −P(Ci) is the probability
that a pick-up event does not happen at Ci.
Therefore,
the travel distance before a pick-up event is discretely distributed. In addition, it is possible that there is no pick-up
event happening after going through the suggested route.
This probability is P(C1) · P(C2) · P(C3) · P(C4). In this
paper, since we only consider the driving routes with a ﬁxed
length, the travel distance beyond the last pick-up point is
set to be D∞equally for all suggested driving routes. Formally, we represent the distribution of the travel distance before next pick-up event with two vectors: D−→
RL =⟨D1, (D1 +
D2), (D1+D2+D3), (D1+D2+D3+D4), D∞⟩and P−→
P(C1) · P(C2), P(C1) · P(C2) · P(C3), P(C1) · P(C2) · P(C3) ·
P(C4), P(C1)·P(C2)·P(C3)·P(C4)⟩. Finally, the Potential
Travel Distance (PTD) function F is deﬁned as the mean of
this distribution as follows.
where · is the dot product of two vectors.
From the deﬁnition of the PTD function, we know that the
evaluation of a suggested drive route is only determined by
the probability of each pick-up point and the travel distance
along the suggested route, except the common D∞. These
two types of information associated with each drive route
can be represented with one 2L-dimensional vector DP =
⟨DP1, · · · , DPl, · · · DP2L⟩. Let us consider the example in
Figure 3, where L = 4. The 8-dimensional vector DP for this
speciﬁc driving route is DP = ⟨D1, P(C1), D2, P(C2), D3,
P(C3), D4, P(C4)⟩.
However, to ﬁnd the optimal suggested route, if we use a
brute-force method, we need to compute the PTD for all directed sequences with a length L.
This involves a lot of
computation.
Indeed, many suggested routes can be removed without computing the PTD function, because all
pick-up points along these routes are far away from the target cab. Along this line, we identify a monotone property of
the Function F as follows.
Lemma 3. The Monotone Property of the PTD Function F. The PTD Function F(DP) is strictly monotonically
increasing with each attribute of vector DP, which is a 2Ldimensional vector.
Proof. A proof sketch is as follows. By the deﬁnition
of the function F in Equation 2, we can ﬁrst derive the
polynomial form of F. From the polynomial form of F, we
can observe that the degree of each variable is one. Also,
D∞is assumed to be one big enough constant. To prove the
monotonicity of F, it is equally to prove that the coeﬃcient
of each variable is positive. This is easy to show. The proof
details are omitted due to the space limit.
The LCP Algorithm
In this subsection, we introduce the LCP algorithm for
ﬁnding an optimal driving route. In LCP, we exploit the
monotone property of the PTD function and two other pruning strategies, Route Dominance and Constrained Subroute
Dominance, for pruning the search space.
Definition 1. Route Dominance. A recommended driving route
RL, associated with the vector DP, dominates another route
eRL, associated with the vector g
DP, iﬀ∃1 ≤l ≤
2L, DPl < g
DP l and ∀1 ≤l ≤2L, DPl ≤g
DP l. This can be
denoted as
By this deﬁnition, if a candidate route A is dominated by
a candidate route B, A cannot be an optimal route. Next,
we provide a deﬁnition of constraint sub-route dominance.
Definition 2. Constrained Sub-route Dominance.
Consider that two sub-routes −→
R sub and −→
sub with an equal
length (the number of pick-up points) and the same source
and destination points. If the associated vector of −→
R sub dominates the associated vector of −→
sub, then −→
R sub dominates
sub, i.e. −→
Figure 4: Illustration: the Sub-route Dominance.
For example, as shown in Figure 4, −→
R sub is C2 →C3 →C4
sub is C2 →C′
The associated vectors of
R sub and −→
sub are DPsub = ⟨D3, P(C3), D4, P(C4)⟩and
4, P(C4)⟩respectively.
dominance of −→
R sub over −→
sub is determined by the dominance of these two vectors. Here, we have the constraints
that two routes have the same length as well as the same
source and destination.
The constrained sub-route dominance enables us to prune the search space in advance. This
is shown in the following proposition.
Proposition 1. LCP Pruning. For two sub-routes A
and B with a length L, which includes only pick-up points, if
sub-route A is dominated by sub-route B under Deﬁnition 2,
the candidate routes with a length L which contain sub-route
A will be dominated and can be pruned in advance.
Let us study the example in Figure 4. If L = 3 and −→
→C3 →C4) dominates −→
sub(C2 →C′
3 →C4), the candidate PoCab →C2 →C3 →C4 dominates the candidate
PoCab →C2 →C′
3 →C4 by Deﬁnition 1. Thus we can
prune the candidate contains −→
sub in advance before online recommendation. Speciﬁcally, the LCP algorithm will
enumerate all the L-length sub-routes, which include only
pick-up points, and prune the dominated sub-routes by Definition 2 oﬄine. This pruning process could be done oﬄine
before the position of a taxi driver is known. As a result,
LCP pruning will save a lot of computational cost since it
reduces the search space eﬀectively.
The SkyRoute Algorithm
In this subsection, we show how to leverage the idea of skyline computing for identifying representative skyline routes
among all the candidate routes. Here, we ﬁrst formally de-
ﬁne skyline routes.
Definition 3. Skyline Route.
A recommended driving route
RL is a skyline route iﬀ∀
RL by Deﬁnition 1. This is denoted as
The skyline route query retrieves all the skyline routes
with a length of L. Formally, we use −→
RSkyline to represent
the set of all the skyline routes.
Lemma 4. Joint Principle of Skyline Routes and
the PTD Function F. The optimal driving route determined by the PTD function F should be a skyline route. This
is denoted as
Proof. (Proof Sketch.) This lemma can be proved by
contradiction. Assume that
1 is an optimal driving route
and is not a skyline route.
By Deﬁnition 3,
dominated by some driving route denoted as (
i ), which is
a skyline route. By Deﬁnition 1, each attribute of the vector
associating with
1 should be not smaller than the corresponding attribute of the vector associating with
there must be one attribute, for which the value of vector
associating with
1 is bigger than that of vector associating
with associating with
i . Then, by Lemma 3, the function
F value of the vector associating with
should be less
than that of the vector associating with
1 . Therefore,
should not be the optimal drive route.
With the joint principle of skyline routes and the PTD
function F in Lemma 4, it is possible to ﬁrst ﬁnd skyline
routes and then search for the optimal driving route from
the set of skyline routes.
This way can eliminate lots of
candidates without computing the PTD function F. Next,
we show how to compute skyline routes.
Indeed, skyline computing, which retrieves non-dominated
data points, has been extensively studied in the database literature . However, most of these algorithms
cannot be directly used to ﬁnd skyline routes in the MSR
problem, because vectors associated with suggested routes
are generated through an expensive cluster network traversal process. In Particular, the performances of traditional
skyline computing algorithms degrade signiﬁcantly when the
network size increases or the length of suggested driving
route is increased. Also, there are a large memory requirement for storing these vectors during the traditional skyline
computing process. Moreover, for real-world applications,
the position of empty cab is dynamic. Therefore, the recommended driving routes are dynamic in a real-time fashion.
This means that we cannot have the indices for the multidimensional data points(vector DP) in advance, which is desired for many traditional skyline computing algorithms .
To this end, we design a SkyRoute algorithm for computing
skyline routes by exploiting the unique properties of skyline
routes for the purpose of eﬃcient computation.
The basic idea of the SkyRoute algorithm is to prune some
candidate routes, which are comprised of the dominated
sub-routes and cannot be skyline routes, at a very early
stage. This idea is based on the observation that any recommended driving routes are composed of sub-routes and
diﬀerent routes can cover the same sub-routes. The search
space will be signiﬁcantly reduced, since lots of candidate
routes containing the dominated sub-routes will be discarded
from further consideration as skyline routes. In the following, we ﬁrst introduce two propositions for candidate routes
pruning based on dominated sub-routes.
Proposition 2. Backward Pruning. If a sub-route R1
from PoCab to an intermediate pick-up point Ci is dominated by another sub-route R2 from PoCab to Ci under
the sub-route dominance By Deﬁnition 2, all the candidate
∋R1, which have R1 as a precedent sub-route will be
dominated by the candidate routes
∋R2. The only diﬀerent between
∋R2 is from PoCab to Ci. Thus,
those candidate routes
∋R1 can be pruned in advance.
Proposition 3. Forward Pruning. If a sub-route R1
from one pick-up point Ci to another pick-up point Cj is
dominated by another sub-route R2 from Ci to Cj under the
sub-route dominance by Deﬁnition 2, then all the candidate
∋R1, which contain R1 as sub-route will be dominated by the candidate routes
∋R2. The only diﬀerence
∋R2 is from Ci to Cj, Therefore,
those candidate routes
∋R1 can be pruned in advance.
With the proposition of Backward Pruning, it is possible to decide some dominated sub-routes and discard some
candidate routes which contain these dominated sub-routes.
Also, the beneﬁt of the proposition of Forwarding Pruning
is the ability to prune some dominated sub-routes as well as
some candidate routes oﬄine, since both probabilities and
distances between pick-up points can be obtained before any
online recommendation of driving routes.
Note that only
sub-routes with a length less than L need to be considered
in the above discussion.
Figure 5 shows the pseudo-code of the SkyRoute algorithm. As can be seen, during oﬄine processing, SkyRoute
checks the dominance of sub-routes with a length L by Definition 2 and prunes the ones dominated by others. This
process is also applied in the LCP algorithm. In addition,
SkyRoute can also prune sub-routes with diﬀerent lengths
with Forward Pruning in proposition 3. During online processing, results of oﬄine processing are used as candidate
routes. From line 2 to line 5, SkyRoute iteratively checks
the sub-routes with PoCab as the source node and prunes
the candidate routes containing dominated sub-routes with
Backward Pruning in proposition 2.
Then, in line 6, the
candidate set is obtained after all the pruning process. Finally, a skyline query is conducted on this candidate set
to ﬁnd skyline routes. Please note that the online search
time of the optimal driving route should include the time of
online process of SkyRoute and the search time on the set
of skyline routes.
Obtaining the Optimal Driving Route
For both LCP and SkyRoute algorithms, after all the
pruning process, we will have a set of ﬁnal candidate routes
for a given taxi driver. To obtain the optimal driving route,
we can simply compute the PTD function F for all the remaining candidate routes with a length L. Then, the route
with the minimal PTD value is the optimal driving route for
this given taxi driver.
The Recommendation Process
Even though we can ﬁnd the optimal drive route for a
given cab with its current position, it is still a challenging problem about how to make the recommendation for
many cabs in the same area. In this section, we address this
ALGORITHM SkyRoute(C,P,Dist,L,PoCab)
C: set of cluster nodes with central positions
P: probability set for all cluster nodes
Dist: pairwise drive distance matrix of cluster nodes
L: the length of suggested drive route
PoCab: the position of one empty cab
R Skyline: list of skyline drive routes.
Online Processing
Enumerate all candidate routes by connecting
PoCab with each sub-route of RL
obtained in step 10 during Oﬄine Processing
for i = 2 : L −1
Decide dominated sub-routes with ith
intermediate cluster and prune the corresponding
candidates by using proposition 2
Update the candidate set by ﬁltering
the pruned candidates in step 3
Select the remained candidate routes with length
of L from the loop above
Final typical skyline query to get −
R Skyline from
those candidate routes in step 6
Oﬄine Processing(LCP)
Enumerate all sub-routes with length
of L from C
Prune and maintain dominated Constrained
Sub-routes with length of L using proposition 3
Maintain the remained non-dominated sub-routes
with length of L, denoted as RL
Figure 5: The SkyRoute Algorithm
problem and introduce a strategy for the recommendation
process in the real world.
A simple way is to suggest all these empty cabs to follow
the same optimal drive route, however there is naturally an
overload problem, which will degrade the performance of the
recommender system. To this end, we employ load balancing
techniques to distribute the empty cabs to follow multiple optimal drive routes. The problem of load balancing
has been widely used in distributed systems for the purpose
of optimizing a given objective through ﬁnding allocations
of multiple jobs to diﬀerent computers. For example, the
load balancing mechanism distributes requests among web
servers in order to minimize the execution time. For the proposed mobile recommendation system, we can treat multiple empty cabs as jobs and multiple optimal drive routes as
computers. Then, we can deal with this overload problem by
exploiting existing load balancing algorithms. Speciﬁcally,
in this study, we apply the circulating mechanism for the recommender systems by exploiting a Round Robin algorithm
 , which is a static load balancing method.
Under the circulating mechanism, to make recommendation for multiple empty cabs, a round robin scheduler alternates the recommendation among multiple optimal drive
routes in a circular manner. As shown in Figure 6, we could
search k optimal drive routes and recommend the NO.1
route to the ﬁrst coming empty cab.
Then, for the second empty cab, the NO. 2 drive route will be recommended.
Assume there are more than k empty cabs, recommendations are repeated from NO. 1 route again after the kth
empty cab. In practice, to achieve this, one central dispatch
(processor) is needed to maintain the empty cabs and assignments among the top-k driving routes. Note that the
load balancing techniques are not the focus of this paper.
Multiple Empty Cabs
K drive routes
Figure 6: Illustration of the Circulating Mechanism.
EXPERIMENTAL RESULTS
In this section, we evaluate the performances of the proposed two algorithms: LCP and SkyRoute.
The Experimental Setup
Real-world Data.
In the experiments, we have used
real-world cab mobility traces, which are provided by the
Exploratorium - the museum of science, art and human perception through the cabspotting project . This data set
contains GPS location traces of approximately 500 taxis
collected around 30 days in the San Francisco Bay Area.
For each recorded point, there are four attributes: latitude,
longitude, fare identiﬁer and time stamp.
In the experiments, we select the successful cab drivers and generate the
cluster information as follows.
Speciﬁcally, we select cab
drivers with total driving hours over 230 and occupancy
rates greater than 0.5. In total, we obtain 20 cab drivers and
their location traces. Based on this selected data, we generate potential pick-up points and the pick-up probability associated with each pick-up point for diﬀerent time periods.
In the experiments, we focus on two time periods: 2PM-
3PM and 6PM-7PM. For these two time periods, we obtain 636 and 400 historical pick-up points respectively. After
calculating the pairwise driving distance of pick-up points
with the Google Map API, we use Cluto for clustering.
All default parameters are used in the clustering process
except for ”-clmethod=direct”. Please note that, since the
driving distance measured by the Google Map API depends
on the driving direction, we use the average to estimate the
distance between each pair of pick-up points. Finally, we
group the historical pick-up points into 10 clusters.
traveling distances between clusters are measured between
centroids of clusters with the Google Map API.
Synthetic data. To enhance validation, we also generate synthetic data for the experiments. Speciﬁcally, we randomly generate potential pick-up points within a speciﬁed
area and generate the pick-up probability associated with
each pick-up point by a standard uniform distribution. In
total, we have 3 synthetic data sets with 10, 15 and 20 pickup points respectively. For this synthetic data, we use the
Euclidean distance instead of the driving distance to measure the traveling distance between pick-up points. Also, for
both real-world and synthetic data, we randomly generate
the positions of the target cab for recommendation.
Experimental Environment. The algorithms were implemented in Matlab2008a. All the experiments were conducted on a Windows 7 with Intel Core2 Quad Q8300 and
6.00GB RAM. The search time for the optimal driving route
and the skyline computing time are two main performance
metrics. All the reported results are the average of 10 runs.
An Illustration of Optimal Driving Routes
Here, we show some optimal driving routes determined by
the PTD function F on real-world data.
In Figure 7, we plot the potential pick-up points within
the time period 6PM-7PM and the assumed position of the
target cab for recommendation.
During this time period,
the optimal drive routes evaluated by the PTD function are
PoCab →C1 →C3 →C2, PoCab →C1 →C3 →C2 →
C7 and PoCab →C4 →C1 →C3 →C2 →C7 for L = 3,
L = 4 and L = 5 respectively.
Figure 7: Illustration: Optimal Driving Routes.
Table 1: Some Acronyms.
Brute-Force Search .
Search with LCP
Search via Skyline Computing
algorithm SkyRoute + BNL.
Searching via Skyline Computing
Algorithm SkyRoute + D&C.
An Overall Comparison
In this subsection, we show an overall comparison of computational performances of several algorithms.
First, in SkyRoute, after the pruning process proposed
in this paper, we apply some traditional skyline computing
methods to ﬁnd the skylines from the remained candidate
set. Here, we employ two skyline computing methods, BNL
and D&C . In this experiment, all acronyms of evaluated
algorithms are given in Table 1. Note that, for BFS, we only
compute the PTD value for all candidate routes one by one
and ﬁnd the maximum value as well as the optimal driving route. Also, most information, such as the locations of
potential pick-up points and the pick-up probability, can be
known in advance. The online computations are the distance
from the target cab to pick-up points and PTD function.
Figure 8 shows the online search time of optimal driving
routes evaluated by the PTD function for diﬀerent values of
L on both synthetic data and real-world data. The search
time shown here includes all the time for online processing.
As can be seen, LCPS outperforms BFS and SR(D&C)S
with a signiﬁcant margin for all diﬀerent lengths of the optimal drive route on both synthetic and real data. The reason
why searching via skyline computing takes longer time than
LCPS or BFS is that skyline computing is partially online
processing and takes a lot of time. Although we only show
the results of the time period 6PM −7PM, a similar trend
has also been observed in other time periods.
Length of Driving Route(L)
Search Time (Sec)
Length of Driving Route(L)
Search Time (Sec)
(b) Comparisons on Synthetic Data (10 Clusters)
(a) Comparisons on Real Data (6−7PM)
Figure 8: A Comparison of Search Time.
Length of Driving Route (L)
Pruning Percentage
Number of Pick−up Points
Pruning Percentage
(a) The Pruning Effect on Real Data (6−7PM)
(b) The Pruning Effect on Synthetic Data (L=3)
Figure 9: The Pruning Eﬀect
In terms of the pruning eﬀect, both LCP and SkyRoute
can prune the search space signiﬁcantly as shown in Figure
9, where we show the pruning ratios of LCP and Skyroute.
Note that the pruning ratio is the number of pruned candidates divided by the original number of all the candidates.
In addition, for LCPS, the pruning process can be done
in advance. This saves a lot of time for online search. In
particular, Table 2 shows a comparison of online search time
between BFS and LCPS across diﬀerent numbers of pickup points and diﬀerent lengths of driving routes on both
synthetic and real-world data. As can be seen, LCPS always
outperforms BFS with a signiﬁcant margin.
A Comparison of Search Time (Second)
between BFS and LCPS
10 Synthetic Pick-up Clusters
15 Synthetic Pick-up Clusters
Real Data (2-3PM)
Finally, Figure 10 shows the online search time of optimal
driving routes (L = 3) across diﬀerent numbers of pick-up
points on synthetic data. In the ﬁgure, a similar trend of
performances can be observed as in Figure 8.
A Comparison of Skyline Computing
In this subsection, we evaluate the performances of diﬀerent skyline computing algorithms.
Number of Pick−up Points
Search Time (Sec)
Figure 10: A Comparison of Search Time (L = 3) on
the Synthetic Data set.
Number of Pick−up Points
Skyline Computing Time (Sec)
Length of Driving Route (L)
Skyline Computing Time (Sec)
SkyRoute(BNL)
SkyRoute(D&C)
(a) Comparisons on Synthetic Data (L=3)
(b) Comparisons on Real Data (6−7PM)
SkyRoute(BNL)
SkyRoute(D&C)
Figure 11: A Comparison of Skyline Computing
This experiment was conducted across diﬀerent numbers
of pick-up points and diﬀerent lengths of recommended driving routes on both synthetic and real-world data. As shown
in Figure 11, SkyRoute with BNL or D&C can lead to
better eﬃciency compared to traditional skyline computing
methods. The above indicates that SkyRoute is an eﬀective
method for computing Skyline routes.
Furthermore, we have observed that the computation cost
of BNL or D&C varies on diﬀerent data sets with the same
size of candidate routes. The reason is that BNL or D&C
has diﬀerent computation complexity for the best and worse
Therefore, even with the same number of pick-up
points and the same length of driving routes, the running
time of SkyRoute(BNL), (SkyRoute(D&C) or SR(D&C)S)
is diﬀerent as shown in Figure 11 and Figure 8
Case: Multiple Evaluation Functions
Here, we show the advantages of searching optimal driving
routes through skyline computing. Speciﬁcally, we evaluate
the following business scenario.
When there are business
needs for diﬀerent ways to deﬁne optimal driving routes,
which can be measured by diﬀerent evaluation functions.
As can be seen in Figure 8 and Figure 10, the search of an
optimal driving route via skyline computing does not outperform LCPS or BFS, because it takes the most part of total online processing time for computing skylines. However,
for a target cab and ﬁxed potential pick-up points, we only
need to compute skylines once. And the search space can be
pruned drastically as shown in Figure 9. In other words, if
the goal is to provide multiple optimal driving routes based
on diﬀerent business needs at the same time. Skyline computing will have an advantage.
Search Time with Multiple Evaluation Functions (Sec)
Comparisons on Synthetic Data (L=3, 10 Clusters)
Comparisons on Real Data (L=3, 6−7PM)
Figure 12: A Comparison of Search Time for Multiple Optimal Driving Routes
To illustrate this beneﬁt of skyline computing, we design
5 diﬀerent evaluation functions (including PTD) to select 5
corresponding optimal drive routes. Note that all these evaluation functions have the monotonicity Property as stated in
lemma 3. Due to the space limitation, we omit the details
of these evaluation functions. Then, we search ﬁve diﬀerent optimal driving routes simultaneously with the methods
shown in Table 1 on both synthetic data and real-world data.
Figure 12 shows the comparisons of computational performances with L = 3. As can be seen, SR(D&C)S outperforms
LCPS and BFS with a signiﬁcant margin.
CONCLUDING REMARKS
In this paper, we developed an energy-eﬃcient mobile recommender system by exploiting the energy-eﬃcient driving
patterns extracted from the location traces of Taxi drivers.
This system has the ability to recommend a sequence of potential pick-up points for a driver in a way such that the
potential travel distance before having customer is minimized. To develop the system, we ﬁrst formalized a mobile
sequential recommendation problem and provided a Potential Travel Distance (PTD) function for evaluating each candidate sequence. Based on the monotone property of the
PTD function, we proposed a recommendation algorithm,
named LCP. Moreover, we observed that many candidate
routes can be dominated by skyline routes, and thus can be
pruned by skyline computing. Therefore, we also proposed
a SkyRoute algorithm to eﬃciently compute the skylines
for candidate routes. An advantage of searching an optimal
route through skyline computing is that it can save the overall online processing time when we try to provide diﬀerent
optimal driving routes deﬁned by diﬀerent business needs.
Finally, experimental results showed that the LCP algorithm outperforms the brute-force method and SkyRoute
with a signiﬁcant margin when searching only one optimal
driving route. Moreover, the results showed that SkyRoute
leads to better performances than brute-force and LCP when
there is an online demand for diﬀerent optimal drive routes
deﬁned by diﬀerent evaluation criteria.
ACKNOWLEDGEMENTS
This research was partially supported by the National Science
Foundation (NSF) via grant number CNS 0831186, the Rutgers
CCC Green Computing Initiative, and the National Natural Science Foundation of China (70890080).