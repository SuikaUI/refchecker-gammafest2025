MIT Open Access Articles
Scaling up crowd-sourcing to very large
datasets: a case for active learning
The MIT Faculty has made this article openly available. Please share
how this access benefits you. Your story matters.
Citation: Barzan Mozafari, Purna Sarkar, Michael Franklin, Michael Jordan, and Samuel
Madden. 2014. Scaling up crowd-sourcing to very large datasets: a case for active learning. Proc.
VLDB Endow. 8, 2 , 125-136.
As Published: 
Publisher: Association for Computing Machinery (ACM)
Persistent URL: 
Version: Author's final manuscript: final author's manuscript post peer review, without
publisher's formatting or copy editing
Terms of use: Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License
Scaling Up Crowd-Sourcing to Very Large Datasets:
A Case for Active Learning
Barzan Mozafari⋆
Purna Sarkar†
Michael Franklin†
Michael Jordan†
Samuel Madden‡
⋆University of Michigan, Ann Arbor
†UC Berkeley
 
{psarkar, franklin, jordan}@cs.berkeley.edu
 
Crowd-sourcing has become a popular means of acquiring labeled
data for many tasks where humans are more accurate than computers, such as image tagging, entity resolution, and sentiment analysis. However, due to the time and cost of human labor, solutions
that rely solely on crowd-sourcing are ofen limited to small datasets
(i.e., a few thousand items). Tis paper proposes algorithms for integrating machine learning into crowd-sourced databases in order
to combine the accuracy of human labeling with the speed and costeﬀectiveness of machine learning classiﬁers. By using active learning as our optimization strategy for labeling tasks in crowd-sourced
databases, we can minimize the number of questions asked to the
crowd, allowing crowd-sourced applications to scale (i.e., label much
larger datasets at lower costs).
Designing active learning algorithms for a crowd-sourced database
poses many practical challenges: such algorithms need to be generic,
scalable, and easy to use, even for practitioners who are not machine
learning experts. We draw on the theory of nonparametric bootstrap to design, to the best of our knowledge, the ﬁrst active learning
algorithms that meet all these requirements.
Our results, on 3 real-world datasets collected with Amazons Mechanical Turk, and on 15 UCI datasets, show that our methods on
average ask 1–2 orders of magnitude fewer questions than the baseline, and 4.5–44× fewer than existing active learning algorithms.
INTRODUCTION
Crowd-sourcing marketplaces, such as Amazon’s Mechanical Turk,
have made it easy to recruit a crowd of people to perform tasks that
are diﬃcult for computers, such as entity resolution , image annotation , and sentiment analysis . Many of
these tasks can be modeled as database problems, where each item
is represented as a row with some missing attributes (labels) that
the crowd workers supply. Tis has given rise to a new generation
of database systems, called crowd-sourced databases , that
enable users to issue more powerful queries by combining humanintensive tasks with traditional query processing techniques. Figure 1 provides a few examples of such queries, where part of the
query is processed by the machine (e.g., whether the word “iPad”
appears in a tweet) while the human-intensive part is sent to the
Attribution-
NonCommercial-NoDerivs 3.0 Unported License. To view a copy of this license, visit Obtain permission prior to any use beyond those covered by the license.
copyright holder by emailing . Articles from this volume
were invited to present their results at the 41st International Conference on
Very Large Data Bases, August 31st - September 4th 2015, Kohala Coast,
Proceedings of the VLDB Endowment, Vol. 8, No. 2
Copyright 2014 VLDB Endowment 2150-8097/14/10.
Figure 1: Examples of Labeling Queries in a Crowd-sourced DB.
crowd for labeling (e.g., to decide if the tweet has a positive sentiment).
While query optimization techniques can reduce the
number of items that need labeling, any crowd-sourced database
that relies solely on human-provided labels will eventually suﬀer
from scalability issues when faced with web-scale datasets and problems (e.g., daily tweets or images). Tis is because labeling each item
by humans can cost several cents and take several minutes. For instance, given the example of Figure 1, even if we ﬁlter out tweets that
do not contain “iPad”, there could still be millions of tweets with
“iPad” that require sentiment labels (‘positive’ or ‘non-positive’).
To enable crowd-sourced databases to scale up to large datasets,
we advocate combining humans and machine learning algorithms
(e.g., classiﬁers), where (i) the crowd labels items that are either inherently diﬃcult for the algorithm, or if labeled, will form the best
training data for the algorithm, and (ii) the (trained) algorithm is
used to label the remaining items much more quickly and cheaply.
In this paper, we focus on labeling algorithms (classiﬁers) that assign
one of several discrete values to each item, as opposed to predicting
numeric values (i.e., regression), or ﬁnding missing items , leaving these other settings for future work.
Speciﬁcally, given a large, unlabeled dataset (say, millions of images) and a classiﬁer that can attach a label to each unlabeled item
(afer suﬃcient training), our goal is to determine which questions
to ask the crowd in order to (1) achieve the best training data and
overall accuracy, given time or budget constraints, or (2) minimize
the number of questions, given a desired level of accuracy.
Our problem is closely related to the classical problem of active
learning (AL), where the objective is to select statistically optimal
training data . However, in order for an AL algorithm to be a
practical optimization strategy for labeling tasks in a crowd-sourced
database, it must satisfy a number of systems challenges and criteria
that have not been a focal concern in traditional AL literature, as
described next.
Design Criteria
An AL algorithm must meet the following criteria to be used as
the default optimization strategy in a crowd-sourced database:
1. Generality. Our system must come with a few built-in AL
algorithms that are applicable to arbitrary classiﬁcation and labeling
tasks, as crowd-sourced systems are used in a wide range of diﬀerent
domains. In Figure 1, for example, one query involves sentiment
analysis while another seeks images containing a dog. Clearly, these
tasks require drastically diﬀerent classiﬁers. Although our system
will allow expert users to provide their own custom-designed AL for
their classiﬁcation algorithm, most users may only have a classiﬁer.
Tus, to support general queries, our AL algorithm should make
minimal or no assumptions about the classiﬁers that users provide
for their labeling tasks.
2. Black-box treatment of the classiﬁer. Many AL algorithms
that provide theoretical guarantees need to access and modify the internal logic of the given classiﬁer (e.g., adding constraints to the classiﬁer’s internal loss-minimization step ). Such modiﬁcations are
acceptable in theoretical settings but not in real-world applications,
as state-of-the-art classiﬁers used in science and industry are rarely
a straightforward implementation of textbook algorithms. Rather,
these ﬁnely-tuned classiﬁers typically use thousands of lines of code
to implement many intertwined steps (e.g., data cleaning, feature selection, parameter tuning, heuristics, etc.). In some cases, moreover,
these codebases use proprietary libraries that cannot be modiﬁed.
Tus, to make our crowd-sourcing system useful to a wide range of
practitioners and scientists (who are not necessarily machine learning experts), we need an AL algorithm that treats the classiﬁer as a
black-box, i.e., does not modify the internals of the classiﬁer.
3. Batching. Many (theoretical) AL algorithms are designed for
online (a.k.a. streaming) scenarios in which items are revealed one
at a time. Tis means that the AL algorithm decides whether to request a label for the current item, and if so, awaits the label before
proceeding to the next item. While these settings are theoretically
attractive, they are unrealistic in practice. First, we ofen have access
to a large pool of unlabeled data to choose from (not just the next
item), which should allow us to make better choices. Second, online AL settings typically perform an (expensive) analysis for each
item , rendering them computationally prohibitive. Tus,
for eﬃciency and practicality, the AL algorithm must support batching,1 so that (i) the analysis is done only once for each batch of multiple items, and (ii) items are sent to the crowd in batches (to be labeled
in parallel).
4. Parallelism. We aim to achieve human-scalability (i.e., asking the crowd fewer questions) through AL. However, we are also
concerned with machine-scalability, because AL ofen involves repeatedly training a classiﬁer and can thus be computationally expensive. While AL has been historically applied to small datasets,
increasingly massive datasets (such as those motivating this paper)
pose new computational challenges. Tus, a design criterion in our
system is that our AL algorithm must be amenable to parallel execution on modern many-core processors and distributed clusters.
5. Noise management. AL has traditionally dealt with expertprovided labels that are ofen taken as ground truth (notable exceptions are agnostic AL approaches ). In contrast, crowd-provided
labels are subject to a greater degree of noise, e.g., innocent errors,
typos, lack of domain knowledge, and even deliberate spamming.
AL has a rich literature in machine learning . However, the focus has been largely theoretical, with concepts from learning theory
used to establish bounds on sample complexity but leaving a significant gap between theory and practice. Rather than aiming at such
theoretical bounds, this paper focuses on a set of practical design
1Batch support is challenging because AL usually involves caseanalysis for diﬀerent combinations of labels and items. Tese combinations grow exponentially with the number of items in the batch,
unless most of the analysis can be shared among diﬀerent cases.
criteria and provides sound heuristics for the AL problem; the origin of these criteria is in real-world and systems considerations (in
particular, issues of scale and ease-of-use).
In this paper, we design the the ﬁrst AL algorithms that meet all
the aforementioned requirements, which to the best of our knowledge no existing AL algorithm has completely satisﬁed. For example, existing AL algorithms that are general do not support
batching or parallelism and ofen require modiﬁcations to the classiﬁer. (See Section 7 for a detailed literature review.) Tus, our proposal paves the way towards a scalable and generic crowd-sourcing
system that can be used by a wide range of practitioners.
Our Contributions
Our main contributions are two AL algorithms, called MinExpError and Uncertainty, along with a noise-management technique,
called partitioning-based allocation (PBA). Te Uncertainty algorithm
requests labels for the items that the classiﬁer is most uncertain about.
We also design a more sophisticated algorithm, called MinExpError, that combines the current quality (say, accuracy) of the classi-
ﬁer with its uncertainty in a mathematically sound way, in order to
choose the best questions to ask. Uncertainty is faster than Min-
ExpError, but it also has lower overall accuracy, especially in the
upfront scenario, i.e., where we request all labels in a single batch.
We also study the iterative scenario, i.e., where we request labels in
multiple batches and reﬁne our decisions afer receiving each batch.
A major novelty of our AL algorithms is in their use of bootstrap
theory, 2 which yields several key advantages. First, bootstrap can
deliver consistent estimates for a large class of estimators,3 making
our AL algorithms general and applicable to nearly any classiﬁcation task. Second, bootstrap-based estimates can be obtained while
treating the classiﬁer as a complete black-box. Finally, the required
bootstrap computations can be performed independently from each
other, hence allowing for an embarrassingly parallel execution.
Once MinExpError or Uncertainty decides which items to send to
the crowd, dealing with the inherent noise in crowd-provided labels
is the next challenge. A common practice is to use redundancy, i.e.,
to ask each question to multiple workers. However, instead of applying the same degree of redundancy to all items, we have developed a
novel technique based on integer linear programming, called PBA,
which dynamically partitions the unlabeled items based on their degree of diﬃculty for the crowd and determines the required degree
of redundancy for each partition.
Tus, with a careful use of bootstrap theory as well as our batching
and noise-management techniques, our AL algorithms meet all our
requirements for building a practical crowd-sourced system, namely
generality, scalability (batching and parallelism), and ease-of-use (blackbox view and automatic noise-management).
We have evaluated the eﬀectiveness of our algorithms on 18 realworld datasets (3 crowd-sourced using Amazon Mechanical Turk,
and 15 well-known datasets from the UCI KDD repository). Experiments show that our AL algorithms achieve the same quality as
several existing approaches while signiﬁcantly reducing the number
of questions asked of the crowd. Speciﬁcally, on average, we reduce
the number of questions asked by:
●100× (7×) in the upfront (iterative) scenario, compared to passive learning, and
2A short background on bootstrap theory is provided in Section 3.1.
3Formally, this class includes any function that is Hadamard differentiable, including M-estimators (which include most machine
learning algorithms and maximum likelihood estimators ).
●44× (4.5×) in the upfront (iterative) scenario, compared to
IWAL which is the state-of-the-art general-purpose
AL algorithm.
Interestingly, we also ﬁnd that our algorithms (which are generalpurpose) are still competitive with, and sometimes even superior
to, some of the state-of-the-art domain-speciﬁc (i.e., less general)
AL techniques. For example, our algorithms ask:
●7× fewer questions than CrowdER and an order of magnitude fewer than CVHull , which are among the most recent AL algorithms for entity resolution in database literature,
●2–8× fewer questions than Bootstrap-LV and MarginDistance , and
●5–7× fewer questions for SVM classiﬁers than AL techniques
that are speciﬁcally designed for SVM .
OVERVIEW OF APPROACH
Our approach in this paper is as follows. Te user provides (i) a
pool of unlabeled items (possibly with some labeled items as initial
training data), (ii) a classiﬁer (or “learner”) that improves with more
and better training data, and a speciﬁcation as to whether learning
should be upfront or iterative, and (iii) a budget or goal, in terms of
time, quality, or cost (and a pricing scheme for paying the crowd).
Our system can operate in two diﬀerent scenarios, upfront or iterative, to train the classiﬁer and label the items (Section 2.2). Our proposed AL algorithms, Uncertainty and MinExpError, can be used
in either scenario (Section 3). Acquiring labels from a crowd raises
interesting issues, such as how best to employ redundancy to minimize error, and how many questions to ask the crowd (Sections 4
and 5). Finally, we empirically evaluate our algorithms (Section 6).
Active Learning Notation
An active learning algorithm is typically composed of (i) a ranker
R, (ii) a selection strategy S, and (iii) a budget allocation strategy
Γ. Te ranker R takes as input a classiﬁcation algorithm4 θ, a set
of labeled items L, and a set of unlabeled items U, and returns as
output an “eﬀectiveness” score wi for each unlabeled item ui ∈U.
Our proposed algorithms in Section 3 are essentially ranking algorithms that produce these scores. A selection strategy then uses the
scores returned from the ranker to choose a subset U′ ⊆U which
will be sent for human labeling. For instance, one selection strategy
is picking the top k items with the largest (or smallest) scores, where
k is determined by the budget or quality requirements. In this paper, we use weighted sampling to choose k unlabeled items, where
the probability of choosing each item is proportional to its score. Finally, once U′ is chosen, a budget allocation strategy Γ decides how
to best acquire labels for all the items in U′: Γ(U′, B) for ﬁnding
the most accurate labels given a ﬁxed budget B, or Γ(U′, Q) for the
cheapest labels given a minimum quality requirement Q. For instance, to reduce the crowd noise, a common strategy is to ask each
question to multiple labelers and take the majority vote. In Section
4, we introduce our Partitioning Based Allocation (PBA) algorithm,
which will be our choice of Γ in this paper.
Active Learning Scenarios
Tis section describes how learning works in the upfront and the
iterative scenarios. Suppose we are given a budget B for asking questions (e.g., in terms of money or time) or a quality requirement Q
4For ease of presentation, in this paper we assume binary classiﬁcation (i.e., {0, 1}), but our work applies to arbitrary classiﬁers.
Upfront Active Learning (B or Q, L0, U, θ, R, S, Γ)
Input: B is the total budget (money, time, or number of questions),
Q is the quality requirement (e.g., minimum accuracy, F1-measure),
L0 is the initial labeled data,
U is the unlabeled data,
θ is a classiﬁcation algorithm to (imperfectly) label the data,
R is a ranker that gives “eﬀectiveness” scores to unlabeled items,
S is a selection strategy (specifying which items should be labeled
by the crowd, given their eﬀectiveness scores).
Γ is a budget allocation strategy for acquiring labels from the crowd
Output: L is the labeled version of U
1: W ←R(θ, L0, U)
//wi ∈W is the eﬀectiveness score for ui ∈U
2: Choose U′ ⊆U based on S(U, W) such that U′ can be labeled with
budget B or θL0(U −U′) satisﬁes Q
4: ML←θL0(U −U′)
//train θ on L0 to automatically label U −U′
5: Immediately display ML to the user
//Early query results
6: CL ←Γ(U′, B or Q)
//Ask (and wait for) the crowd to label U′
7: L ←CL ∪ML
//combine crowd and machine provided labels
Figure 2: Te upfront scenario in active learning.
Iterative Active Learning (B or Q, L0, U, θ, R, S, Γ)
Input: Same as those in Figure 2)
Output: L is the labeled version of U
// labeled data acquired from the crowd
2: L ←θL0(U)
//train θ on L0 & invoke it to label U
3: While our budget B is not exhausted or L’s quality does not meet Q:
W ←R(θ, L0 ∪CL, U)
//wi ∈W is the eﬀective score for ui ∈U
Choose U′ ⊆U based on S(U, W) (subject to B or Q)
L′ ←Γ(U′, B or Q)
//Ask (and wait for) the crowd to label U′
CL ←CL ∪L′, U ←U −U′ //remove crowd labels from U
L ←CL ∪θL0∪CL(U) //train θ on L0 ∪CL to label remaining U
Figure 3: Te iterative scenario in active learning.
(e.g., accuracy or F1-measure5) that our classiﬁer must achieve. Te
choice of the scenario depends on user’s preference and needs.
Figure 2 is the pseudocode of the upfront scenario. In this scenario, the ranker computes eﬀectiveness scores solely based on the
initial labeled data6, L0. Ten, a subset U′ ⊆U is chosen and sent
to the crowd (based on S and, B or Q). While waiting for the crowd
to label U′ (based on Γ and, B or Q), we train our classiﬁer θ on
L0 to label the remaining items, namely U −U′, and immediately
send their labels back to the user. Once crowd-provided labels arrive, they are also sent to the user. Tus, the ﬁnal result consists of
the union of these two labeled sets.
Figure 3 shows the pseudocode of the iterative scenario. In this
scenario, we ask for labels in several iterations. We ask the crowd
to label a few items, adding those labels to the existing training set,
and retrain. Ten, we choose a new set of unlabeled items and iterate
until we have exhausted our budget B or met our quality goal Q. At
each iteration, our allocation strategy (Γ) seeks the cheapest or most
accurate labels for the chosen items (U′), then our ranker uses the
original training data L0 as well as the crowd labels CL collected
thus far to decide how to score the remaining unlabeled items.
Note that the upfront scenario is not an iterative scenario with a
single iteration, because the former does not use the crowd-sourced
labels in training the classiﬁer. Tis diﬀerence is important as different applications may call for diﬀerent scenarios. When early answers are strictly preferred, say in an interactive search interface, the
upfront scenario can immediately feed users with model-provided
labels until the crowd’s answers arrive for the remaining items. Te
5F1-measure is the harmonic mean of precision and recall and is
frequently used to assess the quality of a classiﬁer.
6In the absence of initially labeled data, we can ﬁrst spend part of
the budget to label a small, random sample of the data.
upfront scenario is also preferred when the project has a stringent
accuracy requirement that only gold data (here, L0) be used for training the classiﬁer, say to avoid the potential noise of crowd labels in
the training phase. In contrast, the iterative scenario is computationally slower, as it has to repeatedly retrain a classiﬁer and wait for
crowd-sourced labels. However, it can adaptively adjust its scores
in each iteration, thus achieving a smaller error for the same budget than the upfront one. Tis is because the upfront scenario must
choose all the items it wants labeled at once, based only on a limited
set of initial labels.
RANKING ALGORITHMS
Tis paper proposes two novel AL algorithms, Uncertainty and
MinExpError. AL algorithms consist of (i) a ranker R that assigns
scores to unlabeled items, (ii) a selection strategy S that uses these
scores to choose which items to label, and (iii) a budget allocation
strategy Γ to decide how to acquire crowd labels for those chosen
items. As explained in Section 2.1, our AL algorithms use weighted
sampling and PBA (introduced in Section 4) as their selection and
budget allocation strategies, respectively. Tus, for simplicity, we use
Uncertainty and MinExpError to refer to our AL algorithms as well
as their corresponding rankers. Both rankers can be used in either
upfront or iterative scenarios. Section 3.1 provides brief background
on nonparametric bootstrap theory, which we use in our rankers.
Our rankers are introduced in Sections 3.2 and 3.3.
Background: Nonparametric Bootstrap
Our ranking algorithms rely on nonparametric bootstrap (or simply the bootstrap) to assess the beneﬁt of acquiring labels for different unlabeled items. Bootstrap is a powerful statistical technique traditionally designed for estimating the uncertainty of estimators. Consider an estimator θ (say, a classiﬁer) that can be learned
from data L (say, some training data) to estimate some value of interest for a data point u (say, the class label of u). Tis estimated
value, denoted as θL(u), is a point-estimate (i.e., a single value), and
hence, reveals little information about how this value would change
if we used a diﬀerent data L′. Tis information is critical as most
real-world datasets are noisy, subject-to-change, or incomplete. For
example, in our active learning context, missing data means that we
can only access part of our training data. Tus, L should be treated a
random variable drawn from some (unknown) underlying distribution D. Consequently, statisticians are ofen interested in measuring
distributional information about θL(u), such as variance, bias, etc.
Ideally, one could measure such statistics by (i) drawing many new
datasets, say L1, ⋯, Lk for some large k, from the same distribution
D that generated the original L,7 (ii) computing θL1(u), ⋯, θLk(u),
and ﬁnally (iii) inducing a distribution for θ(u) based on the observed values of θLi (u). We call this true distribution Dθ(u) or
simply D(u) when θ is understood. Figure 4(a) illustrates this computation. For example, when θ is a binary classiﬁer, D(u) is simply a
histogram with two bins (0 and 1), where the value of the i’th bin for
i ∈{0, 1} is Pr[θL(u) = i] when L is drawn from D. Given D(u),
any distributional information (e.g., variance) can be obtained.
Unfortunately, in practice the underlying distribution D is ofen
unknown, and hence, direct computation of D(u) using the procedure of Figure 4(a) is impossible. Tis is where bootstrap 
becomes useful. Te main idea of bootstrap is simple: treat L as
a proxy for its underlying distribution D. In other words, instead
of drawing Li’s directly from D, generate new datasets S1, ⋯, Sk by
resampling from L itself. Each Si is called a (bootstrap) replicate or
7A common assumption in nonparametric bootstrap is that L and
Li datasets are independently and identically drawn (I.I.D.) from D.
simply a bootstrap. Each Si is generated by drawing n = ∣L∣I.I.D.
samples with replacement from L, and hence, some elements of L
might be repeated or missing in Si. Note that all bootstraps have
the same cardinality as L, i.e. ∣Si∣= ∣L∣for all i. By computing θ on
these bootstraps, namely θS1(u), ⋯, θSk(u), we can create an empirical distribution ˆD(u). Tis is the bootstrap computation, which
is visualized in Figure 4(b).
Te theory of bootstrap guarantees that for a large class of estimators θ and suﬃciently large k, we can use ˆD(u) as a consistent
approximation of D(u). Te intuition is that, by resampling from
L, we emulate the original distribution D that generated L. Here,
it is suﬃcient (but not necessary) that θ be relatively smooth (i.e.,
Hadamard diﬀerentiable ) which holds for a large class of machine learning algorithms such as M-estimators, themselves
including maximum likelihood estimators and most classiﬁcation
techniques. In our experiments (Section 6), k=100 or even 10 have
yielded reasonable accuracy (k can also be tuned automatically; see ).
Both of our AL algorithms use bootstrap to estimate the classi-
ﬁer’s uncertainty in its predictions (say, to stop asking the crowd
once we are conﬁdent enough). Employing bootstrap has several
key advantages. First, as noted, bootstrap delivers consistent estimates for a large class of estimators, making our AL algorithms
general and applicable to nearly any classiﬁcation algorithm.8 Second, the bootstrap computation uses a “plug-in” principle; that is,
we simply need to invoke our estimator θ with Si instead of L. Tus,
we can treat θ (here, our classiﬁer) as a complete black-box since
its internal implementation does not need to be modiﬁed. Finally,
individual bootstrap computations θS1(u), ⋯, θSk(u) are independent from each other, and hence can be executed in parallel. Tis
embarrassingly parallel execution model enables scalability by taking full advantage of modern many-core and distributed systems.
Tus, by exploiting powerful theoretical results from classical nonparametric statistics, we can estimate the uncertainty of complex estimators and also scale up the computation to large volumes of data.
Aside from Provost et al. (which is limited to probabilistic classiﬁers and is less eﬀective than our algorithms; see Sections 6 and 7),
no one has exploited the power of bootstrap in AL, perhaps due to
bootstrap’s computational overhead. However, with recent advances
in speeding up bootstrap computation and increases in
RAM sizes and the number of CPU cores, bootstrap is now a computationally viable approach, motivating our use of it in this paper.
Uncertainty Algorithm
Our Uncertainty algorithm aims to ask the crowd the questions
that are hardest for the classiﬁer. Speciﬁcally, we (i) ﬁnd out how
uncertain (or certain) our given classiﬁer θ is in its label predictions
for diﬀerent unlabeled items, and (ii) ask the crowd to label items
for which the classiﬁer is least certain. Te intuition is that, the more
uncertain the classiﬁer, the more likely it will mislabel the item.
While focusing on uncertain items is one of the oldest ideas in
AL literature , previous proposals either (i) require a probabilistic classiﬁer that produces highly accurate class probabilities along
with its label predictions , or (ii) are limited to a particular
classiﬁer. For example, for probabilistic classiﬁers, the class distribution’s entropy is a common measure of uncertainty . While
entropy-based AL can be eﬀective in many situations , in
many other situations, when the classiﬁers do not produce accurate
probabilities, entropy does not guarantee an unbiased estimate of
the uncertainty (see Section 6.3). Other heuristics, such as the distance from the separator, are also used as a measure of uncertainty
8Te only known exceptions are lasso classiﬁers (i.e., L1 regularization). Interestingly, even for lasso classiﬁers, there is a modiﬁed version of bootstrap that can produce consistent estimates .
(a) Ideal computation of D(u)
(b) Bootstrap computation
Figure 4: Bootstrap approximation ˆD(u) of true distribution D(u).
Misclassiﬁed
Figure 5: (a) Fully labeled dataset, (b) initial labels, (c) asking hardest
questions, and (d) asking questions with high impact.
(e.g., SVM classiﬁers ). However, these heuristics cannot be
applied to arbitrary classiﬁers. In contrast, our Uncertainty algorithm applies to both probabilistic and non-probabilistic classiﬁers,
and is also guaranteed by bootstrap theory to produce unbiased estimates. (In Section 6, we also empirically show that our algorithm is
more eﬀective.) Next, we describe how Uncertainty uses bootstrap
to estimate the classiﬁer’s uncertainty.
Let l be the predicted label for item u when we train θ on our labeled data L, i.e., θL(u) = l. As explained in Section 3.1, L is ofen
a random variable, and hence, θL(u) has a distribution (and variance). We use the variance of θ in its prediction, namely Var[θL(u)],
as our formal notion of uncertainty. Our intuition behind this choice
is as follows. A well-established result from Kohavi and Wolpert 
has shown that the classiﬁcation error for item u, say eu, can be decomposed into a sum of three terms:
eu = Var[θL(u)] + bias2[θL(u)] + σ 2(u)
where bias[.] is the bias of the classiﬁer and σ 2(u) is a noise term.9
Our ultimate goal in AL is to reduce the sum of eu for all u. Te
σ 2(u) is an error inherent to the data collection process, and thus
cannot be eliminated through AL. Tus, requesting labels for u’s
that have a large variance, indirectly reduces eu for u’s that have a
large classiﬁcation error. Hence, our Uncertainty algorithm assigns
Var[θL(u)] as the score for each unlabeled item u, to ensure that
items with larger variance are sent to the crowd for labels. Tus, in
Uncertainty algorithm, our goal is to measure Var[θL(u)].
Since the underlying distribution of the training data (D in Figure 4) is unknown to us, we use bootstrap. In other words, we bootstrap our current set of labeled data L, say k times, to obtain k diﬀerent classiﬁers that are then invoked to generate labels for each item
u, as shown in Figure 4(b). Te output of these classiﬁers form an
empirical distribution ˆD(u) that approximates the true distribution
of θL(u). We can then estimate Var[θL(u)] using ˆD(u) which is
guaranteed, by bootstrap theory , to quickly converge to the true
value of Var[θL(u)] as we increase k.
Let Si denote the i’th bootstrap, and θSi (u) = l i
u be the prediction
of our classiﬁer for u when trained on this bootstrap. Deﬁne X(u) ∶=
u/k, i.e., the fraction of classiﬁers in Figure 4(b) that predict a
label of 1 for u. Since l i
u ∈{0, 1}, the uncertainty score for instance
u is given by its variance, which can be computed as:
Uncertainty(u) = Var[θL(u)] = X(u)(1 −X(u))
We evaluate our Uncertainty algorithm in Section 6.
MinExpError Algorithm
Consider the toy dataset of Figure 5(a). Initially, only a few labels
(+ or −) are revealed to us, as shown in Figure 5(b). With these
initial labels we train a classiﬁer, say a linear separator (shown as a
solid line).
Te intuition behind Uncertainty is that, by requesting labels for
the most uncertain items (here being those closer to the separator),
9Squared bias bias2[θL(u)] is deﬁned as [f (u) −E[θL(u)]]2,
where f (u)=E[lu∣u], i.e., expected value of true label given u .
the crowd essentially handles items that are hardest (or ambiguous)
for the classiﬁer. However, this might not always be the best strategy. By acquiring a label for the item closest to the separator and
training a new classiﬁer, as shown in Figure 5(c), our overall accuracy does not change much: despite acquiring a new label, the new
classiﬁer still misclassiﬁes three of the items at the lower-lef corner of Figure 5(c). Tis observation shows that labeling items with
most uncertainty (i.e., asking the hardest questions) may not have
the largest impact on the classiﬁer’s prediction power for other data
points. In other words, an alternative strategy would be to acquire
human labels for items that, if their labels diﬀer from what the current classiﬁer thinks, would have a huge impact on the classiﬁer’s future decisions. In Figure 5(d), the lower-lef points exemplify such
items, which we refer to as having the potential for largest impact on
the classiﬁer’s accuracy.
Note that we cannot completely ignore uncertainty and choose
items based only on their potential impact on the classiﬁer. When
the classiﬁer is highly conﬁdent of its predicted label, no matter how
much impact an opposite label could have on the classiﬁer, acquiring a label for that item wastes resources because the crowd label
will most likely agree with that of the classiﬁer anyway. Tus, our
MinExpError algorithm combines these two strategies in a mathematically sound way, described next.
Let l = θL(u) be the current classiﬁer’s predicted label for u. If
we magically knew that l was the correct label, we could simply add
⟨u, l⟩to L and retrain the classiﬁer. Let eright be this new classiﬁer’s
error. On the other hand, if we somehow knew that l was the incorrect label, we would instead add ⟨u, 1 −l⟩to L and retrain the
classiﬁer accordingly. Let ewrong denote the error of this new classi-
ﬁer. Te problem is that (i) we do not know what the true label is,
and (ii) we do not know the classiﬁer’s error in either case.
Solving (ii) is relatively easy: in each case we assume those labels
and use cross validation on L to estimate both errors, say ˆeright and
ˆewrong. To solve problem (i), we can again use bootstrap to estimate
the probability of our prediction l being correct (or incorrect), say
p(u) ∶= Pr[l = lu∣u], where lu is u’s true label. Since we do not know
lu (or its distribution), we bootstrap L to train k diﬀerent classiﬁers
(following Figure 4’s notation). Let l1, ⋯, lk be the labels predicted
by these classiﬁers for u. Ten, p(u) can be approximated as
ˆp(u) = ∑k
i=1 1(li = l)
Here, 1(c) is the decision function which is 1 when condition c holds
and is zero otherwise. Intuitively, equation (2) says that the probability of the classiﬁer’s prediction being correct can be estimated by
the fraction of classiﬁers that agree on that prediction, if those classiﬁers are each trained on a bootstrap of the training set L.
Our MinExpError algorithm aims to compute the classiﬁer’s expected error if we use the classiﬁer itself to label each item, and ask
the crowd to label those items for which this expected error is larger.
Tis way, the overall expected error will be minimized. To compute the classiﬁer’s expected error, we can average over diﬀerent la-
bel choices:
MinExpError(u)
ˆp(u)ˆeright + (1 −ˆp(u))ˆewrong
We can break down equation (3) as:
MinExpError(u)
ˆewrong −ˆp(u)(ˆewrong −ˆeright)
Assume that ˆewrong −ˆeright ≥0 (an analogous decomposition is
possible when it is negative). Eq. (4) tells us that if the question is too
hard (small ˆp(u)), we may still ask for a crowd label to avoid a high
risk of misclassiﬁcation on u. On the other hand, we may want to
ask a question for which our model is fairly conﬁdent (large ˆp(u)),
but having its true label can still make a big diﬀerence in classifying
other items (ˆewrong is too large). Tis means that, however unlikely,
if our classiﬁer happens to be wrong, we will have a higher overall
error if we do not ask for the true label of u. Tus, our MinExpError
scores naturally combine both the diﬃculty of the question and how
much knowing its answer can improve our classiﬁer.
Complexity and Scalability
Besides its generality, a major beneﬁt of bootstrap is that each
replicate can be shipped to a diﬀerent node, enabling parallel training. Te time complexity of each iteration of Uncertainty is O(k ⋅
T(∣U∣)), where ∣U∣is the number of unlabeled items in that iteration, T(.) is the classiﬁer’s training time (e.g., this is O(∣U∣3) for
SVM), and k is the number of bootstraps. Tus, we only need k
nodes to achieve the same run-time as training a single classiﬁer.
MinExpError is more expensive than Uncertainty as it requires
a case analysis for each unlabeled item. For each iteration, its time
complexity is O((k+∣U∣)⋅T(∣U∣)). Since unlabeled items can be independently analyzed, the algorithm is still parallelizable. However,
MinExpError requires more nodes (i.e., O(∣U∣) nodes) to achieve
the same performance as Uncertainty. Tis additional overhead is
justiﬁed in the upfront scenario, given MinExpError’s superior performance on a limited set of initially labeled data (see Section 6).
HANDLING CROWD UNCERTAINTY
Crowd-provided labels are subject to a great degree of uncertainty:
humans may make innocent (or deliberate errors), or give incorrect
answers to ambiguous questions. Tis section proposes an algorithm called Partitioning Based Allocation (PBA) that reduces this
uncertainty by strategically allocating diﬀerent degrees of redundancy to diﬀerent subgroups of the unlabeled items. PBA is our
proposed instantiation of Γ in the upfront and iterative scenarios
(Figures 2 and 3) which given a ﬁxed budget B maximizes the labels’
accuracy, or given a required accuracy, minimizes cost.
Optimizing Redundancy for Subgroups. Most previous AL approaches assume that labels are provided by domain experts and
thus perfectly correct (see Section 7). In contrast, incorrect labels are
common in a crowd database — an issue conventionally handled by
using redundancy, e.g., asking each question to multiple workers and
combining their answers for the best overall result. Standard techniques, such as asking for multiple answers and using majority vote
or the techniques of Dawid and Skene (DS) can improve answer
quality when the crowd is mostly correct, but will not help much if
users do not converge to the right answer or converge too slowly.
In our experience, crowd workers can be quite imprecise for certain
classiﬁcation tasks. For example, we removed the labels from 1000
tweets with hand-labeled (“gold data”) sentiment (dataset details in
Section 6.1.3), and asked Amazon Mechanical Turk workers to label
them again, then measured the workers’ agreement. We used different redundancy ratios (1, 3, 5) and diﬀerent voting schemes (majority and DS), then computed the crowd’s ability to agree with the
hand-produced labels. Te results are shown in Table 1.
Voting Scheme
Majority Vote
Dawid & Skene
1 worker/label
3 workers/label
5 workers/label
Table 1: Te eﬀect of redundancy (using both majority voting and Dawid
and Skene voting) on the accuracy of crowd labels.
In this case, increasing redundancy from 3 to 5 labels does not
signiﬁcantly increase the crowd’s accuracy. Secondly, we have noticed that crowd accuracy varies for diﬀerent subgroups of the unlabeled data. For example, in a diﬀerent experiment, we asked Mechanical Turk workers to label facial expressions in the CMU Facial
Expression dataset,10 and measured agreement with hand-supplied
labels. Tis dataset consists of 585 head-shots of 20 users, each in
32 diﬀerent combinations of head positions (straight, lef, right, and
up), sunglasses (with and without), and facial expressions (neutral,
happy, sad, and angry). Te crowd’s accuracy was signiﬁcantly worse
when the faces were looking up versus other positions:
Facial orientation
Avg. accuracy
Similar patterns appear in several other datasets, where crowd accuracy is considerably lower for certain subgroups. To exploit these
two observations, we developed our PBA algorithm, which computes the optimal number of questions to ask about each subgroup
by estimating the probability pg with which the crowd correctly classiﬁes items of a given subgroup g, and then solves an integer linear program (ILP) to choose the optimal number of questions (i.e.,
degree of redundancy) for labeling each item from that subgroup,
given these probabilities.
Before introducing our algorithm, we make the following observation. Using majority voting to combine an odd number of answers, say 2v + 1, for an unlabeled item u with a true label l, the
probability of the crowd’s combined answer l∗being correct is the
probability that at most v or fewer workers get the answer wrong.
Denoting this probability with Pg,(2v+1), we have:
Pg,(2v+1) = Pr(l = l∗∣2v + 1 votes) =
) ⋅p2v+1−i
where pg is the probability that a crowd worker will correctly label
an item in group g.
Next, we describe our PBA algorithm, which partitions the items
into subgroups and optimally allocates the budget to diﬀerent subgroups by computing the optimal number of votes per item, Vg, for
each subgroup g. PBA consists of three steps:
Step 1. Partition the dataset into G subgroups. Tis can be done
either by partitioning on some low-cardinality ﬁeld that is already
present in the dataset to be labeled (for example, in an image recognition dataset, we might partition by photographer ID or the time
of day when the picture was shot), or by using an unsupervised clustering algorithm such as k-means. For instance, in the CMU facial
10 
expression dataset, we partitioned the images based on user IDs,
leading to G = 20 subgroups, each with roughly 32 images.
Step 2. Randomly pick n0>1 diﬀerent data items from each subgroup, and obtain v0 labels for each one of them. Estimate pg for
each subgroup g, either by choosing data items for which the label
is known and computing the fraction of labels that are correct, or by
taking the majority vote for each of the n0 items, assuming it is correct, and then computing the fraction of labels that agree with the
majority vote. For example, for the CMU dataset, we asked for v0 =
9 labels for n0 = 2 random images11 from each subgroup, and handlabeled those n0∗G = 40 images to estimate pg for g = 1, . . . , 20.
Step 3. Solve an ILP to ﬁnd the optimal Vg for every group g. We
use bg to denote the budget allocated to subgroup g, and create a
binary indicator variable xgb whose value is 1 iﬀsubgroup g is allocated a budget of b. Also, let fg be the number of items that our
learner has chosen to label from subgroup g. Our ILP formulation
depends on the user’s goal:
Goal 1. Suppose we are given a budget B (in terms of the number
of questions) and our goal is to acquire the most accurate labels for
the items requested by the learner. We can then formulate an ILP to
minimize the following objective function:
xgb ⋅(1 −Pg,b) ⋅fg
where bmax is the maximum number of votes that we are willing to
ask per item. Tis goal function captures the expected weighted error of the crowd, i.e., it has a lower value when we allocate a larger
budget (xgb=1 for a large b when Pg>0.5) to subgroups whose questions are harder for the crowd (Pg,b is small) or the learner has chosen more items from that group (fg is large). Tis optimization is
subject to the following constraints:
xgb ⋅b ⋅fg ≤B −v0 ⋅n0 ⋅G
Here, constraint (7) ensures that we pick exactly one b value for
each subgroup and (8) ensures that we stay within our labeling budget (we subtract the initial cost of estimating pg’s from B).
Goal 2. If we are given a minimum required accuracy Q, and our
goal is to minimize the total number of questions asked, we turn (8)
into a goal and (6) into a constraint, i.e., minimizing ∑G
b ⋅fg while ensuring that ∑G
b=1 xgb ⋅(1 −Pg,b) ⋅fg ≤1 −Q.
Note that one could further improve the pg estimates and the expected error estimate in (6) by incorporating the past accuracy of
individual workers. We leave such extensions to future work. We
evaluate PBA in Section 6.2.
OPTIMIZING FOR THE CROWD
Te previous section described our algorithm for handling noisy
labels. In practice, other optimization questions arise. In Section
5.1, we address how to decide when our accuracy is “good enough”.
Given that a crowd can label multiple items in parallel, in Section
5.2 we discuss the eﬀect of batch size (number of simultaneous questions) on our learning performance.
11Larger v0 and n0 (and accounting for each worker’s accuracy) yield
more reliable pg estimates. Here, we use a small budget to show that
even with a rough estimate we can improve on uniform allocations.
We study the eﬀect of n0 on PBA performance in our report .
When To Stop Asking
As mentioned in Section 2.2, users may either provide a ﬁxed
budget B or a minimum quality requirement Q (e.g., F1-measure).
Given a ﬁxed budget, we can ask questions until the budget is exhausted. However, to achieve a quality level Q, we must estimate the
current error of the trained classiﬁer. Te easiest way to do this is to
measure the trained classiﬁer’s ability to classify the gold data accurately, according to the desired quality metric. We can then continue
to ask questions until a speciﬁc accuracy on the gold data is achieved
(or until the rate of improvement of accuracy levels oﬀ).
In the absence of (suﬃcient) gold data, we adopt the standard kfold cross validation technique, randomly partitioning the crowdlabeled data into test and training sets, and measuring the ability of
a model learned on training data to predict test values. We repeat
this procedure k times and take the average as an overall assessment
of the model’s quality. Section 6.2 shows that this method provides
more reliable estimates of the model’s current quality than relying
on a small amount of gold data.
Effect of Batch Sizes
At each iteration of the iterative scenario, we must choose a subset of the unlabeled items according to their eﬀectiveness scores, and
send it to the crowd for labeling. We call this subset a “batch” (denoted as U′ in Line 5 of Figure 3). An interesting question is how to
set this batch size, say β.
Intuitively, a smaller β increases opportunities to improve the AL
algorithm’s eﬀectiveness by incorporating previously requested labels before deciding which labels to request next. For instance, best
results are achieved when β=1. However, larger batch sizes reduce
the overall run-time substantially by (i) allowing several workers to
label items in parallel, and (ii) reducing the number of iterations.
Tis is conﬁrmed by our experiments in Section 6.2, which show
that the impact of increasing β on the eﬀectiveness of our algorithms
is less dramatic than its impact on the overall run-time. Tus, to ﬁnd
the optimal β, a reasonable choice is to start from a smaller batch
size and continuously increase it (say, double it) until the run-time
becomes reasonable, or the quality metric falls below the minimum
requirement. For a detailed discussion, refer to .
EXPERIMENTAL RESULTS
Tis section evaluates the eﬀectiveness of our AL algorithms compared to the state-of-the-art AL strategies, in terms of speed, cost,
and accuracy with which they can label a dataset.
OverviewoftheResults. Overall, our experiments show the following: (i) our AL algorithms require several orders of magnitude fewer
questions to achieve the same quality than the random baseline,
and substantially fewer questions (4.5×–44×) than the best generalpurpose AL algorithm (IWAL ), (ii) our MinExpError algorithm works better than Uncertainty in the upfront setting, but
the two are comparable in the iterative setting, (iii) Uncertainty has
a much lower computational overhead than MinExpError, and (iv)
surprisingly, even though our AL algorithms are generic and widely
applicable, they still perform comparably to and sometimes much
better than AL algorithms designed for speciﬁc tasks, e.g., 7× fewer
questions than CrowdER and an order of magnitude fewer than
CVHull (two of the most recent AL algorithms for entity resolution), competitive results to Brew et al , and also 2–8× fewer
questions than less general AL algorithms (Bootstrap-LV and
MarginDistance ).
Experimental Setup. All algorithms were tested on a Linux server
with dual-quad core Intel Xeon 2.4 GHz processors and 24GB of
RAM. Troughout this section, unless stated otherwise, we repeated
each experiment 20 times and reported the average result, every task
cost 1¢, and the size of the initial training and the batch size were
0.03% and 10% of the unlabeled set, respectively.
MethodsCompared. We ran experiments on the following learning
algorithms in both the upfront and iterative scenarios:
1. Uncertainty: Our method from Section 3.2.
2. MinExpError: Our method from Section 3.3.
3. IWAL: A popular AL algorithm that follows Importance
Weighted Active Learning , recently extended with batching .
4. Bootstrap-LV: Another bootstrap-based AL that uses the model’s
class probability estimates to measure uncertainty . Tis method
only works for probabilistic classiﬁers (e.g., we exclude this in our
experiments with SVMs).
5. CrowdER: One of the most recent AL techniques speciﬁcally
designed for entity resolution tasks .
6. CVHull: Another state-of-the-art AL speciﬁcally designed for
entity resolution . We found several other entity resolution algorithms to be less eﬀective than and thus omit those from
our comparisons here. (For details see .)
7. MarginDistance: An AL algorithm speciﬁcally designed for SVM
classiﬁers, which picks items that are closer to the margin .
8. Entropy: A common AL strategy that picks items for which
the entropy of diﬀerent class probabilities is higher, i.e., the more
uncertain the classiﬁer, the more similar the probabilities of diﬀerent
classes, and the higher the entropy.
9. Brew et al. : a domain-speciﬁc AL designed for sentiment
analysis, which uses clustering to select an appropriate subset of articles (or tweets) to be tagged by users.
10. Baseline: A passive learner that randomly selects unlabeled
items to send to the crowd.
In the plots, we prepend the scenario name to the algorithm names,
e.g., UpfrontMinExpError or IterativeBaseline. We have repeated
our experiments with diﬀerent classiﬁers as the underlying learner,
including SVM, Na¨ıve-Bayes classiﬁer, neural networks, and decision trees. For lack of space, we only report each experiment for
one type of classiﬁer. When unspeciﬁed, we used linear SVM.
Evaluation Metrics. AL algorithms are usually evaluated based on
their learning curve, which plots the quality measure of interest (e.g.,
accuracy or F1-measure) as a function of the number of data items
that are labeled . To compare diﬀerent learning curves quantitatively, the following metrics are typically used:
1. Area under curve (AUC) of the learning curve.
2. AUCLOG, which is the AUC of the learning curve when the
X-axis is in log-scale.
3. Questions saved, which is the ratio of number of questions
asked by an active learner to those asked by the baseline to achieve
the same quality.
Higher AUCs indicate that the learner achieves a higher quality
for the same cost/number of questions. Due to the diminishingreturn of learning curves, the average quality improvement is usually in the 0–16% range.
AUCLOG favors algorithms that improve the metric of interest
early on (e.g., with few examples). Due to the logarithm, the improvement of this measure is typically in the 0–6% range.
To compute question savings, we average over all the quality levels
that are achievable by both AL and baseline curves. For competent
active learners, this measure should (greatly) exceed 1, as a ratio < 1
indicates a performance worse than that of the random baseline.
Crowd-sourced Datasets
We experiment with several datasets labeled using Amazon Mechanical Turk. In this section, we report the performance of our
algorithms on each of them.
Entity Resolution
Entity resolution (ER) involves ﬁnding diﬀerent records that refer
to the same entity, and is an essential step in data integration/cleaning
 . Humans are typically more accurate at ER than classiﬁers, but also slower and more expensive .
We used the Product ( 
zip) dataset, which contains product attributes (name, description,
and price) of items listed on the abt.com and buy.com websites.
Te task is to detect pairs of items that are identical but listed under diﬀerent descriptions on the two websites (e.g., “iPhone White
16 GB” vs “Apple 16GB White iPhone 4”). We used the same dataset
as , where the crowd was asked to label 8315 pairs of items as
either identical or non-identical. Tis dataset consists of 12% identical pairs and 88% non-identical pairs. In this dataset, each pair
has been labeled by 3 diﬀerent workers, with an average accuracy
of 89% and an F1-measure of 56%. We also used the same classiﬁer
used in , namely a linear SVM where each pair of items is represented by their Levenshtein and Cosine similarities. When trained
on 3% of the data, this classiﬁer has an average accuracy of 80% and
an F1-measure of 40%. Figure 8 shows the results of using diﬀerent
AL algorithms. As expected, while all methods eventually improve
with more questions, their overall F1-measures improve at diﬀerent
rates. MarginDistance, MinExpError, and CrowdER are all comparable, while Uncertainty improves much more quickly than the
others. Here, Uncertainty can identify the items about which the
model has the most uncertainty and get the crowd to label those earlier on. Interestingly, IWAL, which is a generic state-of-the-art AL,
performs extremely poorly in practice. CVHull performs equally
poorly, as it internally relies on IWAL as its AL subroutine. Tis
suggests opportunities for extending CVHull to rely on other AL algorithms in future work.
Tis result is highly encouraging: even though CrowdER and CVHull
are recent AL algorithms highly specialized for improving the recall (and indirectly, F1-measure) of ER, our general-purpose AL algorithms are still quite competitive. In fact, Uncertainty uses 6.6×
fewer questions than CrowdER and an order of magnitude fewer
questions than CVHull to achieve the same F1-measure.
Image Search
Vision-related problems also utilize crowd-sourcing heavily, e.g.,
in tagging pictures, ﬁnding objects, and identifying bounding boxes .
All of our vision experiments employed a relatively simple classiﬁer
where the PHOW features (a variant of dense SIFT descriptors commonly used in vision tasks ) of a set of images are ﬁrst extracted
as a bag of words, and then a linear SVM is used for their classiﬁcation. Even though this is not the state-of-the-art image detection
algorithm, we show that our AL algorithms still greatly reduce the
cost of many challenging vision tasks.
Gender Detection. We used the faces from Caltech101 dataset 
and manually labeled each image with its gender (266 males, 169
females) as our ground truth. We also gathered crowd labels by asking the gender of each image from 5 diﬀerent workers. We started by
training the model on a random set of 11% of the data. In Figure 6, we
show the accuracy of the crowd, the accuracy of our machine learning model, and the overall accuracy of the model plus crowd data.
For instance, when a fraction x of the labels were obtained from the
crowd, the other 1 −x labels were determined from the model, and
thus, the overall accuracy was x ∗ac + (1 −x) ∗am, where ac and
am are the crowd and model’s accuracy, respectively. As in our entity resolution experiments, our algorithms improve the quality of
the labels provided by the crowd, i.e., by asking questions for which
Total # of questions asked
Crowd−Accuracy
UpfrontBaseline
UpfrontMarginDistance
UpfrontUncertainty
UpfrontMinExpError
Model−Accuracy
Total # of questions asked
Overall−Accuracy
Total # of questions asked
Figure 6: Te object detection task (detecting the gender of the person in an image): accuracy of the (a) crowd,
(b) model, (c) overall.
Total # of questions asked
F1−measure
Model−F1−measure
UpfrontBaseline
UpfrontMarginDistance
UpfrontUncertainty
UpfrontMinExpError
Image search task:
whether a scene contains a human.
the crowd tends to be more reliable. Here, though, the crowd produces higher overall quality than in the entity resolution case and
therefore its accuracy is improved only from 98.5% to 100%. Figure 6
shows that both MinExpError and Uncertainty perform well in the
upfront scenario, respectively improving the baseline accuracy by
4% and 2% on average, and improving its AUCLOG by 2-3%. Here,
due to the upfront scenario, MinExpError saves the most number of
questions. Te baseline has to ask 4.7× (3.7×) more questions than
MinExpError (Uncertainty) to achieve the same accuracy. Again,
although speciﬁcally designed for SVM, MarginDistance achieves
little improvement over the baseline.
Image Search. We again mixed 50 human faces and 50 background
images from Caltech101 . Because diﬀerentiating human faces
from background clutter is easy for humans, we used the crowd labels as ground truth in this experiment. Figure 7 shows the upfront
scenario with an initial set of 10 labeled images, where both Uncertainty and MinExpError lif the baseline’s F1-measure by 16%, while
MarginDistance provides a lif of 13%. All three algorithms increase
the baseline’s AUCLOG by 5-6%. Note that the baseline’s F1-measure
degrades slightly as it reaches higher budgets, since the baseline is
forced to give answers to hard-to-classify questions, while the AL algorithms avoid such questions, leaving them to the last batch (which
is answered by the crowd).
Sentiment Analysis
Microblogging sites such as Twitter provide rich datasets for sentiment analysis , where analysts can ask questions such as “how
many of the tweets containing ‘iPhone’ have a positive or negative
sentiment?” Training accurate classiﬁers requires suﬃcient accurately labeled data, and with millions of daily tweets, it is too costly to
ask the crowd to label all of them. In this experiment, we show that
our AL algorithms, with as few as 1K-3K crowd-labeled tweets, can
achieve very high accuracy and F1-measure on a corpus of 10K-100K
unlabeled tweets. We randomly chose these tweets from an online
corpus12 that provides ground truth labels for the tweets, with equal
numbers of positive- and negative-sentiment tweets. We obtained
crowd labels (positive, negative, neutral, or vague/unknown) for each
tweet from 3 diﬀerent workers. Figure 9 shows the results for using
1K initially labeled tweets with the 10K dataset in the iterative setting. Te results conﬁrm that the iterative scenario is best handled
by our Uncertainty algorithm, which even improves on the Brew et
al. algorithm , which is a domain-speciﬁc AL designed for sentiment analysis. Here, the Uncertainty, MinExpError, and Brew et al.
algorithms improve the average F1-measure of the baseline model
by 9%, 4% and 4%, respectively. Also, Uncertainty increases baseline’s
AUCLOG by 4%. In comparison to the baseline, Uncertainty, Min-
ExpError, and Brew et al. reduce the number of questions by factors
of 5.38×, 1.76×, and 4.87×, respectively. Again, the savings are expectedly modest compared to the upfront scenario, where savings
are between 27–46× (see for details of the upfront experiments
with the 100K corpus).
12 
PBA and other Crowd Optimizations
In this section, we present results for our crowd-speciﬁc optimizations described in Section 5.
PBA Algorithm: We ﬁrst report experiments on the PBA algorithm.
Recall that this algorithm partitions the items into subgroups and
optimally allocates the budget amongst them. In the CMU facial
expressions dataset, the crowd had a particularly hard time telling
the facial expression of certain individuals, so we created subgroups
based on the user column of the dataset, and asked the crowd to
label the expression on each face. Choosing v0 = 9, bmax = 9,
and n0 = 2, we compared PBA against a uniform budget allocation scheme, where the same number of questions are asked about
all items uniformly, as done in previous research (see Section 7). Te
results are shown in Figure 10. Here, the X axis shows the normalized budget, e.g., a value of 2 means the budget was twice the total
number of unlabeled items. Te Y axis shows the overall (classiﬁcation) error of the crowd using majority voting under diﬀerent allocations. Here, the solid lines show the actual error achieved under
both strategies, while the blue and green dotted lines show our estimates of their performance before running the algorithms. Figure 10
shows that although our estimates of the actual error are not highly
accurate, since we only use them to solve an ILP that would favor
harder subgroups, our PBA algorithm (solid green) still reduces the
overall crowd error by about 10% (from 45% to 35%). We also show
how PBA would perform if it had an oracle that provided access to
exact values of Pg,b (red line).
k-Fold Cross Validation for Estimating Accuracy: We use k-fold
cross validation to estimate the current quality of our model (details
in ). Figure 11 shows our estimated F1-measure for an SVM classiﬁer on UCI’s cancer dataset. Our estimates are reasonably close to
the true F1 values, especially as more labels are obtained from the
crowd. Tis suggests that k-fold cross validation allows us to eﬀectively estimate current model accuracy, and to stop acquiring more
data once model accuracy has reached a reasonable level.
Te Eﬀect of Batch Size: We now study the eﬀect of batch size on
result quality, based on the observations in Section 5.2. Te eﬀect is
typically moderate (and ofen linear), as shown in Figure 12. Here we
show that the F1-measure gains can be in the 8–10% range (see Section 5.2). However, larger batch sizes reduce runtime substantially,
as Figure 13 shows. Here, going from batch size 1 to 200 signiﬁcantly
reduces the time to train a model, by about two orders of magnitude
(from 1000’s of seconds to 10’s of seconds).
UCI Classiﬁcation Datasets
In Section 6.1, we validated our algorithms on crowd-sourced datasets.
Tis section also compares our algorithms on datasets from the UCI
KDD , where labels are provided by experts; that is, ground truth
and crowd labels are the same. Tus, by excluding the eﬀect of noisy
labels, we can compare diﬀerent AL strategies in isolation. We have
chosen 15 well-known datasets, as shown in Figures 14 and 15. To
avoid bias, we have avoided any dataset-speciﬁc tuning or prepro-
Figure 8: Comparison of diﬀerent AL algorithms for entity resolution: the overall F1measure in the iterative scenario.
Figure 9: Sentiment analysis task: F1-measure
of the model for 10K tweets.
Total # of questions / Total # of unlabeled items
Crowd’s Error (majority vote)
Uniform in reality
Uniform (projected)
PBA in reality
PBA (projected)
Optimal (PBA w/ perfect info)
Figure 10: Te crowd’s noise under diﬀerent
budget allocation schemes.
Total # of questions asked
F1−measure
Projected (Cross−validation)
Figure 11:
Estimating quality with k-fold
cross validation.
Batch Size
Avg. F1−measure
IterativeUncertainty
IterativeMinExpError
Figure 12: Eﬀect of batch size on our algorithms’ F1-measure (vehicle dataset, w/ a budget
of 400 questions).
Batch Size
Processing Time (sec)
IterativeUncertainty
IterativeMinExpError
Figure 13: Eﬀect of batch size on our algorithms’ processing times (vehicle dataset, w/ a
budget of 400 questions).
cessing steps, and applied the same classiﬁer with the same settings
to all datasets. In each case, we experimented with 10 diﬀerent budgets of 10%, 20%, ⋯, 100% (of total number of labels), each repeated
10 times, and reported the average. Also, to compute the F1-measure
for datasets with more than 2 classes, we have either grouped all nonmajority classes into a single class, or arbitrarily partitioned all the
classes into two new ones (details in ).
Here, besides the random baseline, we compare Uncertainty and
MinExpError against four other AL techniques, namely IWAL,
MarginDistance, Bootstrap-LV, and Entropy. IWAL is as general
as our algorithms, MarginDistance only applies to SVM classiﬁcation, and Bootstrap-LV and Entropy are only applicable to probabilistic classiﬁers. For all methods (except for MarginDistance) we
used MATLAB’s decision trees as the classiﬁer, with its default parameters except for the following: no pruning, no leaf merging, and
a ‘minparent’ of 1 (impure nodes with 1 or more items can be split).
Figures 14 and 15 show the reduction in the number of questions
under both upfront and iterative settings for Entropy, Bootstrap-LV,
Uncertainty, and MinExpError, while Table 2 shows the average AU-
CLOG, F1, and reduction in the number of questions asked across
all 15 datasets for all AL methods. Te two ﬁgures omit detailed results for MarginDistance and IWAL, as they performed poorly (as
indicated in Table 2). We report all the measures of diﬀerent AL algorithms in terms of their performance improvement relative to the
baseline (so higher numbers are better). For instance, consider Figure 14. On the yeast dataset, MinExpError reduces the number of
questions asked by 84×, while Uncertainty and Bootstrap-LV reduce
it by about 38× and Entropy does not improve the baseline.
In summary, these results are consistent with those observed with
crowd-sourced datasets. In the upfront setting, MinExpError significantly outperforms other AL techniques, with over 104× savings in
the total number of questions on average. MinExpError also improves the AUCLOG and average F1-measure of the baseline on
average by 5% and 15%, respectively. Afer MinExpError, the Uncertainty and Bootstrap-LV are most eﬀective, producing 55-69×
savings, improving the AUCLOG by 3%, and lifing the average F1measure by 11-12%. Bootstrap-LV performs well here, which we expect is due to its use of bootstrap (similar to our algorithms). However, recall that Bootstrap-LV only works for probabilistic classiﬁers
(e.g., decision trees). Here, MarginDistance is only moderately effective, providing around 13× savings. Finally, the least eﬀective algorithms are IWAL and Entropy, which perform quite poorly across
almost all datasets. IWAL uses learning theory to establish worstcase bounds on sample complexity (based on VC-dimensions), but
these bounds are known to leave a signiﬁcant gap between theory
and practice, as seen here. Entropy relies on the classiﬁer’s own class
probability estimates , and thus can be quite ineﬀective when
these estimates are highly inaccurate. To conﬁrm this, we used bootstrap to estimate the class probabilities more accurately (similarly to
our Uncertainty algorithm), and then computed the entropy of these
estimates. Te modiﬁed version, denoted as Uncertainty (Entropy),
is signiﬁcantly more eﬀective than the baseline (73×), which shows
that our idea of using bootstrap in AL not only achieves generality (beyond probabilistic classiﬁers) but can also improve traditional
AL strategies by providing more accurate probability estimates.
For the iterative scenario, Uncertainty actually works better than
MinExpError, with an average saving of 7× over the baseline in questions asked and an increase in AUCLOG and average F1-measure by
1% and 3%, respectively. Note that savings are generally more modest than in the upfront case because the baseline receives much more
labeled data in the iterative setting and therefore, its average performance is much higher, leaving less room for improvement. However, given the comparable (and even slightly better) performance
of Uncertainty compared to MinExpError in the iterative scenario,
Uncertainty becomes a preferable choice here due to its considerably
smaller processing overhead (see Section 6.4).
Figure 14: Te ratio of the num. of questions asked by the random baseline to those asked by diﬀerent AL algorithms in the Upfront scenario.
Figure 15: Te ratio of the num. of questions asked by the random baseline to those asked by diﬀerent AL algorithms in the Iterative scenario.
Run-time, Scalability, and Monetary Cost
To measure algorithm runtime, we experimented with multiple
datasets. Here, we only report the results for the vehicle dataset.
Figure 13 shows that training runtimes range from a few seconds
to about 5, 000 seconds and depend heavily on batch size, which
determines how many times the model is re-trained.
We also studied the eﬀect of parallelism on our algorithms’ runtimes. Here, we compared diﬀerent AL algorithms in the upfront
scenario on Twitter dataset (10K tweets) as we enabled cores on a
multicore machine. Te results are shown in Figure 16. For Uncertainty, the run-time only improves until we have as many cores as
we have bootstrap replicas (here, 10). Afer that, improvement is
marginal. In contrast, MinExpError scales extremely well, achieving nearly linear speedup because it re-trains the classiﬁer once for
every training point.
Finally, we perform a monetary comparison between our AL algorithms and two diﬀerent baselines. Figure 17 shows the combined
AUCLOG(F1)
Avg(Q’s Saved)
Uncertainty
MinExpError
MarginDistance
Bootstrap-LV
Uncertainty (Entropy)
AUCLOG(F1)
Avg(Q’s Saved)
Uncertainty
MinExpError
MarginDistance
Bootstrap-LV
Uncertainty (Entropy)
Table 2: Average improvement in AUCLOG, Questions Saved, and Average F1, across all 15 UCI datasets, by diﬀerent AL algorithms.
monetary cost (crowd+machines) of achieving diﬀerent levels of quality (i.e., the Model’s F1-measure for Twitter dataset from Section
6.1.3). Te crowd cost is (0.01+0.005)*3 per labeled item, which includes 3× redundancy and Amazon’s commission. Te machine cost
for the baseline (passive learner) only consists of training a classi-
ﬁer while for our algorithms we have also included the computation
of the AL scores. To compute the machine cost, we measured the
running time in core-hours using c3.8xlarge instances of Amazon
EC2 cloud, which is currently $1.68/hour. Te overall cost is clearly
dominated by crowd cost, which is why our AL learners can achieve
the same quality with a much lower cost (since they ask much fewer
questions to the crowd). We also compared against a second baseline where all the items are labeled by the crowd (i.e., no classiﬁers).
As expected, this ‘Crowd Only’ approach is signiﬁcantly more expensive than our AL algorithms. Figure 18 shows that the crowd can
label all the items for $363 with an accuracy of 88.1–89.8%, while we
can easily achieve a close accuracy of 87.9% with only $36 (for labeling 807 items and spending less than $0.00014 on machine computation). Tis order of magnitude in saved dollars will only become
more dramatic over time, as we expect machine costs to continue
dropping according to Moore’s law, while human worker costs will
presumably remain the same or even increase.
RELATED WORK
Crowd-sourced Databases. Tese systems use
optimization techniques to reduce the number of unnecessary questions asked to humans (e.g., number of pair-wise comparisons in a
join or sort query). However, the crowd must still provide at least
as many labels as there are unlabeled items directly requested by the
user. It is simply unfeasible to label millions of items in this fashion. To scale up to large datasets, we use machine learning to avoid
obtaining crowd labels for a signiﬁcant portion of the data.
Active Learning. AL has a rich literature in machine learning (see
 ). However, to the best of our knowledge, no existing AL algorithm satisﬁes all of the desiderata required for a practical crowdsourced system, namely generality, black-box approach, batching,
parallelism, and label-noise management. For example, many AL algorithms are designed for a speciﬁc classiﬁer (e.g., neural networks ,
SVM , or probabilistic classiﬁers ) or a speciﬁc domain (e.g.,
entity resolution , vision , or medical imaging ).
However, our algorithms work for arbitrary classiﬁers and do not
require any domain knowledge. Surprisingly, we are also competitive with (and sometimes even superior to) these domain-speciﬁc
algorithms. E.g., we compared against MarginDistance , CrowdER , CVHull , and Brew et al. .
Te popular IWAL algorithm is generic (except for hinge-loss
classiﬁers such as SVM), but does not support batching or parallelism, and requires adding new constraints to the classiﬁer’s internal loss-minimization step. In fact, most AL proposals that provide theoretical guarantees (i) are not black-box, as they need to
know and shrink the classiﬁer’s hypothesis space at each step, and
(ii) do not support batching, as they rely on IID-based analysis. Notable exceptions are and its IWAL variant ; they are blackbox but do not support batching or parallelism. Bootstrap-LV 
and ParaActive support parallelism and batching, but both are based on VC-dimension bounds , which are known to be
too loose in practice. Tey cause the model to request many more
labels than needed, leading to negligible savings over passive learning (as shown in Section 6). Bootstrap-LV also uses bootstrap, but
unlike our algorithms, it is not general. Noisy labelers are handled
in , but assume the same quality for all labelers and assumes that each labeler’s quality is the same across
all items. Moreover, in Section 6, we empirically showed that our
Figure 16: Eﬀect of parallelism on processing
time: 100K tweets.
Figure 17: Te combined monetary cost of
the crowd and machines for Twitter dataset.
Figure 18: Te monetary cost of AL vs. using
the crowd for all labels.
algorithms are superior to generic AL algorithms (IWAL +ParaActive and Bootstrap-LV ).
CONCLUSIONS
In this paper, we proposed two AL algorithms, Uncertainty and
MinExpError, to enable crowd-sourced databases to scale up to large
datasets. To broaden their applicability to diﬀerent classiﬁcation
tasks, we designed these algorithms based on the theory of nonparametric bootstrap and evaluated them in two diﬀerent settings.
In the upfront setting, we ask all questions to the crowd in one go. In
the iterative setting, the questions are adaptively picked and added
to the labeled pool. Ten, we retrain the model and repeat this
process. While iterative retraining is more expensive, it also has
a higher chance of learning a better model. Additionally, we proposed algorithms for choosing the number of questions to ask different crowd-workers, based on the characteristics of the data being
labeled. We also studied the eﬀect of batching on the overall runtime and quality of our AL algorithms. Our results, on three datasets
collected with Amazon’s Mechanical Turk, and on 15 datasets from
the UCI KDD archive, show that our algorithms make substantially
fewer label requests than state-of-the-art AL techniques. We believe
that these algorithms will prove to be immensely useful in crowdsourced database systems.
ACKNOWLEDGEMENT
We thank Alice Tsay for her careful review and helpful comments
on the paper.