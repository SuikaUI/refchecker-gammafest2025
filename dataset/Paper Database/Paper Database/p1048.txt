Fusing Similarity Models with Markov Chains for Sparse Sequential
Recommendation
Ruining He, Julian McAuley
Department of Computer Science and Engineering
University of California, San Diego
Email: {r4he, jmcauley}@cs.ucsd.edu
Abstract—Predicting personalized sequential behavior is a
key task for recommender systems. In order to predict user
actions such as the next product to purchase, movie to watch,
or place to visit, it is essential to take into account both longterm user preferences and sequential patterns (i.e., short-term
dynamics). Matrix Factorization and Markov Chain methods
have emerged as two separate but powerful paradigms for
modeling the two respectively. Combining these ideas has led
to uniﬁed methods that accommodate long- and short-term
dynamics simultaneously by modeling pairwise user-item and
item-item interactions.
In spite of the success of such methods for tackling dense
data, they are challenged by sparsity issues, which are prevalent
in real-world datasets. In recent years, similarity-based methods
have been proposed for (sequentially-unaware) item recommendation with promising results on sparse datasets. In this
paper, we propose to fuse such methods with Markov Chains to
make personalized sequential recommendations. We evaluate
our method, Fossil, on a variety of large, real-world datasets.
We show quantitatively that Fossil outperforms alternative
algorithms, especially on sparse datasets, and qualitatively
that it captures personalized dynamics and is able to make
meaningful recommendations.
Keywords-Recommender
Sequential
Prediction;
Markov Chains
I. INTRODUCTION
Modeling and understanding the interactions between
users and items, as well as the relationships amongst the
items themselves are the core tasks of a recommender
system. The former helps answer questions like ‘What
kind of item does this speciﬁc user like?’ (item-to-user
recommendation), and the latter ‘Which type of shirts match
the pants just purchased?’ (item-to-item recommendation).
In other words, (long-term) user preferences and (short-term)
sequential patterns are captured by the above two forms of
interactions respectively.
In this paper, we are interested in predicting personalized
sequential behavior from collaborative data (e.g. purchase
histories of users), which is challenging as long- and shortterm dynamics need to be combined carefully to account
for both personalization and sequential transitions. This
challenge is further complicated by sparsity issues in many
real-world datasets, which makes it hard to estimate parameters accurately from limited training sequences. Particularly,
Sequential
action sequence of a certain user
Figure 1: An example of how our method, Fossil, makes
recommendations. Harry Potter 2 is recommended to the
user because it (1) is similar to content already watched (i.e.,
fantasy movies), and (2) frequently follows the recentlywatched movie Harry Potter 1. The former is modeled with
a similarity-based method and the latter Markov Chains.
this challenge is not addressed by models concerned with
historical temporal dynamics , where user-level
sequential patterns are typically ignored (e.g. ‘what will Tom
watch next after watching Harry Potter?’).
To model user preferences, there have been two relevant
streams of work. Traditional item recommendation algorithms are typically based on a low-rank factorization of the
user-item interaction matrix, referred to as Matrix Factorization . Each user or item is represented with a numerical
vector of the same dimension such that the compatibility
between them is estimated by the inner product of their
respective representations. Recently, an item similarity-based
algorithm—Factored Item Similarity Models (FISM)—has
been developed which makes recommendations to a user
u exclusively based on how similar items are to those
already consumed/liked by u. In spite of not explicitly
parameterizing each user, FISM surprisingly outperforms
various competing baselines, including Matrix Factorization,
especially on sparse datasets .
The above methods are unaware of sequential dynamics.
In order to tackle sequential prediction tasks, we need to
resort to alternate methods, such as Markov Chains, that
are able to capture sequential patterns. To this end, Rendle
et al. proposed Factorized Personalized Markov Chains
(FPMC), which combines Matrix Factorization and a ﬁrstorder Markov Chain to model personalized sequential
 
Despite the success achieved by FPMC, it suffers from
sparsity issues and the long-tailed distribution of many
datasets, so that the sequential prediction task is only
partially solved. In this paper, we propose to ﬁll this
gap by fusing similarity-based methods (like FISM) with
Markov Chain methods (like FPMC) to tackle sparse
real-world datasets with sequential dynamics. The resulting method, FactOrized Sequential Prediction with Item
SImilarity ModeLs (or Fossil in short), naturally combines
the two by learning a personalized weighting scheme over
the sequence of items to characterize users in terms of
both preferences and the strength of sequential behavior.
Figure 1 demonstrates an example of how Fossil makes
recommendations.
Fossil brings the following beneﬁts for tackling sparsity
issues: (1) It parameterizes each user with only the historical
items so that cold-user (or ‘cool-user’) issues can be alleviated so long as the representations of items can be estimated
accurately. (2) For cold-users, Fossil can shift more weight
to short-term dynamics to capitalize from ‘global’ sequential
patterns. This ﬂexibility enables Fossil to make reasonable
predictions even though only a few actions may have been
observed for a given user.
Our contributions are summarized as follows: First, we
develop a new method, Fossil, that integrates similaritybased methods with Markov Chains smoothly to make
personalized sequential predictions on sparse and long-tailed
datasets. Second, we demonstrate quantitatively that Fossil is
able to outperform a spectrum of state-of-the-art algorithms
on a variety of large, real-world datasets with around ﬁve
million user actions in total. Finally, we visualize the learned
model and analyze the sequential and personalized dynamics
Data and code are available at 
eng.ucsd.edu/ruining- he/.
II. RELATED WORK
The most closely related works to ours are (1) Item
recommendation methods that model user preferences but
are unaware of sequential dynamics; (2) Works that deal
with temporal dynamics but rely on explicit time stamps;
and (3) Those that address the sequential prediction task we
are interested in.
Item recommendation. Item recommendation usually relies on Collaborative Filtering (CF) to learn from explicit
feedback like star-ratings . CF predicts based only on the
user-item rating matrix and mainly follows two paradigms:
neighborhood- and model-based. Neighborhood-based methods recommend items that either have been enjoyed by likeminded users (user-oriented, e.g. ) or are similar
to those already consumed (item-oriented, e.g. ). Such
methods have to rely on some type of predeﬁned similarity
metric such as Pearson Correlation or Cosine Similarity. In
contrast, model-based methods directly explain the interactions between users and items. There have been a variety
of such algorithms including Bayesian methods ,
Restricted Boltzmann Machines , Matrix Factorization
(MF) methods (the basis of many state-of-the-art recommendation approaches such as , , ), and so on.
In order to tackle implicit feedback data where only positive signals (e.g. purchases, clicks, thumbs-up) are observed,
both neighborhood- and model-based methods have been
extended. Recently, Ning et al. proposed SLIM to learn an
item-item similarity matrix, which has shown to outperform
a series of state-of-the-art recommendation approaches .
Kabbur et al. further explored the low-rank property of
the similarity matrix to handle sparse datasets . Since
similarity (or neighborhood) relationships are learned from
the data, these methods overcome the rigidity of using a
predeﬁned similarity metric. On the other hand, MF has
also been extended in several ways including point-wise
methods that inherently assume non-observed feedback to
be negative , and pair-wise methods like BPR-MF
 that are based on a more realistic assumption that
positive feedback should only be ‘more preferable’ than nonobserved feedback.
Temporal dynamics. Several works take temporal dynamics
into account, mostly based on MF techniques . This
includes seminal work proposed by Koren , where
they showed state-of-the-art results on Netﬂix data by modeling the evolution of users and items over time. However,
such works are ultimately building models to understand
past actions , by making use of the
explicit time stamps. The sequential prediction task differs
from theirs in that it does not use time stamps directly, but
rather models sequential relationships between actions.
Sequential recommendation. Markov Chains have demonstrated their strength at modeling stochastic transitions, from
uncovering sequential patterns (e.g. ) to directly
modeling decision processes . For the sequential prediction/recommendation task, Rendle et al. proposed FPMC
which combines the power of MF at modeling personal
preferences and the strength of Markov Chains at modeling
sequential patterns . Our work follows this thread but
contributes in that (1) we make use of a similarity-based
method for modeling user preferences so that sparsity issues
are mitigated; and (2) we further consider Markov Chains
with higher orders to model sequential smoothness across
multiple time steps.
III. SEQUENTIAL PREDICTION
A. Problem Formulation and Notation
Objects to be recommended in the system are referred
to as items. The most common recommendation approaches
focus on modeling types of items of interest to each user,
without accounting for any sequential information, e.g., the
Table I: Notation
Explanation
user set, item set
a speciﬁc user, item, time step
the item user u interacted with at time step t
action sequence of user u, Su = (Su
2 , . . . , Su
the set of items in Su, I+
2 , . . . , Su
bias term associated with item i, βi ∈R
latent vector associated with item i, Pi ∈RK
latent vector associated with item i, Qi ∈RK
dimensionality of the vector representing each user/item
order of Markov Chains
global weighting vector, η = (η1, η2, . . . , ηL)
personalized weighting vector, ηu = (ηu
2 , . . . , ηu
probability that user u chooses item j after item i
prediction that user u chooses item i at time step t
personalized total order of user u at time step t
weighting factor, α ∈R
learning rate, ϵ ∈R
the logistic (sigmoid) function
last item purchased/reviewed, or place visited by the user in
We are tackling sequential prediction tasks which are formulated as follows. Let U = {u1, u2, . . . , u|U|} denote the
set of users and I = {i1, i2, . . . , i|I|} the set of items. Each
user u is associated with a sequence of actions (or ‘events’)
Su (e.g. items purchased by u, or places u has checked in):
2 , . . . , Su
|Su|), where Su
k ∈I. We use I+
denote the set of items in Su where the sequential signal
is ignored. Using the above data exclusively, our objective
is to predict the next action of each user and thus make
recommendations accordingly. Notation used throughout this
paper is summarized in Table I. Boldfaced symbols are used
to denote matrices.
B. Modeling User Preferences
Modeling and understanding long-term preferences of
users is a key to any recommender system. Traditional
methods such as Matrix Factorization (e.g. ) are usually
based on a low-rank assumption. They project users and
items to a low-rank latent space (K-dimensional) such that
the coordinates of each user within the space capture the
preferences towards these K latent dimensions. The afﬁnity
bpu,i between user u and item i is then estimated by the inner
product of the vector representations of u and i:
bpu,i = ⟨Xu, Yi⟩.
Recently, a novel similarity-based method, called Sparse
Linear Methods (SLIM), has been developed and shown to
outperform a series of state-of-the-art approaches including
Matrix Factorization based methods . By learning an
item-to-item similarity matrix W from the user action
history (e.g. purchase logs), it predicts the user-item afﬁnity
as follows:
u is the set of items u has interacted with. Wj,i is
the element at the j-th row and i-th column of matrix W,
denoting the similarity of item j to item i. The underlying
rationale it follows is that the more j is similar to those
items already consumed/liked by u, the more likely j will
be a preferable choice for u.
Without parameterizing each user explicitly, SLIM relaxes
the low-rank assumption enforced on user representations
and has achieved higher recommendation accuracy (see 
for details).
The major challenge faced by SLIM comes from the large
amount of parameters (|I|×|I|) to be estimated from the
sparse user-item interactions. SLIM approaches this issue
by exploring the sparsity characteristic of W using L1norm regularization when inferring the parameters. Another
direction is to capitalize on the low-rank potential of the
similarity matrix by decomposing W into the product of
two independent low-rank matrices :
where P and Q are both |I|×K matrices and K ≪|I|. This
method is called Factored Item Similarity Models (FISM)
and brings two beneﬁts: (1) It signiﬁcantly reduces the
number of parameters and has been shown to generate stateof-the-art performance on a series of sparse datasets; and (2)
Compared to SLIM, it is stronger at capturing the transitive
property of item similarities.1 When it comes to real-world
datasets which are usually highly sparse, the above beneﬁts
contribute considerably to recommendation performance.
C. Modeling Sequential Patterns
Sequential (or short-term) dynamics are typically modeled by Markov Chains. Given the last item i that has
been interacted with, the ﬁrst-order Markov Chain predicts
the probability of item j being chosen at the next step
p(j | i) by maximum likelihood estimation of the itemto-item transition matrix. A further improvement can be
made by factorizing the transition matrix into two low-rank
matrices, similar to the idea in Section III-B (i.e., Eq. (3));
thus the transition probability of item i to item j is estimated
by the following inner product:
p(j | i) ∝⟨Mi, Nj⟩,
where Mi and Nj are the latent vector representations of
item i and j respectively. Note that each item i is associated
with two vectors: Mi and Ni.
1For instance, if items a and b, b and c are two co-purchase pairs in the
training data but (a, c) is not, SLIM will erroneously estimate the similarity
of a and c to be 0.
Markov Chains are strong at capturing short-term dynamics. For instance, if one purchased a laptop recently, it is
reasonable to recommend relevant items such as peripherals
or laptop backpacks. Nevertheless, such methods are limited
in their ability to capture user preferences that are both
personal and long-term (e.g. what type of laptop backpack
this particular user likes). Thus there is a need to combine
the two lines of models carefully in order to beneﬁt from
modeling long- and short-term dynamics simultaneously.
D. The Uniﬁed Sequential Prediction Model
Recently, Rendle et al. introduced a seminal method
that combines Matrix Factorization (i.e., Eq. (1)) and the
ﬁrst-order Markov Chain (i.e., Eq. (4)) to form a uniﬁed
prediction model, which is dubbed Factorized Personalized
Markov Chains (FPMC) . The probability that an arbitrary
user u transitions from the last item i to the next item j is
estimated by
pu(j | i) ∝⟨Xu, Yj⟩+ ⟨Mi, Nj⟩,
where the ﬁrst inner product computes how much u likes
item j and the second calculates the extent to which j is
‘similar’ to the last item i.2
IV. THE PROPOSED Fossil MODEL
A. The Basic Model
In contrast to FPMC, here we take another direction and
investigate combining similarity-based methods and Markov
Chains to approach the sequential prediction task (see Figure
2). In particular, we take FISM (see Section III-B) as our
starting point, in light of its ability to handle the sparsity
issues in real-world datasets.
The basic form of our model is as follows:
pu(j | i) ∝
user preferences
⟨Pj′, Qj⟩+ (η + ηu)
personalized
weighting factor
sequential dynamics
⟨Mi, Nj⟩, (6)
where each user is parameterized with only a single scalar
ηu that controls the relative weights of the long- and shortterm dynamics. η is a global parameter shared by all users
and helps center ηu at 0.
The above formulation parameterizes each item with four
vectors, i.e., Pi, Qi, Mi, and Ni. Considering the limited
number of parameters we can afford in the sparse datasets
we are interested in, we reduce the four matrices to two
by enforcing P = M and Q = N. This makes sense since
ultimately sequentially-related items are also ‘similar’ to one
2In , the authors took a tensor-factorization perspective of the predictor, which brings an additional term modeling the interactions between u
and the last item i. However, this term is not required as it always gets
canceled out when making predictions.
Similarity­based
Factorization
First­order
Markov Chains
Long­term Dynamics                 Short­term Dynamics
High­order
Markov Chains
Existing methods
Our method
Modeling                                    Modeling
Figure 2: Our method, Fossil, is a combination of similaritybased methods and (high-order) Markov Chains, in contrast
to existing methods that combine Matrix Factorization and
ﬁrst-order Markov Chains .
another. Adding a bias term βj and normalizing the longterm dynamics component, we arrive at a new formulation
as follows:
pu(j | i) ∝βj + ⟨
Pj′ + (η + ηu) · Pi, Qj⟩.
B. Modeling Higher-order Markov Chains
Up to now we have used ﬁrst-order Markov Chains to
model short-term temporal dynamics. Next, we extend our
formulation to consider high-order Markov Chains to capture
smoothness across multiple time steps. Given the most recent
L items user u has consumed (Su
t−2, . . . , Su
new formulation predicts the probability of item j being the
next item (at time step t) with an Lth order Markov Chain
as shown in Eq. (7). In this new formulation, each user is
associated with a vector ηu = (ηu
2 , . . . , ηu
L). Likewise,
the global bias becomes the vector η = (η1, η2, . . . , ηL).
The rationale behind this idea is that each of the previous
L actions should contribute with different weights to the
high-order smoothness.
C. Inferring Model Parameters
The ultimate goal of the sequential prediction task is to
rank observed (or ground-truth) items as high as possible
so that the recommender system can make plausible recommendations. This means it is natural to derive a personalized
total order >u,t (at each step t) to minimize a ranking loss
such as sequential Bayesian Personalized Ranking (S-BPR)
 . Here i >u,t j means that item i is ranked higher than
item j for user u at step t given the action sequence before
For each user u and for each time step t, S-BPR employs
a sigmoid function σ(bpu,t,Su
t −bpu,t,j) (bpu,t,· is a shorthand
for the prediction in Eq. (7)) to characterize the probability
that ground-truth item Su
t is ranked higher than a ‘negative’
item j given the model parameters Θ, i.e., p(Su
t >u,t j|Θ).
Assuming independence of users and time steps, model
parameters Θ are inferred by optimizing the following
t−2, . . . , Su
previous L items u interacted with
long-term dynamics
short-term dynamics
maximum a posteriori (MAP) estimation:
t >u,t j|Θ) p(Θ)
ln σ(bpu,t,Su
t −bpu,t,j) + ln p(Θ),
where the pairwise ranking between the ground-truth and
all negative items goes through all users and all time steps.3
p(Θ) is a Gaussian prior over the model parameters. Note
that due to the ‘additive’ characteristic, our formulation can
allow t to run from 2 (instead of L + 1) to the last item in
The large amount of positive-negative pairs in the objective makes conventional batch gradient descent unaffordable.
As such, we adopt Stochastic Gradient Descent (SGD) which
has seen wide success for learning models in BPR-like optimization frameworks (e.g. ). The SGD training procedure works as follows. First, it uniformly samples a user u
from U as well as a time step t from {2, 3, . . . , |Su|}. Next, a
negative item j ∈I and j /∈{Su
t−1, . . . , Su
t−min(L,t−1)}
is uniformly sampled, which forms a training triple (u, t, j).
Finally, the optimization procedure updates parameters in
the following fashion:
Θ ←Θ+ϵ·(σ(bpu,t,j −bpu,t,Su
t ) ∂(bpu,t,Su
t −bpu,t,j)
where ϵ is the learning rate and λΘ is a regularization
hyperparameter.
V. EXPERIMENTS
A. Datasets and Statistics
To evaluate the ability and applicability of our method to
handle different real-world scenarios, we include a spectrum
of large datasets from different domains in order to predict
actions ranging from the next product to purchase, next
movie to watch, to next review to write, and next place to
check-in. Note that these datasets also vary signiﬁcantly in
terms of user and item density (i.e., number of actions per
user/item).
Amazon. The ﬁrst group of large datasets are from Amazon.com,4 recently introduced by . This is among the
largest datasets available that includes review texts and
3i.e., optimize the AUC metric (See Section V-B).
4 
Table II: Statistics of the Datasets.
Amazon-Ofﬁce
Amazon-Auto
Amazon-Game
Amazon-Toy
Amazon-Cell
Amazon-Clothes
174,484 1,068,972
Amazon-Elec
145,199 2,109,879
Foursquare
556,942 4,951,237
Amazon datasets are ranked by the ‘#actions’ column. Ofﬁce: Ofﬁce
Products, Auto: Automotive, Game: Video Games, Toy: Toys and
Games, Cell: Cell Phones and Accessories, Clothes: Clothing, Shoes
and Jewelry, Elec: Electronics.
time stamps spanning from May 1996 to July 2014. Each
top-level category of products on Amazon.com has been
constructed as an independent dataset by the authors of .
In this paper, we take a variety of large categories including
ofﬁce products, automotive, video games, toys and games,
cell phones and accessories, clothing, shoes, and jewelry,
and electronics.
Epinions. The next dataset is collected from a popular online
consumer review website Epinions.com5 by the authors
of . Like Amazon data, it includes all actions of all
users on the website so that the sequential relationships are
maintained. This dataset spans January 2001 to November
Foursquare. We also include another popular dataset which
is often used to evaluate next Point-Of-Interest prediction
algorithms. It is from Foursquare.com6 and includes a large
number of check-ins (i.e., visits) of users at different venues
(e.g. restaurants), spanning December 2011 to April 2012.
Note that the setting in this paper is to compare all methods
using collaborative data exclusively, as in Section III-A;
making use of side signals like geographical data is beyond
the scope of this work.
For each of the above datasets, we ﬁlter out inactive
users and items with fewer than ﬁve associated actions.
Star-ratings are converted to implicit feedback (i.e., ‘binary’
actions) by setting the corresponding entries to 1; that is, we
care about the purchase/review/check-in actions regardless
5 
6 
of the speciﬁc rating values. Statistics of each dataset after
the above processing are shown in Table II.
B. Evaluation Methodology
All methods are evaluated with the AUC (Area Under
the ROC curve) metric, not only because it is widely used
(e.g. ), but also because it is a natural choice in our
case as all comparison methods directly optimize this metric
on the training set.
For each dataset, we use the two most recent actions of
each user to create a validation set V and a test set E:
one action for validation and the other for testing. All other
actions are used as the training set T . The training set T is
used to train all comparison methods, and hyperparameters
are tuned with the validation set V. Finally, all trained
models are evaluated on the test set E:
1(bpu,|Su|,gu > bpu,|Su|,j),
where gu is the ground-truth item of user u at the most
recent time step |Su|. The indicator function 1(b) returns
1 if the argument b is true, 0 otherwise. The goal here is
for the held-out action to calculate how highly the groundtruth item has been ranked for each user u according to the
learned personalized total order >u,t.
C. Comparison Methods
We include a series of state-of-the-art methods in the ﬁeld
of both item recommendation and sequential prediction.
1) Popularity (POP): always recommends items based
on the rank of their popularity in the system.
2) Bayesian Personalized Ranking (BPR-MF) : is
a state-of-the-art method for personalized item recommendation. It only considers long-term preferences
and uses Matrix Factorization as the underlying
predictor.
3) Factored Item Similarity Models (FISM) : is a
recently-proposed similarity-based algorithm for personalized item recommendation. We build our model
on top of it to tackle the sequential prediction task.
4) Factorized Markov Chains (FMC): factorizes the
item-to-item transition matrix (|I|×|I|) to capture the
likelihood that an arbitrary user transitions from one
item to another. Here we use a ﬁrst-order Markov
Chain as higher orders incur a state-space explosion.
5) Factorized Personalized Markov Chain (FPMC)
 : is a method that uses a personalized Markov
Chain (see Eq. (5)) for the sequential prediction task
we are interested in. Recall that FPMC is ultimately
a combination of Matrix Factorization and ﬁrst-order
Markov Chains.
6) Factorized Sequential Prediction with Item Similarity Models (Fossil): is the algorithm proposed in this
Table III: Models. P: Personalized?, Q: seQuentially-aware?,
S: Similarity-based?, E: Explicitly model users?, H: consider
High-order Markov Chains?.
paper (see Eq. (7)). Markov Chains of different orders
will be experimented with and compared against other
For clarity, the above methods are collated in Table III
in terms of whether they are ‘personalized,’ ‘sequentiallyaware,’ ‘similarity-based,’ ‘explicitly model users,’ and ‘consider high-order Markov Chains.’ Note that all methods
(except POP) directly optimize the pairwise ranking of
ground-truth actions versus negative actions in the training
set T (i.e., the AUC metric), so that the fairness of the
comparison is maximized.
These baselines are designed to demonstrate (1) the performance achieved by state-of-the-art sequentially-unaware
recommendation methods (BPR-MF and FISM) and purely
sequential methods (MC); (2) the effectiveness of the stateof-the-art sequential prediction method by combining BPR-
MF and MC (FPMC); and (3) the strength of our proposed
combination of a similarity-based algorithm and (high-order)
Markov Chains (Fossil).
D. Performance and Quantitative Analysis
For simplicity and fair comparison, the number of dimensions of user/item representations (or the rank of the
matrices) in all methods is ﬁxed to the same number K. We
experimented with different values of K and demonstrate
our results in Table IV (K = 10). Due to the sparsity of these
datasets, no algorithm observed signiﬁcant performance improvements when increasing K beyond 10 (see the last row
of Table IV for the average accuracy of all methods when
setting K to 20).
For clarity, on the right of the table we show the percentage improvement of a variety of methods—FPMC vs. BPR-
MF, Fossil vs. FISM, Fossil vs. FPMC, and Fossil vs. the
best baselines. We make a few comparisons and summarize
our ﬁndings as follows.
FISM vs. BPR-MF. BPR-MF and FISM are two powerful
methods to model users’ personalized preferences, i.e., longterm dynamics. Although ultimately they all factorize a
matrix at their core, they differ signiﬁcantly both in terms
of the rationales they follow and performance they achieve.
BPR-MF relies on factorization of the user-item interaction
matrix and parameterizes each user with a K-dimensional
Table IV: AUC on different datasets (higher is better). The number of latent dimensions for all comparison methods (except
for POP) is set to K = 10. For Fossil, we test different orders of the Markov Chain (i.e., 1, 2, and 3). On the right we
demonstrate the improvement of FPMC vs. BPR-MF, Fossil vs. FISM, Fossil vs. FPMC, and Fossil vs. the best baselines.
% improvement
f vs. best
Amazon-Ofﬁce
Amazon-Auto
Amazon-Game
Amazon-Toy
Amazon-Cell
Amazon-Clothes
Amazon-Elec
Foursquare
Avg. (K = 10)
Avg. (K = 20)
vector. In contrast, FISM is based on the factorization of
the item-item similarity matrix and relaxes the need to
explicitly parameterize users, who may only have a few
actions in the training set. According to our experimental
results, FISM exhibits signiﬁcant improvements over BPR-
MF on all datasets (over 4 percent on average), which makes
it a strong building-block for our sequential prediction task.
FMC vs. BPR-MF & FISM. Compared to BPR-MF and
FISM, FMC focuses on capturing sequential patterns among
items, i.e., short-term dynamics. Notably, FMC achieved
comparable prediction accuracy with BPR-MF. This suggests that sequential patterns are important dynamics and
that it would be limiting to only consider long-term user
preferences.
FPMC vs. BPR-MF & FMC. BPR-MF and FMC are
limited by missing an important type of dynamic prevalent in
our datasets. FPMC combines them and emerges as a comprehensive model that is both personalized and sequentiallyaware. Quantitatively, FPMC is the strongest among the
three—0.99 percent better than BPR-MF and 0.80 percent
better than FMC on average (when K = 10).
Fossil vs. FPMC. By fusing FISM, which is strong at
modeling long-term dynamics on sparse data, and Markov
Chains, Fossil enhances the performance of FISM by as
much as 2.79 percent on average, compared to 0.99 percent
achieved by FPMC over BPR-MF. Comparing Fossil with
FPMC, we found that (1) Fossil beats FPMC signiﬁcantly
on all datasets, with a large improvement of 6.54 percent on
average, and (2) the improvement is even larger on sparse
datasets like Amazon-Auto, Amazon-Clothes, and Epinions.
The superior performance of Fossil on various datasets
demonstrates its efﬁcacy to handle real-world datasets.
Orders of Markov Chains. Generally, the performance
of Fossil gets better on most datasets when increasing the
order of the Markov Chains involved (from 1 to 3 in our
experiments), indicating that earlier actions are also useful
for prediction. On the other hand, small orders seem to be
enough to achieve good performance, presumably because
sequential patterns do not involve actions from a long time
Fossil vs. others. The rightmost column of Table IV demonstrates the performance improvement of Fossil versus the
best baseline method in each case. We found that Fossil
outperforms all baselines in all cases with an enhancement
of 2.5 percent on average.
E. Reproducibility
The hyperparameter α in Eq. (7) is set to 0.2 on all
datasets. Regularization hyperparameters are always tuned
with grid search using the validation set V. λΘ (in Eq. (10))
yielded the best performance when set to 0.1 in most cases.
The learning rate ϵ is set to 0.01.
F. Training Efﬁciency
All experiments were performed on a single machine with
8 cores and 64GB main memory. The largest dataset—
Amazon Electronics takes around 4 hours to train Fossil
with third-order Markov Chains (i.e., L = 3) and 20 latent
dimensions (i.e., K = 20). It is easy to verify that Eq. (7)
takes O(LK) for prediction. Since L and K are usually
small numbers for sparse datasets, the computational cost is
manageable.
VI. A STUDY ON THE EFFECT OF DATA SPARSITY
We proceed by further studying the effect of dataset
sparsity on different methods. To this end, we perform
experiments on a popular dataset—MovieLens-1M,7 which
is dense and consists of about 1 million ratings from 6,040
users on 3,706 movies dated from April 2000 to February
2003. Again, we convert all star-ratings to implicit feedback
for our experiments. The number of dimensions K is set to
We construct a sequence of datasets each with a different
threshold N on the number of recent user actions; that is,
7 
Table V: Statistics of the MovieLens Datasets.
Dataset Threshold
Table VI: AUC on different datasets (higher is better). The
number of latent dimensions K is set to 10. For Fossil, we
test different orders of the Markov Chain (i.e., 1, 2, and 3).
BPR-MF FISM
FPMC Fossil
ML-50 0.8032
0.8564 0.8566 0.8825 0.8802 0.8837 0.8865
ML-30 0.7980
0.8515 0.8463 0.8674 0.8748 0.8794 0.8797
ML-20 0.7919
0.8476 0.8357 0.8503 0.8704 0.8735 0.8728
ML-10 0.7722
0.8276 0.8026 0.8301 0.8540 0.8546 0.8551
0.7711 0.7275 0.7458 0.7945 0.7940 0.7931
a dataset is constructed by taking only the N most recent
actions of each user. Actions beyond this point are dropped.
Note that sampling is not used as it would break the sequential characteristic exploited by the models. We decrease the
threshold N from 50 to 5 (leading to a series of increasingly
sparse datasets) and observe the performance variation of all
methods. Statistics of the datasets are summarized in Table
V. Experimental results are collected in Table VI. As we can
see from the table, the accuracy of all methods drops if we
decrease the threshold from 50 to 5. This makes sense since
we have less information regarding both users and transitions
among items. In this section, we compare Fossil with FPMC
to answer a series of questions on their effectiveness based
on the results in Table VI.
A. How Much do Short-term Dynamics Help?
We begin by investigating the improvements due to modeling sequential patterns on top of BPR-MF and FISM. In
Figure 3 we demonstrate the improvement of FPMC over
BPR-MF, in contrast to that achieved by Fossil (with 1st-,
2nd-, and 3rd-order Markov Chains) over FISM. From the
ﬁgure we observe that the improvement of FPMC over BPR-
MF decreases as data become sparser, due to the amount
of additional parameters introduced to model short-term
dynamics. In contrast, Fossil introduces only a small amount
of parameters (i.e., the weighting vectors η and ηu), and
thus outperforms FISM more consistently. Additionally, high
orders of Markov Chains appear to help more when the
dataset is dense, e.g., ML-50 vs. others.
B. How Much do Long-term Dynamics Help?
One may consider FPMC and Fossil as two different methods to enhance Markov Chains by incorporating long-term
user preferences. To demonstrate the beneﬁts of modeling
FPMC vs. BPR­MF
Fossil­1 vs. FISM
Fossil­2 vs. FISM
Fossil­3 vs. FISM
Percentage Improv. (%)
Figure 3: Improvement from modeling short-term dynamics.
Such dynamics (with 1st-, 2nd-, and 3rd-order Markov
Chains) are consistently helpful for FISM, in contrast to the
deteriorating improvement of FPMC over BPR-MF when
the dataset is sparse.
FPMC vs. FMC
Fossil­1 vs. FMC
Fossil­2 vs. FMC
Fossil­3 vs. FMC
Percentage Improv. (%)
Figure 4: Improvement from modeling long-term dynamics
on top of Markov Chains. The improvement achieved by
Fossil increases as datasets get sparser.
Fossil­1 vs. FPMC
Fossil­2 vs. FPMC
Fossil­3 vs. FPMC
Percentage Improv. (%)
Figure 5: Improvement achieved by Fossil over FPMC as
dataset sparsity increases.
long-term dynamics, in Figure 4 we show the amount of
improvement achieved by FPMC and Fossil over FMC. As
datasets become sparser, the performance gap between Fossil
and FMC increases by as much as 9 percent, in contrast to
the relatively ‘ﬂat’ improvement of around 3 percent from
FPMC. This demonstrates the strength of Fossil as well as
the compatibility of FISM and Markov Chains since they
are both ultimately modeling relationships among items.
C. Fossil and FPMC
In Figure 5 we demonstrate the performance gain of our
proposed method over FPMC. Fossil outperforms FPMC
increasingly as sparsity grows. Note that FPMC requires as
Figure 6: Demonstration of item transitions. On the left are
a few sampled items (or queries) from the Clothing, Shoes
and Jewelry dataset. On the right are the top-ranked items
(from the same dataset) that each query is likely to transition
to, according to arg minj∈I⟨Pquery, Qj⟩.
many as 50 actions per user in order to achieve comparable
performance with Fossil.
For further investigation, we also performed additional
experiments where we reduced the number of parameters
of FPMC by setting the matrix M = N in Eq. (5), in
the hope that it could favor sparse datasets. However, no
signiﬁcant improvement (or even worse prediction accuracy)
was observed.
To sum up, the two key components of Fossil, i.e., the
similarity-based method and (high-order) Markov Chains,
both contribute considerably to its performance especially
on sparse datasets. And thus the precise combination of
the two generates strong results for the sparse sequential
recommendation task.
VII. VISUALIZATION AND QUALITATIVE ANALYSIS
In this section, we visualize the learned Fossil model and
qualitatively analyze our ﬁndings. We choose to visualize
the results achieved on Clothing, Shoes and Jewelry dataset
from Amazon.com (see Section V-A) due to its large size,
signiﬁcant variability, and the convenience to demonstrate
user actions. The model we use for visualization is the ﬁrstorder Fossil model trained on the dataset with K set to 10.
A. Visualizing Sequential Dynamics
First, we visualize the transition among items to answer
questions like ‘What kind of outﬁts are compatible with
this outdoor cap?’. Fossil encodes this dynamic by the
inner product of Pi and Qj where i is the item already
#actions in the training set
Figure 7: Demonstration of the importance of short-term
dynamics for different users. Fossil learns to assign higher
weights to cold users to rely more on sequential patterns.
consumed and j the item considered for recommendation.
Quantitatively, given a ‘query’ item i at the current time
step, items that are most likely to appear at next step are
computed according to
For demonstration, we take a few samples from the above
dataset, as shown on the left of the separator in Figure 6.
Next, we use them as queries to get corresponding recommendations according to Eq. (12). Items retrieved for each
query are shown on the right. We make two observations
from this ﬁgure. On the one hand, although the model is
unaware of the identity of items, it learns the underlying
homogeneity correctly, as we see from the ﬁrst row (i.e., the
Star Wars theme) and last three rows (i.e., watches, shirts
and jewelry respectively). On the other hand, items from
different subcategories are surfaced to generate compatible
outﬁts, e.g. rows 2 and 5.
B. Visualizing Personal Dynamics
Recall that each user u is parameterized with a vector ηu
to model the personalized comparative importance of shortterm dynamics versus long-term dynamics. The scatter plot
in Figure 7 shows such weights (ηu
0 ) learned for users in the
From the scatter plot we make a few observations as
follows. (1) Fossil gives ‘cool’ users (users with few actions) higher weights, which makes sense since sequential
patterns have to carry more weight when we do not have
enough observations to infer users’ preferences. This also
conﬁrms that it is necessary to model short-term dynamics
on sparse datasets in order to enhance the performance
of item recommendation methods like FISM. (2) As we
increment the number of actions, Fossil relies more on longterm preferences as they become increasingly accurate.
Recommen­     Ground­
dation           truth
User Sequences
Figure 8: Demonstration of recommendations made for
users with large η0
u values, indicating strong ‘sequential
consistency.’
In Figure 8 we demonstrate recommendations made for a
few users as well as the corresponding ground-truth items
(from the test set E). Here the users are sampled from those
with the largest ηu
0 and at least 5 actions in the training set
T . The threshold is used so that ηu
0 is forced to capture the
‘sequential consistency’ of user u to some degree, instead
of merely the user sparsity involved. From Figure 8 we can
observe a certain amount of such consistency within each
sequence. E.g., jewelry (row 1), wearables for boys (row 4)
and business men (row 5).
In conclusion, it is precisely the ability to carefully
accommodate multiple types of dynamics as well as personalization that makes Fossil a successful method to handle
the sequential recommendation task.
VIII. CONCLUSION
In this paper, we proposed a new method, Fossil, that
fuses similarity-based models with Markov Chains to predict
personalized sequential behavior. We performed extensive
experiments on multiple large, real-world datasets, and
found that Fossil outperforms existing methods considerably.
We studied the effect of sparsity on different methods and
found that Fossil is especially strong when the prediction
task is challenged by sparsity issues. We visualized the
learned Fossil model on a large dataset from Amazon.com
and observed that it captures sequential and personalized
dynamics in a reasonable way, along with the favorable
quantitative results achieved.
Acknowledgments. This work is supported by NSF-IIS-1636879,
and donations from Adobe, Symantec, and NVIDIA.