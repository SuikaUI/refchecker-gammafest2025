J Intell Inf Syst
DOI 10.1007/s10844-011-0183-2
Community-based anomaly detection
in evolutionary networks
Zhengzhang Chen · William Hendrix ·
Nagiza F. Samatova
Received: 7 March 2011 / Revised: 2 August 2011 / Accepted: 6 October 2011
© Springer Science+Business Media, LLC 2011
Abstract Networks of dynamic systems, including social networks, the World Wide
Web, climate networks, and biological networks, can be highly clustered. Detecting
clusters, or communities, in such dynamic networks is an emerging area of research;
however, less work has been done in terms of detecting community-based anomalies.
While there has been some previous work on detecting anomalies in graph-based
data, none of these anomaly detection approaches have considered an important
property of evolutionary networks—their community structure. In this work, we
present an approach to uncover community-based anomalies in evolutionary networks characterized by overlapping communities. We develop a parameter-free and
scalable algorithm using a proposed representative-based technique to detect all six
possible types of community-based anomalies: grown, shrunken, merged, split, born,
and vanished communities. We detail the underlying theory required to guarantee
the correctness of the algorithm. We measure the performance of the communitybased anomaly detection algorithm by comparison to a non–representative-based
algorithm on synthetic networks, and our experiments on synthetic datasets show
that our algorithm achieves a runtime speedup of 11–46 over the baseline algorithm.
We have also applied our algorithm to two real-world evolutionary networks,
Food Web and Enron Email. Significant and informative community-based anomaly
dynamics have been detected in both cases.
This work was supported in part by the U.S. Department of Energy, Office of Science, the office
of Advanced Scientific Computing Research (ASCR) and the Office of Biological
and Environmental Research (BER) and the U.S. National Science Foundation
(Expeditions in Computing). Oak Ridge National Laboratory is managed
by UT-Battelle for the LLC U.S. D.O.E. under contract no. DEAC05-00OR22725.
Z. Chen · W. Hendrix · N. F. Samatova (B)
Department of Computer Science, North Carolina State University, Raleigh, NC 27695, USA
e-mail: 
Z. Chen · N. F. Samatova
Computer Science and Mathematics Division, Oak Ridge National Laboratory,
Oak Ridge, TN 37831, USA
J Intell Inf Syst
Keywords Anomaly detection · Time-varying graphs · Evolutionary analysis ·
Community detection · Community-based anomaly
1 Introduction
As opposed to most research in anomaly detection, which is based on strings or
attribute-value data as the medium, graph-based anomaly detection focuses on data
that can be represented as a graph . It has provided new approaches for handling data that can’t be easily analyzed with traditional non–graphbased data mining approaches and has found applications
in several domains. One of the most important of these areas is intrusion detection.
GrIDS, a graph-based intrusion detection system, was developed by Staniford-chen
et al. . Padmanabh et al. proposed a random walk-based approach
to detect outliers in Wireless Sensor Networks. Eberle and Holder focused
on detecting anomalies in cargo shipments. Noble and Cook used anomaly detection techniques to discover incidents of credit card fraud .
Graph-based anomaly detection has been studied from two major perspectives:
“white crow” and “in-disguise” anomalies. Intuitively, a “white crow” anomaly (also
called an “outlier” in many papers) is an observation that deviates substantially
from the other observations , while an “in-disguise”
anomaly is only a minor deviation from the normal pattern , as shown in Fig. 1. For example, if we are analyzing the voters list and we
come across a person whose age is 322, then we can take that as a “white crow”
anomaly, because the age of a voter will typically lie between 18 and 100. On the
other hand, anyone who is attempting to commit credit card fraud would not want to
be caught—a criminal would want his or her activities to look as normal as possible,
which represents an “in-disguise” anomaly. Anomalies classified as “white crow” are
usually detected as nodes, edges, or subgraphs, while “in-disguise” anomalies are now
only identified through unusual patterns, including uncommon nodes or entity alterations. A summary of the various research directions in this area is shown in Fig. 2.
Fig. 1 “White crow” and
“in-disguise” anomalies
In-disguise
J Intell Inf Syst
Research on Graph -based
Anomaly Detection
“White Crow” Anomaly
“In-disguise” Anomaly
Type of Anomalies
Type of Anomalies
Substructures
Alterations
Simple Graph:
Random Walk
[Moonesinghe 2006]
Bipartite Graph:
Relevance Search
[Sun 2005]
kNN Graph: Densitybased Method
[Hautamaki 2004]
Description
Length Principle
[Chakrabarti
Subdue-based
[Noble 2003]
Measurement
[Lin 2003]
Tensor-based
[Sun 2006]
Description
[Eberle 2007]
Event-based
[Shetty 2005]
Fig. 2 A summary of the various research directions in graph-based anomaly detection
Research on “white crow” anomaly detection has traditionally focused on exploring three different types of anomalies. Aiming to identify anomalous nodes,
Moonesinghe and Tan proposed a random walk–based approach that represents the dataset as a weighted undirected graph. Similarly, an algorithm based on
random walks with restarts was used by Sun et al. for relevance search in an
unweighted bipartite graph, in which vertices with low normality scores were treated
as anomalies. Hautamäki et al. took a different approach and applied two
density-based outlier detection methods to discover novelty vertices in a k-nearest
neighbour graph. To identify unusual edges, Chakrabarti used the minimum
description length principle to identify outlier edges, or the edges whose removal
would best compress the graph. With the purpose of finding abnormal patterns, Noble
and Cook used a variant of the minimum description length principle to deal
with both anomalous substructures and anomalous subgraphs, based on their Subdue
J Intell Inf Syst
system. In contrast to Noble and Cook , Lin and Chalupsky applied
rarity measurements to discover unusually linked entities within a labeled directed
Unlike the previously mentioned single graph algorithms, Cheng et al. 
provided a robust algorithm for discovery of anomalies in noisy multivariate time
series data. To deal with higher order data, Sun et al. introduced a tensorbased approach. Other related work on “white crow” anomaly detection can be found
in Chan and Mahoney , Sun et al. , Keogh et al. and others.
“In-disguise” anomalies are more difficult to detect because they are highly hidden
in the graph, and less work has been reported on detecting such anomalies. Eberle
and Holder introduced three algorithms based on the minimum description
length principle for the purpose of detecting three categories of anomalies that
closely resemble normal behavior, including label modifications, vertex/edge insertions, and vertex/edge deletions. In addition, Shetty and Adibi exploited an
event-based entropy model that combines information theory with statistical techniques to discover hidden prominent people in an Enron e-mail dataset. However,
none of these work is focused on detecting “in-disguise” anomalies in multiple graphs.
Meanwhile, neither “white crow” nor “in-disguise” anomaly detection approaches
have considered one of the important properties of evolutionary networks: their
community structure, which is sometimes referred to as clustering .
Networks of dynamic systems can be highly clustered .
A community, defined as a collection of individual objects that interact unusually
frequently, is a very common substructure in many networks , including social networks, metabolic and protein interaction networks,
financial market networks, and even climate networks. In social networks, a community is a real social grouping sharing the same interests or background . In biological networks, a community might represent a set of proteins
that perform a distinct function together. Communities in financial market networks
might denote groups of investors that own the same stocks, and communities in
climate networks might indicate regions with a similar climate or climate indices.
Many algorithms have been developed for detecting community structures in
static graphs. Girvan and Newman proposed a community discovery algorithm based on the iterative removal of edges with high betweenness scores. To
reduce the computational cost of the betweenness-based algorithm, Clauset et al.
 proposed a modularity-based algorithm. In contrast, Palla et al. did not
focus on detecting separate communities, but on finding overlapping communities.
Defining communities as maximal cliques, Schmidt et al. proposed a parallel,
scalable, and memory-efficient algorithm for their enumeration.
In addition, some work has been done on detecting conserved or stable communities in evolutionary networks. Hopcroft et al. proposed a method that utilizes
a “nature community” to track stable clusters over time. A framework for identifying
communities in dynamic social networks, proposed by Tantipathananandh et al.
 , makes explicit use of temporal changes. Using the Clique Percolation Method
to locate communities, Palla et al. defined auto-correlation and stationarity
to characterize a community. From an application perspective, Steinhaeuser et al.
 provided a method to identify climate regions by detecting communities in
time-varying climate networks.
J Intell Inf Syst
Communities in real networks change over time, and being able to detect small
community deviations can help us understand and exploit these networks more
effectively. For example, in biological networks, a small variation in a gene-gene
association community may represent an event, such as gene fusion , gene fission , gene gain , gene decay , or gene duplication , that would change the properties
of the gene products (e.g., proteins) and, consequently, affect the phenotype of
the organism. Interesting community deviation patterns in Food Web and social
networks are discussed in Section 3.
Thus, in contrast to the previous work on identifying communities or tracking
conserved communities, we focus on detecting community-based anomalies, a new
type of “in-disguise” anomalies, in dynamic networks. Specifically, our work proposes the novel problem of detecting these “in-disguise” anomalies across multiple
dynamically evolving graphs, or evolutionary networks, for short. Our approach
follows from the need to address the following four challenges:
How do we define community-based anomalies, and how many types of
community-based anomalies are possible in evolutionary networks? From an
anomaly detection perspective, we are interested in dynamic, abnormal communities that would reveal novel properties of the network, as opposed to
conserved communities or communities at a single snapshot. For example, is
there a community at snapshot t that splits into smaller communities or merges
with others at snapshot t + t? Does any community at snapshot t disappear at
snapshot t + t, or does any new community appear at snapshot t + t? Do the
sizes of the communities change over time?
Most real networks are dynamic and characterized by overlapping communities
 . Detecting dynamic communities from networks characterized
by overlapping communities is more challenging than discovering communities
in static networks.
How do we detect community-based anomalies across multiple dynamically
evolving networks? As we mentioned earlier, real-world networks change over
time, requiring us to adopt evolutionary analysis techniques to detect such
anomalies.
Since there may be hundreds or even thousands of communities in each realworld network, how to scale a community-based anomaly detection algorithm to
large graphs?
In this paper, we propose solutions to all four of these problems. Our algorithm is based on the proposed notion of graph representatives and community
representatives. Graph representatives helps us reduce the expensive computational
cost of enumerating communities, which we model as maximal cliques, whereas
community representatives is utilized to identify community-based anomalies.
The contributions of our work are:
We identify a new type of anomaly—the community-based anomaly in complex
evolutionary networks.
Our work tackles the unexplored question of detecting “in-disguise” anomalies
across multiple graphs.
J Intell Inf Syst
We prove that there are only six possible types of community-based anomalies
in dynamic simple undirected graphs.
We develop a community-based anomaly detection algorithm based on graph
representatives and community representatives.
We evaluate our method on real datasets to confirm its applicability in practice.
The rest of the paper is organized as follows: Section 2 introduces some necessary
definitions and formally defines the problem. In Section 3, we show application
of community-based anomaly detection to two real-world dynamic networks, Food
Web and Enron Email. Section 4 presents the community-based anomaly detection
algorithm. In Section 5, we evaluate the algorithm with synthetic data. Finally,
Section 6 concludes the paper.
2 Problem statement
In this paper, the ultimate goal is to find community-based anomalies in dynamic graphs, and our algorithm is based on graph representatives and community
representatives. Thus, the following terms and problems need to be addressed. The
symbols used in the paper are listed in Table 1.
Problem 1 (Community-based anomaly detection) Given a time-varying sequence
of undirected simple graphs G = {G1, G2, G3, ...}, where the nodes in each graph can
belong to different communities, detect the community-based anomalies between
consecutive graphs, including grown, shrunken, merged, split, born, and vanished
communities (see Definition 7).
Definition 1 (Community) Communities are the maximal cliques in a graph.
There is no formal definition for the community structure in a network . The simplest and the most conservative definition of a commu-
Table 1 Symbol table
Description
A simple undirected labeled graph
A sequence of graphs
The community of index i in graph Gt
The representative node set of graph Gi
t is a predecessor of C j
t+1, or C j
t+1 is a successor of Ci
The node set of community Ci
Common nodes between graphs Gi and Gi+1
The size of community C
The number of timestamps in the sequence
The number of vertices in community C
A vertex j in a graph
The list of communities in Gi
The list of communities that contain node v j in graph Gi
Checked(Gi)
The list of nodes in Gi that have been checked
The empty set
J Intell Inf Syst
nity is a clique, a set of vertices that are pairwise adjacent to one another. Another
definition used by Girvan and Newman is a dense subgraph, a group of
vertices within which the connections are denser than between different groups
 .
As our goal is to detect abnormal, changing communities, we propose to use the
more specific community definition, namely clique. From an application perspective,
we could lose important information if we shifted to dense subgraphs as communities. For example, consider protein functional modules (biological communities) in
protein-protein interaction networks. Across different organisms, such evolutionary
networks might have undergone small changes, or perturbations, due to evolutionary
events such as gene fusion, gene fission, gene gain, gene decay, or gene duplication. Relatively small perturbations to the network structure due to the genotype
variation may induce phenotype variations, such as organism’s capability to produce
hydrogen or ethanol, to resist high temperature, to fix nitrogen, etc. Since network
perturbations could be infinitesimal, considering communities as dense subgraphs
with respect to some density parameter, may arguably be insufficient for capturing
such fine-grain changes to the network structure. Therefore, we propose to use the
simplest, the most stringent, and parameter-free definition of a community—a clique.
We use the maximal clique, i.e., a clique that can’t be extended by adding any more
vertices in order to decrease the space of putative anomaly-based communities to
evaluate and thus to reduce the overall computational cost.
Definition 2 (Community size) The community size, |C|, is the number of vertices in
the community, so |C| = |V(C)|.
Definition 3 (Graph representative) Representatives of graph Gi are the nodes that
also appear in Gi−1, Gi+1, or both. Thus, Rep(Gi) = {vi | vi ∈V(Gi) ∩(V(Gi−1) ∪
V(Gi+1))}.
Nodes that only appear in one graph are called graph-specific nodes or vertices.
Definition 4 (Graph-specific community) A graph-specific community is a community that does not contain any graph representative.
Since our goal is to detect community-based anomalies, we do not try to discover
graph-specific communities. Thus, by using graph representatives as seeds, we do
not need to enumerate all communities in the graphs, only those communities that
contain graph representatives, and thus potentially reducing computational time (see
Section 4 for details).
Definition 5 (Community predecessor and successor) If community Ci
t at snapshot
t is a subset or superset of community C j
t+1 at snapshot t + 1, then the community Ci
is a predecessor of C j
t+1, and C j
t+1 is a successor of Ci
t. This relationship is denoted by
Definition 6 (Community representative) A community representative of Ci
node in Ci
t that has the minimum number of appearances in other communities of the
J Intell Inf Syst
same graph. If there is more than one node that satisfies this condition, we choose
one at random.
The rationale for our definition of a community representative follows from the
observation that the community Ci
t can be represented by a node that only appears
in community Ci
t. However, since the communities in our networks may be highly
overlapping, we cannot guarantee that such a node exists, so we look for a node
t that has the minimum number of appearances in other communities to use
as its representative. In this way, we limit the nodes that belong to more than one
community from being a community representative, which helps to establish the
relationships between the communities (see Section 4 for details).
Definition 7 (Community-based anomalies) In contrast to Palla et al. , which
focuses on the stability/stationarity of the communities, our goal is to detect
community-based anomalies. As there are six basic events that may occur to a
community , we can define six possible types of community-based
anomalies in evolutionary networks (see Fig. 3).
Grown community
In real-world networks, some “big” communities, like community 2, can be
grown from previous “smaller” communities by adding some new members.
These “big” communities are called grown communities.
Fig. 3 Possible types of
community-based anomalies
in evolutionary networks
Grown Community
Shrunken Community
Merged Community
Split Community
Born Community
Vanished Community
J Intell Inf Syst
Shrunken community
On the other hand, shrunken communities, like community 4, are communities
caused by previous “bigger” communities losing some members.
Merged community
In addition, two or more “small” communities at snapshot t often join together
to form one merged community, like community 7, at snapshot t + 1.
Split community
Meanwhile, a split community at snapshot t, like community 8, may break up into
multiple communities at snapshot t + 1.
Born community
What’s more, some “new” communities, like community 11, may appear in some
snapshots, but born communities should contain at least one graph representative in order to avoid considering graph-specific communities as anomalies.
Vanished community
Alternatively, some “old” communities, like community 12, may disappear.
Similar to born communities, vanished communities should contain at least one
graph representative to exclude graph-specific communities.
Evolutionary network conservation, which is often manifested with stable communities that do not change over time, is a well-recognized property of many
real-world complex dynamic networks. For example, in climate networks, such
communities may correspond to well-known climate indicies. Likewise, in biological
networks, such stable communities may correspond to protein complexes, such as
ATP synthase or ribosomal machinery, and metabolic pathways, such as TCA cycle.
In contrast to stable communities, an anomalous community is often highly hidden
among an enormous number of stable communities in evolutionary networks. In realworld networks, like social networks, a majority of people’s friendship communities
tend to be stable despite frequently occuring changes in individuals’ activities and
communication patterns .
It is often the case, especially if t is small, that only very few communities
might slighly change due to some anomalous events. For example, resignation of the
CEO in a company may induce changes to community composition, if community
membership is defined by email communication traffic between a sender and a
receiver. Likewise, in climate networks, the seasons of unusually high hurricane
activity are likely induced by changes in climate communities found in the climate
networks for the seasons with low hurricane activity. Thus, rare and anomolous
events are likely caused by or induce structural changes in the communities, and
result in the appearance of anomalous communities. Such anomalous communities
often overlap with other “normal” (or stable) communities, which makes it even
more difficult to distinguish between normal and anomolous communities. Thus,
community-based anomaly can be seen as a new type of “in-disguise” anomaly.
3 Application of community-based anomaly detection to real-world
dynamic networks
In addition to the more controlled experiments using synthetic graph data sets, as
described in Section 5, we applied our algorithm to two real-world dynamic networks,
J Intell Inf Syst
Table 2 Food Web communities
Abnormal communities
communities
Four grown communities, one born community, four communities will
split in fall, one vanished community, and one merged community
Two shrunken communities and four vanished communities
(will disappear in winter)
Four merged communities
Food Web and Enron Email. In this section, we consider only communities of size
three or more.
Food Web dataset
The Food Web dataset, which was originally compiled by Baird
and Ulanowicz , consists of marine organisms living in the Chesapeake Bay,
containing 33 vertices that represent the ecosystem’s most prominent taxa. Edges
Phytoplank
Other suspen
phytoplank
Other suspen
Alewif&blue
Alewif&blue
Grown Communities:
Shrunken Communities:
Fig. 4 Example of a grown community and a shrunken community in Food Web
J Intell Inf Syst
Fig. 5 Example of a split
community and a merged
community in Food Web
Zoo plankton
Merged Communities:
Split Communities:
Ctenophore
Ctenophore
between taxa denote trophic relationships—one taxon feeding on another. Here, we
ignore directionality and consider the network as an undirected graph. Girvan and
Newman has used this dataset as a static graph to detect the communities,
while we construct the networks on a seasonal basis from spring to winter to discover
community-based anomalies in the dynamic network.
By applying our algorithm to the Food Web networks, we find instances of all
six types of community-based anomalies (see Table 2). Summer is the most active
community changing season: four communities grow because microzooplankton,
which cannot be found in Spring, become involved in the energy flow network. Four
communities split because bacteria do not feed on microzooplankton in Fall. The
disappearance of sea nettle in the Fall results in a vanished community (zooplankton,
ctenophore, and sea nettle). This community was a born community in Summer,
indicating that it is unstable. Due to a lack of food in Winter, four communities merge
in order to benefit from more members with food energy. Typical community-based
anomaly examples discovered in Food Web are shown in Figs. 4, 5 and 6. Note that
Sea nettle
Ctenophore
Born Community:
Vanished Community:
Fig. 6 Example of a born community and a vanished community in Food Web
J Intell Inf Syst
Table 3 Enron email dataset
properties
Number of edges
Number of communities
the different circles represent different communities at the same time stamp—we can
see that Food Web is characterized by overlapping communities.
ENRON dataset
This data set consists of approximately 1.5 million email communications sent or received by employees in Enron, Inc. It is much more complex
than the Food Web dataset. We take a subset containing only messages between
Enron employees from January to December of 2001 and construct sender-torecipient undirected graphs on a monthly basis. The graphs have 151 nodes (Enron
employees), with low edge density and short average distance between vertices,
which shows a “small-world” effect and indicates that the graphs have community
structure. The properties of each graph are shown in Table 3.
The community-based anomalies in each month discovered by our algorithm are
shown in Table 4. We can see that there are more abnormal communities in October
than in any other month. The most likely trigger of this event is the fact that Enron
announced a third quarter loss of $618 million on October 16 of 2001, which is also
thought to be the trigger of the Enron scandal.
In order to see the details of the community-based anomalies in October, let us
consider one of the most important nodes—Louise Kitchen, the former President of
Enron. There are 20 abnormal communities containing Louise Kitchen in October:
Table 4 Community–based anomalies in enron email dataset
J Intell Inf Syst
16 born communities, 4 grown communities, 1 split community, and 1 shrunken
community. From Fig. 7, we can see that some employees like Sally Beck, Chief
Operating Officer, joined the senior management communication groups, probably
to discuss the serious issues or suggest strategies, while only one person—Phillip
Shrunken Community:
Grown Communities:
Split Community:
Fig. 7 Abnormal communities containing Louise kitchen in October
J Intell Inf Syst
Fig. 8 Shrunken communities due to Jeff Skillng resigning as CEO in August
Allen—left the groups. Confusion among the Enron employees may be why Louise
Kitchen’s communication groups grew rather than shrank during the turbulent
times. As a second example, take Jeff Skilling, the former CEO of Enron. There
are 19 email communities contain Jeff Skilling in August, but among these, three
communities shrank in September (see Fig. 8), while the other 16 communities
disappeared after Jeff Skilling resigned as CEO in August, perhaps because many
employees quit or joined other work groups after Skilling’s resignation.
4 Community-based anomaly detection algorithm
In this section, we discuss the proposed algorithm for solving the problem presented
above. We prove some necessary lemmas and theorems in Section 4.1. Then, based
on the abnormal community decision rules described in Section 4.2, we illustrate how
to detect community-based anomalies in Section 4.3.
4.1 Lemmas and theorems
We present the following theorems and lemmas to provide a sound theoretical basis
for our community-based anomaly detection. Proofs for these appear in Appendix.
Lemma 1 If community Ci
t has more than one predecessor (or successor), then the
sizes of its predecessors (or successors) are either all larger than
 or all smaller
Similarly, if a community Ci
t has more than one successor, then the sizes of its
successors are either all larger than
 or all smaller than
. This lemma is used
to prove the following completeness result:
Theorem 1 Let Gt and Gt+1 both be simple, undirected graphs, where communities
are defined as maximal cliques. If Gt+1 is the perturbed graph formed by either adding
edges/nodes to or removing edges/nodes from the baseline graph Gt, then there are
only six possible types of community-based anomalies between Gt and Gt+1: grown
J Intell Inf Syst
communities, shrunken communities, merged communities, split communities, born
communities, and vanished communities, as defined in Definition 7.
Lastly, we present a theorem that will allow us to reduce the computational
complexity of identifying the community-based anomalies.
Theorem 2 If community Ci
t is represented by vertex vi ∈Ci
t, and community C j
represented by vertex v j ∈C j
t+1, where Ci
t+1, then vi ∈C j
t+1 or v j ∈Ci
From Theorem 2, if there is more than one node in community Cm
satisfies the condition of community representative, then we can randomly choose
vm to represent Cm
t and vn to represent Cn
t+1 to help check the relationship between
t+1 as follows:
t+1, then Cn
t+1 can be detected as a potential successor to Ci
Definition 5, the relationship Cm
t+1 would be established if Cn
satisfies Cm
If vm /∈Cn
t+1, then by Theorem 2, vn ∈Cm
t+1. In this case, we can
detect the relationship Cm
t+1 through vn and check whether Cm
Thus, random selection of the community representative will not affect our
detection results.
4.2 Abnormal community decision rules
Based on our result from Theorem 1, we can identify community-based anomalies
using the following rules:
If community Ci
t has only one predecessor C j
If the size of the predecessor is smaller than
, then Ci
t is a grown
community.
If the size of the predecessor is larger than
t is the only successor
t−1, then Ci
t is a shrunken community.
If the size of the predecessor is larger than
t is not the only
successor of C j
t−1, then Ci
t is a product of the split community C j
If community Ci
t has more than one predecessor:
If the sizes of the predecessors are all smaller than
, then Ci
t is a merged
community.
If the sizes of the predecessors are all larger than
t is the only
successor of one of its predecessors, then Ci
t is a shrunken community.
If the sizes of the predecessors are all larger than
t is not the
only successor of one of its predecessors, then that community is a split
community and Ci
t is one of its products.
If community Ci
t has no predecessor, then Ci
t is a born community.
If community Ci
t has no successor, then Ci
t is a vanished community.
J Intell Inf Syst
4.3 Algorithm description
In this section, we describe our method for detecting and tracking anomalous
communities based on the proposed notion of graph representatives and community
representatives.
To the best of our knowledge, the proposed problem of detecting and tracking
community-based anomalies in evolutionary networks has not been addressed in
literature. Thus, for comparison purposes, we first briefly describe a brute-force
solution that does not use graph representatives and community representatives.
Then, we provide details on how graph representatives can help reduce the expensive
computational cost caused by community enumeration, and how community representatives can be utilized to effectively identify community-based anomalies.
Non-representative-based method
A brute-force solution that does not use graph or
community representatives is to first enumerate all communities in each graph, and
then compare all possible pairs of communities belonging to consecutive timestamps.
For example, to find the successors of community A in Fig. 9, we need to compare
community A with communities D, E, F, and K at snapshot t + 1; that is, we compare
community A with all communities at snapshot t + 1, although only community F is
the successor of A. This two-stage approach is infeasible and impractical, because
of a possibly enormous number of communities to search. Among those, there are
many redundant communities (e.g., graph-specific communities (see Definition 4))
in each graph, and it does not make much sense to compare pairs of communities
that contain no common members or few members.
Representative-based method
To reduce the computational cost, we designed an
algorithm based on the graph representatives and community representatives (see
Definition 3 and 6 in Section 2). The workflow of the algorithm is shown in Fig. 10.
For each graph, we first find graph representatives (see Step 1 in Fig. 10) and enumerate the communities that are seeded by the graph representatives to avoid generating
graph-specific communities (see Step 2 in Fig. 10). We call these communities seedcommunities. In every seed-community, we select only one node as a community
representative (see Step 3 in Fig. 10) and use community representatives to establish
Fig. 9 Example for tracking community-based anomalies using the non–representative-based
J Intell Inf Syst
Fig. 10 Workflow of the
community-based anomaly
detection algorithm
Sequence of Dynamic Graphs
Step 1: Identify
Step 2: Emumerate
Step 4: Establish
Step 5: Detect
Born Community:
Grown Community:
Graph Representatives
Communities
Step 3: Identify
Community Representatives
Community Relationships
predecessor–successor relationships between a pair of seed-communities from two
consecutive graphs (see Step 4 in Fig. 10). Once all the predecessors and successors
of the community Ci
t have been found, we apply the abnormal community decision
rules in Section 4.2 to determine the type of anomaly present, if any (see Step 5 in
Let us apply the representative-based algorithm to the same example in Fig. 9.
Instead of enumerating all communities, the algorithm first identifies the set of
J Intell Inf Syst
Fig. 11 Example for tracking community-based anomalies using the representative-based
method. Triangles: community representatives; Filled shapes: graph representatives; Empty shapes:
graph-specific vertices; Circles: communities; Dashed lines: predecessor–successor community
relationships
graph representatives, which are the filled triangle or rectangle nodes highlighted
in Fig. 11. Using graph representatives as seeds to generate communities, graphspecific communities (see Definition 4), like communities K and L in Fig. 9, now
disappear (see Fig. 11). This strategy could possibly save a lot of computational cost
on community enumeration. Once, we generate the seed-communities in each graph,
the algorithm searches for community representatives (triangular nodes in Fig. 11)
by selecting the vertices that appear in the fewest number of communities.
Taking advantage of community representatives, the algorithm can establish the
predecessor–successor community relationships much more efficiently. Let us take
community A at timestamp t, for example. To find the successor(s) of community A,
the algorithm first finds all the communities that contain the community representative of A at timestamp t + 1. In this case, only community F contains the community
representative. Then, the algorithm checks whether community F is a subset or
superset of A (see Definition 5). Only if one of these two conditions holds true
does the algorithm establish the predecessor–successor relationship between A and
F. When there are only grown, merged, born, or vanished community anomalies, the
algorithm does not need to consider commmunities earlier in the sequence of graphs.
For example, community A grows into community F, communities B and C merge
into E, community D emerges, and community F disappears. However, in cases of
shrunken or split communities, the algorithm may need to “backtrack” by using the
representative of community Ci
t to look for its predecessors at timestamp t −1. For
example, community D shrinks into I with the disappearance of representative 12
at timestamp t + 2, and community E splits into H and G with representative 3 ∈H
but 3 /∈G. To detect these anomalies, the algorithm needs to connect communities
G and I at timestamp t + 2 to communities E and D, respectively, at timestamp t + 1
by “backtracking” the community representatives of G and I (6 and 10).
From Fig. 11, we can also see that if there is more than one node in the same
community with the minimum number of appearances in other communities, then
randomly choosing one node as a community representative would not affect the
J Intell Inf Syst
detection results. For example, if we choose 9 instead of 1 as representative of
community A or 8 instead of 3 as representative of B, we will still identify F as
successor of A and E as the successor of B, since all nodes in the predecessors of the
grown (or merged) community will also appear in the grown (or merged) community.
Namely, if the representative of Ci
t appears in the successors of Ci
t, then we will
find all such successors for Ci
t, because we check all communities that contain the
representative of Ci
t at timestamp t + 1. Even if the representative of Ci
t disappears
in some successors of Ci
t, we can still establish the relationship between Ci
its successors by “backtracking” from the representatives of its successors, like the
example of communities G, I, E, and D shown previously.
Once the community relationship is established, the algorithm uses the decision
rules (see Section 4.2) to determine whether a community is an anomaly, based on
the numbers and sizes of its predecessors and successors:
A grown community, like community F in Fig. 11, can be detected by comparing
the communities at the prior timestamp that contain the community representative 1 of F (community A, in this case). Because community F is larger than
its predecessor A and has no other predecessors, based on decision rule 1a,
community F is a grown community.
A shrunken community, like community J in Fig. 11, can be detected by decision
rule 1b, since it has only one larger predecessor.
A community, such as community E that has two smaller successors–community
H and G is identified as a split community (see decision rule 1c).
A community, such as community E, is also detected as a merged community by
the algorithm, because it has two smaller predecessors, community B and C, at
timestamp t (see decision rule 2a).
A community, like community M that has no predecessor (see decision rule 3),
is detected as a born community.
A community, like community J that has no successor (see decision rule 4), is
identified as a vanished community.
We give a pseudocode description for our representative-based community anomaly detection algorithm in Algorithm 1. The input to the Algorithm 1 is a sequence of
undirected graphs. Lines 1–12 are concerned with finding the graph representatives
for each graph in the sequence and enumerating all the communities in each graph
using the graph representatives as seeds. In lines 13–20, the algorithm calculates the
number of times each node in each seedcommunity appears in each graph. It chooses
one node with the fewest occurence in each community as the community representative (line 22). In line 23 through line 28, the algorithm establishes predecessor–
successor community relationships. Since some community representatives may
disappear in the successors of the community, lines 29 through 35 backtrack to
establish community relationships between communities in the preceding timestep.
This way, the algorithm can establish all community relationships. Finally, lines 37
through 41 apply the abnormal community decision rules to these relationships to
identify the community-based anomalies. Thus, if any community in each graph
belongs to one of six possible types of community-based anomalies, the algorithm
will detect this anomaly and return its anomaly type.
J Intell Inf Syst
5 Effectiveness of representative-based methodology
In this section, we evaluate the community-based anomaly detection algorithm on
synthetic graph datasets to have a more controlled settings for assessing alogirthmic
performance. These experiments complement the discoveries and insights offered by
our algorithm when applied to real-world network data, Food Web and Enron Email
datasets, as described in Section 3. Specifically, we focus on answering the following
two questions:
What is the performance of the community-based anomaly detection algorithm
using our representative-based technique?
Is our algorithm scalable to large graphs?
We study the performance of the community-based anomaly detection algorithm
relative to the non–representative-based algorithm on synthetic networks of increasing size. Our experiments were conducted on a PC with an Intel Core 2 Duo CPU
(2.1GHz) and 4GB of RAM. Our algorithm was implemented in the C programming
language, and is available upon request. We measure the improvement in the runtime
of our algorithm versus the non-representative-based algorithm in terms of speedup,
which we calculate by dividing the runtime of non–representative-based algorithm to
the runtime of our algorithm.
In this experiment, we study the effectiveness of the proposed representativebased technique. All the graphs in the synthetic datasets are generated by GTgraph and follow the Recursive Matrix Graph model
(R-MAT) so that they have a small-world nature. The
parameters for the synthetic graphs, which appear in Table 5, are defined as follows:
|V| is the number of vertices in a graph, Numgv is the number of graph-specific
vertices in a graph, and Ei is the number of edges in a graph Gi. On all graphs,
we use default values of 0.45, 0.15, 0.15 and 0.25 for the R-MAT parameters a, b, c,
d, with a : b and a : c ratios of 3:1, as in many real world graphs . After graph enumeration, we use a program to re-label some of the vertices
according to the parameter Numgv, so that we can have some graph-specific vertices
in each graph when we build the sequence of graphs. For example, in the dataset
syn_500, we can relabel the vertices v j ∈ in graph Gi as v j + 50 ∗(i −1).
Other graph-specific vertices in other datasets can be similarly re-labeled.
In the first experiment, we try to test the collective effectiveness of graph
representatives and community representatives in our algorithm. We measure the
entire runtime of the representative-based algorithm and the non–representativebased algorithm in each of the synthetic datasets. The result of the experiments
Table 5 Summary of synthetic datasets
syn_1000_1
syn_1000_2
syn_1000_3
J Intell Inf Syst
J Intell Inf Syst
Table 6 Performance comparison on synthetic data
syn_1000_1
on the datasets syn_500, syn_1000_1, syn_1500, syn_2000, and syn_3000 are shown
in Table 6, where Tnon is the runtime of the non–representative algorithm, Trep
is the runtime of representative algorithm, and the last six columns are the counts
of the six types of anomalies detected by the algorithm. From Fig. 12, we can see that
the representative-based algorithm achieves a speedup of 11–46 times with respect
to the non–representative-based algorithm. Additionally, the experimental results
show that our algorithm is scalable to large graphs.
In the second experiment, we try to test the sole effectiveness of graph representatives in the community enumeration step. We use our in-house parallel
MCE algorithm (available upon request) to enumerate the
communities in each graph for both algorithms. However, as discussed in Section 4.3,
we enumerate all the communities in each graph for the non–representative-based
method, but in the representative-based algorithm, we use the graph representatives
as seeds to avoid graph-specific community enumeration.
The results are shown in Table 7, where NCnon is the number of cliques enumerated by the non–representative-based method, NCrep is the number of cliques
enumerated by the representative-based method, TCnon is the runtime of community
enumeration using the non–representative-based method, and TCrep is the runtime
of community enumeration using representative-based method.
As shown in Table 7, the representative-based method achieves speedups of
more than 1.1 in community enumeration on the dataset syn_1000_1, in which 10%
of the vertices are graph-specific vertices; speedups of around 1.4 on the dataset
syn_1000_2, in which 20% of the vertices are graph-specific vertices; and speedups of
around 2 on the dataset syn_1000_3, in which 30% of the vertices are graph-specific
vertices. The experiments on the datasets syn_500, syn_1500, syn_2000, and syn_3000
Fig. 12 Runtime speedup of
the representative-based
algorithm over the
non–representative-based
algorithm. The time to
perform I/O operations is
syn_1000_1 syn_1500
J Intell Inf Syst
Table 7 Effectiveness of graph representatives
syn_1000_1
syn_1000_2
syn_1000_3
also show that the representative-based method can achieve a speedup of at least
1.1 in the community enumeration step, when the dataset has 10% graph-specific
6 Conclusion
In this paper, we have defined a new type of “in-disguise” anomaly, the communitybased anomaly. In addition, we have proven that there are only six possible types
of community-based anomalies in evolutionary networks: grown, shrunken, merged,
split, born, and vanished communities. We have proposed a new method based on
graph representatives and community representatives to reduce the computational
cost. Based on the abnormal community decision rules, our algorithm can discover
meaningful results in evolutionary networks that cannot be detected by other graphbased anomaly detection algorithms. The main properties of our algorithm are as
it is parameter-free and automatic by nature;
it is applicable to evolutionary networks characterized by overlapping communities; and
it is scalable to large networks.
We have demonstrated the effectiveness of our algorithm over a number of
synthetic as well as practical examples. Experimental results on real-world networks
show that our algorithm can detect meaningful community abnormalities.
Acknowledgements
The authors would like to thank Matthew C. Schmidt for his maximal clique
enumeration program code, and we would like to thank Kevin A. Wilson and Ye Jin for valuable
discussions.
J Intell Inf Syst
Proofs for Theorems and Lemmas of Section 4.1
Lemma 1 If community Ci
t has more than one predecessor (or successor), the sizes
of its predecessors (or successors) are either all larger than
 or all smaller
Proof Suppose otherwise, that C1
t has a predecessor with smaller size, as well as
one with a larger size. Let C1
t−1,..., Cn
t−1 (where n ≥2) be all predecessors
t, and suppose that
 for some 1 ≤j, k ≤n, j ̸= k.
From Definition 5 and the sizes of the three communities, we know that C j
t−1, so C j
t−1. However, C j
t−1 and Ck
t−1 are both maximal cliques
in the same graph, and C j
t−1 contradicts the definition of a maximal clique.
Therefore, it is impossible to have the size of one predecessor be larger than the size
of the community and the size of another predecessor be smaller than the size of the
community.
Theorem 1 Let Gt and Gt+1 both be simple, undirected graphs, where communities
are defined as maximal cliques. If Gt+1 is the perturbed graph formed by either adding
edges/nodes to or removing edges/nodes from the baseline graph Gt, then there are
only six possible types of community-based anomalies between Gt and Gt+1: grown
communities, shrunken communities, merged communities, split communities, born
communities, and vanished communities, as defined in Definition 7.
Proof Assume that C1
t , . . . , Cm
are all communities in Gt and that V1
. . . , Vm
are the node sets of the communities, respectively. Also assume that
t+1, . . . , Cn
t are all communities in Gt+1 and that V1
t+1, . . . , Vn
t+1 are the
node sets of the communities, respectively. Here, we define Vi
t+1 to mean that
t only contains all the nodes in V j
To determine the type of a specific community, we only need to compare the node
sets of communities in Gt+1 with the node sets of communities in Gt. If V j
where 1 ≤i ≤m and 1 ≤j ≤n, then community C j
t+1 contains exactly those nodes in
community Ci
t, which means that C j
t+1 is a conserved community and not an anomaly.
In the following, we consider all possible anomalies by analyzing all possible
mappings between predecessors and successors. In particular, when deciding if
community Ci
t is an anomaly, we do not need to consider the situation where Ci
a single successor as long as we have covered all cases for the predecessors of C j
the community Ci
t has only one successor C j
t+1, then the community C j
t+1 should have
either one predecessor or more than one predecessor, both of which can be covered
by using predecessor conditions. The same reasoning applies for not considering the
case where a community has more than one successor of larger size. In other words,
we need to consider all cases for predecessors, but only two cases for successors: when
J Intell Inf Syst
a community has no successor and when a community has more than one successor
of smaller size.
For a specific j (where 1 ≤j ≤n), there is at least one i (where 1 ≤i ≤m)
that satisfies V j
t. Then, by Definition 5, community C j
t+1 has at least
one predecessor, including Ci
t, with larger size than C j
t+1. Let I = {i | V j
There are two non-exclusive sub-cases here:
For ℓ∈I, if there is some k (where 1 ≤k ≤n) other than j that satisfies
t , then Cℓ
t has more than one smaller-size successor (C j
t+1). Additionally, by Lemma 1, we know that Cℓ
t cannot have a successor
with larger size than C j
t . Thus, Cℓ
t is a split community, and C j
t+1 is one of its
For ℓ∈I, if there is no k (where 1 ≤k ≤n) other than j that satisfies Vk
t , then Cℓ
t has only one smaller-size successor C j
t+1, and C j
t+1 has at least
one predecessor, including Cℓ
t , with larger size. Also, by Lemma 1, we know
t+1 cannot have a predecessor with smaller size than C j
t+1. Thus, C j
is a shrunken community.
For a specific j (where 1 ≤j ≤n), there is only one i (where 1 ≤i ≤m) that
satisfies V j
t. Then, community C j
t+1 has one predecessor Ci
t with smaller
size than C j
t+1. Additionally, by Lemma 1, we know that C j
t+1 cannot have
a predecessor with larger size than C j
t+1. Thus, community C j
t+1 is a grown
community.
For a specific j (where 1 ≤j ≤n), there is more than one i (where 1 ≤i ≤m) that
satisfies V j
t. Then, community C j
t+1 has more than one predecessor with
smaller size. Also, by Lemma 1, we know that C j
t+1 cannot have a predecessor
with larger size than C j
t+1. Thus, community C j
t+1 is a merged community.
For a specific j (where 1 ≤j ≤n), there is no i (where 1 ≤i ≤m) that satisfies
t, which means that community C j
t+1 has no predecessor.
t+1 is a born community.
For a specific i (where 1 ≤i ≤m), there is at least one j (where 1 ≤j ≤n) that
satisfies V j
t. Let J = { j | V j
t}. Then, for each k ∈J, there is at least
one i (where 1 ≤i ≤m) that satisfies Vk
t, which is case 1. Thus, this case
can be converted to case 1.
For a specific i (where 1 ≤i ≤m), there is at least one j (where 1 ≤j ≤n) that
satisfies V j
t. Let J = { j | V j
t}. Then, for each k ∈J, there is at least
one i (where 1 ≤i ≤m) that satisfies Vk
t, which is case 2 or 3. Thus, this
case can be converted to case 2 or 3.
For a specific i (where 1 ≤i ≤m), there is no j (where 1 ≤j ≤n) that satisfies
t, which means that community Ci
t has no successor. Thus,
t is a vanished community.
Since all relationships between V j
t+1 (where 1 ≤j ≤n) and Vi
t (where 1 ≤i ≤m)
have been covered, there are only six possible different types of community-based
anomalies.
J Intell Inf Syst
Theorem 2 If community Ci
t is represented by vertex vi ∈Ci
t, and community C j
represented by vertex v j ∈C j
t+1, where Ci
t+1, then vi ∈C j
t+1 or v j ∈Ci
Proof By Definition 5, Ci
t+1 implies that Ci
t+1 or C j
then vi ∈C j
t+1, and if C j
t, then v j ∈Ci