Why does deep and cheap learning work so well?∗
Henry W. Lin, Max Tegmark, and David Rolnick
Dept. of Physics, Harvard University, Cambridge, MA 02138
Dept. of Physics, Massachusetts Institute of Technology, Cambridge, MA 02139 and
Dept. of Mathematics, Massachusetts Institute of Technology, Cambridge, MA 02139
 
We show how the success of deep learning could depend not only on mathematics but also on
physics: although well-known mathematical theorems guarantee that neural networks can approximate arbitrary functions well, the class of functions of practical interest can frequently be approximated through “cheap learning” with exponentially fewer parameters than generic ones. We explore
how properties frequently encountered in physics such as symmetry, locality, compositionality, and
polynomial log-probability translate into exceptionally simple neural networks. We further argue
that when the statistical process generating the data is of a certain hierarchical form prevalent
in physics and machine-learning, a deep neural network can be more eﬃcient than a shallow one.
We formalize these claims using information theory and discuss the relation to the renormalization
group. We prove various “no-ﬂattening theorems” showing when eﬃcient linear deep networks cannot be accurately approximated by shallow ones without eﬃciency loss; for example, we show that
n variables cannot be multiplied using fewer than 2n neurons in a single hidden layer.
INTRODUCTION
Deep learning works remarkably well, and has helped dramatically improve the state-of-the-art in areas ranging
from speech recognition, translation and visual object
recognition to drug discovery, genomics and automatic
game playing . However, it is still not fully understood why deep learning works so well. In contrast to
GOFAI (“good old-fashioned AI”) algorithms that are
hand-crafted and fully understood analytically, many algorithms using artiﬁcial neural networks are understood
only at a heuristic level, where we empirically know that
certain training protocols employing large data sets will
result in excellent performance. This is reminiscent of the
situation with human brains: we know that if we train
a child according to a certain curriculum, she will learn
certain skills — but we lack a deep understanding of how
her brain accomplishes this.
This makes it timely and interesting to develop new analytic insights on deep learning and its successes, which
is the goal of the present paper. Such improved understanding is not only interesting in its own right, and for
potentially providing new clues about how brains work,
but it may also have practical applications. Better understanding the shortcomings of deep learning may suggest
ways of improving it, both to make it more capable and
to make it more robust .
∗Published in Journal of Statistical Physics:
 
s10955-017-1836-5
The swindle: why does “cheap learning” work?
Throughout this paper, we will adopt a physics perspective on the problem, to prevent application-speciﬁc details from obscuring simple general results related to dynamics, symmetries, renormalization, etc., and to exploit
useful similarities between deep learning and statistical
mechanics.
The task of approximating functions of many variables is
central to most applications of machine learning, including unsupervised learning, classiﬁcation and prediction,
as illustrated in Figure 1. For example, if we are interested in classifying faces, then we may want our neural
network to implement a function where we feed in an image represented by a million greyscale pixels and get as
output the probability distribution over a set of people
that the image might represent.
When investigating the quality of a neural net, there are
several important factors to consider:
• Expressibility: What class of functions can the
neural network express?
• Eﬃciency: How many resources (neurons, parameters, etc.) does the neural network require to approximate a given function?
• Learnability: How rapidly can the neural network
learn good parameters for approximating a function?
This paper is focused on expressibility and eﬃciency,
and more speciﬁcally on the following well-known 
problem: How can neural networks approximate functions well in practice, when the set of possible functions
is exponentially larger than the set of practically possible
networks? For example, suppose that we wish to classify
 
Unsupervised
Generation
Classification
FIG. 1: In this paper, we follow the machine learning convention where y refers to the model parameters and x refers to
the data, thus viewing x as a stochastic function of y (please
beware that this is the opposite of the common mathematical
convention that y is a function of x). Computer scientists usually call x a category when it is discrete and a parameter vector when it is continuous. Neural networks can approximate
probability distributions. Given many samples of random vectors y and x, unsupervised learning attempts to approximate
the joint probability distribution of y and x without making any assumptions about causality. Classiﬁcation involves
estimating the probability distribution for y given x.
opposite operation, estimating the probability distribution of
x given y is often called prediction when y causes x by being
earlier data in a time sequence; in other cases where y causes
x, for example via a generative model, this operation is sometimes known as probability density estimation. Note that in
machine learning, prediction is sometimes deﬁned not as as
outputting the probability distribution, but as sampling from
megapixel greyscale images into two categories, e.g., cats
or dogs. If each pixel can take one of 256 values, then
there are 2561000,000 possible images, and for each one,
we wish to compute the probability that it depicts a cat.
This means that an arbitrary function is deﬁned by a list
of 2561000,000 probabilities, i.e., way more numbers than
there are atoms in our universe (about 1078).
Yet neural networks with merely thousands or millions
of parameters somehow manage to perform such classi-
ﬁcation tasks quite well. How can deep learning be so
“cheap”, in the sense of requiring so few parameters?
We will see in below that neural networks perform a combinatorial swindle, replacing exponentiation by multiplication: if there are say n = 106 inputs taking v = 256
values each, this swindle cuts the number of parameters
from vn to v×n times some constant factor. We will show
that this success of this swindle depends fundamentally
on physics: although neural networks only work well for
an exponentially tiny fraction of all possible inputs, the
laws of physics are such that the data sets we care about
for machine learning (natural images, sounds, drawings,
text, etc.) are also drawn from an exponentially tiny fraction of all imaginable data sets. Moreover, we will see
that these two tiny subsets are remarkably similar, enabling deep learning to work well in practice.
The rest of this paper is organized as follows. In Section II, we present results for shallow neural networks
with merely a handful of layers, focusing on simpliﬁcations due to locality, symmetry and polynomials. In Section III, we study how increasing the depth of a neural
network can provide polynomial or exponential eﬃciency
gains even though it adds nothing in terms of expressivity, and we discuss the connections to renormalization, compositionality and complexity.
We summarize
our conclusions in Section IV.
EXPRESSIBILITY AND EFFICIENCY OF
SHALLOW NEURAL NETWORKS
Let us now explore what classes of probability distributions p are the focus of physics and machine learning, and
how accurately and eﬃciently neural networks can approximate them. We will be interested in probability distributions p(x|y), where x ranges over some sample space
and y will be interpreted either as another variable being
conditioned on or as a model parameter. For a machinelearning example, we might interpret y as an element of
some set of animals {cat, dog, rabbit, ...} and x as the vector of pixels in an image depicting such an animal, so that
p(x|y) for y = cat gives the probability distribution of images of cats with diﬀerent coloring, size, posture, viewing
angle, lighting condition, electronic camera noise, etc. For
a physics example, we might interpret y as an element of
some set of metals {iron, aluminum, copper, ...} and x as
the vector of magnetization values for diﬀerent parts of
a metal bar. The prediction problem is then to evaluate
p(x|y), whereas the classiﬁcation problem is to evaluate
Because of the above-mentioned “swindle”, accurate approximations are only possible for a tiny subclass of all
probability distributions. Fortunately, as we will explore
below, the function p(x|y) often has many simplifying
features enabling accurate approximation, because it follows from some simple physical law or some generative
model with relatively few free parameters:
for example, its dependence on x may exhibit symmetry, locality
and/or be of a simple form such as the exponential of
a low-order polynomial. In contrast, the dependence of
p(y|x) on y tends to be more complicated; it makes no
sense to speak of symmetries or polynomials involving a
variable y = cat.
Let us therefore start by tackling the more complicated
case of modeling p(y|x).
This probability distribution
p(y|x) is determined by the hopefully simpler function
p(x|y) via Bayes’ theorem:
p(x|y)p(y)
y′ p(x|y′)(y′),
Machine learning
Hamiltonian
Surprisal −ln p
Cheap learning
Quadratic H
Gaussian p
Translationally symmetric H Convnet
Computing p from H
Softmaxing
Free energy diﬀerence
KL-divergence
Eﬀective theory
Nearly lossless data distillation
Irrelevant operator
Relevant operator
TABLE I: Physics-ML dictionary.
where p(y) is the probability distribution over y (animals
or metals, say) a priori, before examining the data vector
Probabilities and Hamiltonians
It is useful to introduce the negative logarithms of two of
these probabilities:
Hy(x) ≡−ln p(x|y),
µy ≡−ln p(y).
Statisticians refer to −ln p as “self-information” or “surprisal”, and statistical physicists refer to Hy(x) as the
Hamiltonian, quantifying the energy of x (up to an arbitrary and irrelevant additive constant) given the parameter y. Table I is a brief dictionary translating between
physics and machine-learning terminology. These deﬁnitions transform equation (1) into the Boltzmann form
N(x)e−[Hy(x)+µx],
e−[Hy(x)+µy].
This recasting of equation (1) is useful because the
Hamiltonian tends to have properties making it simple to evaluate. We will see in Section III that it also
helps understand the relation between deep learning and
renormalization .
Bayes theorem as a softmax
Since the variable y takes one of a discrete set of values,
we will often write it as an index instead of as an argument, as py(x) ≡p(y|x). Moreover, we will often ﬁnd it
convenient to view all values indexed by y as elements
of a vector, written in boldface, thus viewing py, Hy and
µy as elements of the vectors p, H and µ, respectively.
Equation (3) thus simpliﬁes to
N(x)e−[H(x)+µ],
using the standard convention that a function (in this
case exp) applied to a vector acts on its elements.
We wish to investigate how well this vector-valued function p(x) can be approximated by a neural net. A standard n-layer feedforward neural network maps vectors
to vectors by applying a series of linear and nonlinear
transformations in succession. Speciﬁcally, it implements
vector-valued functions of the form 
f(x) = σnAn · · · σ2A2σ1A1x,
where the σi are relatively simple nonlinear operators
on vectors and the Ai are aﬃne transformations of the
form Aix = Wix+bi for matrices Wi and so-called bias
vectors bi. Popular choices for these nonlinear operators
σi include
• Local function: apply some nonlinear function σ to
each vector element,
• Max-pooling: compute the maximum of all vector
• Softmax: exponentiate all vector elements and normalize them to so sum to unity
(We use ˜σ to indicate the softmax function and σ to indicate an arbitrary non-linearity, optionally with certain
regularity requirements).
This allows us to rewrite equation (5) as
p(x) = ˜σ[−H(x) −µ].
This means that if we can compute the Hamiltonian vector H(x) with some n-layer neural net, we can evaluate
the desired classiﬁcation probability vector p(x) by simply adding a softmax layer. The µ-vector simply becomes
the bias term in this ﬁnal layer.
What Hamiltonians can be approximated by
feasible neural networks?
It has long been known that neural networks are universal1 approximators , in the sense that networks with
1 Neurons are universal analog computing modules in much the
same way that NAND gates are universal digital computing mod-
virtually all popular nonlinear activation functions σ(x)
can approximate any smooth function to any desired accuracy — even using merely a single hidden layer. However, these theorems do not guarantee that this can be
accomplished with a network of feasible size, and the following simple example explains why they cannot: There
are 22n diﬀerent Boolean functions of n variables, so a
network implementing a generic function in this class requires at least 2n bits to describe, i.e., more bits than
there are atoms in our universe if n > 260.
The fact that neural networks of feasible size are nonetheless so useful therefore implies that the class of functions
we care about approximating is dramatically smaller. We
will see below in Section II D that both physics and machine learning tend to favor Hamiltonians that are polynomials2 — indeed, often ones that are sparse, symmetric
and low-order. Let us therefore focus our initial investigation on Hamiltonians that can be expanded as a power
Hy(x) = h+
hijkxixjxk+· · · .
If the vector x has n components (i = 1, ..., n), then there
are (n + d)!/(n!d!) terms of degree up to d.
Continuous input variables
If we can accurately approximate multiplication using a
small number of neurons, then we can construct a network eﬃciently approximating any polynomial Hy(x) by
repeated multiplication and addition. We will now see
that we can, using any smooth but otherwise arbitrary
non-linearity σ that is applied element-wise. The popular
logistic sigmoid activation function σ(x) = 1/(1 + e−x)
will do the trick.
Theorem: Let f be a neural network of the form f =
A2σA1, where σ acts elementwise by applying some
smooth non-linear function σ to each element. Let the
ules: any computable function can be accurately evaluated by
a suﬃciently large network of them. Just as NAND gates are
not unique (NOR gates are also universal), nor is any particular
neuron implementation — indeed, any generic smooth nonlinear
activation function is universal .
The class of functions that can be exactly expressed by a neural network must be invariant under composition, since adding
more layers corresponds to using the output of one function
as the input to another.
Important such classes include linear functions, aﬃne functions, piecewise linear functions (generated by the popular Rectiﬁed Linear unit “ReLU” activation
function σ(x) = max[0, x]), polynomials, continuous functions
and smooth functions whose nth derivatives are continuous. According to the Stone-Weierstrass theorem, both polynomials and
piecewise linear functions can approximate continuous functions
arbitrarily well.
input layer, hidden layer and output layer have sizes 2, 4
and 1, respectively. Then f can approximate a multiplication gate arbitrarily well.
To see this, let us ﬁrst Taylor-expand the function σ
around the origin:
σ(u) = σ0 + σ1u + σ2
2 + O(u3).
Without loss of generality, we can assume that σ2 ̸= 0:
since σ is non-linear, it must have a non-zero second
derivative at some point, so we can use the biases in
A1 to shift the origin to this point to ensure σ2 ̸= 0.
Equation (10) now implies that
σ(u+v)+σ(−u−v)−σ(u−v)−σ(−u+v)
 u2 + v2
where we will term m(u, v) the multiplication approximator. Taylor’s theorem guarantees that m(u, v) is an arbitrarily good approximation of uv for arbitrarily small |u|
and |v|. However, we can always make |u| and |v| arbitrarily small by scaling A1 →λA1 and then compensating by scaling A2 →λ−2A2. In the limit that λ →∞,
this approximation becomes exact. In other words, arbitrarily accurate multiplication can always be achieved
using merely 4 neurons. Figure 2 illustrates such a multiplication approximator. (Of course, a practical algorithm
like stochastic gradient descent cannot achieve arbitrarily
large weights, though a reasonably good approximation
can be achieved already for λ−1 ∼10.)
Corollary: For any given multivariate polynomial and
any tolerance ϵ > 0, there exists a neural network of ﬁxed
ﬁnite size N (independent of ϵ) that approximates the
polynomial to accuracy better than ϵ. Furthermore, N
is bounded by the complexity of the polynomial, scaling
as the number of multiplications required times a factor
that is typically slightly larger than 4.3
This is a stronger statement than the classic universal
universal approximation theorems for neural networks , which guarantee that for every ϵ there exists some
N(ϵ), but allows for the possibility that N(ϵ) →∞as
ϵ →0. An approximation theorem in provides an
ϵ-independent bound on the size of the neural network,
but at the price of choosing a pathological function σ.
3 In addition to the four neurons required for each multiplication,
additional neurons may be deployed to copy variables to higher
layers bypassing the nonlinearity in σ. Such linear “copy gates”
implementing the function u →u are of course trivial to implement using a simpler version of the above procedure: using A1
to shift and scale down the input to fall in a tiny range where
σ′(u) ̸= 0, and then scaling it up and shifting accordingly with
Continuous multiplication gate:
Binary multiplication gate:
FIG. 2: Multiplication can be eﬃciently implemented by simple neural nets, becoming arbitrarily accurate as λ →0 (left)
and β →∞(right).
Squares apply the function σ, circles
perform summation, and lines multiply by the constants labeling them. The “1” input implements the bias term. The
left gate requires σ′′(0) ̸= 0, which can always be arranged by
biasing the input to σ. The right gate requires the sigmoidal
behavior σ(x) →0 and σ(x) →1 as x →−∞and x →∞,
respectively.
Discrete input variables
For the simple but important case where x is a vector
of bits, so that xi = 0 or xi = 1, the fact that x2
makes things even simpler. This means that only terms
where all variables are diﬀerent need be included, which
simpliﬁes equation (9) to
Hy(x) = h+
hijkxixjxk+· · · .
The inﬁnite series equation (9) thus gets replaced by
a ﬁnite series with 2n terms, ending with the term
h1...nx1 · · · xn. Since there are 2n possible bit strings x,
the 2n h−parameters in equation (12) suﬃce to exactly
parametrize an arbitrary function Hy(x).
The eﬃcient multiplication approximator above multiplied only two variables at a time, thus requiring multiple layers to evaluate general polynomials. In contrast,
H(x) for a bit vector x can be implemented using merely
three layers as illustrated in Figure 2, where the middle
layer evaluates the bit products and the third layer takes
a linear combination of them. This is because bits allow an accurate multiplication approximator that takes
the product of an arbitrary number of bits at once, exploiting the fact that a product of bits can be trivially
determined from their sum: for example, the product
x1x2x3 = 1 if and only if the sum x1 + x2 + x3 = 3. This
sum-checking can be implemented using one of the most
popular choices for a nonlinear function σ: the logistic
sigmoid σ(x) =
1+e−x which satisﬁes σ(x) ≈0 for x ≪0
and σ(x) ≈1 for x ≫1. To compute the product of
some set of k bits described by the set K (for our example above, K = {1, 2, 3}), we let A1 and A2 shift and
stretch the sigmoid to exploit the identity
Since σ decays exponentially fast toward 0 or 1 as β is increased, modestly large β-values suﬃce in practice; if, for
example, we want the correct answer to D = 10 decimal
places, we merely need β > D ln 10 ≈23. In summary,
when x is a bit string, an arbitrary function py(x) can be
evaluated by a simple 3-layer neural network: the middle layer uses sigmoid functions to compute the products
from equation (12), and the top layer performs the sums
from equation (12) and the softmax from equation (8).
What Hamiltonians do we want to
approximate?
We have seen that polynomials can be accurately approximated by neural networks using a number of neurons
scaling either as the number of multiplications required
(for the continuous case) or as the number of terms (for
the binary case). But polynomials per se are no panacea:
with binary input, all functions are polynomials, and
with continuous input, there are (n + d)!/(n!d!) coeﬃcients in a generic polynomial of degree d in n variables,
which easily becomes unmanageably large. We will now
discuss situations in which exceptionally simple polynomials that are sparse, symmetric and/or low-order play
a special role in physics and machine-learning.
Low polynomial order
The Hamiltonians that show up in physics are not random functions, but tend to be polynomials of very low
order, typically of degree ranging from 2 to 4. The simplest example is of course the harmonic oscillator, which
is described by a Hamiltonian that is quadratic in both
position and momentum. There are many reasons why
low order polynomials show up in physics. Two of the
most important ones are that sometimes a phenomenon
can be studied perturbatively, in which case, Taylor’s
theorem suggests that we can get away with a low order
polynomial approximation.
A second reason is renormalization: higher order terms in the Hamiltonian of a
statistical ﬁeld theory tend to be negligible if we only
observe macroscopic variables.
At a fundamental level, the Hamiltonian of the standard model of particle physics has d = 4.
many approximations of this quartic Hamiltonian that
are accurate in speciﬁc regimes, for example the Maxwell
equations governing electromagnetism, the Navier-Stokes
equations governing ﬂuid dynamics, the Alv´en equations governing magnetohydrodynamics and various Ising
models governing magnetization — all of these approximations have Hamiltonians that are polynomials in the
ﬁeld variables, of degree d ranging from 2 to 4.
This means that the number of polynomial coeﬃcients in
many examples is not inﬁnite as in equation (9) or exponential in n as in equation (12), merely of order O(n4).
There are additional reasons why we might expect low order polynomials. Thanks to the Central Limit Theorem
 , many probability distributions in machine-learning
and statistics can be accurately approximated by multivariate Gaussians, i.e., of the form
p(x) = eh+P
ij hijxixj,
which means that the Hamiltonian H = −ln p is a
quadratic polynomial.
More generally, the maximumentropy probability distribution subject to constraints on
some of the lowest moments, say expectation values of the
2 · · · xαn
n ⟩for some integers αi ≥0 would lead
to a Hamiltonian of degree no greater than d ≡P
Image classiﬁcation tasks often exploit invariance under
translation, rotation, and various nonlinear deformations
of the image plane that move pixels to new locations. All
such spatial transformations are linear functions (d = 1
polynomials) of the pixel vector x. Functions implementing convolutions and Fourier transforms are also d = 1
polynomials.
Of course, such arguments do not imply that we should
expect to see low order polynomials in every application.
If we consider some data set generated by a very simple
Hamiltonian (say the Ising Hamiltonian), but then discard some of the random variables, the resulting distribution will in general become quite complicated. Similarly,
if we do not observe the random variables directly, but
observe some generic functions of the random variables,
the result will generally be a mess.
These arguments,
however, might indicate that the probability of encountering a Hamiltonian described by a low-order polynomial in some application might be signiﬁcantly higher
than what one might expect from some naive prior. For
example, a uniform prior on the space of all polynomials of degree N would suggest that a randomly chosen
polynomial would almost always have degree N, but this
might be a bad prior for real-world applications.
We should also note that even if a Hamiltonian is described exactly by a low-order polynomial, we would not
expect the corresponding neural network to reproduce a
low-order polynomial Hamiltonian exactly in any practical scenario for a host of possible reasons including limited data, the requirement of inﬁnite weights for inﬁnite
accuracy, and the failure of practical algorithms such as
stochastic gradient descent to ﬁnd the global minimum
of a cost function in many scenarios. So looking at the
weights of a neural network trained on actual data may
not be a good indicator of whether or not the underlying
Hamiltonian is a polynomial of low degree or not.
One of the deepest principles of physics is locality: that
things directly aﬀect only what is in their immediate
vicinity. When physical systems are simulated on a computer by discretizing space onto a rectangular lattice, locality manifests itself by allowing only nearest-neighbor
interaction.
In other words, almost all coeﬃcients in
equation (9) are forced to vanish, and the total number
of non-zero coeﬃcients grows only linearly with n. For
the binary case of equation (9), which applies to magnetizations (spins) that can take one of two values, locality
also limits the degree d to be no greater than the number of neighbors that a given spin is coupled to (since all
variables in a polynomial term must be diﬀerent).
Again, the applicability of these considerations to particular machine learning applications must be determined
on a case by case basis. Certainly, an arbitrary transformation of a collection of local random variables will result in a non-local collection. (This might ruin locality in
certain ensembles of images, for example). But there are
certainly cases in physics where locality is still approximately preserved, for example in the simple block-spin
renormalization group, spins are grouped into blocks,
which are then treated as random variables. To a high
degree of accuracy, these blocks are only coupled to their
nearest neighbors. Such locality is famously exploited by
both biological and artiﬁcial visual systems, whose ﬁrst
neuronal layer performs merely fairly local operations.
Whenever the Hamiltonian obeys some symmetry (is invariant under some transformation), the number of independent parameters required to describe it is further
reduced. For instance, many probability distributions in
both physics and machine learning are invariant under
translation and rotation. As an example, consider a vector x of air pressures yi measured by a microphone at
times i = 1, ..., n. Assuming that the Hamiltonian describing it has d = 2 reduces the number of parameters
N from ∞to (n + 1)(n + 2)/2.
Further assuming locality (nearest-neighbor couplings only) reduces this to
N = 2n, after which requiring translational symmetry
reduces the parameter count to N = 3. Taken together,
the constraints on locality, symmetry and polynomial order reduce the number of continuous parameters in the
Hamiltonian of the standard model of physics to merely
Symmetry can reduce not merely the parameter count,
but also the computational complexity. For example, if
a linear vector-valued function f(x) mapping a set of n
variables onto itself happens to satisfy translational symmetry, then it is a convolution (implementable by a convolutional neural net; “convnet”), which means that it
can be computed with n log2 n rather than n2 multiplications using Fast Fourier transform.
Above we investigated how probability distributions from
physics and computer science applications lent themselves to “cheap learning”, being accurately and eﬃciently approximated by neural networks with merely a
handful of layers. Let us now turn to the separate question of depth, i.e., the success of deep learning: what
properties of real-world probability distributions cause
eﬃciency to further improve when networks are made
deeper? This question has been extensively studied from
a mathematical point of view , but mathematics alone cannot fully answer it, because part of the answer involves physics. We will argue that the answer involves the hierarchical/compositional structure of generative processes together with inability to eﬃciently “ﬂatten” neural networks reﬂecting this structure.
Hierarchical processess
One of the most striking features of the physical world
is its hierarchical structure.
Spatially, it is an object
hierarchy: elementary particles form atoms which in turn
form molecules, cells, organisms, planets, solar systems,
galaxies, etc. Causally, complex structures are frequently
created through a distinct sequence of simpler steps.
Figure 3 gives two examples of such causal hierarchies
generating data vectors y0 7→y1 7→... 7→yn that are
relevant to physics and image classiﬁcation, respectively.
Both examples involve a Markov chain4 where the probability distribution p(yi) at the ith level of the hierarchy
is determined from its causal predecessor alone:
pi = Mipi−1,
where the probability vector pi speciﬁes the probability distribution of p(yi) according to (pi)y ≡p(yi) and
the Markov matrix Mi speciﬁes the transition probabilities between two neighboring levels, p(yi|yi−1). Iterating
equation (15) gives
pn = MnMn−1 · · · M1p0,
so we can write the combined eﬀect of the the entire
generative process as a matrix product.
4 If the next step in the generative hierarchy requires knowledge
of not merely of the present state but also information of the
past, the present state can be redeﬁned to include also this information, thus ensuring that the generative process is a Markov
In our physics example (Figure 3, left), a set of cosmological parameters y0 (the density of dark matter, etc.)
determines the power spectrum y1 of density ﬂuctuations
in our universe, which in turn determines the pattern
of cosmic microwave background radiation y2 reaching
us from our early universe, which gets combined with
foreground radio noise from our Galaxy to produce the
frequency-dependent sky maps (y3) that are recorded by
a satellite-based telescope that measures linear combinations of diﬀerent sky signals and adds electronic receiver
For the recent example of the Planck Satellite
 , these datasets yi, y2, ... contained about 101, 104,
108, 109 and 1012 numbers, respectively.
More generally, if a given data set is generated by a (classical) statistical physics process, it must be described by
an equation in the form of equation (16), since dynamics
in classical physics is fundamentally Markovian: classical equations of motion are always ﬁrst order diﬀerential
equations in the Hamiltonian formalism.
This technically covers essentially all data of interest in the machine
learning community, although the fundamental Markovian nature of the generative process of the data may be
an in-eﬃcient description.
Our toy image classiﬁcation example (Figure 3, right)
is deliberately contrived and over-simpliﬁed for pedagogy: y0 is a single bit signifying “cat or dog”, which
determines a set of parameters determining the animal’s
coloration, body shape, posture, etc. using approxiate
probability distributions, which determine a 2D image
via ray-tracing, which is scaled and translated by random amounts before a randomly generated background
In both examples, the goal is to reverse this generative hierarchy to learn about the input y ≡y0 from the output
yn ≡x, speciﬁcally to provide the best possibile estimate
of the probability distribution p(y|y) = p(y0|yn) — i.e.,
to determine the probability distribution for the cosmological parameters and to determine the probability that
the image is a cat, respectively.
Resolving the swindle
This decomposition of the generative process into a hierarchy of simpler steps helps resolve the“swindle” paradox
from the introduction: although the number of parameters required to describe an arbitrary function of the input data y is beyond astronomical, the generative process
can be speciﬁed by a more modest number of parameters,
because each of its steps can.
Whereas specifying an
arbitrary probability distribution over multi-megapixel
images x requires far more bits than there are atoms
in our universe, the information specifying how to compute the probability distribution p(x|y) for a microwave
background map ﬁts into a handful of published journal
articles or software packages .
For a megapixel
foregrounds
n, n , Q, T/S
Ω, Ω , Λ, τ, h
Pixel 1 Pixel 2 ΔT
6422347 6443428 -454.841
3141592 2718281 141.421
8454543 9345593 654.766
1004356 8345388 -305.567
... ... ...
TRANSFORMED
RAY-TRACED
FINAL IMAGE
SOLIDWORKS
cat or dog?
take linear
combinations,
select background
select color,
shape & posture
fluctuations
scale & translate
param 1 param 2 param 3
6422347 6443428 -454.841
3141592 2718281 141.421
8454543 9345593 654.766
1004356 8345388 -305.567
... ... ...
FIG. 3: Causal hierarchy examples relevant to physics (left) and image classiﬁcation (right). As information ﬂows down the
hierarchy y0 →y1 →... →yn = y, some of it is destroyed by random Markov processes. However, no further information is
lost as information ﬂows optimally back up the hierarchy as byn−1 →... →by0. The right example is deliberately contrived and
over-simpliﬁed for pedagogy; for example, translation and scaling are more naturally performed before ray tracing, which in
turn breaks down into multiple steps.
image of a galaxy, its entire probability distribution is
deﬁned by the standard model of particle physics with
its 32 parameters , which together specify the process transforming primordial hydrogen gas into galaxies.
The same parameter-counting argument can also be applied to all artiﬁcial images of interest to machine learning:
for example, giving the simple low-informationcontent instruction “draw a cute kitten” to a random
sample of artists will produce a wide variety of images y
with a complicated probability distribution over colors,
postures, etc., as each artist makes random choices at a
series of steps. Even the pre-stored information about
cat probabilities in these artists’ brains is modest in size.
Note that a random resulting image typically contains
much more information than the generative process creating it; for example, the simple instruction “generate
a random string of 109 bits” contains much fewer than
109 bits. Not only are the typical steps in the generative hierarchy speciﬁed by a non-astronomical number of
parameters, but as discussed in Section II D, it is plausible that neural networks can implement each of the steps
eﬃciently.5
5 Although our discussion is focused on describing probability distributions, which are not random, stochastic neural networks
A deep neural network stacking these simpler networks
on top of one another would then implement the entire
generative process eﬃciently. In summary, the data sets
and functions we care about form a minuscule minority,
and it is plausible that they can also be eﬃciently implemented by neural networks reﬂecting their generative
process. So what is the remainder? Which are the data
sets and functions that we do not care about?
Almost all images are indistinguishable from random
noise, and almost all data sets and functions are indistinguishable from completely random ones. This follows from Borel’s theorem on normal numbers , which
states that almost all real numbers have a string of decimals that would pass any randomness test, i.e., are
indistinguishable from random noise.
Simple parameter counting shows that deep learning (and our human
brains, for that matter) would fail to implement almost
all such functions, and training would fail to ﬁnd any
useful patterns. To thwart pattern-ﬁnding eﬀorts. cryptography therefore aims to produces random-looking patterns. Although we might expect the Hamiltonians describing human-generated data sets such as drawings,
text and music to be more complex than those describing
simple physical systems, we should nonetheless expect
them to resemble the natural data sets that inspired their
creation much more than they resemble random functions.
Suﬃcient statistics and hierarchies
The goal of deep learning classiﬁers is to reverse the hierarchical generative process as well as possible, to make
inferences about the input y from the output x. Let us
now treat this hierarchical problem more rigorously using
information theory.
Given P(y|x), a suﬃcient statistic T(x) is deﬁned by the
equation P(y|x) = P(y|T(x)) and has played an important role in statistics for almost a century . All the
information about y contained in x is contained in the
suﬃcient statistic. A minimal suﬃcient statistic is
some suﬃcient statistic T∗which is a suﬃcient statistic
for all other suﬃcient statistics. This means that if T(y)
is suﬃcient, then there exists some function f such that
T∗(y) = f(T(y)). As illustrated in Figure 3, T∗can be
thought of as a an information distiller, optimally compressing the data so as to retain all information relevant
to determining y and discarding all irrelevant information.
can generate random variables as well. In biology, spiking neurons provide a good random number generator, and in machine
learning, stochastic architectures such as restricted Boltzmann
machines do the same.
The suﬃcient statistic formalism enables us to state some
simple but important results that apply to any hierarchical generative process cast in the Markov chain form of
equation (16).
Theorem 2: Given a Markov chain described by our
notation above, let Ti be a minimal suﬃcient statistic of
P(yi|yn). Then there exists some functions fi such that
Ti = fi ◦Ti+1. More casually speaking, the generative hierarchy of Figure 3 can be optimally reversed one step at
a time: there are functions fi that optimally undo each
of the steps, distilling out all information about the level
above that was not destroyed by the Markov process.
Here is the proof. Note that for any k ≥1, the “backwards” Markov property P(yi|yi+1, yi+k) = P(yi|yi+1)
follows from the Markov property via Bayes’ theorem:
P(yi|yi+k, yi+1) = P(yi+k|yi, yi+1)P(yi|yi+1)
P(yi+k|yi+1)
= P(yi+k|yi+1)P(yi|yi+1)
P(yi+k|yi+1)
= P(yi|yi+1).
Using this fact, we see that
P(yi|yn) =
P(yi|yi+1yn)P(yi+1|yn)
P(yi|yi+1)P(yi+1|Ti+1(yn)).
Since the above equation depends on yn only through
Ti+1(yn), this means that Ti+1 is a suﬃcient statistic for
P(yi|yn). But since Ti is the minimal suﬃcient statistic,
there exists a function fi such that Ti = fi ◦Ti+1.
Corollary 2: With the same assumptions and notation
as theorem 2, deﬁne the function f0(T0) = P(y0|T0) and
fn = Tn−1. Then
P(y0|yn) = (f0 ◦f1 ◦· · · ◦fn) (yn).
The proof is easy. By induction,
T0 = f1 ◦f2 ◦· · · ◦Tn−1,
which implies the corollary.
Roughly speaking, Corollary 2 states that the structure of
the inference problem reﬂects the structure of the generative process. In this case, we see that the neural network
trying to approximate P(y|x) must approximate a compositional function. We will argue below in Section III F
that in many cases, this can only be accomplished eﬃciently if the neural network has ≳n hidden layers.
In neuroscience parlance, the functions fi compress the
data into forms with ever more invariance , containing features invariant under irrelevant transformations
(for example background substitution, scaling and translation).
Let us denote the distilled vectors byi ≡fi(byi+1), where
byn ≡y. As summarized by Figure 3, as information ﬂows
down the hierarchy y = y0 →y1 →...
exn = x, some of it is destroyed by random processes.
However, no further information is lost as information
ﬂows optimally back up the hierarchy as y →byn−1 →
Approximate information distillation
Although minimal suﬃcient statistics are often diﬃcult
to calculate in practice, it is frequently possible to come
up with statistics which are nearly suﬃcient in a certain
sense which we now explain.
An equivalent characterization of a suﬃcient statistic is
provided by information theory . The data processing inequality states that for any function f and
any random variables x, y,
I(x, y) ≥I(x, f(y)),
where I is the mutual information:
p(x, y) log p(x, y)
A suﬃcient statistic T(x) is a function f(x) for which “≥”
gets replaced by “=” in equation (21), i.e., a function
retaining all the information about y.
Even information distillation functions f that are not
strictly suﬃcient can be very useful as long as they distill
out most of the relevant information and are computationally eﬃcient. For example, it may be possible to trade
some loss of mutual information with a dramatic reduction in the complexity of the Hamiltonian; e.g., Hy (f(x))
may be considerably easier to implement in a neural network than Hy (x). Precisely this situation applies to the
physical example described in Figure 3, where a hierarchy of eﬃcient near-perfect information distillers fi have
been found, the numerical cost of f3 , f2 ,
f1 and f0 scaling with the number of inputs parameters n as O(n), O(n3/2), O(n2) and O(n3),
respectively. More abstractly, the procedure of renormalization, ubiquitous in statistical physics, can be viewed
as a special case of approximate information distillation,
as we will now describe.
Distillation and renormalization
The systematic framework for distilling out desired information from unwanted “noise” in physical theories is
known as Eﬀective Field Theory . Typically, the desired information involves relatively large-scale features
that can be experimentally measured, whereas the noise
involves unobserved microscopic scales.
A key part of
this framework is known as the renormalization group
(RG) transformation . Although the connection
between RG and machine learning has been studied or alluded to repeatedly , there are signiﬁcant misconceptions in the literature concerning the connection
which we will now attempt to clear up.
Let us ﬁrst review a standard working deﬁnition of what
renormalization is in the context of statistical physics,
involving three ingredients: a vector y of random variables, a course-graining operation R and a requirement
that this operation leaves the Hamiltonian invariant except for parameter changes. We think of y as the microscopic degrees of freedom — typically physical quantities
deﬁned at a lattice of points (pixels or voxels) in space.
Its probability distribution is speciﬁed by a Hamiltonian
Hy(x), with some parameter vector y. We interpret the
map R : y →y as implementing a coarse-graining6 of
the system. The random variable R(y) also has a Hamiltonian, denoted H′(R(y)), which we require to have the
same functional form as the original Hamiltonian Hy, although the parameters y may change. In other words,
H′(R(x)) = Hr(y)(R(x)) for some function r. Since the
domain and the range of R coincide, this map R can be
iterated n times Rn = R ◦R ◦· · · R, giving a Hamiltonian Hrn(y)(Rn(x)) for the repeatedly renormalized data.
Similar to the case of suﬃcient statistics, P(y|Rn(x)) will
then be a compositional function.
Contrary to some claims in the literature, eﬀective ﬁeld
theory and the renormalization group have little to do
with the idea of unsupervised learning and pattern-
Instead, the standard renormalization procedures in statistical physics are essentially a feature extractor for supervised learning, where the features typically correspond to long-wavelength/macroscopic degrees
of freedom.
In other words, eﬀective ﬁeld theory only
makes sense if we specify what features we are interested
in. For example, if we are given data x about the position and momenta of particles inside a mole of some liquid
and is tasked with predicting from this data whether or
not Alice will burn her ﬁnger when touching the liquid,
a (nearly) suﬃcient statistic is simply the temperature
of the object, which can in turn be obtained from some
very coarse-grained degrees of freedom (for example, one
6 A typical renormalization scheme for a lattice system involves
replacing many spins (bits) with a single spin according to some
In this case, it might seem that the map R could not
possibly map its domain onto itself, since there are fewer degrees
of freedom after the coarse-graining. On the other hand, if we
let the domain and range of R diﬀer, we cannot easily talk about
the Hamiltonian as having the same functional form, since the
renormalized Hamiltonian would have a diﬀerent domain than
the original Hamiltonian. Physicists get around this by taking
the limit where the lattice is inﬁnitely large, so that R maps an
inﬁnite lattice to an inﬁnite lattice.
could use the ﬂuid approximation instead of working directly from the positions and momenta of ∼1023 particles). But without specifying that we wish to predict
(long-wavelength physics), there is nothing natural about
an eﬀective ﬁeld theory approximation.
To be more explicit about the link between renormalization and deep-learning, consider a toy model for natural
Each image is described by an intensity ﬁeld
φ(r), where r is a 2-dimensional vector. We assume that
an ensemble of images can be described by a quadratic
Hamiltonian of the form
y0φ2 + y1(∇φ)2 + y2
2 + · · ·
Each parameter vector y deﬁnes an ensemble of images;
we could imagine that the ﬁctitious classes of images that
we are trying to distinguish are all generated by Hamiltonians Hy with the same above form but diﬀerent parameter vectors y. We further assume that the function φ(r) is
speciﬁed on pixels that are suﬃciently close that derivatives can be well-approximated by diﬀerences. Derivatives are linear operations, so they can be implemented
in the ﬁrst layer of a neural network. The translational
symmetry of equation (23) allows it to be implemented
with a convnet. If can be shown that for any coursegraining operation that replaces each block of b×b pixels
by its average and divides the result by b2, the Hamiltonian retains the form of equation (23) but with the
parameters yi replaced by
i = b2−2iyi.
This means that all parameters yi with i ≥2 decay exponentially with b as we repeatedly renormalize and b keeps
increasing, so that for modest b, one can neglect all but
the ﬁrst few yi’s. What would have taken an arbitrarily
large neural network can now be computed on a neural
network of ﬁnite and bounded size, assuming that we
are only interested in classifying the data based only on
the coarse-grained variables. These insuﬃcient statistics
will still have discriminatory power if we are only interested in discriminating Hamiltonians which all diﬀer in
their ﬁrst few Ck. In this example, the parameters y0
and y1 correspond to “relevant operators” by physicists
and “signal” by machine-learners, whereas the remaining parameters correspond to “irrelevant operators” by
physicists and “noise” by machine-learners.
The ﬁxed point structure of the transformation in this example is very simple, but one can imagine that in more
complicated problems the ﬁxed point structure of various transformations might be highly non-trivial. This
is certainly the case in statistical mechanics problems
where renormalization methods are used to classify various phases of matters; the point here is that the renormalization group ﬂow can be thought of as solving the
pattern-recognition problem of classifying the long-range
behavior of various statistical systems.
In summary, renormalization can be thought of as a type
of supervised learning7, where the large scale properties
of the system are considered the features. If the desired
features are not large-scale properties (as in most machine learning cases), one might still expect the a generalized formalism of renormalization to provide some intuition to the problem by replacing a scale transformation
with some other transformation. But calling some procedure renormalization or not is ultimately a matter of
semantics; what remains to be seen is whether or not semantics has teeth, namely, whether the intuition about
ﬁxed points of the renormalization group ﬂow can provide concrete insight into machine learning algorithms.
In many numerical methods, the purpose of the renormalization group is to eﬃciently and accurately evaluate
the free energy of the system as a function of macroscopic
variables of interest such as temperature and pressure.
Thus we can only sensibly talk about the accuracy of
an RG-scheme once we have speciﬁed what macroscopic
variables we are interested in.
No-ﬂattening theorems
Above we discussed how Markovian generative models
cause p(x|y) to be a composition of a number of simpler functions fi. Suppose that we can approximate each
function fi with an eﬃcient neural network for the reasons given in Section II. Then we can simply stack these
networks on top of each other, to obtain an deep neural
network eﬃciently approximating p(x|y).
But is this the most eﬃcient way to represent p(x|y)?
Since we know that there are shallower networks that
accurately approximate it, are any of these shallow networks as eﬃcient as the deep one, or does ﬂattening necessarily come at an eﬃciency cost?
To be precise, for a neural network f deﬁned by equation (6), we will say that the neural network fℓ
ﬂattened version of f if its number ℓof hidden layers is
smaller and fℓ
ϵ approximates f within some error ϵ (as
7 A subtlety regarding the above statements is presented by the
Multi-scale Entanglement Renormalization Ansatz (MERA) .
MERA can be viewed as a variational class of wave functions
whose parameters can be tuned to to match a given wave function as closely as possible. From this perspective, MERA is as an
unsupervised machine learning algorithm, where classical probability distributions over many variables are replaced with quantum wavefunctions.
Due to the special tensor network structure found in MERA, the resulting variational approximation
of a given wavefunction has an interpretation as generating an
RG ﬂow. Hence this is an example of an unsupervised learning
problem whose solution gives rise to an RG ﬂow. This is only
possible due to the extra mathematical structure in the problem
(the speciﬁc tensor network found in MERA); a generic variational Ansatz does not give rise to any RG interpretation and
vice versa.
measured by some reasonable norm). We say that fℓ
a neuron-eﬃcient ﬂattening if the sum of the dimensions
of its hidden layers (sometimes referred to as the number
of neurons Nn) is less than for f. We say that fℓ
synapse-eﬃcient ﬂattening if the number Ns of non-zero
entries (sometimes called synapses) in its weight matrices
is less than for f. This lets us deﬁne the ﬂattening cost
of a network f as the two functions
Cn(f, ℓ, ϵ) ≡min
Cs(f, ℓ, ϵ) ≡min
specifying the factor by which optimal ﬂattening increases the neuron count and the synapse count, respectively.
We refer to results where Cn > 1 or Cs > 1
for some class of functions f as “no-ﬂattening theorems”,
since they imply that ﬂattening comes at a cost and ef-
ﬁcient ﬂattening is impossible.
A complete list of no-
ﬂattening theorems would show exactly when deep networks are more eﬃcient than shallow networks.
There has already been very interesting progress in this
spirit, but crucial questions remain.
On one hand, it
has been shown that deep is not always better, at least
empirically for some image classiﬁcation tasks . On
the other hand, many functions f have been found for
which the ﬂattening cost is signiﬁcant.
Certain deep
Boolean circuit networks are exponentially costly to ﬂatten . Two families of multivariate polynomials with
an exponential ﬂattening cost Cn are constructed in .
 focus on functions that have tree-like hierarchical compositional form, concluding that the ﬂattening
cost Cn is exponential for almost all functions in Sobolev
space. For the ReLU activation function, ﬁnds a class
of functions that exhibit exponential ﬂattening costs; 
study a tailored complexity measure of deep versus shallow ReLU networks. shows that given weak conditions on the activation function, there always exists at
least one function that can be implemented in a 3-layer
network which has an exponential ﬂattening cost.
Finally, study the diﬀerential geometry of shallow
versus deep networks, and ﬁnd that ﬂattening is exponentially neuron-ineﬃcient. Further work elucidating the
cost of ﬂattening various classes of functions will clearly
be highly valuable.
Linear no-ﬂattening theorems
In the mean time, we will now see that interesting no-
ﬂattening results can be obtained even in the simpler-tomodel context of linear neural networks , where the
σ operators are replaced with the identity and all biases
are set to zero such that Ai are simply linear operators
(matrices). Every map is speciﬁed by a matrix of real
(or complex) numbers, and composition is implemented
by matrix multiplication.
One might suspect that such a network is so simple that
the questions concerning ﬂattening become entirely trivial: after all, successive multiplication with n diﬀerent
matrices is equivalent to multiplying by a single matrix
(their product). While the eﬀect of ﬂattening is indeed
trivial for expressibility (f can express any linear function, independently of how many layers there are), this
is not the case for the learnability, which involves nonlinear and complex dynamics despite the linearity of the
network . We will show that the eﬃciency of such
linear networks is also a very rich question.
Neuronal eﬃciency is trivially attainable for linear networks, since all hidden-layer neurons can be eliminated
without accuracy loss by simply multiplying all the
weight matrices together. We will instead consider the
case of synaptic eﬃciency and set ℓ= ϵ = 0.
Many divide-and-conquer algorithms in numerical linear
algebra exploit some factorization of a particular matrix A in order to yield signiﬁcant reduction in complexity. For example, when A represents the discrete Fourier
transform (DFT), the fast Fourier transform (FFT) algorithm makes use of a sparse factorization of A which only
contains O(n log n) non-zero matrix elements instead of
the naive single-layer implementation, which contains n2
non-zero matrix elements. As ﬁrst pointed out in ,
this is an example where depth helps and, in our terminology, of a linear no-ﬂattening theorem: fully ﬂattening
a network that performs an FFT of n variables increases
the synapse count Ns from O(n log n) to O(n2), i.e., incurs a ﬂattening cost Cs = O(n/ log n) ∼O(n). This
argument applies also to many variants and generalizations of the FFT such as the Fast Wavelet Transform and
the Fast Walsh-Hadamard Transform.
Another important example illustrating the subtlety of
linear networks is matrix multiplication. More speciﬁcally, take the input of a neural network to be the entries
of a matrix M and the output to be NM, where both
M and N have size n × n. Since matrix multiplication is
linear, this can be exactly implemented by a 1-layer linear neural network. Amazingly, the naive algorithm for
matrix multiplication, which requires n3 multiplications,
is not optimal: the Strassen algorithm requires only
O(nω) multiplications (synapses), where ω = log2 7 ≈
2.81, and recent work has cut this scaling exponent down
to ω ≈2.3728639 . This means that fully optimized
matrix multiplication on a deep neural network has a
ﬂattening cost of at least Cs = O(n0.6271361).
Low-rank matrix multiplication gives a more elementary
no-ﬂattening theorem. If A is a rank-k matrix, we can
factor it as A = BC where B is a k × n matrix and
C is an n × k matrix. Hence the number of synapses is
n2 for an ℓ= 0 network and 2nk for an ℓ= 1-network,
giving a ﬂattening cost Cs = n/2k > 1 as long as the
rank k < n/2.
Finally, let us consider ﬂattening a network f = AB,
where A and B are random sparse n × n matrices such
that each element is 1 with probability p and 0 with probability 1 −p. Flattening the network results in a matrix
k AikBkj, so the probability that Fij = 0 is
Hence the number of non-zero components
will on average be
 1 −(1 −p2)n
1 −(1 −p2)n
= 1 −(1 −p2)n
Note that Cs ≤1/2p and that this bound is asymptotically saturated for n ≫1/p2. Hence in the limit where n
is very large, ﬂattening multiplication by sparse matrices
p ≪1 is horribly ineﬃcient.
A polynomial no-ﬂattening theorem
In Section II, we saw that multiplication of two variables
could be implemented by a ﬂat neural network with 4
neurons in the hidden layer, using equation (11) as illustrated in Figure 2. In Appendix A, we show that equation (11) is merely the n = 2 special case of the formula
s1...snσ(s1x1 + ... + snxn),
where the sum is over all possible 2n conﬁgurations of
s1, · · · sn where each si can take on values ±1. In other
words, multiplication of n variables can be implemented
by a ﬂat network with 2n neurons in the hidden layer. We
also prove in Appendix A that this is the best one can
do: no neural network can implement an n-input multiplication gate using fewer than 2n neurons in the hidden
This is another powerful no-ﬂattening theorem,
telling us that polynomials are exponentially expensive
to ﬂatten. For example, if n is a power of two, then the
monomial x1x2...xn can be evaluated by a deep network
using only 4n neurons arranged in a deep neural network
where n copies of the multiplication gate from Figure 2
are arranged in a binary tree with log2 n layers (the 5th
top neuron at the top of Figure 2 need not be counted, as
it is the input to whatever computation comes next). In
contrast, a functionally equivalent ﬂattened network requires a whopping 2n neurons. For example, a deep neural network can multiply 32 numbers using 4n = 160 neurons while a shallow one requires 232 = 4, 294, 967, 296
neurons. Since a broad class of real-world functions can
be well approximated by polynomials, this helps explain
why many useful neural networks cannot be eﬃciently
CONCLUSIONS
We have shown that the success of deep and cheap (lowparameter-count) learning depends not only on mathematics but also on physics, which favors certain classes of
exceptionally simple probability distributions that deep
learning is uniquely suited to model. We argued that the
success of shallow neural networks hinges on symmetry,
locality, and polynomial log-probability in data from or
inspired by the natural world, which favors sparse loworder polynomial Hamiltonians that can be eﬃciently approximated. These arguments should be particularly relevant for explaining the success of machine-learning applications to physics, for example using a neural network
to approximate a many-body wavefunction . Whereas
previous universality theorems guarantee that there exists a neural network that approximates any smooth function to within an error ϵ, they cannot guarantee that the
size of the neural network does not grow to inﬁnity with
shrinking ϵ or that the activation function σ does not become pathological. We show constructively that given a
multivariate polynomial and any generic non-linearity, a
neural network with a ﬁxed size and a generic smooth activation function can indeed approximate the polynomial
highly eﬃciently.
Turning to the separate question of depth, we have argued that the success of deep learning depends on the
ubiquity of hierarchical and compositional generative
processes in physics and other machine-learning applications. By studying the suﬃcient statistics of the generative process, we showed that the inference problem
requires approximating a compositional function of the
form f1 ◦f2 ◦f2 ◦· · · that optimally distills out the information of interest from irrelevant noise in a hierarchical process that mirrors the generative process. Although such compositional functions can be eﬃciently
implemented by a deep neural network as long as their
individual steps can, it is generally not possible to retain
the eﬃciency while ﬂattening the network. We extend existing “no-ﬂattening” theorems by showing that
eﬃcient ﬂattening is impossible even for many important
cases involving linear networks. In particular, we prove
that ﬂattening polynomials is exponentially expensive,
with 2n neurons required to multiply n numbers using
a single hidden layer, a task that a deep network can
perform using only ∼4n neurons.
Strengthening the analytic understanding of deep learning may suggest ways of improving it, both to make it
more capable and to make it more robust. One promising area is to prove sharper and more comprehensive
no-ﬂattening theorems, placing lower and upper bounds
on the cost of ﬂattening networks implementing various
classes of functions.
Acknowledgements: This work was supported by the
Foundational Questions Institute 
the Rothberg Family Fund for Cognitive Science and NSF
grant 1122374. We thank Scott Aaronson, Frank Ban,
Yoshua Bengio, Rico Jonschkowski, Tomaso Poggio, Bart
Selman, Viktoriya Krakovna, Krishanu Sankar and Boya
Song for helpful discussions and suggestions, Frank Ban,
Fernando Perez, Jared Jolton, and the anonymous referee
for helpful corrections and the Center for Brains, Minds,
and Machines (CBMM) for hospitality.
Appendix A: The polynomial no-ﬂattening theorem
We saw above that a neural network can compute polynomials accurately and eﬃciently at linear cost, using
only about 4 neurons per multiplication. For example,
if n is a power of two, then the monomial Qn
i=1 xi can
be evaluated using 4n neurons arranged in a binary tree
network with log2 n hidden layers. In this appendix, we
will prove a no-ﬂattening theorem demonstrating that
ﬂattening polynomials is exponentially expensive:
Theorem: Suppose we are using a generic smooth activation function σ(x) = P∞
k=0 σkxk, where σk ̸= 0 for
0 ≤k ≤n. Then for any desired accuracy ϵ > 0, there
exists a neural network that can implement the function
i=1 xi using a single hidden layer of 2n neurons. Furthermore, this is the smallest possible number of neurons
in any such network with only a single hidden layer.
This result may be compared to problems in Boolean circuit complexity, notably the question of whether TC0 =
Here circuit depth is analogous to number
of layers, and the number of gates is analogous to the
number of neurons. In both the Boolean circuit model
and the neural network model, one is allowed to use neurons/gates which have an unlimited number of inputs.
The constraint in the deﬁnition of TCi that each of the
gate elements be from a standard universal library (AND,
OR, NOT, Majority) is analogous to our constraint to use
a particular nonlinear function. Note, however, that our
theorem is weaker by applying only to depth 1, while
TC0 includes all circuits of depth O(1).
Proof that 2n neurons are suﬃcient
A neural network with a single hidden layer of m neurons that approximates a product gate for n inputs can
be formally written as a choice of constants aij and wj
satisfying
Here, we use ≈to denote that the two sides of (A1) have
identical Taylor expansions up to terms of degree n; as we
discussed earlier in our construction of a product gate for
two inputs, this exables us to achieve arbitrary accuracy
ϵ by ﬁrst scaling down the factors xi, then approximately
multiplying them and ﬁnally scaling up the result.
We may expand (A1) using the deﬁnition σ(x)
k=0 σkxk and drop terms of the Taylor expansion with
degree greater than n, since they do not aﬀect the approximation. Thus, we wish to ﬁnd the minimal m such
that there exist constants aij and wj satisfying
for all 0 ≤k ≤n −1. Let us set m = 2n, and enumerate
the subsets of {1, . . . , n} as S1, . . . , Sm in some order.
Deﬁne a network of m neurons in a single hidden layer
by setting aij equal to the function si(Sj) which is −1 if
i ∈Sj and +1 otherwise, setting
aij = (−1)|Sj|
In other words, up to an overall normalization constant,
all coeﬃcients aij and wj equal ±1, and each weight wj
is simply the product of the corresponding aij.
We must prove that this network indeed satisﬁes equations (A2) and (A3). The essence of our proof will be
to expand the left hand side of Equation (A1) and show
that all monomial terms except x1 · · · xn come in pairs
that cancel. To show this, consider a single monomial
p(x) = xr1
1 · · · xrn
n where r1 + . . . + rn = r ≤n.
If p(x) ̸= Qn
i=1 xi, then we must show that the coef-
ﬁcient of p(x) in σr
j=1 wj (Pn
i=1 aijxi)r is 0.
p(x) ̸= Qn
i=1 xi, there must be some i0 such that ri0 = 0.
In other words, p(x) does not depend on the variable xi0.
Since the sum in Equation (A1) is over all combinations
of ± signs for all variables, every term will be canceled
by another term where the (non-present) xi0 has the opposite sign and the weight wj has the opposite sign:
+ (−1)|Sj∪{i0}|
si(Sj ∪{i0})xi
si(Sj ∪{i0})xi
i=1 si(Sj)xi)r
i=1 si(Sj ∪{i0})xi)r,
ri0 = 0. Therefore, the overall coeﬃcient of p(x) in the
above expression must vanish, which implies that (A3) is
If instead p(x) = Qn
i=1 xi, then all terms have the coeﬃcient of p(x) in (Pn
i=1 aijxi)n is n! Qn
i=1 aij = (−1)|Sj|n!,
because all n! terms are identical and there is no cancelation. Hence, the coeﬃcient of p(x) on the left-hand side
of (A2) is
(−1)|Sj|n! = 1,
completing our proof that this network indeed approximates the desired product gate.
From the standpoint of group theory, our construction involves a representation of the group G = Zn
2, acting upon
the space of polynomials in the variables x1, x2, . . . , xn.
The group G is generated by elements gi such that gi ﬂips
the sign of xi wherever it occurs. Then, our construction
corresponds to the computation
f(x1, . . . , xn) = (1−g1)(1−g2) · · · (1−gn)σ(x1+x2+. . .+xn).
Every monomial of degree at most n, with the exception
of the product x1 · · · xn, is sent to 0 by (1−gi) for at least
one choice of i. Therefore, f(x1, . . . , xn) approximates a
product gate (up to a normalizing constant).
Proof that 2n neurons are necessary
Suppose that S is a subset of {1, . . . , n} and consider
taking the partial derivatives of (A2) and (A3), respectively, with respect to all the variables {xh}h∈S. Then,
for all 0 ≤k ≤n −1. Let A denote the 2n × m matrix
with elements
We will show that A has full row rank. Suppose, towards
contradiction, that ctA = 0 for some non-zero vector c.
Speciﬁcally, suppose that there is a linear dependence
between rows of A given by
cℓASℓ,j = 0,
where the Sℓare distinct and cℓ̸= 0 for every ℓ. Let s be
the maximal cardinality of any Sℓ. Deﬁning the vector d
whose components are
taking the dot product of equation (A8) with d gives
0 = ctAd =
ℓ|(|Sℓ|=s)
ℓ|(|Sℓ|<s)
!(n+|Sℓ|−s)−|Sℓ|
Applying equation (A6) (with k = n+|Sℓ|−s) shows that
the second term vanishes.
Substituting equation (A5)
now simpliﬁes equation (A10) to
ℓ|(|Sℓ|=s)
cℓ|n −Sℓ|!
i.e., to a statement that a set of monomials are linearly
dependent. Since all distinct monomials are in fact linearly independent, this is a contradiction of our assumption that the Sℓare distinct and cℓare nonzero.
conclude that A has full row rank, and therefore that
m ≥2n, which concludes the proof.
 Y. LeCun, Y. Bengio, and G. Hinton, Nature 521, 436
 Y. Bengio, Foundations and trends R
⃝in Machine Learning 2, 1 .
 S. Russell, D. Dewey, and M. Tegmark, AI Magazine 36
 R. Herbrich and R. C. Williamson, Journal of Machine
Learning Research 3, 175 .
 J. Shawe-Taylor, P. L. Bartlett, R. C. Williamson, and
M. Anthony, IEEE transactions on Information Theory
44, 1926 .
 T. Poggio, F. Anselmi, and L. Rosasco, Tech. Rep., Center for Brains, Minds and Machines (CBMM) .
 P. Mehta and D. J. Schwab, ArXiv e-prints ,
1410.3831.
 K. Hornik, M. Stinchcombe, and H. White, Neural networks 2, 359 .
 G. Cybenko, Mathematics of control, signals and systems
2, 303 .
 A. Pinkus, Acta Numerica 8, 143 .
 B. Gnedenko, A. Kolmogorov, B. Gnedenko, and A. Kolmogorov, Amer. J. Math. 105, 28 .
 E. T. Jaynes, Physical review 106, 620 .
 M. Tegmark, A. Aguirre, M. J. Rees, and F. Wilczek,
Physical Review D 73, 023505 .
 O. Delalleau and Y. Bengio, in Advances in Neural Information Processing Systems , pp. 666–674.
 H. Mhaskar, Q. Liao, and T. Poggio, ArXiv e-prints
 , 1603.00988.
 
 R. Adam, P. Ade, N. Aghanim, Y. Akrami, M. Alves,
M. Arnaud, F. Arroja, J. Aumont, C. Baccigalupi,
M. Ballardini, et al., arXiv preprint arXiv:1502.01582
 U. Seljak and M. Zaldarriaga, arXiv preprint astroph/9603033 .
 M. Tegmark, Physical Review D 55, 5895 .
 J. Bond, A. H. Jaﬀe, and L. Knox, Physical Review D
57, 2117 .
 M. Tegmark, A. de Oliveira-Costa, and A. J. Hamilton,
Physical Review D 68, 123523 .
 P. Ade, N. Aghanim, C. Armitage-Caplan, M. Arnaud,
M. Ashdown, F. Atrio-Barandela, J. Aumont, C. Baccigalupi, A. J. Banday, R. Barreiro, et al., Astronomy &
Astrophysics 571, A12 .
 M. Tegmark, The Astrophysical Journal Letters 480, L87
 G. Hinshaw,
C. Barnes,
C. Bennett,
M. Greason,
M. Halpern, R. Hill, N. Jarosik, A. Kogut, M. Limon,
S. Meyer, et al., The Astrophysical Journal Supplement
Series 148, 63 .
 G. Hinton, Momentum 9, 926 .
 M. ´Emile Borel, Rendiconti del Circolo Matematico di
Palermo 27, 247 .
 R. A. Fisher, Philosophical Transactions of the Royal Society of London. Series A, Containing Papers of a Mathematical or Physical Character 222, 309 .
 M. Riesenhuber and T. Poggio, Nature neuroscience 3,
1199 .
 S. Kullback and R. A. Leibler, Ann. Math. Statist.
22, 79 , URL 
1177729694.
 T. M. Cover and J. A. Thomas, Elements of information
theory .
 M. Kardar, Statistical physics of ﬁelds .
 J. Cardy,
Scaling and renormalization in statistical
physics, vol. 5 .
 J. K. Johnson, D. M. Malioutov, and A. S. Willsky, ArXiv
e-prints , 0710.0013.
 C. B´eny, ArXiv e-prints , 1301.3124.
 S. Saremi and T. J. Sejnowski, Proceedings of the
 URL
 
 E. Miles Stoudenmire and D. J. Schwab, ArXiv e-prints
 , 1605.05775.
 G. Vidal, Physical Review Letters 101, 110501 ,
quant-ph/0610099.
 J. Ba and R. Caruana, in Advances in neural information
processing systems , pp. 2654–2662.
 J. Hastad, in Proceedings of the eighteenth annual ACM
symposium on Theory of computing , pp.
 M. Telgarsky, arXiv preprint arXiv:1509.08101 .
 G. F. Montufar, R. Pascanu, K. Cho, and Y. Bengio,
in Advances in neural information processing systems
 , pp. 2924–2932.
 
 B. Poole, S. Lahiri, M. Raghu, J. Sohl-Dickstein, and
S. Ganguli, ArXiv e-prints , 1606.05340.
 M. Raghu, B. Poole, J. Kleinberg, S. Ganguli, and
J. Sohl-Dickstein, ArXiv e-prints , 1606.05336.
 A. M. Saxe, J. L. McClelland, and S. Ganguli, arXiv
 
 Y. Bengio, Y. LeCun, et al., Large-scale kernel machines
34, 1 .
 V. Strassen, Numerische Mathematik 13, 354 .
 F. Le Gall, in Proceedings of the 39th international symposium on symbolic and algebraic computation , pp. 296–303.
 
 H. Vollmer, Introduction to circuit complexity: a uniform
approach .