Machine Learning, 46, 131–159, 2002
c⃝2002 Kluwer Academic Publishers. Manufactured in The Netherlands.
Choosing Multiple Parameters for Support
Vector Machines
OLIVIER CHAPELLE
 
LIP6, Paris, France
VLADIMIR VAPNIK
 
AT&T Research Labs, 200 Laurel Ave, Middletown, NJ 07748, USA
OLIVIER BOUSQUET
 
´Ecole Polytechnique, France
SAYAN MUKHERJEE
 
MIT, Cambridge, MA 02139, USA
Editor: Nello Cristianini
The problem of automatically tuning multiple parameters for pattern recognition Support Vector
Machines (SVMs) is considered. This is done by minimizing some estimates of the generalization error of SVMs
using a gradient descent algorithm over the set of parameters. Usual methods for choosing parameters, based
on exhaustive search become intractable as soon as the number of parameters exceeds two. Some experimental
results assess the feasibility of our approach for a large number of parameters (more than 100) and demonstrate
an improvement of generalization performance.
support vector machines, kernel selection, leave-one-out procedure, gradient descent, feature
Introduction
In the problem of supervised learning, one takes a set of input-output pairs Z = {(x1, y1),
. . . , (xℓ, yℓ)} and attempts to construct a classiﬁer function f that maps input vectors x ∈X
onto labels y ∈Y. We are interested here in pattern recognition or classiﬁcation, that is the
case where the set of labels is simply Y = {−1, 1}. The goal is to ﬁnd a f ∈F which
minimizes the error ( f (x) ̸= y) on future examples. Learning algorithms usually depend
on parameters which control the size of the class F or the way the search is conducted in F.
Several techniques exist for performing the selection of these parameters. The idea is to ﬁnd
the parameters that minimize the generalization error of the algorithm at hand. This error can
be estimated either via testing on some data which has not been used for learning (hold-out
testing or cross-validation techniques) or via a bound given by theoretical analysis.
Tuning multiple parameters.
Usually there are multiple parameters to tune at the same time
and moreover, the estimates of the error are not explicit functions of these parameters, so
O. CHAPELLE ET AL.
that the naive strategy which is exhaustive search in the parameter space becomes intractable
since it would correspond to running the algorithm on every possible value of the parameter
vector (up to some discretization). We propose here a methodology for automatically tuning
multiple parameters for the Support Vector Machines (SVMs) which takes advantage of the
speciﬁc properties of this algorithm.
The SVM algorithm.
Support vector machines (SVMs) realize the following idea: map a
n-dimensional input vector x ∈Rn1 into a high dimensional (possibly inﬁnite dimensional)
feature space H by  and construct an optimal separating hyperplane in this space. Different
mappings construct different SVMs.
When the training data is separable, the optimal hyperplane is the one with the maximal
distance (in H space) between the hyperplane and the closest image (xi) of the vector xi
from the training data. For non-separable training data a generalization of this concept is
Suppose that the maximal distance is equal to γ and that the images (x1), . . . , (xℓ) of
the training vectors x1, . . . , xℓare within a sphere of radius R. Then the following theorem
holds true .
Theorem 1.
Given a training set Z = {(x1, y1), . . . , (xℓ, yℓ)} of size ℓ, a feature space
H and a hyperplane (w,b), the margin γ (w, b, Z) and the radius R(Z) are deﬁned by
γ (w, b, Z) =
yi(w · (xi) + b)
R(Z) = min
a,xi ∥(xi) + a∥
The maximum margin algorithm Lℓ: (X × Y)ℓ→H×R takes as input a training set of size
ℓand returns a hyperplane in feature space such that the margin γ (w, b, Z) is maximized.
Note that assuming the training set separable means that γ > 0. Under this assumption, for
all probability measures P underlying the data Z, the expectation of the misclassiﬁcation
probability
perr(w, b) = P(sign(w · (X) + b) ̸= Y)
has the bound
E{perr(Lℓ−1(Z))} ≤1
γ 2(L(Z), Z)
The expectation is taken over the random draw of a training set Z of size ℓ−1 for the left
hand side and size ℓfor the right hand side.
This theorem justiﬁes the idea of constructing a hyperplane that separates the data with a
large margin: the larger the margin the better the performance of the constructed hyperplane.
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
Note however that according to the theorem the average performance depends on the ratio
E{R2/γ 2} and not simply on the large margin γ .
Why multiple parameters?
The SVM algorithm usually depends on several parameters.
One of them, denoted C, controls the tradeoff between margin maximization and error
minimization. Other parameters appear in the non-linear mapping into feature space. They
are called kernel parameters. For simplicity, we will use a classical trick that allows us
to consider C as a kernel parameter, so that all parameters can be treated in a uniﬁed
framework.
It is widely acknowledged that a key factor in an SVM’s performance is the choice of the
kernel. However, in practice, very few different types of kernels have been used due to the
difﬁculty of appropriately tuning the parameters. We present here a technique that allows
to deal with a large number of parameters and thus allows to use more complex kernels.
Another potential advantage of being able to tune a large number of parameters is the
possibility of rescaling the attributes. Indeed, when no a priori knowledge is available about
the meaning of each of the attributes, the only choice is to use spherical kernels (i.e. give the
same weight to each attribute). But one may expect that there is a better choice for the shape
of the kernel since many real-world database contain attributes of very different natures.
There may thus exist more appropriate scaling factors that give the right weight to the right
feature. For example, we will see how to use radial basis function kernels (RBF) with as
many different scaling factors as input dimensions:
K(x, z) = exp
The usual approach is to consider σ = σ1 = · · · = σn and to try to pick the best value for
σ. However, using the proposed method, we can choose automatically good values for the
scaling factors σi. Indeed, these factors are precisely parameters of the kernel.
Moreover, we will demonstrate that the problem of feature selection can be addressed
with the same framework since it corresponds to ﬁnding those attributes which can be
rescaled with a zero factor without harming the generalization.
We thus see that tuning kernel parameters is something extremely useful and a procedure
that allows to do this would be a versatile tool for various tasks such as ﬁnding the right
shape of the kernel, feature selection, ﬁnding the right tradeoff between error and margin,
etc. All this gives a rationale for developing such techniques.
Our approach.
In summary, our goal is not only to ﬁnd the hyperplane which maximizes
the margin but also the values of the mapping parameters that yield best generalization
error. To do so, we propose a minimax approach: maximize the margin over the hyperplane
coefﬁcients and minimize an estimate of the generalization error over the set of kernel
parameters. This last step is performed using a standard gradient descent approach.
What kind of error estimates.
We will consider several ways of assessing the generalization
O. CHAPELLE ET AL.
• Validation error: this procedure requires a reduction of the amount of data used for
learning in order to save some of it for validation. Moreover, the estimates have to be
smoothed for proper gradient descent.
• Leave-one-out error estimates: this procedure gives an estimate of the expected generalization as an analytic function of the parameters.
We will examine how the accuracy of the estimates inﬂuences the whole procedure of ﬁnding
optimal parameters. In particular we will show that what really matters is how variations of
the estimates relate to variations of the test error rather than how their values are related.
The paper is organized as follows. The next section introduces the basics of
SVMs. The different possible estimates of their generalization error are described in
Sections 3 and 4 explains how to smooth theses estimates. Then we introduce in
Section 5 a framework for minimizing those estimates by gradient descent. Section 6 deals
with the computation of gradients of error estimates with respect to kernel parameters. Finally, in Sections 7 and 8, we present experimental results of the method applied to a variety
of databases in different contexts. Section 7 deals with ﬁnding the right penalization along
with the right radius for a kernel and with ﬁnding the right shape of a kernel. In Section 8
we present results of applying our method to feature selection.
Support vector learning
We introduce some standard notations for SVMs; for a complete description, see . Let {(xi, yi)}1≤i≤ℓbe a set of training examples, xi ∈Rn which belong to a class
labeled by yi ∈{−1, 1}. In the SVM methodology, we map these vectors into a feature
space using a kernel function K(xi, x j) that deﬁnes an inner product in this feature space.
Here, we consider a kernel Kθθθ depending on a set of parameters θ. The decision function
given by an SVM is:
f (x) = sign
i yi Kθθθ(xi, x) + b
where the coefﬁcients α0
i are obtained by maximizing the following functional:
αiα j yi y j Kθθθ(xi, x j)
under the constraints
i = 1, . . . , ℓ.
The coefﬁcients α0
i deﬁne a maximal margin hyperplane in a high-dimensional feature
space where the data are mapped through a non-linear function  such that (xi) · (x j) =
K(xi, x j).
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
This formulation of the SVM optimization problem is called the hard margin formulation
since no training errors are allowed. Every training point satisﬁes the inequality yi f (xi) ≥1
and for points xi with corresponding αi > 0 an equality is satisﬁed. These points are called
support vectors.
Notice that one may require the separating hyperplane to pass through the origin by
choosing a ﬁxed b = 0. This variant is called the hard margin SVM without threshold. In
that case, the optimization problem remains the same as above except that the constraint
 αi yi = 0 disappears.
Dealing with non-separability.
For the non-separable case, one needs to allow training
errors which results in the so called soft margin SVM algorithm . It
can be shown that soft margin SVMs with quadratic penalization of errors can be considered
as a special case of the hard margin version with the modiﬁed kernel .
where I is the identity matrix and C a constant penalizing the training errors. In the rest of
the paper, we will focus on the hard margin SVM and use (3) whenever we have to deal
with non-separable data. Thus C will be considered just as another parameter of the kernel
Estimating the performance of an SVM
Ideally we would like to choose the value of the kernel parameters that minimize the true
risk of the SVM classiﬁer. Unfortunately, since this quantity is not accessible, one has to
build estimates or bounds for it. In this section, we present several measures of the expected
error rate of an SVM.
Single validation estimate
If one has enough data available, it is possible to estimate the true error on a validation
set. This estimate is unbiased and its variance gets smaller as the size of the validation set
increases. If the validation set is {(x′
i)}1≤i≤p, the estimate is
where  is the step function: (x) = 1 when x > 0 and (x) = 0 otherwise.
O. CHAPELLE ET AL.
Leave-one-out bounds
The leave-one-out procedure consists of removing from the training data one element,
constructing the decision rule on the basis of the remaining training data and then testing
on the removed element. In this fashion one tests all ℓelements of the training data (using ℓ
different decision rules). Let us denote the number of errors in the leave-one-out procedure
by L(x1, y1, . . . , xℓ, yℓ). It is known that the the leave-one-out
procedure gives an almost unbiased estimate of the expected generalization error:
ℓE(L(x1, y1, . . . , xℓ, yℓ)),
where pℓ−1
err is the probability of test error for the machine trained on a sample of size ℓ−1
and the expectations are taken over the random choice of the sample.
Although this lemma makes the leave-one-out estimator a good choice when estimating
the generalization error, it is nevertheless very costly to actually compute since it requires
running the training algorithm ℓtimes. The strategy is thus to upper bound or approximate
this estimator by an easy to compute quantity T having, if possible, an analytical expression.
If we denote by f 0 the classiﬁer obtained when all training examples are present and f i
the one obtained when example i has been removed, we can write:
L(x1, y1, . . . , xℓ, yℓ) =
(−yp f p(xp)),
which can also be written as
L(x1, y1, . . . , xℓ, yℓ) =
(−yp f 0(xp) + yp( f 0(xp) −f p(xp))).
Thus, if Up is an upper bound for yp( f 0(xp) −f p(xp)), we will get the following upper
bound on the leave-one-out error:
L(x1, y1, . . . , xℓ, yℓ) ≤
since for hard margin SVMs, yp f 0(xp) ≥1 and  is monotonically increasing.
3.2.1. Support vector count.
Since removing a non-support vector from the training set
does not change the solution computed by the machine (i.e. Up = f 0(xp) −f p(xp) = 0
for xp non-support vector), we can restrict the preceding sum to support vectors and upper
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
bound each term in the sum by 1 which gives the following bound on the number of errors
made by the leave-one-out procedure :
where NSV denotes the number of support vectors.
3.2.2. Jaakkola-Haussler bound.
For SVMs without threshold, analyzing the optimization performed by the SVM algorithm when computing the leave-one-out error, Jaakkola
and Haussler proved the inequality:
yp( f 0(xp) −f p(xp)) ≤α0
pK(xp, xp) = Up
which leads to the following upper bound:
pK(xp, xp) −1
Note that Wahba, Lin, and Zhang proposed an estimate of the number of errors
made by the leave-one-out procedure, which in the hard margin SVM case turns out to be
pK(xp, xp),
which can be seen as an upper bound of the Jaakkola-Haussler one since (x −1) ≤x for
3.2.3. Opper-Winther bound.
For hard margin SVMs without threshold, Opper and
Winther used a method inspired from linear response theory to prove the following:
under the assumption that the set of support vectors does not change when removing the
example p, we have
yp( f 0(xp) −f p(xp)) =
where KSV is the matrix of dot products between support vectors; leading to the following
O. CHAPELLE ET AL.
3.2.4. Radius-margin bound.
For SVMs without threshold and with no training errors,
Vapnik proposed the following upper bound on the number of errors of the leaveone-out procedure:
where R and γ are the radius and the margin as deﬁned in Theorem 1.
3.2.5. Span bound.
Vapnik and Chapelle and Chapelle and Vapnik derived
an estimate using the concept of span of support vectors.
Under the assumption that the set of support vectors remains the same during the leaveone-out procedure, the following equality is true:
yp( f 0(xp) −f p(xp)) = α0
where Sp is the distance between the point (xp) and the set p where
This gives the exact number of errors made by the leave-one-out procedure under the
previous assumption:
The span estimate can be related to other approximations:
Link with Jaakkola-Haussler bound.
If we consider SVMs without threshold, the constraint  λi = 1 can be removed in the deﬁnition of the span. Then we can easily upper
bound the value of the span: S2
p ≤K(xp, xp), and thus recover the Jaakkola-Haussler bound.
Link with R2/γ 2.
For each support vector, we have yp f 0(xp) = 1. Since for x ≥0,
(x −1) ≤x, the number of errors made by the leave-one-out procedure is bounded by:
It has been shown that the span Sp is bounded by the diameter
of the smallest sphere enclosing the training points and since  α0
p = 1/γ 2, we ﬁnally get
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
A similar derivation as the one used in the span bound has been proposed in Joachims ,
wheretheleave-one-outerrorisboundedby|{p, 2α0
p R2 > yp f 0(xp)}|,with0 ≤K(xi, xi) ≤
Link with Opper-Winther.
When the support vectors do not change, the hard margin case
without threshold gives the same value as the Opper-Winther bound, namely:
Smoothing the test error estimates
The estimate of the performance of an SVM through a validation error (4) or the leaveone-out error (5) requires the use of the step function . However, we would like to use a
gradient descent approach to minimize those estimates of the test error. Unfortunately the
step function is not differentiable. As already mentioned in Section 3.2.5, it is possible to
bound (x −1) by x for x ≥0. This is how the bound R2/γ 2 is derived from the leave-oneout error. Nevertheless by doing so, large errors count more than one, therefore it might be
advantageous instead to use a contracting function of the form (x) = (1 + exp(−Ax +
B))−1 (see ﬁgure 1).
However, the choice of the constants A and B is difﬁcult. If A is too small, the estimate
is not accurate and A is too large, the resulting estimate is not smooth.
Instead of trying to pick good constants A and B, one can try to get directly a smooth
approximationofthetesterrorbyestimatingposteriorprobabilities.Recently,Plattproposed
the following estimate of the posterior distribution P(Y = 1 | X = x) of an SVM output f (x)
 :
˜PA,B(x) = ˜P(Y = 1 | X = x) =
1 + exp(Af (x) + B),
where f (x) is the output of the SVM. The constants A and B are found by minimizing the
Kullback-Leibler divergence between ˜P and an empirical approximation of P built from a
validation set (x′
(A∗, B∗) = arg max
log( ˜PA,B(x′
i)) + 1 −y′
log .
According to this estimate the best threshold for our SVM classiﬁer f is such that
f (x) = sign( ˜PA∗,B∗(x) −0.5). Note that if B∗̸= 0, we obtained a correction compared to
the usual SVM threshold.
O. CHAPELLE ET AL.
Validation error for different values of the width (in log scale) of an RBF kernel. Top left: with a
step function, (x) = 1x > 0. Top right: sigmoid function, (x) = (1 + exp(−5x))−1. Bottom: linear function,
(x) = 1 + x for x > −1, 0 otherwise. Note that on the bottom picture, the minimum is not at the right place.
By deﬁnition the generalization error of our classiﬁer is
P(Y ̸= f (X)) =
x, f (x)=−1
P(Y = 1 | x)dµ(x) +
x, f (x)=1
(Y = −1| x)dµ(x).
This error can be empirically estimated as2:
P(Y ̸= f (X)) ≈
min( ˜P(x′
i), 1 −˜P(x′
Note that the labels of the validation set are not used directly in this last step but indirectly
through the estimation of the constants A and B appearing in the parametric form of ˜PA∗,B∗.
To have a better understanding of this estimate, let us consider the extreme case where there
is no error on the validation set. Then the maximum likelihood algorithm is going to yield
A = −∞and ˜PA∗,B∗(x) will only take binary values. As a consequence, the estimate of the
error probability will be zero.
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
Optimizing the kernel parameters
Let’s go back to the SVM algorithm. We assume that the kernel k depends on one or several
parameters, encoded into a vector θ = (θ1, . . . , θn). We thus consider a class of decision
functions parametrized by α, b and θ:
fαα,b,θθθ(x) = sign
αi yi Kθθθ(x, xi) + b
We want to choose the values of the parameters α and θ such that W (see Eq. (2)) is
maximized (maximum margin algorithm) and T , the model selection criterion, is minimized
(best kernel parameters). More precisely, for θ ﬁxed, we want to have α0 = arg max W(α)
and choose θ0 such that
θ0 = arg min
T (α0, θ).
When θ is a one dimensional parameter, one typically tries a ﬁnite number of values and
picks the one which gives the lowest value of the criterion T . When both T and the SVM
solution are continuous with respect to θ, a better approach has been proposed by Cristianini,
Campbell, and Shawe-Taylor : using an incremental optimization algorithm, one can
train an SVM with little effort when θ is changed by a small amount. However, as soon as
θ has more than one component computing T (α, θ) for every possible value of θ becomes
intractable, and one rather looks for a way to optimize T along a trajectory in the kernel
parameter space.
Using the gradient of a model selection criterion to optimize the model parameters has
been proposed in Bengio and demonstrated in the case of linear regression and
time-series prediction. It has also been proposed by Larsen et al. to optimize the
regularization parameters of a neural network.
Here we propose an algorithm that alternates the SVM optimization with a gradient step
is the direction of the gradient of T in the parameter space. This can be achieved by the
following iterative procedure:
1. Initialize θ to some value.
2. Using a standard SVM algorithm, find the maximum of the
quadratic form W :
α0(θ) = arg max
3. Update the parameters θ such that T is minimized.
This is typically achieved by a gradient step (see below).
4. Go to step 2 or stop when the minimum of T is reached.
Solving step 3 requires estimating how T varies with θ. We will thus restrict ourselves to
the case where Kθθθ can be differentiated with respect to θ. Moreover, we will only consider
cases where the gradient of T with respect to θ can be computed (or approximated).
O. CHAPELLE ET AL.
Note that α0 depends implicitly on θ since α0 is deﬁned as the maximum of W. Then, if
we have n kernel parameters (θ1, . . . , θn), the total derivative of T 0(·) ≡T (α0(·), ·) with
respect to θp is:
Having computed the gradient ∇θθθT (α0, θ), a way of performing step 3 is to make a
gradient step:
δθk = −ε∂T (α0, θ)
for some small and eventually decreasing ε. The convergence can be improved with the use
of second order derivatives (Newton’s method):
δθk = −(θθθT )−1 ∂T (α0, θ)
where the Laplacian operator  is deﬁned by
(θθθT )i, j = ∂2T (α0, θ)
In this formulation, additional constraints can be imposed through projection of the gradient.
Computing the gradient
In this section, we describe the computation of the gradient (with respect to the kernel
parameters) of the different estimates of the generalization error. First, for the bound R2/γ 2
(see Theorem 1), we obtain a formulation of the derivative of the margin (Section 6.1) and of
the radius (Section 6.2). For the validation error (see Eq. (4)), we show how to calculate the
derivative of the hyperplane parameters α0 and b (see Section 6.3). Finally, the computation
of the derivative of the span bound (7) is presented in Section 6.4.
We ﬁrst begin with a useful lemma.
Suppose we are given a (n × 1) vector vθ and an (n × n) matrix Pθ smoothly
depending on a parameter θ. Consider the function:
L(θ) = max
x∈F xT vθ −1
F = {x : bT x = c, x ≥0}.
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
Let ¯x be the the vector x where the maximum in L(θ) is attained. If this minimum is unique
In other words, it is possible to differentiate L with respect to θ as if ¯x did not depend on
θ. Note that this is also true if one (or both) of the constraints in the deﬁnition of F are
We ﬁrst need to express the equality constraint with a Lagrange multiplier λ and
the inequality constraints with Lagrange multipliers γi:
L(θ) = max
x,λ,γ xT vθ −1
2xT Pθx −λ(bT x −c) + γ T x.
At the maximum, the following conditions are veriﬁed:
vθ −Pθ ¯x = ¯λb −¯γ ,
bT ¯x = c,
¯γi ¯xi = 0,
We will not consider here differentiability problems. The interested reader can ﬁnd details in Bonnans and Shapiro . The main result is that whenever ¯x is unique, L is
differentiable.
∂θ ¯x + ∂¯xT
∂θ (vθ −Pθ ¯x),
where the last term can be written as follows,
∂θ (vθ −Pθ ¯x) = ¯λ∂¯xT
∂θ b −∂¯xT
Using the derivatives of the optimality conditions, namely
∂θ ¯xi + ¯γi
and the fact that either ¯γi = 0 or ¯xi = 0 we get:
∂θ ¯xi = ¯γi
O. CHAPELLE ET AL.
∂θ (vθ −Pθ ¯x) = 0
and the result follows.
Computing the derivative of the margin
Note that in feature space, the separating hyperplane {x : w·(x)+b = 0} has the following
and is normalized such that
1≤i≤ℓyi(w · (xi) + b) = 1.
It follows from the deﬁnition of the margin in Theorem 1 that this latter is γ = 1/∥w∥. Thus
we write the bound R2/γ 2 as R2∥w∥2.
The previous lemma enables us to compute the derivative of ∥w∥2. Indeed, it can be
shown that
2∥w∥2 = W(α0),
and the lemma can be applied to the standard SVM optimization problem (2), giving
∂K(xi, x j)
Computing the derivative of the radius
Computing the radius of the smallest sphere enclosing the training points can be achieved
by solving the following quadratic problem :
βi K(xi, xi) −
βiβ j K(xi, x j)
under constraints
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
We can again use the previous lemma to compute the derivative of the radius:
∂K(xi, xi)
∂K(xi, x j)
where β0 maximizes the previous quadratic form.
Computing the derivative of the hyperplane parameters
Let us ﬁrst compute the derivative of α0 with respect to a parameter θ of the kernel. For
this purpose, we need an analytical formulation for α0. First, we suppose that the points
which are not support vectors are removed from the training set. This assumption can be
done without any loss of generality since removing a point which is not support vector does
not affect the solution. Then, the fact that all the points lie on the margin can be written
ij = yi y j K(xi, x j). If there are n support vectors, H is a (n + 1)×(n + 1) matrix.
The parameters of the SVMs can be written as:
(α0, b)T = H−1(1 · · · 1 0)T .
We are now able to compute the derivatives of those parameters with respect to a kernel
parameter θp. Indeed, since the derivative of the inverse of a matrix M depending on a
parameter θp can be written3
it follows that
H−1(1 · · · 1 0)T ,
and ﬁnally
O. CHAPELLE ET AL.
We can easily use the result of this calculation to recover the computation ∂∥w∥2
∂θp . Indeed, if
we denote ˜α = (α0, b), we have ∥w∥2 = (α0)T KYα0 = ˜αT H ˜α and it turns out that:
˜α + 2 ˜αH ∂˜α
˜α −2 ˜αHH−1 ∂H
= −(α0)T ∂KY
Computing the derivative of the span-rule
Now, let us consider the span value. Recall that the span of the support vector xp is deﬁned
as the the distance between the point (xp) and the set p deﬁned by (6). Then the value
of the span can be written as:
Note that we introduced a Lagrange multiplier µ to enforce the constraint  λi = 1.
Introducing the extended vector ˜λ = (λT µ)T and the extended matrix of the dot products
between support vectors
the value of the span can be written as:
µ (K(xp, xp) −2vT ˜λ + ˜λ
where H is the submatrix of ˜KSV with row and column p removed, and v is the p-th column
From the fact that the optimal value of ˜λ is H−1v, it follows:
p = K(xp, xp) −vT H−1v
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
The last equality comes from the following block matrix identity, known as the “Woodbury”
formula 
where B1 = (A1 −AA−1
The closed form we obtain is particularly attractive since we can compute the value of
the span for each support vector just by inverting the matrix KSV .
Combining Eqs. (12) and (11), we get the derivative of the span
Thus, the complexity of computing the derivative of the span-rule with respect to a
parameter θp of the kernel requires only the computation of ∂K(xi,x j)
and the inversion of
the matrix ˜KSV . The complexity of these operations is not larger than that of the quadratic
optimization problem itself.
There is however a problem in this approach: the value given by the span-rule is not
continuous. By changing smoothly the value of the parameters θ, the coefﬁcients αp change
continuously, but the span S2
p does not. There is actually a discontinuity for most support
vectors when the set of support vectors changes. This can be easily understood from Eq. (6):
suppose that upon changing the value of the parameter from θ to θ + ε, a point xm is not a
support vector anymore, then for all other support vectors (xp)p̸=m, the set p is going to
be smaller and a discontinuity is likely to appear for the value of Sp = d((xp), p).
The situation is explained in ﬁgure 2: we plotted the value of the span of a support vector
xp versus the width of an RBF kernel σ. Almost everywhere the span is decreasing, hence a
negative derivative, but some jumps appear, corresponding to a change in the set of support
vectors. Moreover the span is globally increasing: the value of the derivate does not give us
a good indication of the global evolution of the span.
One way to solve is this problem is to try to smooth the behavior of the span. This can
be done by imposing the following additional constraint in the deﬁnition of p in Eq. (6):
|λi| ≤c α0
i , where c is a constant. Given this constraint, if a point xm is about to leave or
has just entered the set of support vectors, it will not have a large inﬂuence on the span of
the other support vectors, since α0
m will be small. The effect of this constraint is to make
the set p become “continuous” when the set of support vectors changes.
However this new constraint prevents us from computing the span as efﬁciently as in
Eq. (12). A possible solution is to replace the constraint by a regularization term in the
computation of the span:
λλλ,  λi=1
(xp) −
O. CHAPELLE ET AL.
Value of  S2
p, the sum of the span of the training points for different values of the width of an RBF
kernel varying in the small vicinity.
With this new deﬁnition of the span, Eq. (12) becomes:
p = 1/( ˜KSV + D)−1
where D is a diagonal matrix with elements Dii = η/α0
i and Dn+1,n+1 = 0. As shown on
ﬁgure 3, the span is now much smoother and its minimum is still at the right place. In our
experiments, we took η = 0.1.
Note that computing the derivative of this new expression is no more difﬁcult than the
previous span expression.
Left: the minima of the span prediction with regularization (dashed line) and without regularization (solid line) are close. Right: detailed behavior of the span for different values of the regularizer,
η = 0, 0.001, 0.01, 0.1.
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
It is interesting to look at the leave-one-out error for SVMs without threshold. In this
case, the value of the span with regularization writes:
(xp) −
As already pointed out in Section 3.2.5, if η = 0, the value of span is:
and we recover the Opper-Winther bound.
On the other hand, if η = +∞, then λ = 0 and S2
p = K(xp, xp). In this case, the span
bound is identical to the Jaakkola-Haussler one.
In a way, the span bound with regularization is in between the bounds of Opper-Winther
and Jaakkola-Haussler.
Experiments
Experiments have been carried out to assess the performance and feasibility of our method.
The ﬁrst set of experiments consists in ﬁnding automatically the optimal value of two
parameters: the width of an RBF kernel and the constant C in Eq. (3). The second set of
experiments corresponds to the optimization of a large number of scaling factors in the
case of handwritten digit recognition. We then show that optimizing scaling factors leads
naturally to feature selection and demonstrate the application of the method to the selection
of relevant features in several databases.
Optimization details
The core of the technique we present here is a gradient descent algorithm. We used the
optimization toolbox of Matlab to perform it. It includes second order updates to improve
the convergence speed. Since we are not interested in the exact value of the parameters
minimizing the functional, we used a loose stopping criterion.
Benchmark databases
In a ﬁrst set of experiments, we tried to select automatically the width σ of a RBF kernel,
K(x, z) = exp
along the constant C penalizing the training error appearing in Eq. (3).
O. CHAPELLE ET AL.
Inordertoavoidaddingpositivityconstraintsintheoptimizationproblem(fortheconstant
C and the width σ of the RBF kernel), we use the parameterization θ = (log C, log σ).
Moreover, this turns out to give a more stable optimization. The initial values are C = 1 and
log σ = −2. Each component being normalized by its standard deviation, this corresponds
to a rather small value for σ.
We used benchmark databases described in R¨atsch, Onoda, and M¨uller . Those
databases, as long as the 100 differents training and test splits are available at
 
We followed the same experimental setup as in R¨atsch, Onoda, and M¨uller . On
each of the ﬁrst 5 training sets, the kernel parameters are estimated using either 5-fold
cross-validation, minimization of R2/γ 2, or the span-bound. Finally, the kernel parameters
are computed as the median of the 5 estimations.
The results are shown in Table 1.
It turns out that minimizing R2/γ 2 or the span estimates yields approximately the same
performances as picking-up the parameters which minimize the cross-validation error. This
is not very surprising since cross-validation is known to be an accurate method for choosing
the hyper-parameters of any learning algorithm.
A more interesting comparison is the computational cost of these methods. Table 2
shows how many SVM trainings in average are needed to select the kernel parameters on
each split. The results for cross-validation are the ones reported in R¨atsch, Onoda, and
Test error found by different algorithms for selecting the SVM parameters C and σ.
Cross-validation
Span-bound
Breast cancer
26.04 ± 4.74
26.84 ± 4.71
25.59 ± 4.18
23.53 ± 1.73
23.25 ± 1.7
23.19 ± 1.67
15.95 ± 3.26
15.92 ± 3.18
16.13 ± 3.11
4.80 ± 2.19
4.62 ± 2.03
4.56 ± 1.97
22.42 ± 1.02
22.88 ± 1.23
22.5 ± 0.88
The ﬁrst column reports the results from R¨atsch, Onoda, and M¨uller . In the second
and last column, the parameters are found by minimizing R2/γ 2 and the span-bound using a
gradient descent algorithm.
Average number of SVM trainings on one training set needed to select the parameters C and σ using
standard cross-validation or by minimizing R2/γ 2 or the span-bound.
Cross-validation
Span-bound
Breast cancer
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
M¨uller . They tried 10 different values for C and σ and performed 5-fold crossvalidation. The number of SVM trainings on each of the 5 training set needed by this
method is 10 × 10 × 5 = 500.
The gain in complexity is impressive: on average 100 times fewer SVM training iterations
are required to ﬁnd the kernel parameters. The main reason for this gain is that there were
two parameters to optimize. Because of computational reasons, exhaustive search by crossvalidation can not handle the selection of more than 2 parameters, whereas our method can,
as highlighted in the next section.
Discussion.
As explained in Section 3.2, R2/γ 2 can seem to be a rough upper bound of the
span-bound, which is in an accurate estimate of the test error .
However in the process of choosing the kernel parameters, what matters is to have a bound
whose minimum is close to the optimal kernel parameters. Even if R2/γ 2 cannot be used
to estimate the test error, the previous experiments show that its minimization yields quite
good results. The generalization error obtained by minimizing the span-bound (cf Table 1)
are just slightly better. Since the minimization of the latter is more difﬁcult to implement
and to control (more local minima), we recommend in practice to minimize R2/γ 2. In the
experiments of the following section, we will only relate experiments with this bound, but
similar results have been obtained with the span-bound.
Automatic selection of scaling factors
In this experiment, we try to choose the scaling factors for an RBF and polynomial kernel
of degree 2. More precisely, we consider kernels of the following form:
K(x, z) = exp
Most of the experiments have been carried out on the USPS handwritten digit recognition
database. This database consists of 7291 training examples and 2007 test examples of digit
images of size 16 × 16 pixels. We try to classify digits 0 to 4 against 5 to 9. The training
set has been split into 23 subsets of 317 examples and each of this subset has been used
successively during the training.
To assess the feasibility of our gradient descent approach for ﬁnding kernel parameters,
we ﬁrst used only 16 parameters, each one corresponding to a scaling factor for a squared
tile of 16 pixels as shown on ﬁgure 4.
The scaling parameters were initialized to 1. The evolution of the test error and of the
bound R2/γ 2 is plotted versus the number of iterations in the gradient descent procedure
in ﬁgures 5 (polynomial kernel) and 6 (RBF kernel).
O. CHAPELLE ET AL.
On each of the 16 tiles, the scaling factors of the 16 pixels are identical.
Evolution of the test error (left) and of the bound R2/γ 2 (right) during the gradient descent optimization
with a polynomial kernel.
Evolution of the test error (left) and of the bound R2/γ 2 (right) during the gradient descent optimization
with an RBF kernel.
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
Scaling factors found by the optimization procedure: darker means smaller scaling factor.
Note that for the polynomial kernel, the test error went down to 9% whereas the best test
error with only one scaling parameter is 9.9%. Thus, by taking several scaling parameters,
we managed to make the test error decrease.
It might be interesting to have a look at the value of the scaling coefﬁcients we have have
found. For this purpose, we took 256 scaling parameters (one per pixel) and mini- mized
R2/γ 2 with a polynomial kernel. The map of the scaling coefﬁcient is shown in ﬁgure 7.
The result is quite consistent with what one could expect in such a situation: the coef-
ﬁcients near the border of the picture are smaller than those in the middle of the picture,
so that these coefﬁcients can be directly interpreted as measures of the relevance of the
corresponding features.
Discussion.
This experiment can be considered as a sanity check experiment. Indeed, it
proves it is feasible to choose multiple kernel parameters of an SVM and that it does not
lead to overﬁtting. However, the gain in test error was not our main motivation since we
did not expect any signiﬁcant improvement on such a problem where most features play a
similar role (taking all scaling factors equal on this database seems a reasonable choice).
However as highlighted by ﬁgure 7, this method can be a powerful tool to perform feature
selection.
Feature selection
The motivation for feature selection is three-fold:
1. Improve generalization error
2. Determine the relevant features (for explanatory purposes)
3. Reduce the dimensionality of the input space (for real-time applications)
Finding optimal scaling parameters can lead to feature selection algorithms. Indeed, if
one of the input components is useless for the classiﬁcation problem, its scaling factor
is likely to become small. But if a scaling factor becomes small enough, it means that it
is possible to remove it without affecting the classiﬁcation algorithm. This leads to the
following idea for feature selection: keep the features whose scaling factors are the largest.
O. CHAPELLE ET AL.
This can also be performed in a principal components space where we scale each principal
component by a scaling factor.
We consider two different parametrization of the kernel. The ﬁrst one correspond to
rescaling the data in the input space:
Kθθθ(x, z) = K(θT x, θT z)
where θ ∈Rn.
The second one corresponds to rescaling in the principal components space:
Kθθθ(x, z) = K(θT x, θT z)
where Σ is the matrix of principal components.
We compute θ and α using the following iterative procedure:
1. Initialize θ = (1, . . . , 1)
2. In the case of principal component scaling, perform
principal component analysis to compute the matrix .
3. Solve the SVM optimization problem
4. Minimize the estimate of the error T with respect to θ
with a gradient step.
5. If a local minimum of T is not reached go to step 3.
6. Discard dimensions corresponding to small elements in θ
and return to step 2.
We demonstrate this idea on two toy problems where we show that feature selection
reduces generalization error. We then apply our feature selection algorithm to DNA Microarray data where it is important to ﬁnd which genes are relevant in performing the classiﬁcation. It also seems in these types of algorithms that feature selection improves performances.
Lastly, we apply the algorithm to face detection and show that we can greatly reduce the
input dimension without sacriﬁcing performance.
We compared several algorithms
• The standard SVM algorithm with no feature selection
• Our feature selection algorithm with the estimate R2/γ 2 and with the span estimate
• The standard SVM applied after feature selection via a ﬁlter method
The three ﬁlter methods we used choose the m largest features according to: Pearson
correlationcoefﬁcients,theFishercriterionscore,4 andtheKolmogorov-Smirnovtest.5 Note
that the Pearson coefﬁcients and Fisher criterion cannot model nonlinear dependencies.
In the two following artiﬁcial datasets our objective was to assess the ability of the
algorithm to select a small number of target features in the presence of irrelevant and
redundant features .
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
A comparison of feature selection methods on (a) a linear problem and (b) a nonlinear problem both
with many irrelevant features. The x-axis is the number of training points, and the y-axis the test error as a fraction
of test points.
For the ﬁrst example, six dimensions of 202 were relevant. The probability of y = 1 or −1
was equal. The ﬁrst three features {x1, x2, x3} were drawn as xi = yN(i, 1) and the second
three features {x4, x5, x6} were drawn as xi = N(0, 1) with a probability of 0.7, otherwise
the ﬁrst three were drawn as xi = N(0, 1) and the second three as xi = yN(i −3, 1). The
remaining features are noise xi = N(0, 20), i = 7, . . . , 202.
For the second example, two dimensions of 52 were relevant. The probability of y = 1
or −1 was equal. The data are drawn from the following: if y = −1 then {x1, x2} are drawn
from N(µ1, ) or N(µ2, ) with equal probability, µ1 = {−3
4, −3} and µ2 = { 3
 = I, if y = 1 then {x1, x2} are drawn again from two normal distributions with equal
probability, with µ1 = {3, −3} and µ2 = {−3, 3} and the same  as before. The rest of the
features are noise xi = N(0, 20), i = 3, . . . , 52.
In the linear problem the ﬁrst six features have redundancy and the rest of the features
are irrelevant. In the nonlinear problem all but the ﬁrst two features are irrelevant.
We used a linear kernel for the linear problem and a second order polynomial kernel for
the nonlinear problem.
We imposed the feature selection algorithms to keep only the best two features. The
results are shown in ﬁgure 8 for various training set sizes, taking the average test error on
500 samples over 30 runs of each training set size. The Fisher score (not shown in graphs
due to space constraints) performed almost identically to correlation coefﬁcients.
In both problem, we clearly see that our method outperforms the other classical methods for feature selection. In the nonlinear problem, among the ﬁlter methods only the
Kolmogorov-Smirnov test improved performance over standard SVMs.
DNA microarray data
Next, we tested this idea on two leukemia discrimination problems and
a problem of predicting treatment outcome for Medulloblastoma.6 The ﬁrst problem was to
O. CHAPELLE ET AL.
classify myeloid versus lymphoblastic leukemias based on the expression of 7129 genes.
The training set consists of 38 examples and the test set 34 examples. Standard linear SVMs
achieve 1 error on the test set. Using gradient descent on R2/γ 2 we achieved 0 error using
30 genes and 1 error using 1 gene. Using the Fisher score to select features resulted in 1
error for both 1 and 30 genes.
The second leukemia classiﬁcation problem was discriminating B versus T cells for
lymphoblasticcells .StandardlinearSVMsmake1errorforthisproblem.
Using either the span bound or gradient descent on R2/γ 2 results in 0 error using 5 genes,
whereas the Fisher score get 2 errors using the same number of genes.
The ﬁnal problem is one of predicting treatment outcome of patients that have
Medulloblastoma. Here there are 60 examples each with 7129 expression values in the
dataset and we use leave-one-out to measure the error rate. A standard SVM with a Gaussian
kernel makes 24 errors, while selecting 60 genes using the gradient descent on R2/γ 2 we
achieved an error of 15.
Face detection
The trainable system for detecting frontal and near-frontal views of faces in gray images
presented in Heisele, Poggio, and Pontil gave good results in terms of detection rates.
The system used gray values of 19 × 19 images as inputs to a second-degree polynomial
kernel SVM. This choice of kernel lead to more than 40,000 features in the feature space.
Searching an image for faces at different scales took several minutes on a PC. To make
ROC curves for different number of PCA gray features.
CHOOSING MULTIPLE PARAMETERS FOR SUPPORT VECTOR MACHINES
the system real-time reducing the dimensionality of the input space and the feature space
was required. The feature selection in principal components space was used to reduce the
dimensionality of the input space .
The method was evaluated on the large CMU test set 1 consisting of 479 faces and about
57,000,000 non-face patterns. In ﬁgure 9, we compare the ROC curves obtained for different
numbers of selected components.
The results showed that using more than 60 components does not improve the performances of the system .
Conclusion
We proposed an approach for automatically tuning the kernel parameters of an SVM. This
is based on the possibility of computing the gradient of various bounds on the generalization
error with respect to these parameters. Different techniques have been proposed to smooth
these bounds while preserving their accuracy in predicting the location of the minimum
of test error. Using these smoothed gradients we were able to perform gradient descent
to search the kernel parameter space, leading to both an improvement of the performance
and a reduction of the complexity of the solution (feature selection). Using this method,
we chose in the separable case appropriate scaling factors. In the non separable case,
this method allows us to choose simultaneously scaling factors and parameter C (see
The beneﬁts of this technique are many. First it allows to actually optimize a large number
of parameters while previous approaches only could deal with 2 parameters at most. Even
in the case of a small number of parameters, it improves the run time by a large amount.
Moreover experimental results have demonstrated that an accurate estimate of the error is
not required and that a simple estimate like R2/γ 2 has a very good behaviour in terms of
ﬁnding the right parameters. In a way this renders the technique even more applicable since
this estimate is very simple to compute and derive. Finally, this approach avoids holding
out some data for validation and thus makes full use of the training set for the optimization
of parameters, contrary to cross-validation methods.
This approach and the fact that it has be proven successful in various situation opens
new directions of research in the theory and practice of Support Vector Machines. On
the practical side, this approach makes possible the use of highly complex and tunable
kernels, the tuning of scaling factors for adapting the shape of the kernel to the problem
and the selection of relevant features. On the theoretical side, it demonstrates that even
when a large number of parameter are simultaneously tuned the overﬁtting effect remains
Of course a lot of work remains to be done in order to properly understand the reasons.
Another interesting phenomenon is the fact that the quantitative accuracy of the estimate
used for the gradient descent is only marginally relevant. This raises the question of how to
design good estimates for parameter tuning rather than accurate estimates.
Future investigation will focus on trying to understand these phenomena and obtain
bounds on the generalization error of the overall algorithm, along with looking for new
problems where this approach could be applied as well as new applications.
O. CHAPELLE ET AL.
Acknowledgments
The authors would like to thank Jason Weston and ´Elodie N´ed´elec for helpful comments
and discussions.
1. In the rest of this article, we will reference vectors and matrices using bold notation.
2. We note ˜P(x) as an abbreviation for ˜PA∗,B∗(x).
3. This inequality can be easily proved by differentiating MM−1 = I.
, where µ±
r is the mean value for the r-th feature in the positive and negative classes and σ ±
is the standard deviation.
5. KStst(r) =
ℓsup( ˆP{X ≤fr} −ˆP{X ≤fr, yr = 1}) where fr denotes the r-th feature from each training
example, and ˆP is the corresponding empirical distribution.
6. The database will be available at :