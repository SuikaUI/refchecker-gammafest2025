Cascade R-CNN: High Quality Object Detection
and Instance Segmentation
Zhaowei Cai, and Nuno Vasconcelos
Abstract—In object detection, the intersection over union (IoU) threshold is frequently used to deﬁne positives/negatives. The
threshold used to train a detector deﬁnes its quality. While the commonly used threshold of 0.5 leads to noisy (low-quality) detections,
detection performance frequently degrades for larger thresholds. This paradox of high-quality detection has two causes: 1) overﬁtting,
due to vanishing positive samples for large thresholds, and 2) inference-time quality mismatch between detector and test hypotheses.
A multi-stage object detection architecture, the Cascade R-CNN, composed of a sequence of detectors trained with increasing IoU
thresholds, is proposed to address these problems. The detectors are trained sequentially, using the output of a detector as training set
for the next. This resampling progressively improves hypotheses quality, guaranteeing a positive training set of equivalent size for all
detectors and minimizing overﬁtting. The same cascade is applied at inference, to eliminate quality mismatches between hypotheses
and detectors. An implementation of the Cascade R-CNN without bells or whistles achieves state-of-the-art performance on the COCO
dataset, and signiﬁcantly improves high-quality detection on generic and speciﬁc object detection datasets, including VOC, KITTI,
CityPerson, and WiderFace. Finally, the Cascade R-CNN is generalized to instance segmentation, with nontrivial improvements over
the Mask R-CNN. To facilitate future research, two implementations are made available at 
(Caffe) and (Detectron).
Index Terms—Object Detection, High Quality, Cascade, Bounding Box Regression, Instance Segmentation.
INTRODUCTION
Object detection is a complex problem, requiring the solution of two tasks. First, the detector must solve the recognition problem, distinguishing foreground objects from background and assigning them the proper object class labels.
Second, the detector must solve the localization problem,
assigning accurate bounding boxes to different objects. An
effective architecture for the solution of the two tasks, on
which many of the recently proposed object detectors are
based, is the two-stage R-CNN framework , , ,
 . This frames detection as a multi-task learning problem
that combines classiﬁcation, to solve the recognition problem, and bounding box regression, to solve localization.
Despite the success of this architecture, the two problems
can be difﬁcult to solve accurately. This is partly due to
the fact that there are many “close” false positives, corresponding to “close but not correct” bounding boxes. An
effective detector must ﬁnd all true positives in an image,
while suppressing these close false positives. This requirement makes detection more difﬁcult than other classiﬁcation
problems, e.g. object recognition, where the difference between positives and negatives is not as ﬁne-grained. In fact,
the boundary between positives and negatives must be carefully deﬁned. In the literature, this is done by thresholding
the intersection over union (IoU) score between candidate
and ground truth bounding boxes. While the threshold is
typically set at the value of u = 0.5, this is a very loose
requirement for positives. The resulting detectors frequently
produce noisy bounding boxes, as shown in Fig. 1 (a).
Z. Cai and N. Vasconcelos are with the Department of Electrical and
Computer Engineering, University of California, San Diego, San Diego,
CA 92093, USA, E-mail: {zwcai,nuno}@ucsd.edu.
person: 1.00
person: 1.00
person: 0.99
person: 0.99
person: 0.87
person: 0.82
person: 0.77
person: 0.70
person: 0.64
person: 0.63
person: 0.56
frisbee: 1.00
frisbee: 1.00
frisbee: 0.99
frisbee: 0.97
(a) Detection of u = 0.5
person: 1.00
person: 0.99
person: 0.96
person: 0.94
person: 0.55
frisbee: 0.99
frisbee: 0.99
frisbee: 0.99
frisbee: 0.93
(b) Detection of u = 0.7
(c) Examples of increasing qualities
Fig. 1: (a) and (b) detections by object detectors of increasing qualities,
and (c) examples of increasing quality.
Hypotheses that most humans would consider close false
positives frequently pass the IoU ≥0.5 test. While training
examples assembled under the u = 0.5 criterion are rich
and diverse, they make it difﬁcult to train detectors that can
effectively reject close false positives.
In this work, we deﬁne the quality of a detection hypothesis as its IoU with the ground truth, and the quality
of a detector as the IoU threshold u used to train it. Some
examples of hypotheses of increasing quality are shown in
Fig. 1 (c). The goal is to investigate the poorly researched
problem of learning high quality object detectors. As shown in
Fig. 1 (b), these are detectors that produce few close false
positives. The starting premise is that a single detector can
only be optimal for a single quality level. This is known
in the cost-sensitive learning literature , , where the
optimization of different points of the receiver operating
characteristic (ROC) requires different loss functions. The
Output IoU
Localization Performance
(a) Regressor
Classification Loss
(b) Classiﬁer
IoU Threshold
Detection Performance
u=0.5 (AP=0.349)
u=0.6 (AP=0.354)
u=0.7 (AP=0.319)
(c) Detector
Fig. 2: Bounding box localization, classiﬁcation loss and detection performance of object detectors of increasing IoU threshold u.
main difference is that we consider the optimization for a
given IoU threshold, rather than false positive rate.
Some evidence in support of this premise is given
in Fig. 2, which presents the bounding box localization
performance, classiﬁcation loss and detection performance,
respectively, of three detectors trained with IoU thresholds
of u = 0.5, 0.6, 0.7. Localization and classiﬁcation are evaluated as a function of the detection hypothesis IoU. Detection
is evaluated as a function of the IoU threshold, as in COCO
 . Fig. 2 (a) shows that the three bounding box regressors
tend to achieve the best performance for examples of IoU
in the vicinity of the threshold used for detector training.
Fig. 2 (c) shows a similar effect for detection, up to some
overﬁtting for the highest thresholds. The detector trained
with u = 0.5 outperforms the detector trained with u = 0.6
for low IoUs, underperforming it at higher IoUs. In general,
a detector optimized for a single IoU value is not optimal
for other values. This is also conﬁrmed by the classiﬁcation
loss, shown in Fig. 2 (b), whose peaks are near the thresholds used for detector training. In general, the threshold
determines the classiﬁcation boundary where the classiﬁer
is most discriminative, i.e. has largest margin , .
The observations above suggest that high quality detection requires a close match between the quality of the
detector and that of the detection hypotheses. The detector will only achieve high quality if presented with high
quality proposals. This, however, cannot be guaranteed by
simply increasing the threshold u during training. On the
contrary, as seen for the detector of u = 0.7 in Fig. 2
(c), forcing a high value of u usually degrades detection
performance. We refer to this problem, i.e. that training a
detector with higher threshold leads to poorer performance,
as the paradox of high-quality detection. This problem has two
causes. First, object proposal mechanisms tend to produce
hypotheses distributions heavily imbalanced towards low
quality. In result, the use of larger IoU thresholds during
training exponentially reduces the number of positive training examples. This is particularly problematic for neural
networks, which are very example intensive, making the
“high u” training strategy very prone to overﬁtting. Second,
there is a mismatch between the quality of the detector and
that of the hypotheses available at inference time. Since, as
shown in Fig. 2, high quality detectors are only optimal for
high quality hypotheses, detection performance can degrade
substantially for hypotheses of lower quality.
In this paper, we propose a new detector architecture,
denoted as Cascade R-CNN, that addresses these problems,
to enable high quality object detection. The new architecture
is a multi-stage extension of the R-CNN, where detector
stages deeper into the cascade are sequentially more selective against close false positives. As is usual for classiﬁer
cascades , , the cascade of R-CNN stages is trained
sequentially, using the output of one stage to train the next.
This leverages the observation that the output IoU of a
bounding box regressor is almost always better than its
input IoU, as can be seen in Fig. 2 (a), where nearly all plots
are above the gray line. In result, the output of a detector
trained with a certain IoU threshold is a good hypothesis
distribution to train the detector of the next higher IoU
threshold. This has some similarity to boostrapping methods
commonly used to assemble datasets for object detection
 , . The main difference is that the resampling performed by the Cascade R-CNN does not aim to mine hard
negatives. Instead, by adjusting bounding boxes, each stage
aims to ﬁnd a good set of close false positives for training the
next stage. The main outcome of this resampling is that the
quality of the detection hypotheses increases gradually, from
one stage to the next. In result, the sequence of detectors
addresses the two problems underlying the paradox of highquality detection. First, because the resampling operation
guarantees the availability of a large number of examples for
the training of all detectors in the sequence, it is possible
to train detectors of high IoU without overﬁtting. Second,
the use of the same cascade procedure at inference time
produces a set of hypotheses of progressively higher quality,
well matched to the increasing quality of the detector stages.
This enables higher detection accuracies, as suggested by
The Cascade R-CNN is quite simple to implement and
trained end-to-end. Our results show that a vanilla implementation, without any bells and whistles, surpasses
almost all previous state-of-the-art single-model detectors, on
the challenging COCO detection task , especially under
the stricter evaluation metrics. In addition, the Cascade R-
CNN can be built with any two-stage object detector based
on the R-CNN framework. We have observed consistent
gains (of 2∼4 points, and more under stricter localization
metrics), at a marginal increase in computation. This gain is
independent of the strength of the baseline object detectors,
for all the models we have tested. We thus believe that this
simple and effective detection architecture can be of interest
for many object detection research efforts.
A preliminary version of this manuscript was previously published in . After the original publication, the
Cascade R-CNN has been successfully reproduced within
many different codebases, including the popular Detectron
 , PyTorch1, and TensorFlow2, showing consistent and
reliable improvements independently of implementation
codebase. In this expanded version, we have extended the
Cascade R-CNN to instance segmentation, by adding a
mask head to the cascade, denoted as Cascade Mask R-
CNN. This is shown to achieve non-trivial improvements
over the popular Mask R-CNN . A new and more
extensive evaluation is also presented, showing that the
Cascade R-CNN is compatible with many complementary
enhancements proposed in the detection and instance segmentation literatures, some of which were introduced after
 , e.g. GroupNorm . Finally, we further present the
results of a larger set of experiments, performed on various
popular generic/speciﬁc object detection datasets, including
PASCAL VOC , KITTI , CityPerson and Wider-
Face . These experiments demonstrate that the paradox
of high quality object detection applies to all these tasks,
and that the Cascade R-CNN enables more effective high
quality detection than previously available methods. Due to
these properties, as well as its generality and ﬂexibility, the
Cascade R-CNN has recently been adopted by the winning
teams of the COCO 2018 instance segmentation challenge3,
the OpenImage 2018 challenge4, and the Wider Challenge
20185. To facilitate future research, we have released the
code on two codebases, Caffe and Detectron .
RELATED WORK
Due to the success of the R-CNN detector, which
combines a proposal detector and a region-wise classiﬁer,
this two-stage architecture has become predominant in the
recent past. To reduce redundant CNN computations, the
SPP-Net and Fast R-CNN introduced the idea of
region-wise feature extraction, enabling the sharing of the
bulk of feature computations by object instances. The Faster
R-CNN then achieved further speeds-up by introducing
a region proposal network (RPN), becoming the cornerstone
of modern object detection. Later, some works extended
this detector to address various problems of detail. For
example, the R-FCN proposed efﬁcient region-wise full
convolutions to avoid the heavy CNN computations of the
Faster R-CNN; and the Mask R-CNN added a network head that computes object masks to support instance
segmentation. Some more recent works have focused on
normalizing feature statistics , , modeling relations
between instances , non maximum suppression (NMS)
 , and other aspects , .
Scale invariance, an important requisite for effective
object detection, has also received substantial attention in
the literature , , . While natural images contain
objects at various scales, the ﬁxed receptive ﬁeld size of the
ﬁlters implemented by the RPN makes it prone to scale
1. 
2. 
3. 
4. 
5. 
mismatches. To overcome this, the MS-CNN introduced a
multi-scale object proposal network, by generating outputs
at multiple layers. This leverages the different receptive ﬁeld
sizes of the different layers to produce a set of scale-speciﬁc
proposal generators, which is then combined into a strong
multi-scale generator. Similarly, the FPN detects highrecall proposals at multiple output layers, with recourse to a
scale-invariant feature representation by adding a top-down
connection across feature maps of different network depths.
Both the MS-CNN and FPN rely on a feature pyramid
representation for multi-scale object detection. SNIP , on
the other hand, recently revisited image pyramid in modern
object detection. It normalizes the gradients from different
object scales during training, such that the whole detector is
scale-speciﬁc. Scale-invariant detection is achieved by using
an image pyramid at inference.
One-stage object detection architectures have also become popular for their computational efﬁciency. YOLO
 outputs very sparse detection results and enables realtime object detection, by forwarding the input image once
through an efﬁcient backbone network. SSD detects
objects in a way similar to the RPN , but uses multiple
feature maps at different resolutions to cover objects at
various scales. The main limitation of these detectors is that
their accuracy is typically below that of two-stage detectors.
The RetinaNet detector was proposed to address the
extreme foreground-background class imbalance of dense
object detection, achieving results comparable to two-stage
detectors. Recently, CornerNet proposed to detect an
object bounding box as a pair of keypoints, abandoning
the widely used concept of anchors ﬁrst introduced by
the Faster R-CNN. This detector has achieved very good
performance with the help of some training and testing
enhancements. ReﬁneDet added an anchor reﬁnement
module to the single-shot SSD , to improve localization
accuracy. This is somewhat similar to the cascaded localization implemented by the proposed Cascade R-CNN, but
ignores the problem of high-quality detection.
Some explorations in multi-stage object detection have
also been proposed. The multi-region detector of introduced iterative bounding box regression, where a R-CNN is
applied several times to produce successively more accurate
bounding boxes. , , used a multi-stage procedure
to generate accurate proposals, which are forwarded to an
accurate model (e.g. Fast R-CNN). , proposed an
alternative procedure to localize objects sequentially. While
this is similar in spirit to the Cascade-RCNN, these methods
use the same regressor iteratively for accurate localization.
On the other hand, , embedded the classic cascade
architecture of in an object detection network. Finally,
 iterated between the detection and segmentation tasks,
to achieve improved instance segmentation.
Upon publication of the conference version of this
manuscript, several works have pursued the idea behind
Cascade R-CNN , , , . , applied it to
single-shot object detectors, showing nontrivial improvements for high quality single-shot detection, for general
objects and pedestrians, respectively. The IoU-Net explored in greater detail high-quality localization, achieving
some gains over the Cascade R-CNN by cascading more
bounding box regression steps. showed it is possible to
(a) Faster R-CNN
(b) Cascade R-CNN
(c) Iterative BBox at inference
(d) Integral Loss
Fig. 3: The architectures of different frameworks. “I” is input image, “conv” backbone convolutions, “pool” region-wise feature extraction, “H”
network head, “B” bounding box, and “C” classiﬁcation. “B0” is proposals in all architectures.
achieve state-of-the-art object detectors without ImageNet
pretraining, with a help of the Cascade R-CNN. These works
show that the Cascade R-CNN idea is robust and applicable
to various object detection architectures. This suggests that
it should continue to be useful despite future advances in
object detection.
HIGH QUALITY OBJECT DETECTION
In this section, we discuss the challenges of high quality
object detection.
Object Detection
While the ideas proposed in this work can be applied to
various detector architectures, we focus on the popular twostage architecture of the Faster R-CNN , shown in Fig. 3
(a). The ﬁrst stage is a proposal sub-network, in which the
entire image is processed by a backbone network, e.g. ResNet
 , and a proposal head (“H0”) is applied to produce
preliminary detection hypotheses, known as object proposals. In the second stage, these hypotheses are processed by
a region-of-interest detection sub-network (“H1”), denoted
as a detection head. A ﬁnal classiﬁcation score (“C”) and a
bounding box (“B”) are assigned per hypothesis. The entire
detector is learned end-to-end, using a multi-task loss with
bounding box regression and classiﬁcation components.
Bounding Box Regression
A bounding box b = (bx, by, bw, bh) contains the four
coordinates of an image patch x. Bounding box regression
aims to regress a candidate bounding box b into a target
bounding box g, using a regressor f(x, b). This is learned
from a training set (gi, bi), by minimizing the risk
Lloc(f(xi, bi), gi).
As in Fast R-CNN ,
Lloc(a, b) =
i∈{x,y,w,h}
smoothL1(ai −bi)
smoothL1(x) =
otherwise,
is the smooth L1 loss function. To encourage invariance to
scale and location, smoothL1 operates on the distance vector
∆= (δx, δy, δw, δh) deﬁned by
δx = (gx −bx)/bw,
δy = (gy −by)/bh
δw = log(gw/bw),
δh = log(gh/bh).
Since bounding box regression usually performs minor adjustments on b, the numerical values of (4) can be very
small. This usually makes the regression loss much smaller
than the classiﬁcation loss. To improve the effectiveness
of multi-task learning, ∆is normalized by its mean and
variance, e.g. δx is replaced by
x = δx −µx
This is widely used in the literature , , , , .
Classiﬁcation
The classiﬁer is a function h(x) that assigns an image patch
x to one of M +1 classes, where class 0 contains background
and the remaining classes the objects to detect. h(x) is a
M + 1-dimensional estimate of the posterior distribution
over classes, i.e. hk(x) = p(y = k|x), where y is the
class label. Given a training set (xi, yi), it is learned by
minimizing the classiﬁcation risk
Lcls(h(xi), yi),
Lcls(h(x), y) = −log hy(x)
is the cross-entropy loss.
Detection Quality
Consider a ground truth object of bounding box g associated
with class label y, and a detection hypothesis x of bounding
box b. Since a b usually includes an object and some
amount of background, it can be difﬁcult to determine if
a detection is correct or not. This is usually addressed by
the intersection over union (IoU) metric
IoU(b, g) = b ∩g
If the IoU is above a threshold u, the patch is considered an
example of the class of the object of bounding box g and
denoted “positive”. Thus, the class label of a hypothesis x is
a function of u,
IoU(b, g) ≥u
otherwise.
If the IoU does not exceed the threshold for any object, x is
assigned to the background and denoted “negative”.
Although there is no need to deﬁne positive/neagtive
examples for the bounding box regression task, an IoU
threshold u is also required to select the set of samples
G = {(gi, bi)|IoU(bi, gi) ≥u}
used to train the regressor. While the IoU thresholds used
for the two tasks do not have to be identical, this is usual
in practice. Hence, the IoU threshold u deﬁnes the quality of
a detector. Large thresholds encourage detected bounding
boxes to be tightly aligned with their ground truth counterparts. Small thresholds reward detectors that produce loose
bounding boxes, of small overlap with the ground truth.
A main challenge of object detection is that, no matter
the choice of threshold, the detection setting is highly adversarial. When u is high, positives contain less background
but it is difﬁcult to assemble large positive training sets.
When u is low, richer and more diverse positive training
sets are possible, but the trained detector has little incentive
to reject close false positives. In general, it is very difﬁcult
to guarantee that a single classiﬁer performs uniformly well
over all IoU levels. At inference, since the majority of the
hypotheses produced by a proposal detector, e.g. RPN 
or selective search , have low quality, the detector must
be more discriminant for lower quality hypotheses. A standard compromise between these conﬂicting requirements is
to settle on u = 0.5, which is used in almost all modern
object detectors. This, however, is a relatively low threshold,
leading to low quality detections that most humans consider
close false positives, as shown in Fig. 1 (a).
Challenges to High Quality Detection
Despite the signiﬁcant progress in object detection of the
past few years, few works attempted to address high quality
detection. This is mainly due to the following reasons.
First, evaluation metrics have historically placed greater
emphasis on the low quality detection regime. For performance evaluation, an IoU threshold u is used to determine
whether a detection is a success (IoU(b, g) ≥u) or failure
(IoU(b, g) < u). Many object detection datasets, including
PASCAL VOC , ImageNet , Caltech Pedestrian ,
etc., use u = 0.5. This is partly because these datasets were
established a while ago, when object detection performance
was far from what it is today. However, this loose evaluation
standard is adopted even by relatively recent datasets, such
as WiderFace , or CityPersons . This is one of the
main reasons why performance has saturated for many
of these datasets. Others, such as COCO or KITTI
 use stricter evaluation metrics: average precision at
u = 0.7 for car in KITTI, and mean average precision across
u = [0.5 : 0.05 : 0.95] in COCO. While recent works have
focused on these less saturated datasets, most detectors are
still designed with the loose IoU threshold of u = 0.5,
associated with the low-quality detection regime. In this
work, we show that there is plenty of room for improvement
when a stricter evaluation metric, e.g. u ≥0.75, is used and
that it is possible to achieve signiﬁcant improvements by
designing detectors speciﬁcally for the high quality regime.
Second, the design of high quality object detectors is not
a trivial generalization of existing approaches, due to the
paradox of high quality detection. To beat the paradox, it is
necessary to match the qualities of the hypotheses generator
and the object detector. In the literature, there have been
efforts to increase the quality of hypotheses, e.g. by iterative
bounding box regression , or better RPN design
 , , and some efforts to increase the quality of the
Fig. 4: IoU histograms of training samples of each cascade stage. The
distribution of the 1st stage is the RPN output. Shown in red are the
percentage of positives for the corresponding IoU threshold.
object detector, e.g. by using the integral loss on a set of
IoU thresholds . These attempts fail to guarantee high
quality detection because they consider only one of the
goals, missing the fact that the qualities of both tasks need to
be increased simultaneously. On one hand, raising the quality
of the hypotheses has little beneﬁt if the detector remains of
low quality, because the latter is not trained to discriminate
high quality from low quality hypotheses. On the other, if
only the detector quality is increased, there are too few high
quality hypotheses for it to classify, leading to no detection
improvement. In fact, because, as shown in Fig. 4 (left), the
set of positive samples decreases quickly with u, a high u
detector is prone to overﬁtting. Hence, a high u detector can
easily overﬁt and perform worse than a low u detector, as
shown in Fig. 2 (c).
CASCADE R-CNN
In this section we introduce the Cascade R-CNN detector.
Architecture
The architecture of the Cascade R-CNN is shown in Fig.
3 (b). It is a multi-stage extension of the Faster R-CNN
architecture of Fig. 3 (a). In this work, we focus on the the
detection sub-network, simply adopting the RPN of Fig.
3 (a) for proposal detection. However, the Cascade R-CNN
is not limited to this proposal mechanism, other choices
should be possible. As discussed in the section above, the
goal is to increase the quality of hypotheses and detector
simultaneously, to enable high quality object detection. This
is achieved with a combination of cascaded bounding box
regression and cascaded detection.
Cascaded Bounding Box Regression
High quality hypotheses can be easily produced during
training, where ground truth bounding boxes are available,
e.g. by sampling around the ground truth. The difﬁculty
is to produce high quality proposals at inference, when
ground truth is unavailable. This problem is addressed with
resort to cascaded bounding box regression.
As shown in Fig. 2 (a), a single regressor cannot usually
perform uniformly well over all quality levels. However, as
is commonly done for pose regression or face alignment
 , , , the regression task can be decomposed into a
sequence of simpler steps. In the Cascade R-CNN detector,
the idea is implemented with a cascaded regressor with
the architecture of Fig. 3 (b). This consists of a cascade of
specialized regressors
f(x, b) = fT ◦fT −1 ◦· · · ◦f1(x, b),
µx = 0.0020
µy = 0.0022
σx = 0.1234
σy = 0.1297
µx = 0.0048
µy = −0.0012
σx = 0.0606
σy = 0.0613
µx = 0.0032
µy = −0.0021
σx = 0.0391
σy = 0.0376
µw = 0.0161
µh = 0.0498
σw = 0.2272
σh = 0.2255
µw = −0.0007
µh = 0.0122
σw = 0.1221
σh = 0.1230
µw = −0.0017
µh = 0.0004
σw = 0.0798
σh = 0.0773
Fig. 5: Distribution of the distance vector ∆of (4) (without normalization) at different cascade stages. Top: plot of (δx, δy). Bottom: plot of
(δw, δh). Red dots are outliers for the increasing IoU thresholds of later
stages, and the statistics shown are obtained after outlier removal.
where T is the total number of cascade stages. The key point
is that each regressor ft is optimized for the bounding box
distribution {bt} generated by the previous regressor, rather
than the initial distribution {b1}. In this way, the hypotheses
are improved progressively.
This is illustrated in Fig. 5, which presents the distribution of the regression distance vector ∆= (δx, δy, δw, δh) at
different cascade stages. Note that most hypotheses become
closer to the ground truth as they progress through the
cascade. There are also some hypotheses that fail to meet
the stricter IoU criteria of the later cascade stages. These are
declared outliers and eliminated. It should be noted that,
as discussed in Section 3.1.1, ∆needs be mean/variance
normalized, as in (5), for effective multi-task learning. The
mean and variance statistics computed after this outlier
removal step are used to normalize ∆at each cascade stage.
Our experiments show that this implementation of cascaded
bounding box regression generates hypotheses of very high
quality at both training and inference.
Cascaded Detection
As shown in the left of Fig. 4, the initial hypotheses distribution produced by the RPN is heavily tilted towards low
quality. For example, only 2.9% of examples are positive
for an IoU threshold u = 0.7. This makes it difﬁcult to
train a high quality detector. The Cascade R-CNN addresses
the problem by using cascade regression as a resampling
mechanism. This is inspired by Fig. 2 (a), where nearly
all curves are above the diagonal gray line, showing that
a bounding box regressor trained for a certain u tends
to produce bounding boxes of higher IoU. Hence, starting
from examples {(xi, bi)}, cascade regression successively
resamples an example distribution {(x′
i)} of higher IoU.
This enables the sets of positive examples of the successive
stages to keep a roughly constant size, even when the detector quality u is increased. Figure 4 illustrates this property,
showing how the example distribution tilts more heavily
towards high quality examples after each resampling step.
At each stage t, the R-CNN head includes a classiﬁer
ht and a regressor ft optimized for the corresponding IoU
threshold ut, where ut > ut−1. These are learned with loss
L(xt, g) = Lcls(ht(xt), yt) + λ[yt ≥1]Lloc(ft(xt, bt), g),
where bt = ft−1(xt−1, bt−1), g is the ground truth object for
xt, λ = 1 the trade-off coefﬁcient, yt is the label of xt under
the ut criterion, according to (9), [·] is the indicator function.
Note that the use of [·] implies that the IoU threshold u
of bounding box regression is identical to that used for
classiﬁcation. This cascade learning has three important
consequences for detector training. First, the potential for
overﬁtting at large IoU thresholds u is reduced, since positive examples become plentiful at all stages (see Fig. 4).
Second, detectors of deeper stages are optimal for higher
IoU thresholds. Third, because some outliers are removed
as the IoU threshold increases (see Fig. 5), the learning
effectiveness of bounding box regression increases in the
later stages. This simultaneous improvement of hypotheses
and detector quality enables the Cascade R-CNN to beat
the paradox of high quality detection. At inference, the
same cascade is applied. The quality of the hypotheses
is improved sequentially, and higher quality detectors are
only required to operate on higher quality hypotheses, for
which they are optimal. This enables the high quality object
detection results of Fig. 1 (b), as suggested by Fig. 2.
Differences from Previous Works
The Cascade R-CNN has similarities to previous works
using iterative bounding box regression and integral loss for
detection. There are, however, important differences.
Iterative Bounding Box Regression: Some works , ,
 have previously argued that the use of a single bounding box regressor f is insufﬁcient for accurate localization.
These methods apply f iteratively, as a post-processing step
f ′(x, b) = f ◦f ◦· · · ◦f(x, b),
that reﬁnes a bounding box b. This is called iterative bounding
box regression and denoted as iterative BBox. It can be implemented with the inference architecture of Fig. 3 (c) where
all heads are identical. Note that this is only for inference, as
training is identical to that of a two-stage object detector, e.g.
the Faster R-CNN of Fig. 3 (a) with u = 0.5. This approaches
ignores two problems. First, as shown in Fig. 2, a regressor
f trained at u = 0.5 is suboptimal for hypotheses of higher
IoUs. It actually degrades bounding box accuracy for IoUs
larger than 0.85. Second, as shown in Fig. 5, the distribution
of bounding boxes changes signiﬁcantly after each iteration.
While the regressor is optimal for the initial distribution it
can be quite suboptimal after that. Due to these problems,
iterative BBox requires a fair amount of human engineering,
in the form of proposal accumulation, box voting, etc, and
has somewhat unreliable gains , , . Usually, there
is no beneﬁt beyond applying f twice.
The Cascade R-CNN differs from iterative BBox in several ways. First, while iterative BBox is a post-processing
procedure used to improve bounding boxes, the Cascade
R-CNN uses cascade regression as a resampling mechanism
that changes the distribution of hypotheses processed by
the different stages. Second, because cascade regression is
used at both training and inference, there is no discrepancy
Fig. 6: Architectures of the Mask R-CNN (a) and three Cascade Mask R-CNN strategies for instance segmentation (b)-(d). Beyond the deﬁnitions
of Fig. 3, “S” denotes a segmentation branch. Note that segmentations branches do not necessarily share heads with the detection branch.
between training and inference distributions. Third, the
multiple specialized regressors {fT , fT −1, · · · , f1} are optimal for the resampled distributions of the different stages. This
is unlike the single f of (13), which is only optimal for the
initial distribution. Our experiments show that the Cascade
R-CNN enables more precise localization than that possible
with iterative BBox, and requires no human engineering.
Integral Loss: proposed an ensemble of classiﬁers with
the architecture of Fig. 3 (d) and trained with the integral
loss. This is a loss
Lcls(h(x), y) =
Lcls(hu(x), yu)
that targets various quality levels, deﬁned by a set of IoU
thresholds U = {0.5, 0.55, · · · , 0.75}, chosen to ﬁt the evaluation metric of the COCO challenge.
The Cascade R-CNN differs from this detector in several
ways. First, (14) fails to address the problem that the various
loss terms operate on different numbers of positives. As
shown on Fig. 4 (left), the set of positive samples decreases
quickly with u. This is particularly problematic because it
makes the high quality classiﬁers very prone to overﬁtting.
On the other hand, as shown in Fig. 4, the resampling of
the Cascade R-CNN produces a nearly constant number of
positive examples as the IoU threshold u increases. Second,
at inference, the high quality classiﬁers are required to
process proposals of overwhelming low quality, for which
they are not optimal. This is unlike the higher quality
detectors of the Cascade R-CNN, which are only required
to operate on higher quality hypotheses. Third, the integral
loss is designed to ﬁt the COCO metrics and, by deﬁnition,
the classiﬁers are ensembled at inference. The Cascade R-
CNN aims to achieve high quality detection, and the high
quality detector itself in the last stage can obtain the stateof-the-art detection performance. Due to all this, the integral
loss detector of Fig. 3 (d) usually fails to outperform the
vanilla detector of Fig. 3 (a), for most quality levels. This
is unlike the Cascade R-CNN, which can have signiﬁcant
improvements.
INSTANCE SEGMENTATION
Instance segmentation has become popular in the recent
past , , . It aims to predict pixel-level segmentation
for each instance, in addition to determining its object class.
This is more difﬁcult than object detection, which only
predicts a bounding box (plus class) per instance. In general,
instance segmentation is implemented in addition to object
detection, and a stronger object detector usually leads to
improved instance segmentation. The most popular instance
segmentation method is arguably the Mask R-CNN .
Like the Cascade R-CNN, it is a variant on the two-stage
detector. In this section, we extend the Cascade R-CNN
architecture to the instance segmentation task, by adding
a segmentation branch similar to that of the Mask R-CNN.
Mask R-CNN
The Mask R-CNN extends the Faster R-CNN by adding
a segmentation branch in parallel to the existing detection
branch during training. It has the architecture of Fig. 6 (a).
The training instances are the positive examples also used
to train the detection task. At inference, object detections are
complemented with segmentation masks, for all detected
Cascade Mask R-CNN
In the Mask R-CNN, the segmentation branch is inserted
in parallel to the detection branch. However, the Cascade
R-CNN has multiple detection branches. This raises the
questions of 1) where to add the segmentation branch and 2)
how many segmentation branches to add. We consider three
strategies for mask prediction in the Cascade R-CNN. The
ﬁrst two strategies address the ﬁrst question, adding a single
mask prediction head at either the ﬁrst or last stage of the
Cascade R-CNN, as shown in Fig. 6 (b) and (c), respectively.
Since the instances used to train the segmentation branch
are the positives of the detection branch, their number
varies in these two strategies. As shown in Fig. 4, placing
the segmentation head later on the cascade leads to more
examples. However, because segmentation is a pixel-wise
operation, a large number of highly overlapping instances
is not necessarily as helpful as for object detection, which
is a patch-based operation. The third strategy addresses
the second question, adding a segmentation branch to each
cascade stage, as shown in Fig. 6 (d). This maximizes the
diversity of samples used to learn the mask prediction task.
At inference time, all three strategies predict the segmentation masks on the patches produced by the ﬁnal object
detection stage, irrespective of the cascade stage on which
the segmentation mask is implemented and how many
segmentation branches there are. The ﬁnal mask prediction
is obtained from the single segmentation branch for the
architectures of Fig. 6 (b) and (c), and from the ensemble
of three segmentation branches for the architecture of Fig.
6 (d). Our experiments show that these architectures of the
Cascade Mask R-CNN outperform the Mask R-CNN.
EXPERIMENTAL RESULTS
In this section, we present an extensive evaluation of the
Cascade R-CNN detector.
Experimental Set-up
Experiments were performed over multiple datasets and
baseline network architectures.
The bulk of the experiments was performed on MS-COCO
2017 , which contains ∼118k images for training, 5k
for validation (val) and ∼20k for testing without provided
annotations (test-dev). The COCO average precision (AP)
measure averages AP across IoU thresholds from 0.5 to
0.95, with an interval of 0.05. It measures detection performance at various qualities, encouraging high quality
detection results, as discussed in Section 3.3. All models
were trained on the COCO training set and evaluated on
the val set. Final results are also reported on the test-dev
set for fair comparison with the state-of-the-art. To assess
the robustness and generalization ability of the Cascade R-
CNN, experiments were also performed on Pascal VOC ,
KITTI , CityPersons and WiderFace . Instance
segmentation was also evaluated on COCO, using the same
evaluation metrics as object detection. The only difference
is that the IoU is computed with respect to the mask rather
than a bounding box.
Implementation Details
All regressors are class agnostic for simplicity. All Cascade
R-CNN detection stages have the same architecture, which
is the detection head of the baseline detector. Unless otherwise noted, the Cascade R-CNN is implemented with four
stages: one RPN and three detection heads with thresholds
U = {0.5, 0.6, 0.7}. The sampling of the ﬁrst detection stage
follows , . In subsequent stages, resampling is implemented by using all the regressed outputs from the previous
stage, as discussed in Section 4.3. No data augmentation was
used except standard horizontal image ﬂipping. Inference
was performed at a single image scale, with no further bells
and whistles. All baseline detectors were reimplemented
with Caffe , using the same codebase, for fair comparison. Some experiments with the FPN and Mask R-CNN
baselines were implemented on the Detectron platform.
Baseline Networks
To test the versatility of the Cascade R-CNN, experiments
were performed with multiple popular baselines: Faster R-
CNN and MS-CNN with VGG-Net backbone, R-
FCN and FPN with ResNet backbones , for the
task of object detection, and Mask R-CNN with ResNet
backbones for instance segmentation. These baselines have
a wide range of performances. Unless noted, their default
settings were used. End-to-end training was used instead of
multi-step training.
Faster R-CNN: the network head has two fully connected
layers. To reduce parameters, was used to prune less
important connections. 2048 units were retained per fully
connected layer and dropout layers were removed. These
changes have negligible effect on detection performance.
Training started with a learning rate of 0.002, which was
reduced by a factor of 10 at 60k and 90k iterations, and
stopped at 100k iterations, on 2 synchronized GPUs, each
holding 4 images per iteration. 128 RoIs were used per
R-FCN: the R-FCN adds a convolutional, a bounding box
regression, and a classiﬁcation layer to the ResNet. For
this baseline, all Cascade R-CNN heads have this structure.
Online hard negative mining was not used. Training
started with a learning rate of 0.003, which was decreased
by a factor of 10 at 160k and 240k iterations, and stopped at
280k iterations, on 4 synchronized GPUs, each holding one
image per iteration. 256 RoIs were used per image.
FPN: since ofﬁcial source code was not publicly available for
the FPN when we performed our original experiments ,
the implementation details were somewhat different from
those later made available in the Detectron implementation.
RoIAlign was used for a stronger baseline. This is
denoted as FPN+ and was used in all ablation studies,
with the ResNet-50 as a backbone as usual. Training used
a learning rate of 0.005 for 120k iterations and 0.0005 for the
next 60k iterations, on 8 synchronized GPUs, each holding
one image per iteration. 256 RoIs were used per image. We
have also reimplemented the Cascade R-CNN of FPN on
Detectron platform, when it is publicly available.
MS-CNN: the MS-CNN is a popular multi-scale object
detector for speciﬁc object categories, e.g. vehicle, pedestrian, face, etc. It was used as baseline detector for experiments on KITTI, CityPersons and WiderFace. For this
baseline, the Cascade R-CNN adopted the same two-step
training strategy of the MS-CNN: proposal sub-network
trained ﬁrst and then joint end-to-end training. All detection heads were only added at the second step, where the
learning rate was initially 0.0005, decreased by a factor of 10
at 10k and 20k iterations and stopped at 25k iterations, on
one GPU of batch size 4 images.
Mask R-CNN: the Mask R-CNN was used as baseline for
instance segmentation. The default Detectron implementation was adopted, using the 1x learning schedule. Training
started with a learning rate of 0.02, which was reduced by
a factor of 10 at 60k and 80k iterations, and stopped at 90k
iterations, on 8 synchronized GPUs, each holding 2 images
per iteration. 512 RoIs were used per image.
Quality Mismatch
An initial set of experiments was designed to evaluate the
impact of the mistmatch between proposal and detector
quality on detection performance. Figure 7 (a) shows the AP
curves of three individually trained detectors of increasing
IoU threshold in U = {0.5, 0.6, 0.7}. The detector of u = 0.5
outperforms the detector of u = 0.6 at low IoU levels, but
underperforms it at higher levels. However, the detector
of u = 0.7 underperforms the other two. To understand
why this happens, we changed the quality of the proposals
at inference. Figure 7 (b) shows the results obtained when
ground truth bounding boxes were added to the set of
proposals. While all detectors improved, the detector of
u = 0.7 had the largest gains, and the best performance for
almost all IoU levels. These results suggest two conclusions.
First, the commonly used u = 0.5 threshold is not effective
for precise detection, simply more robust to low quality
IoU Threshold
Detection Performance
u=0.5 (AP=0.349)
u=0.6 (AP=0.354)
u=0.7 (AP=0.319)
u=0.6 (AP=0.367)
u=0.7 (AP=0.352)
IoU Threshold
Detection Performance
u=0.5 (AP=0.394)
u=0.6 (AP=0.457)
u=0.7 (AP=0.495)
Fig. 7: (a) detection performance of individually trained detectors, with
their own proposals (solid curves) or Cascade R-CNN stage proposals
(dashed curves). (b) results of adding ground truth to the proposal set.
IoU Threshold
u=0.5 (AP=0.355)
u=0.6 (AP=0.352)
u=0.7 (AP=0.256)
IoU Threshold
u=0.5 (AP=0.365)
u=0.6 (AP=0.383)
u=0.7 (AP=0.355)
IoU Threshold
u=0.5 (AP=0.368)
u=0.6 (AP=0.384)
u=0.7 (AP=0.383)
Fig. 8: Detection performance of all Cascade R-CNN detectors at all
cascade stages.
proposals. Second, precise detection requires hypotheses
that match the detector quality.
Next, the original proposals were replaced by the Cascade R-CNN proposals of higher quality (u = 0.6 and
u = 0.7 used the 2nd and 3rd stage proposals, respectively). Figure 7 (a) suggests that the performance of the
two detectors is signiﬁcantly improved when the quality
of the test proposals matches the detector quality. Testing
Cascade R-CNN detectors of different qualities at all cascade
stages produced similar observations. Figure 8 shows that
each detector was improved by the use of more precise
hypotheses, with higher quality detectors exhibiting larger
gains. For example, the detector of u = 0.7 performed
poorly for the low quality proposals of the 1st stage, but
much better for the more precise hypotheses available at the
deeper cascade stages. The jointly trained detectors of Fig.
8 also outperformed the individually trained detectors of
Fig. 7 (a), even when the same proposals were used. This
indicates that the detectors are better trained within the
Cascade R-CNN architecture.
Comparison with Iterative BBox and Integral Loss
In this section, we compare the Cascade R-CNN to the
iterative BBox and integral loss detectors. Iterative BBox was
implemented by applying the detection head of FPN+ baseline iteratively at inference, three times. The integral loss
detector was implemented with three classiﬁcation heads,
using U = {0.5, 0.6, 0.7}.
Localization: The localization performances of cascade regression and iterative BBox are compared in Fig. 9 (a). The
use of a single regressor degrades localization for hypotheses of high IoU. This effect accumulates when the regressor
is applied iteratively, as in iterative BBox, and performance
actually drops with iteration number. Note the very poor
performance of iterative BBox after 3 iterations. On the contrary, the cascade regressor has better performance at later
stages, outperforming iterative BBox at almost all IoU levels.
Note that, although cascade regression can slightly degrade
high input IoUs, e.g. IoU>0.9, this decrease is negligible
Output IoU
Localization Performance
iterative 1st
iterative 3rd
cascade 1st
cascade 3rd
IoU Threshold
Integral Loss
u=0.5 (AP=0.354)
u=0.6 (AP=0.355)
u=0.7 (AP=0.337)
ensemble (AP=0.354)
Fig. 9: (a) localization performance of iterative BBox and Cascade R-
CNN regressors. (b) detection performance of the individual classiﬁers
of the integral loss detector.
FPN+ baseline
Iterative BBox
Integral Loss
Cascade R-CNN
TABLE 1: Comparison of the Cascade R-CNN with iterative BBox and
integral loss detectors.
because, as shown in Fig. 4, the number of hypotheses with
such high IoUs is extremely small.
Integral Loss: Figure 9 (b) summarizes the detection performances of all classiﬁers of the integral loss detector, sharing
a single regressor. The classiﬁer of u = 0.6 is the best at all
IoU levels, with u = 0.7 producing the worst results. The
ensemble of all classiﬁers shows no visible gain.
Table 1 shows that both iterative BBox and integral loss
marginally improve on the baseline detector, and are not
effective for high quality detection. On the other hand, the
Cascade R-CNN achieves the best performance at all IoU
levels. As expected, the gains are mild for low IoUs, e.g. 0.8
for AP50, but signiﬁcant for the higher ones, e.g. 6.1 for AP80
and 8.7 for AP90. Note that high quality object detection was
rarely explored before this work. These experiments show
that 1) it has more room for improvement than low quality
detection, which focuses on AP50, and 2) the overall AP can
be signiﬁcantly improved if it is effectively addressed.
Ablation Experiments
A few ablation experiments were run to enable a better
understanding of the Cascade R-CNN.
Stage-wise Comparison: Table 2 summarizes stagewise performance. Note that the ﬁrst stage already outperforms the
baseline detector, due to the beneﬁts of multi-stage multitask learning. Since deeper cascade stages prefer higher
quality localization, they encourage the learning of features
conducive to it. This beneﬁts the earlier cascade stages, due
to the feature sharing by the backbone network. The second
stage improves performance substantially, and the third is
equivalent to the second. This differs from the integral loss
detector, where the higher IoU classiﬁer is relatively weak.
While the former (later) stage is better at low (high) IoU
metrics, the ensemble of all classiﬁers is the best overall.
IoU Thresholds: A Cascade R-CNN was trained using IoU
threshold u = 0.5 for all heads. In this case, the stages differ
only in the hypotheses at their input. Each stage is trained
with the corresponding hypotheses, i.e. accounting for the
distribution changes of Fig. 5. The ﬁrst row of Table 3 shows
test stage
FPN+ baseline
TABLE 2: Stagewise performance of the Cascade R-CNN. 1 ∼3 indicates an ensemble result, obtained by averaging the three classiﬁer
probabilities for 3rd stage proposals.
statistics
TABLE 3: Ablation experiments. “IoU↑” indicates increasing IoU
thresholds, “update statistics” updating regression statistics, and “stage
loss” weighting of stage losses.
that this cascade improves on the baseline detector. This
supports the claim that stages should be optimized for the
corresponding sample distributions. The second row shows
performance that improves further when the threshold u
increases across stages. As discussed in Section 4.3, the
detector becomes more selective against close false positives
and specialized to the more precise hypotheses.
Regression Statistics: In Section 3.1.1, we saw that the
distance vector ∆is normalized by the regression statistics
(mean and variance), as in (5). In the Cascade R-CNN, these
statistics are updated stage by stage, as illustrated in Fig.
5. Updating the statistics of (5) in deeper stages helps the
effective multi-task learning of classiﬁcation and regression.
Empirically, the learning is not very sensitive to the exact
values of these statistics. For simplicity, we set µ = 0 for all
stages, Σ = (σx, σy, σw, σh) = (0.1, 0.1, 0.2, 0.2) for the ﬁrst
stage, Σ/2 for the second, and Σ/3 for the third, in all of our
experiments. The third and fourth row of Table 3 show that
this is beneﬁcial, when compared to using the statistics of
the ﬁrst stage in all stages (the ﬁrst and second row).
Stage Losses: The Cascade R-CNN has multiple detection
heads, each with its own loss. We have explored two
schemes to combine these losses: decay and avg. In avg, the
loss of stage t receives a weight wt = 1/T , where T is
the number of stages. In decay, the weight is wt = 1/2t−1.
For both schemes, the learning rate of the head parameters
of stage t is rescaled by 1/wt, to ensure that these are
sufﬁciently trained. No rescaling is needed for the backbone
network parameters, since they receive gradients from all
stages. Table 3 shows that 1) avg has somewhat better
performance for high quality metrics, but worse for low
quality ones, and 2) the two methods have similar overall
AP. The decay scheme is used in the remainder of the paper.
Number of Stages: Table 4 summarizes the impact of the
number of stages in the Cascade R-CNN performance.
Adding a second stage signiﬁcantly improves the baseline
detector. Three detection stages still produce non-trivial
improvement, but the addition of a 4th stage (u = 0.75)
has a slight performance decrease. Note, however, that
# stages test stage
TABLE 4: The impact of the number of stages in Cascade R-CNN.
while the overall AP degrades, the four-stage cascade has
the best performance at high IoU levels. The three-stage
cascade achieves the best trade-off between cost and AP
performance, and is used in the remaining experiments.
Comparison with the state-of-the-art
An implementation of the Cascade R-CNN, based on the
FPN+ detector and the ResNet-101 backbone, is compared
to state-of-the-art single-model detectors in Table 56. The
settings are those of Section 6.1.3, but training used 280k
iterations, with learning rate decreased at 160k and 240k iterations. The number of RoIs was also increased to 512. The
top of the table reports to one-stage detectors, the middle to
two-stage, and the bottom to multi-stage (3-stages+RPN for
the Cascade R-CNN). Note that all the compared state-ofthe-art detectors are trained with u = 0.5.
An initial observation is that our FPN+ implementation
is better than the original FPN , providing a very strong
baseline. Nevertheless, the extension from FPN+ to Cascade
R-CNN improved performance by ∼4 points. In fact, the
vanilla Cascade R-CNN, without any bells and whistles,
outperformed almost all single-model detectors under all
evaluation metrics. This includes the COCO challenge 2016
winner G-RMI , the recent Deformable R-FCN , RetinaNet , Mask R-CNN , RelationNet , DetNet ,
CornerNet , etc. Note some of these methods leverage
several training or inference enhancements, e.g. multi-scale,
soft NMS , etc, making the comparison very unfair. Finally, compared to the previously best multi-stage detector
on COCO, AttractioNet , the vanilla Cascade R-CNN has
a gain of 7.1 points.
The only detector that outperforms the Cascade R-CNN
in Table 5 is SNIP , which uses multi-scale training
and inference, a larger input size, a stronger backbone, Soft
NMS, and some other enhancements. For a more fair comparison, we implemented the Cascade R-CNN with multiscale training/inference, a stronger backbone (ResNeXt-152
 ), mask supervision, etc. This enhanced Cascade R-CNN
surpassed SNIP by 5.2 points. It also outperforms the singlemodel MegDet detector (50.6 mAP), which won the COCO
challenge in 2017 and uses many other enhancements .
The Cascade R-CNN is conceptually straightforward, simple to implement, and can be combined, in a plug and play
manner, with many detector architectures.
Generalization Capacity
To more thoroughly test this claim, a three-stage Cascade R-
CNN was implemented with three baseline detectors: Faster
R-CNN, R-FCN, and FPN+. All settings are as discussed
above, with the variations discussed in Section 6.5 for the
6. Some detectors are omitted in this comparison because their singlemodel results on COCO test-dev are not publicly available.
YOLOv2 
DarkNet-19
SSD513 ∗
ResNet-101
RetinaNet ∗
ResNet-101
CornerNet ∗⋆
Hourglass-104
Faster R-CNN+++ ∗⋆
ResNet-101
Faster R-CNN w FPN 
ResNet-101
Faster R-CNN w FPN+ (ours)
ResNet-101
G-RMI ∗⋆
Inception-ResNet-v2
Deformable R-FCN ∗⋆
Aligned-Inception-ResNet
Mask R-CNN 
ResNet-101
RelationNet 
ResNet-101
DetNet 
SNIP ∗⋆
AttractioNet ⋆
VGG16+Wide ResNet
Cascade R-CNN
ResNet-101
Cascade R-CNN∗⋆
ResNeXt-152
TABLE 5: Performance of state-of-the-art single-model detectors on COCO test-dev. Entries denoted by ∗and ⋆use enhancements at training
and inference, respectively.
test-dev (20k)
speed speed
AP50 AP75 APS APM APL
AP50 AP75 APS APM APL
Faster R-CNN
0.075s 278M
0.115s 704M
0.075s 184M
ResNet-101
0.075s 206M
0.083s 256M
0.095s 165M
0.115s 272M
ResNet-101
0.115s 238M
TABLE 6: Performance of Cascade R-CNN implementations with multiple detectors. All speeds are reported per image on a single Titan Xp GPU.
FPN+ detector. Table 6 presents a comparison of the AP
performance of the three detectors.
Detection Performance: Again, our implementations are
better than the original detectors , , . Still, the
Cascade R-CNN improves on all baselines by 2∼4 points,
independently of their strength. Similar gains are observed
for val and test-dev. These results show that the Cascade
R-CNN is widely applicable across detector architectures.
Parameters and Timing: The number of Cascade R-CNN
parameters increases with the number of stages. The increase is linear and proportional to the parameter cardinality
of the baseline detector head. However, because the head
has much less computation than the backbone network, the
Cascade R-CNN has small computational overhead, at both
training and testing. This is shown in Table 6.
Codebase and Backbone: The Cascade R-CNN of FPN
was also reimplemented on the Detectron codebase 
with various backbone networks. Table 7 summarizes these
experiments, showing very consistent improvements (3∼4
points) across backbones. The Cascade R-CNN has also
been independently reproduced by other research groups,
on PyTorch and TensorFlow. These again show that the
Cascade R-CNN can provide reliable gains across detector
architectures, backbones, codebases, and implementations.
Fast R-CNN: As shown in Fig. 3 (b), the Cascade R-CNN
is not limited to the standard Faster R-CNN architecture. To
test this, we trained the Cascade R-CNN in the way of the
Fast R-CNN, using pre-collected proposals. The results of
AP50 AP75 APS APM APL
Fast ResNet-50
ResNet-101
ResNeXt-101
ResNet-50-GN
ResNet-101-GN
TABLE 7: Performance of various implementations of the Cascade R-
CNN with the FPN detector on Detectron, using the 1x schedule.
Table 7 show that the gains of the Cascade R-CNN hold for
frameworks other than the Faster R-CNN.
Group Normalization: Group normalization (GN) is a
recent normalization technique, published after the Cascade
R-CNN. It addresses the problem that batch normalization
(BN) must be frozen for object detector training, due to
the inaccurate statistics that can be derived from small batch
sizes . GN, an alternative to BN that is independent
of batch size, has comparable performance to large-batch
synchronized BN. Table 7 shows that the Cascade R-CNN
with GN has similar gains to those obersved for the other
architectures. This suggests that the Cascade R-CNN will
continue to be useful even as architectural enhancements
continue to emerge in the literature.
stage AP100 AP100
TABLE 8: Proposal recall of Cascade R-CNN stages.
Proposal Evaluation
Table 8 summarizes the proposal recall performance of a
Cascade R-CNN implemented with the FPN detector and
ResNet-50 backbone. The ﬁrst Cascade R-CNN stage has
proposal recall close to that of the FPN baseline. The addition of a bounding box regression stage improves recall
signiﬁcantly, e.g. from 59.1 to 70.7 for AP1k and close to 20
points for AP1k
l . This shows that the additional bounding
box regression is very effective at improving proposal recall
performance. The addition of a third stage has a smaller but
non-negligible gain. This high proposal recall performance
secures the later high-quality object detection task.
Instance Segmentation by Cascade Mask R-CNN
Table 9 summarizes the instance segmentation performance
of the Cascade Mask R-CNN strategies of Fig. 6. These experiments, use the Mask R-CNN, implemented on Detectron
with 1x schedule as baseline. All three strategies improve
on baseline performance, although with smaller gains than
object detection (see Table 2), especially at high quality. For
example, the AP90 improvement of 8.7 points for object
detection falls to 1.8 points, showing that plenty of room
is left for improving high quality instance segmentation.
Comparing strategies, (c) outperforms (b). This is because
(b) trains the mask head in the ﬁrst stage but tests after
the last stage, leading to a mask prediction mismatch. This
mismatch is reduced by (c). The addition of a mask branch
to each stage by strategy (d) does not have noticeable
beneﬁts over (c), but requires much more computation and
memory. Strategy (b) has the best trade-off between cost and
AP performance, and is used in the remainder of the paper.
To evaluate the instance segmentation robustness of the
Cascade Mask R-CNN, several backbone networks are compared in Table 10. Since this architecture can detect objects,
detection results are also shown. Note that the additional
mask supervision makes these better than those of Table 7.
The gains of the Cascade Mask R-CNN are very consistent
for all backbone networks. Even when the strongest model,
ResNeXt-152 , is used with training data augmentation
and 1.44x schedule, the Cascade Mask R-CNN has a
gain of 2.9 points for detection and 1.0 point for instance
segmentation. Adding inference enhancements, the gains
are still 2.1 points for detection and 0.8 points for instance
segmentation. This robustness explains why the Cascade R-
CNN was widely used in the COCO challenge 2018, where
the task is instance segmentation, not object detection.
Results on PASCAL VOC
The Cascade R-CNN was further tested on the PASCAL
VOC dataset . Following , , the models were
trained on VOC2007 and VOC2012 trainval (16,551
images) and tested on VOC2007 test (4,952 images).
Two detector architectures were evaluated: Faster R-CNN
Mask R-CNN baseline
strategy of Fig. 6 (b)
strategy of Fig. 6 (c)
strategy of Fig. 6 (d)
TABLE 9: The instance segmentation comparison among three strategies of the Cascade Mask R-CNN.
(with AlexNet and VGG-Net backbones) and R-FCN (with
ResNet-50 and ResNet-101). Training details were as discussed in Section 6.1.3, and both AlexNet and VGG-Net
were pruned. More speciﬁcally, Faster R-CNN (R-FCN)
training started with a learning rate of 0.001 (0.002), which
was reduced by a factor of 10 at 30k (60k) and stopped at 45k
(90k) iterations. Since the standard VOC evaluation metric
(AP at IoU of 0.5) is fairly saturated, and the focus of this
work is high quality detection, the COCO metrics were used
for evaluation7. Table 11 summarizes the performance of all
detectors, showing that the Cascade R-CNN signiﬁcantly
improves the overall AP in all cases. These results are
further evidence for the robustness of the Cascade R-CNN.
Additional Results on other Datasets
Beyond generic object detection datasets, the Cascade R-
CNN was tested on some speciﬁc object detection tasks,
including KITTI , CityPerson and WiderFace .
The MS-CNN , a detector of strong performance on these
tasks, was used as baseline for all of them.
KITTI: One of the most popular datasets for autonomous
driving, KITTI contains 7,481 training/validation images,
and 7,518 for testing with held annotations. The 2D object
detection task contains three categories: car, pedestrian, and
cyclist. Evaluation is based on the VOC AP at IoU of 0.7, 0.5,
and 0.5 for the three categories, respectively. Since the focus
of this work is high quality detection, the Cascade R-CNN
was only tested on the car category. As shown in Table 12,
it improved the baseline by 0.87 points for the Moderate,
and 1.9 points for the Hard regime, on the test set. These
improvements are nontrivial, given that MS-CNN is a strong
detector and the KITTI car detection task is fairly saturated.
CityPersons: CityPersons is a recently published pedestrian
detection dataset, collected across multiple European cities.
It contains 2,975 training and 500 validation images, and
1,575 images for testing with held annotations. Evaluation
is based on miss-rate (MR) at IoU=0.5. We also report
results for MR at IoU=0.75, which is more commensurate
with high quality detection. This is consistent with a recent
trend to adopt the stricter COCO metric for pedestrian and
face detection, see e.g. the Wider Challenge 2018. Table 13
compares the validation set performance of the Cascade
R-CNN with that of the baseline MS-CNN (performances
on validation and test sets are usually equivalent on this
dataset). The Cascade R-CNN has large performance gains,
especially for the stricter evaluation metric. For example, it
improves the baseline performance by ∼10 points on the
Reasonable set at MR75.
7. The PASCAL VOC annotations were transformed to COCO format,
and the COCO toolbox used for evaluation. Results are different from
the standard VOC evaluation.
Object Detection
Instance Segmentation
ResNet-101
ResNet-50-GN
ResNet-101-GN
ResNeXt-101
ResNeXt-152∗
ResNeXt-152∗⋆
TABLE 10: Performance of the Cascade Mask R-CNN on multiple backbone networks on COCO 2017 val. ∗and ⋆denotes enhancement
techniques at training and inference, respectively, as in .
Faster R-CNN
Faster R-CNN
ResNet-101
TABLE 11: Detection results on PASCAL VOC 2007 test.
Moderate Hard
TABLE 12: MS-CNN detection results for the car class on KITTI test set.
WiderFace: One of the most challenging face detection
datasets, mainly due to its diversity in scale, pose and
occlusion, WiderFace contains 32,203 images with 393,703
annotated faces, of which 12,880 are used for training,
3,226 for validation, and the remainder for testing with
held annotations. Evaluation is based on the VOC AP at
IoU=0.5 on three subsets, easy, medium and hard, of
different detection difﬁculty. Again, we have used AP at
IoU=0.5 and IoU=0.75 and evaluation on the validation set.
Table 14 shows that, while the Cascade R-CNN is close to
the baseline MS-CNN for AP50, it signiﬁcantly boosts its
performance for AP75. The gain is smaller on the hard
than on the easy and medium, because the former contains
mainly very small and heavily occluded faces, for which
high quality detection is difﬁcult. This observation mirrors
the COCO experiments of Table 6, where improvements in
APS are smaller than for APL.
CONCLUSION
In this work, we have proposed a multi-stage object detection framework, the Cascade R-CNN, for high quality
object detection, a rarely explored problem in the detection
literature. This architecture was shown to overcome the high
quality detection challenges of overﬁtting during training
and quality mismatch during inference. This is achieved
by training stages sequentially, using the output of one to
train the next, and the same cascade is applied at inference.
cascade Reasonable Small
TABLE 13: MS-CNN detection results on CityPersons validation set.
TABLE 14: MS-CNN Detection results on WiderFace validation set.
The Cascade R-CNN was shown to achieve very consistent performance gains on multiple challenging datasets,
including COCO, PASCAL VOC, KITTI, CityPersons, and
WiderFace, for both generic and speciﬁc object detection.
These gains were also observed for many object detectors,
backbone networks, and techniques for detection and instance segmentation. We thus believe that the Cascade R-
CNN can be useful for many future object detection and
instance segmentation research efforts.
Acknowledgment: This work was funded by NSF Awards
IIS-1546305 and IIS-1637941, and a GPU donation from
NVIDIA. We would also like to thank Kaiming He for
valuable discussions.