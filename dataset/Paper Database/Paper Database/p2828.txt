Machine Learning, 25, 117-149 
(~) 1996 Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.
The Power of Amnesia: Learning Probabilistic
Automata with Variable Memory Length
~boratory#rComputerScience, MIZ Cambri~e, MA02139
d 
YORAM SINGER
AT&T Labs, 600 Mountain Avenue, Murray Hill, NJ 07974
singer @ research.att.com
Institute of Computer Science, Hebrew University, Jerusalem 91904, Israel
tishby @ cs .huji.ac.il
Editor: Thomas Hancock
We propose and analyze a distribution learning algorithm for variable memory length Markov
processes. These processes can be described by a subclass of probabilistic finite automata which we name
Probabilistic Suffix Automata (PSA). Though hardness results are known for learning distributions generated by
general probabilistic automata, we prove that the algorithm we present can efficiently learn distributions generated
by PSAs. In particular, we show that for any target PSA, the KL-divergence between the distribution generated by
the target and the distribution generated by the hypothesis the learning algorithm outputs, can be made small with
high confidence in polynomial time and sample complexity. The learning algorithm is motivated by applications
in human-machine interaction, Here we present two applications of the algorithm. In the first one we apply the
algorithm in order to construct a model of the English language, and use this model to correct corrupted text. In
the second application we construct a simple stochastic model for E.coli DNA.
Keywords: Learning distributions, probabilistic automata, Markov models, suffix trees, text correction
Introduction
Statistical modeling of complex sequences is a fundamental goal of machine learning due to
its wide variety of natural applications. The most noticeable examples of such applications
are statistical models in human communication such as natural language, handwriting and
speech , and statistical models of biological sequences such as
DNA and proteins .
These kinds of complex sequences clearly do not have any simple underlying statistical
source since they are generated by natural sources. However, they typically exhibit the
following statistical property, which we refer to as the short memory property. If we
consider the (empirical) probability distribution on the next symbol given the preceding
subsequence of some given length, then there exists a length L (the memory length) such
that the conditional probability distribution does not change substantially if we condition it
on preceding subsequences of length greater than L.
This observation lead Shannon, in his seminal paper , to suggest modeling
such sequences by Markov chains of order L > 1, where the order is the memory length
of the model. Alternatively, such sequences may be modeled by Hidden Markov Models
D. RON, Y. SINGER AND N. TISHBY
(HMMs) which are more complex distribution generators and hence may capture additional
properties of natural sequences. These statistical models define rich families of sequence
distributions and moreover, they give efficient procedures both for generating sequences
and for computing their probabilities. However, both models have severe drawbacks. The
size of Markov chains grows exponentially with their order, and hence only very low order
Markov chains can be considered in practical applications. Such low order Markov chains
might be very poor approximators of the relevant sequences. In the case of HMMs, there
are known hardness results concerning their learnability which we discuss in Section 1.1.
In this paper we propose a simple stochastic model and describe its learning algorithm.
It has been observed that in many natural sequences, the memory length depends on the
context and is notfixed. The model we suggest is hence a variant of order L Markov chains,
in which the order, or equivalently, the memory, is variable. We describe this model using
a subclass of Probabilistic Finite Automata (PFA), which we name Probabilistic Suffix
Automata (PSA).
Each state in a PSA is labeled by a string over an alphabet ~. The transition function
between the states is defined based on these string labels, so that a walk on the underlying
graph of the automaton, related to a given sequence, always ends in a state labeled by
a suffix of the sequence. The lengths of the strings labeling the states are bounded by
some upper bound L, but different states may be labeled by strings of different length,
and are viewed as having varying memory length. When a PSA generates a sequence,
the probability distribution on the next symbol generated is completely defined given the
previously generated subsequence of length at most L. Hence, as mentioned above, the
probability distributions these automata generate can be equivalently generated by Markov
chains of order L, but the description using a PSA may be much more succinct. Since the
size of order L markov chains is exponential in L, their estimation requires data length and
time exponential in L.
In our learning model we assume that the learning algorithm is given a sample (consisting
either of several sample sequences or of a single sample sequence) generated by an unknown
target PSA M of some bounded size. The algorithm is required to output a hypothesis
machine 21~/, which is not necessarily a PSA but which has the following properties. M can
be used both to efficiently generate a distribution which is similar to the one generated by
M, and given any sequence s, it can efficiently compute the probability assigned to s by
this distribution.
Several measures of the quality of a hypothesis can be considered. Since we are mainly
interested in models for statistical classification and pattern recognition, the most natural
measure is the Kullback-Leibler (KL) divergence. Our results hold equally well for the
variation (L1) distance and other norms, which are upper bounded by the KL-divergence.
Since the KL-divergence between Markov sources grows linearly with the length of the
sequence, the appropriate measure is the KL-divergence per symbol. Therefore, we define
an e-good hypothesis to be an hypothesis which has at most e KL-divergence per symbol
to the target source.
In particular, the hypothesis our algorithm outputs, belongs to a class of probabilistic
machines named Probabilistic Suffix Trees (PST). The learning algorithm grows such a
suffix tree starting from a single root node, and adaptively adds nodes (strings) for which
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
there is strong evidence in the sample that they significantly affect the prediction properties
of the tree.
We show that every distribution generated by a PSA can equivalently be generated by
a PST which is not much larger. The converse is not true in general. We can however
characterize the family of PSTs for which the converse claim holds, and in general, it is
always the case that for every PST there exists a not much larger PFA that generates an
equivalent distribution. There are some contexts in which PSAs are preferable, and some
in which PSTs are preferable, and therefore we use both representation in the paper. For
example, PSAs are more efficient generators of distributions, and since they are probabilistic
automata, their well defined state space and transition function can be exploited by dynamic
programming algorithms which are used for solving many practical problems. In addition,
there is a natural notion of the stationary distribution on the states of a PSA which PSTs
lack. On the other hand, PSTs sometimes have more succinct representations than the
equivalent PSAs, and there is a natural notion of growing them.
Stated formally, our main theoretical result is the following. If both a bound L, on
the memory length of the target PSA, and a bound n, on the number of states the target
PSA has, are known, then for every given 0 < e < 1 and 0 < ~ < 1, our learning
algorithm outputs an e-good hypothesis PST, with confidence I - 5, in time polynomial in
L, •, I~1, !, and ½. Furthermore, such a hypothesis can be obtained from a single sample
sequence if the sequence length is also polynomial in a parameter related to the rate in
which the target machine converges to its stationary distribution. Despite an intractability
result concerning the learnability of distributions generated by Probabilistic Finite Automata
 , that is described in Section 1.1, our restricted model can be learned
in a PAC-like sense efficiently. This has not been shown so far for any of the more popular
sequence modeling algorithms.
We present two applications of the learning algorithm. In the first application we apply
the algorithm in order to construct a model of the English language, and use this model to
correct corrupted text. In the second application we cons~uct a simple stochastic model for
E.coli DNA. Combined with a learning algorithm for a different subclass of probabilistic
automata , the algorithm presented here is part of a complete
cursive handwriting recognition system .
Related Work
The most powerful (and perhaps most popular) model used in modeling natural sequences is
the Hidden Markov Model (HMM). A detailed tutorial on the theory of HMMs as well as se-
lected applications in speech recognition is given by Rabiner . A commonly
used procedure for learning an HMM from a given sample is a maximum likelihood param-
eter estimation procedure that is based on the Baum-Welch method (which is a special case of the EM (Expectation-Maximization) algorithm
 ). However, this algorithm is guaranteed to converge
only to a local maximum, and thus we are not assured that the hypothesis it outputs can
serve as a good approximation for the target distribution. One might hope that the problem
D. RON, Y. SINGER AND N. TISHBY
can be overcome by improving the algorithm used or by finding a new approach. Unfortu-
nately, there is strong evidence that the problem cannot be solved efficiently.
Abe and Warmuth study the problem of training HMMs. The
HMM training problem is the problem of approximating an arbitrary, unknown source
distribution by distributions generated by HMMs. They prove that HMMs are not train-
able in time polynomial in the alphabet size, unless RP -- NP. Gillman and Sipser
 study the problem of exactly inferring an (ergodic) HMM over a
binary alphabet when the inference algorithm can query a probability oracle for the long-
term probability of any binary string. They prove that inference is hard: any algorithm
for inference must make exponentially many oracle calls. Their method is information
theoretic and does not depend on separation assumptions for any complexity classes.
Natural simpler alternatives, which are often used as well, are order L Markov chains
 , also known as n-gram models. As noted earlier, the size
of an order L Markov chain is exponential in L and hence, if we want to capture more
than very short term memory dependencies in the sequences, of substantial length in the
sequences, then these models are clearly not practical.
HSffgen studies families of distributions related to the ones studied in
this paper, but his algorithms depend exponentially and not polynomially on the order, or
memory length, of the distributions. Freund et. al. point out that
their result for learning typical deterministic finite automata from random walks without
membership queries, can be extended to learning typical PFAs. Unfortunately, there is
strong evidence indicating that the problem of learning general PFAs is hard. Kearns et.
al. show that PFAs are not efficiently learnable under the assumption
that there is no efficient algorithm for learning noisy parity functions in the PAC model.
The machines used as our hypothesis representation, namely Probabilistic Suffix Trees
(PSTs), were introduced (in a slightly different form) in and have been
used for other tasks such as universal data compression .
Perhaps the
strongest among these results (which has been brought to our attention after the completion
of this work) and which is most tightly related to our result is . This paper describes an efficient sequential procedure for universal data compres-
sion for PSTs by using a larger model class. This algorithm can be viewed as a distribution
learning algorithm but the hypothesis it produces is not a PST or a PSA and hence cannot
be used for many applications. Willems et. aL show that their algorithm can be modified
to give the minimum description length PST. However, in case the source generating the
examples is a PST, they are able to show that this PST convergence only in the limit of
infinite sequence length to that source.
Vitter and Krishnan adapt a version of
the Ziv-Lempel data compression algorithm to get a page prefetching
algorithm, where the sequence of page accesses is assumed to be generated by a PFA. They
show that the page fault rate of their algorithm converges to the page fault rate of the
best algorithm that has full knowledge of the source. This is true for almost all page
access sequences (in the limit of the sequence length). Laird and Saul 
describe a prediction algorithm which is similar in spirit to our algorithm and is based
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
on the Markov tree or Directed Acyclic Word Graph approach which is used for data
compression . They do not analyze the correctnes of the algorithm formally,
but present several applications of the algorithm.
Overview of the Paper
The paper is organized as follows. In Section 2 we give basic definitions and notation and
describe the families of distributions studied in this paper, namely those generated by PSAs
and those generated by PSTs. In Section 4 we discuss the relation between the above two
families of distributions. In Section 5 the learning algorithm is described. Some of the
proofs regarding the correctness of the learning algorithm are given in Section 6. Finally,
we demonstrate the applicability of the algorithm by two illustrative examples in Section 7.
In the first example we use our algorithm to learn the structure of natural English text, and
use the resulting hypothesis for correcting corrupted text. In the second example we use
our algorithm to build a simple stochastic model for E.coli DNA. The detailed proofs of the
claims presented in Section 4 concerning the relation between PSAs and PSTs are provided
in Appendices A and B. The more technical proofs and lemmas regarding the correctness
of the learning algorithm are given in Appendix C.
Preliminaries
Basic Definitions and Notations
Let E be a finite alphabet. By E* we denote the set of all possible strings over E. For any
integer N, EN denotes all strings of length N, and E<_N denotes the set of all strings with
length at most N. The empty string is denoted by e. For any string s = sl... st, si C E,
we use the following notations:
The longest prefix of s different from s is denoted by prefix(s) de f 8182
. . . Sl--1.
The longest suffix of s different from s is denoted by suffix(s) clef
S 2...sl_ls
The set of all suffixes of s is denoted by Suffix*(s) de__f {Si... St I 1 < i < l} U (e}.
A string s t is aproper suffix of s, if it a suffix of s but is not s itself.
Let s 1 and s 2 be two strings in E*. If s 1 is a suffix of s 2 then we shall say that s 2 is a
suffix extension of sl.
Aset ofstrings S is called a suffix free set if Vs E S, Suffiz*(s) nS = {s}.
D. RON, Y. SINGER AND N. TISHBY
Probabilistic Finite Automata and Prediction Suffix Trees
Probabilistic Finite Automata
A Probabilistic Finite Automaton (PFA) M is a 5-tuple (Q, E, r, 7, 70, where Q is a finite
set of states, E is a finite alphabet, "c : Q x E --~ Q is the transition function, 7 : Q x E ---+
 is the next symbol probability function, and 7r : Q ~
 is the initialprobability
distribution over the starting states. The functions "7 and 7r must satisfy the following
conditions: for every q E Q, Y'~,,cr~ 7(q, or) = 1, and ~qCQ 7r(q) = 1. We assume that
the transition function ~- is defined on all states q and symbols cr for which 7(q, ~r) > 0,
and on no other state-symbol pairs. ~- can be extended to be defined on Q x E* as follows:
A PFA M generates strings of infinite length, but we shall always discuss probability
distributions induced on prefixes of these strings which have some specified finite length.
If PM is the probability distribution M defines on infinitely long strings, then PM
N, for any
N _> 0, will denote the probability induced on strings of length N. We shall sometimes
drop the superscript N, assuming that it is understood from the context. The probability
that M generates a string r = rlr2.., rN in y]N is
(qO) H'y(¢-',r,)
where qi+l = ~_(qi, ri).
Probabilistic Suffix Automata
We are interested in learning a subclass of PFAs which we name Probabilistic Suffix Au-
tomata (PSA). These automata have the following property. Each state in a PSA M is
labeled by a string of finite length in E*. The set of strings labeling the states is suffix free.
For every two states ql,qZ E Q and for every symbol o- E E, if'r(qt,~r) = qZ and q1 is
labeled by a string s 1, then q2 is labeled by a string s z which is a suffix of s a .o-. In order
that ~- be well defined on a given set of strings S, not only must the set be suffix free, but it
must also have the following property. For every string s in S labeling some state q, and
every symbol a for which 7(q, ~r) > 0, there exists a string in S which is a suffix of scr.
For our convenience, from this point on, if q is a state in Q then q will also denote the string
labeling that state.
We assume that the underlying graph of M, defined by Q and ~- (-,-), is strongly connected,
i.e., for every pair of states q and q' there is a directed path from q to q'. Note that in our
definition of PFAs we assumed that the probability associated with each transition (edge in
the underlying graph) is non-zero, and hence strong connectivity implies that every state
can be reached from every other state with non-zero probability. For simplicity we assume
M is aperiodic, i.e., that the greatest common divisor of the lengths of the cycles in its
underlying graph is 1. These two assumptions ensure us that M is ergodic. Namely, there
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
exists a distribution IIM on the states such that for every state we may start at, the probability
distribution on the state reached after time t as t grows to infinity, converges to IIM. The
probability distribution Yl M is the unique distribution satisfying
nM(q')-y(q',
q' s,t. "r(q',o-)=q
and is named the stationary distribution of M. We ask that for every state q in Q, the
initial probability of q, 7r(q), be the stationary probability of q, IIM (q). It should be noted
that the assumptions above are needed only when learning from a single sample string and
not when learning from many sample strings. However, for sake of brevity we make these
requirements in both cases.
For any given L > 0, the subclass of PSAs in which each state is labeled by a string of
length at most L is denoted by L-PSA. An example 2-PSA is depicted in Figure 1. A special
case of these automata is the case in which Q includes all strings in E n. An example of
such a 2-PSA is depicted in Figure 1 as well. These automata can be described as Markov
chains of order L. The states of the Markov chain are the symbols of the alphabet E, and
the next state transition probability depends on the last L states (symbols) traversed. Since
every L-PSA can be extended to a (possibly much larger) equivalent L-PSA whose states
are labeled by all strings in E L, it can always be described as a Markov chain of order L.
Alternatively, since the states of an L-PSA might be labeled by only a small subset of ~<L,
and many of the suffixes labeling the states may be much shorter than L, it can be viewed
as a Markov chain with variable order, or variable memory.
Learning Markov chains of order L, i.e., L-PSAs whose states are labeled by all E L
strings, is straightforward (though it takes time exponential in L). Since the 'identity' of
the states (i.e., the strings labeling the states) is known, and since the transition function
~- is uniquely defined, learning such automata reduces to approximating the next symbol
probability function 7. For the more general case of L-PSAs in which the states are labeled
by strings of variable length, the task of an efficient learning algorithm is much more
involved since it must reveal the identity of the states as well.
Prediction Suffix Trees
Though we are interested in learning PSAs, we choose as our hypothesis class the class
of prediction suffix trees (PST) defined in this section. We later show (Section 4) that for
every PSA there exists an equivalent PST of roughly the same size.
A PST T, over an alphabet E, is atree of degree IEI. Each edge in the tree is labeled by
a single symbol in E, such that from every internal node there is exactly one edge labeled
by each symbol. The nodes of the tree are labeled by pairs (s, 7s) where s is the string
associated with the walk starting from that node and ending in the root of the tree, and
% : E ---+ is the next symbol probability function related with s. We require that for
every string s labeling a node in the tree, ~-]~ % (or) = 1.
As in the case of PFAs, a PST T generates strings of infinite length, but we consider the
probability distributions induced on finite length prefixes of these strings. The probability
that T generates a string r = rlr2.., rN in ~N is
D. RON, Y. SINGER AND N. TISHBY
= II~=i%,-1 (r d
where s o =- e, and for I < j < N - 1, s j is the string labeling the deepest node reached
by taking the walk corresponding to riri-1 • •. rl starting at the root of T. For example,
using the PST depicted in Figure 1, the probability of generating the string 00101, is
0.5 x 0.5 x 0.25 × 0.5 × 0.75, and the labels of the nodes that are used for the prediction
are s o = e, s I = 0, s 2 = 00, s 3 = 1, s 4 = 10. In view of this definition, the requirement
that every internal node have exactly I~1 sons may be loosened, by allowing the omission
of nodes labeled by substrings which are generated by the tree with probability 0.
PSTs therefore generate probability distributions in a similar fashion to PSAs. As in the
case of PSAs, symbols are generated sequentially and the probability of generating a symbol
depends only on the previously generated substring of some bounded length. In both cases
there is a simple procedure for determining this substring, as well as for determining the
probability distribution on the next symbol conditioned on the substring. However, there
are two (related) differences between PSAs and PSTs. The first is that PSAs generate each
symbol simply by traversing a single edge from the current state to the next state, while for
each symbol generated by a PST, one must walk down from the root of the tree, possibly
traversing L edges. This implies that PSAs are more efficient generators. The second
difference is that while in PSAs for each substring (state) and symbol, the next state is
well defined, in PSTs this property does not necessarily hold. Namely, given the current
generating node of a PST, and the next symbol generated, the next node is not necessarily
uniquely defined, but might depend on previously generated symbols which are not included
in the string associated with the current node. For example, assume we have a tree whose
leaves are: 1,00,010,110 (see Figure B.1 in Appendix B). If 1 is the current generating
leaf and it generates 0, then the next generating leaf is either 010 or 110 depending on the
symbol generated just prior to 1.
PSTs, like PSAs, can always be described as Markov chains of (fixed) finite order, but as
in the case of PSAs this description might be exponentially large.
We shall sometimes want to discuss only the structure of a PST and ignore its prediction
property. In other words, we will be interested only in the string labels of the nodes and not
in the values of %(.). We refer to such trees as suffix trees. We now introduce two more
notations. The set of leaves of a suffix tree T is denoted by E(T), and for a given string s
labeling a node v in T, T(s) denotes the subtree rooted at v.
The Learning Model
The learning model described in this paper is motivated by the PAC model for learn-
ing boolean concepts from labeled examples and is similar in spirit to that introduced in
 . We start by defining an e-good hypothesis PST with respect to a
given PSA.
Definition. Let M be a PSA and let T be a PST. Let PM and PT be the two probability
distributions they generate respectively. We say that T is an e-good hypothesis with respect
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
(" ")~,~(00)--0.25
n(10)=0.25
~(00)=0.25
'",.,,.."~"
~(0.5,0.5)
Figure 1. Left: A 2-PSA. The strings labeling the states are the suffixes corresponding to them. Bold edges
denote transitions with the symbol '1 ', and dashed edges denote transitions with '0'. The transition probabilities
are depicted on the edges. Middle: A 2-PSA whose states are labeled by all strings in {0, 1} Z. The strings
labeling the states are the last two observed symbols before the state was reached, and hence it can be viewed as
a representation ofa Markov chain of order 2. Right: A prediction suffix tree. The prediction probabilities of the
symbols '0' and '1', respectively, are depicted beside the nodes, in parentheses. The three models are equivalent
in the sense that they induce the same probability distribution on strings from {0, 1}%
to M, if for every N > 0,
NDKL[pNIIp~] <_ e
DKL[P ItP¢lde2
P (r)log pN(r)
is the Kullback-Leibler divergence between the two distributions.
In this definition we chose the Kullback-Leibler (KL) divergence as a distance measure
between distributions. Similar definitions can be considered for other distance measures
such as the variation and the quadratic distances. Note that the KL-divergence bounds the
variation distance as follows : Df,;L[PIIIP2] >- ½11P1 - P'2111.2
Since the L1 norm bounds the L2 norm, the last bound holds for the quadratic distance
as well. Note that the KL-divergence between distributions, generated by finite order
markov chains, is proportional to the length of the strings over which the divergence is
computed, when this length is longer than the order of the model. Hence, to obtain a
measure independent of that length it is necessary to divide the KL-divergence by the
length of the strings, N.
A learning algorithm for PSAs is given the maximum length L of the strings labeling
the states of the target PSA M, and an upper bound n on the number of states in M. The
algorithm is also given a confidence (security) parameter 0 < 5 < 1 and an approximation
parameter 0 < e < 1. We analyze the following two learning scenarios. In the first
scenario the algorithm has access to a source of sample strings of minimal length L + 1,
independently generated by M. In the second scenario it is given only a single (long)
sample string generated by M. In both cases we require that it output a hypothesis PST T,
which with probability at least 1 - ~ is an e-good hypothesis with respect to M.
The only drawback to having a PST as our hypothesis instead ofa PSA (or more generally
a PFA), is that the prediction procedure using a tree is somewhat less efficient (by at most
D. RON, Y. SINGER AND N. TISHBY
a factor of L). Since no transition function is defined, in order to predict/generate each
symbol, we must walk from the root until a leaf is reached. As mentioned earlier, we show
in Appendix B that every PST can be transformed into an equivalent PFA which is not much
larger. This PFA differs from a PSA only in the way it generates the first L symbols. We
alsoshow that if the PST has a certain property (defined in Appendix B), then it can be
transformed into an equivalent PSA.
In order to measure the efficiency of the learning algorithm, we separate the case in which
the algorithm is given a sample consisting of independently generated sample strings, from
the case in which it is given a single sample string. In the first case we say that the learning
1 and 1. In order to define
algorithm is efficient if it runs in time polynomial in L, n, It, I, 7
efficiency in the latter case we need to take into account an additional property of the model
- its mixing or convergence rate. To do this we next discuss another parameter of PSAs
(actually, of PFAs in general).
For a given PSA, M, let RM denote the n x n stochastic transition matrix defined by
~-(., .) and 7(', ) when ignoring the transition labels. That is, ifs i and s j are states in M
and the last symbol in s j is ~r, then RM(S i, s j) is "/(s ~, cr) ifT(s i, ~r) = sJ, and 0 otherwise.
Hence, RM is the transition matrix of an ergodic Markov chain.
Let/~M denote the time reversal of RM. That is,
IIM(sJ)t~M(8 j , 8 i)
KM(S ~, 8J) =
where 1-IM is the stationary probability vector of RM as defined in Equation (2). Define
the multiplicative reversiblization UM of M by UM = RM-RM. Denote the second largest
eigenvalue of UM by A2(UM).
If the learning algorithm receives a single sample string, we allow the length of the string
(and hence the running time of the algorithm) to be polynomial not only in L, n, ]E I, 1,
and ½, but also in 1/(1 - A2(UM) ). The rationale behind this is roughly the following.
In order to succeed in learning a given PSA, we must observe each state whose stationary
probability is non-negligible enough times so that the algorithm can identify that the state
is significant, and so that the algorithm can compute (approximately) the next symbol
probability function. When given several independently generated sample strings, we can
easily bound the size of the sample needed by a polynomial in L, n, ]El, £c, and ½, using
Chernoff bounds. When given one sample string, the given string must be long enough so as
to ensure convergence of the probability of visiting a state to the stationary probability. We
show that this convergence rate can be bounded using algebraic properties of UM, namely,
its second largest eigenvalue .
Emulation of PSAs by PSTs
In this section we show that for every PSA there exists an equivalent PST which is not
much larger. This allows us to consider the PST equivalent to our target PSA, whenever it
is convenient.
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
THEOREM 1 For every L-PSA, M = (Q, E, % 7, 7r), there exists an equivalentPST TM,
of maximal depth L and at most L . IQI nodes.
(Sketch) We describe below the consmaction needed to prove the claim.
complete proof is provided in Appendix A.
Let TM be the tree whose leaves correspond to the strings in Q. For each leaf s, and
for every symbol or, let %(a) = 7(s, a). This ensures that for every given string s which
is a suffix extension of a leaf in TM, and for every symbol cr, PM(als ) = PTM(~r[s). It
remains to define the next symbol probability functions for the internal nodes of TM. These
functions must be defined so that TM generates all strings related to its nodes with the same
probability as M.
For each node s in the tree, let the weight of s, denoted by ws, be Ws
~-]~s'~Q, scs~J3~*(~') 7r(s'). In other words, the weight of a leaf in TM is the stationary
probability of the corresponding state in M; and the weight of an internal node labeled by
a string s, equals the sum of the stationary probabilities over all states of which s is a suffix
(which also equals the sum of the weights of the leaves in the subtree rooted at the node).
Using the weights of the nodes we assign values to the 7~'s of the internal nodes s in the tree
in the following manner. For every symbol cr let "y~ (a) = Y'~8'eQ, 8Es~y~x*(~') -~f'~' 7( sl, a).
The probability ~'~ (a), of generating a symbol c~ following a string s, shorter than any state
in M, is thus a weighted average of "),(s', a) taken over all states s ~ which correspond to
suffix extensions of s. The weight related with each state in this average, corresponds to
its stationary probability. As an example, the probability distribution over the first sym-
bol generated by TM, is ~--~Q 7r(s)7(s, -). This probability distribution is equivalent, by
definition, to the probability distribution over the first symbol generated by M.
Finally, if for some internal node in TM, its next symbol probability function is equivalent
to the next symbol probability functions of all of its descendants, then we remove all its
descendants from the tree.
An example of the construction described in the proof of Theorem 1 is illustrated in
Figure 1. The PST on the right was constructed based on the PSA on the left, and is
equivalent to it. Note that the next symbol probabilities related with the leaves and the
internal nodes of the tree are as defined in the proof of the theorem.
The Learning Algorithm
We start with an overview of the algorithm. Let M = (Q, E, ~-, 7, 7r) be the target L-PSA
we would like to learn, and let IQI <- n. According to Theorem 1, there exists a PST T, of
size bounded by L - IQI, which is equivalent to M. We use the sample statistics to define
the empirical probability function, P(-), and using/5 we construct a suffix tree, 2?, which
with high probability is a subtree of T. We define our hypothesis PST, 7 ~, based on 7 ~ and
The construction of 7 ~ is done as follows. We start with a tree consisting of a single node
(labeled by the empty string e) and add nodes which we have reason to believe should
be in the tree. A node v labeled by a string s is added as a leaf to 7 ~ if the following
holds. The empirical probability of s,/5(s), is non-negligble, and for some symbol (r, the
D. RON: Y. SINGER AND N. TISHBY
empirical probability of observing cr following s, namely/5(otis), differs substantially from
the empirical probability of observing a following suJfiz(s), namely/5(c~tsuffix(s)). Note
that suffi~c(s) is the string labeling the parent node of v. Our decision rule for adding v,
is thus dependent on the ratio between/5(cqs) and P(alsuffiz(s)). We add a given node
only when this ratio is substantially greater than 1. This suffices for our analysis (due to
properties of the KL-divergence), and we need not add a node if the ratio is smaller than 1.
Thus, we would like to grow the tree level by level, adding the sons of a given leaf in the
tree, only if they exhibit such a behavior in the sample, and stop growing the tree when the
above is not true for any leaf. The problem is that the node might belong to the tree even
though its next symbol probability function is equivalent to that of its parent node. The
leaves of a PST must differ from their parents (or they are redundant) but internal nodes
might not have this property. The PST depicted in Figure 1 illustrates this phenomena. In
this example, "70(') = "Te('), but both "700(') and "71o(') differ from V0(@ Therefore, we
must continue testing further potential descendants of the leaves in the tree up to depth L.
As mentioned before, we do not test strings which belong to branches whose em-
pirical count in the sample is small.
This way we avoid exponential grow-up in the
number of strings tested.
A similar type of branch-and-bound technique (with vari-
ous bounding criteria) is applied in many algorithms which use trees as data structures
 ). The set of strings tested at each step, denoted by S,
can be viewed as a kind of p_otentialfrontier of the growing tree 2P, which is of bounded size.
After the construction of T is completed, we define T by adding nodes so that all internal
nodes have full degree, and defining the next symbol probability function for each node
based on/6. These probability functions are defined so that for every string s in the tree and
for every symbol a, "Ts (or) is bounded from below by "7~in which is a parameter that is set
subsequently. This is done by using a conventional smoothing technique. Such a bound on
% (or) is needed in order to bound the KL-divergence between the target distribution and
the distribution our hypothesis generates.
The above scheme follows a top-down approach since we start with a tree consisting of a
single root node and a frontier consisting only of its children, and incrementally grow the
suffix tree T and the frontier A'. Alternatively, a bottom-up procedure can be devised. In
a bottom-up procedure we start by putting in o ~ all strings of length at most L which have
significant counts, and setting 2P to be the tree whose nodes correspond to the strings in
S. We then trim T starting from its leaves and proceeding up the tree by comparing the
prediction probabilities of each node to its parent node as done in the top-down procedure.
The two schemes are equivalent and yield the same prediction suffix tree. However, we find
the incremental top-down approach somewhat more intuitive, and simpler to implement.
Moreover, our top-down procedure can be easily adapted to an online setting which is useful
in some practical applications.
Let P denote the probability distribution generated by M. We now formally define the
empiricalprobability function P, based on a given sample generated by M. For a given
string s, P(s) is roughly the relative number of times s appears in the sample, and for any
symbol a, P(als ) is roughly the relative number of times o- appears after s. We give a more
precise definition below.
LEARNING PROBABILISTIC
AUTOMATA WITH VARIABLE MEMORY LENGTH
If the sample consists of one sample string r of length m, then for any string s of length
at most L, define Xj(S) to be i if rj_l~l+l.., rj = s and 0 otherwise. Let
and for any symbol (7, let
/3(O.18 ) =
Ej=~ xj(8)
If the sample consists of ra t sample strings rl,..., r
, each of length £ > L + 1, then for
any string 8 of length at most L, define X~ (s) to be I if rj_l~ I +1"'" zj = s, and 0 otherwise.
p(s)- ra,(e- r)
and for any symbol 0-, let
/'(ol8) = EF', Ej=L xj+l(80-)
Ei=l E3=L X~(s)
For simplicity we assume that all the sample strings have the same length and that this
length is polynomial in n, L, and E. The case in which the sample strings are of different
lengths can be treated similarly, and if the strings are too long then we can ignore parts of
In the course of the algorithm and in its analysis we refer to several parameters which are
all simple functions of e, n, L and IEI, and are set as follows:
2nLlog(X/Tmin)
2nLlog(48LlEI/~) '
Llog(48LIE]/e)IEI
The size of the sample is set in the analysis of the algorithm.
A pseudo code describing the learning algorithm is given in Figure 2 and an illustrative
run of the algorithm is depicted in Figure 3.
D. RON. Y. SINGER AND N. TISHBY
Algorithm Learn-PSA
1. Initialize 7 ~ and S: let T consist of a single root node (corresponding to e), and let
5; ~- {G I ~ C X and/5(0-) > (1 - q)eo}.
2. While S ¢ 0, pick any s E :~ and do:
(A) Remove s from S;
(B) If there exists a symbol a E E such that
P(O'I8 ) ~ (1 ~- 52)'~rnin and b( ls)/P( ls yfix(s)) > 1 + 3ez ,
then add to 7 ~ the node corresponding to s and all the nodes on the path from the
deepest node in T that is a suffix of s, to s;
(C) If 14 < L then for every ~' c ~, if/3(G'-s) > (1 - ei)eo, then add cr'-s to S.
3. Initialize T to be 7 ~.
Extend 7 ~ by adding all missing sons of internal nodes.
For each s labeling a node in 7 ~, let
%(~r) -- P(~rls')(1 - IXhm~n) + 7m~n ,
where s ' is the longest suffix of s in 7 ~.
Figure 2. Algorithm Learn-PSA
Analysis of the Learning Algorithm
In this section we state and prove our main theorem regarding the correctness and efficiency
of the learning algorithm Learn-PSA, described in Section 5.
THEOREM 2 For every target PSA M, and for every given security parameter 0 < 6 < 1,
and approximation parameter 0 < ~ < 1, Algorithm Learn-PSA outputs a hypothesis PST,
:F, such that with probability at least 1 - 5:
1. T is an e-good hypothesis with respect to M.
2. The number of nodes in :F is at most
• L times the number of states in M.
If the algorithm has access to a source of independently generated sample strings, then
its running time is polynomial in L, n, IXI, ~ and ½. If the algorithm has access to only
one sample string, then its running time is polynomial in the same parameters and in
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
(::: ~ ::'~(0.6,0.4)
;* ;i: ~'~(0.4,0.6)
~.";:I::]V:
~:';~ (0.4,0.6)
(0.6,0.4) {~i:~i ';~
~i:i0; !?!(0.6,0.4)
:~;~:,/:~.;':
(0.6,0.4) (0.4,0.6)
~::;o~i~(o.8,o.z)
¢;~ii;?'.( • , • ):5!~:.( . , )
• <. ?..:.~.~
(0.6,0.4) (0.4,0.6) (0.4,0.6) (0"6'0"4)t4 ~0.6,0.4)
(0.8,0.2) (0.3,0.7)
Figure 3. An illustrative run of the learning algorithm. The prediction suffix trees created along the run of the
algorithm are depicted from left to right and top to bottom. At each stage of the run, the nodes from T are plotted
in dark grey while the nodes from S are plotted in light grey. The alphabet is binary and the predictions of the next
bit are depicted in parenthesis beside each node. The final tree is plotted on the bottom right part and was built by
adding to T (bottom left) all missing children. Note that the node labeled by 10o was added to the final tree but
is not part of any of the intermediate trees. This can happen when the probability of the string 100 is small.
D. RON, Y. SINGER AND N. TISHBY
In order to prove the theorem above we first show that with probability 1 - 5, a large enough
sample generated according to M is typical to M, where typical is defined subsequently.
We then assume that our algorithm in fact receives a typical sample and prove Theorem 2
based on this assumption. Roughly speaking, a sample is typical if for every substring
generated with non-negligible probability by M, the empirical counts of this substring and
of the next symbol given this substring, are not far from the corresponding probabilities
defined by M.
Definition. A sample generated according to M is typical if for every string s E E <L the
following two properties hold:
1. Ifs E Qthen [/5(s)- 7r(s)[ _< eleo;
2. If/5(s) > (1 - ca)co then for every ~r E E, IP(~rls) - P(~ls)l _< ~2~Ymin;
Where Go, q, e2, and "/min were defined in Section 5.
1. There exists a polynomial rn~o in L, n, IE[, !, and 1, such that the probability that a
sample of m' > rMo(L,n,[E}, 1 1
-2, -~) strings each of length at least L + 1 generated
according to M is typical is at least 1 - 5.
2. There exists a polynomial mo in L, n, [E[, ¼, }, and 1/(1 - )~2(UM)), such that
the probability that a single sample stying of length ra __> Tno(Z , 72, [Y][, -~'1 ½~ 1/(1 -
~k2 (UM))) generated according to M is typical is at least 1 - &
The proof of Lemma 1 is provided in Appendix C.
Let T be the PST equivalent to the target PSA M, as defined in Theorem 1. In the next
lemma we prove two claims. In the first claim we show that the prediction properties of
our hypothesis PST 25, and of T, are similar. We use this in the proof of the first claim in
Theorem 2, when showing that the KL-divergence per symbol between T and M is small.
In the second claim we give a bound on the size of T in terms of T, which implies a similar
relation between 25 and M (second claim in Theorem 2);
1. For every string s in T, if P(s) > eo then %(cr)
suffix of s corresponding to a node in 25.
If Leaxn-PSA is given a typical sample then:
___ 1 + e/2 , where s I is the longest
2. 1251 -< (]E[- 1). ITI.
Proof: (Sketch, the complete proofs of both claims are provided in Appendix C.)
In order to prove the first claim, we argue that if the sample is typical, then there cannot
exist such strings s and s' which falsify the claim. We prove this by assuming that there
exists such a pair, and reaching contradiction. Based on our setting of the parameters e2
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
and "[min, we show that for such a pair, s and s', the ratio between %(c 0 and %,(or)
must be bounded from below by 1 + e/4. If s = s', then we have already reached a
contradiction. If s # s', then we can show that the algorithm must add some longer suffix
of s to 7 ~, contradicting the assumption that s' is the longest suffix of s corresponding
to a node in T.
In order to bound the size of 20, we show that 2? is a subtree of T.
This suffices to prove the second claim, since when transforming 2P into 20, we add at
most all IP, I - 1 siblings of every node in 2?. We prove that 2 ~ is a subtree of T, by
arguing that in its construction, we did not add any string which does not correspond to
a node in T. This follows from the decision rule according to which we add nodes to LP.
Proof of Theorem 2: According to Lemma 1, with probability at least 1 - 6 our algorithm
receives a typical sample. Thus according to the second claim in Lemma 2, ]T] _< (IEI -
1)-ITI and since ITI _< L-IQI, then 1201 < I~l' L. IQI and the second claim in the theorem
Let r = rlr2 • • • rN, where ri C E, and for any prefix r (i) of r, where r (0 = rl... ri,
let s[r (i)] and 5[r (i)] denote the strings corresponding to the deepest nodes reached upon
taking the walk ri... rl on T and T respectively. In particular, s[r (°)] ---- g[r (°)] ---- e. Let
/3 denote the probability distribution generated by 20. Then
~ P(r)log/5(r )
P(r)- log 1-Ii=lg %It"-')]^ (r~)
IIi=1%[~('-,1 (r~)
,~s[r(i_l) ] (Ti)
~/8[ r(i-1) ] (Ti)
P(s[r(i-1)])<e o
%[r._q (r~)
P(r). log "~[r¢'-l>l (ri)
r6~ N s.t.
P(s[r(i-a)])>_eo
For every 1 < i < N, the first term in the parenthesis in Equation (8d) can be bounded as
follows. For each string r, the worst possible ratio between %[r(~-1)] (ri) and -~[r(~_l)] (ri),
is 1/~[min. The total weight of all strings in the first term equals the total weight of all
the nodes in T whose weight is at most co, which is at most nLeo. The first term is thus
bounded by nLeo log(I/Train). Based on Lemma 2, the ratio between %[r(~-lq (ri) and
5'~[r(,-1)](ri) for every string r in the second term in the parenthesis, is at most 1 + e/2.
Since the total weight of all these strings is bounded by 1, the second term is bounded by
log(1 + e/2). Combining the above with the value of e0 (that was set in Section 5 to be
e~ (2nL log(i/Train)) ), we get that,
D. RON, Y. SINGER AND N. TISHBY
-~DKL[P [I/3N] _< -~.N[nLeolog--+ log(l+e/2)] < e.
Using a straightforward implementation of the algorithm, we can get a (very rough) upper
bound on the running time of the algorithm which is of the order of the square of the size
of the sample times L. In this implementation, each time we add a string s to S or to T,
we perform a complete pass over the given sample to count the number of occurrences
of s in the sample and its next symbol statistics. According to Lemma 1, this bound is
polynomial in the relevant parameters, as required in the theorem statement. Using the
following more time-efficient, but less space-efficient implementation, we can bound the
running time of the algorithm by the size of the sample times L. For each string in S, and
each leaf in T we keep a set of pointers to all the occurrences of the string in the sample.
For such a string s, if we want to test which of its extensions, as should we add to S or
to 7 ~, we need only consider all occurrences of s in the sample (and then distribute them
accordingly among the strings added). For each symbol in the sample there is a single
pointer, and each pointer corresponds to a single string of length i for every I < i < L.
Thus the running time of the algorithm is of the order of the size of the sample times L.
Applications
A slightly modified version of our learning algorithm was applied and tested on various prob-
lems such as: correcting corrupted text, predicting DNA bases ,
and part-of-speech disambiguation resolving . We are still explor-
ing other possible applications of the algorithm. Here we demonstrate how the algorithm
can be used to correct corrupted text and how to build a simple model for DNA strands.
7.1. Correcting Corrupted Text
In many machine recognition systems such as speech or handwriting recognizers, the recog-
nition scheme is divided into two almost independent stages. In the first stage a low-level
model is used to perform a (stochastic) mapping from the observed data (e.g., the acoustic
signal in speech recognition applications) into a high level alphabet. If the mapping is
accurate then we get a correct sequence over the high level alphabet, which we assume
belongs to a corresponding high level language. However, it is very common that errors
in the mapping occur, and sequences "in the high level language are corrupted. Much of
the effort in building recognition systems is devoted to correct the corrupted sequences. In
particular, in many optical and handwriting character recognition systems, the last stage
employs natural-language analysis techniques to correct the corrupted sequences. This can
be done after a good model of the high level language is learned from uncorrupted examples
of sequences in the language. We now show how to use PSAs in order to perform such a
We applied the learning algorithm to the bible. The alphabet was the english letters and
the blank character. We removed Jenesis and it served as a test set. The algorithm was
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
applied to the rest of the books with L = 30, and the accuracy parameters (ei) were of
order O(v/-N), where N is the length of the training data. This resulted in a PST having
less than 3000 nodes. This PST was transformed into a PSA in order to apply an efficient
text correction scheme which is described subsequently. The final automaton constitutes
both of states that are of length 2, like ' qu' and ' xe', and of states which are 8 and 9
symbols long, like ' shal i be' and "there was'. This indicates that the algorithm really
captures the notion of variable memory that is needed in order to have accurate predictions.
Building a Markov chain of order L in this case is clearly not practical since it requires
I~l L = 279 = 7625597484987 states!
Let ~ = (rl, r2,..., rt) be the observed (corrupted) text. If an estimation of the cor-
rupting noise probability is given, then we can calculate for each state sequence 77 =
(q0, ql, q2,..., qt), qi C Q, the probability that ~ was created by a walk over the PSA
which constitutes of the states 77. For 0 < i < t, let Xi be a random variable over Q, where
Xi = q denotes the event that the/th state passed was q. For 1 < i < t let Y/be a random
variable over E, where Y/= cr denotes the event that the ith symbol observed was c< For
C 7 C Qt+l, let )( = 77 denote the joint event that Xi = qi for every 0 < i < t, and for
E E t, let g = f denote the joint event that Y/ = ri for every 1 < i < t. If we assume
that the corrupting noise is i.i.d and is independent of the states that constitute the walk,
then the most likely state sequence, qML, is
---- arg max P (2 = qlY = f) = arg max P (Y = flJ~ = q) P(){ = 77) (lOa)
P (Xi = qdXi-1 = qi-1
(Z =T, IX, =q,)+ log(.(q0))+
(P (Xi = qdXi-x = qi_j
where for deriving the last Equality (10c) we used the monotonicity of the log function
and the fact that the corruption noise is independent of the states. Let the string labeling
qi be sl,..., sl. Then P(Y/ = rilX ~ = qi) is the probability that ri is an uncorrupted
symbol if ri = sl, and is the probability that the noise process flipped st to be ri otherwise.
Note that the sum (10c) can be computed efficiently in a recursive manner. Moreover, the
maximization of Equation (10a) can be performed efficiently by using a dynamic program-
ming (DP) scheme . This scheme requires O(IQI × t) operations. If IQI is
large, then approximation schemes to the optimal DP, such as the stack decoding algorithm
 can be employed. Using similar methods it is also possible to correct errors
when insertions and deletions of symbols occur as well.
We tested the algorithm by taking a text from Jenesis and corrupting it in two ways. First,
we altered every letter (including blanks) with probability 0.2. In the second test we altered
D. RON, Y. SINGER AND N. TISHBY
every letter with probability 0.1 and we also changed each blank character, in order to test
whether the resulting model is powerful enough to cope with non-uniform noise. The result
of the correction algorithm for both cases as well as the original and corrupted texts are
depicted in Figure 4.
Original Text:
and god called the dry land earth and the gathering together of the waters called he seas and
god saw that it was good and god said let the earth bring forth grass the herb yielding seed
and the fruit tree yielding fruit after his kind
Corrupted text (1):
and god cavsed the drxjland earth ibd shg gathervng together oj the waters cflled re seas
aed god saw thctpit was good ann god said let tae earth bring forth gjasb tse hemb yielpinl
peed and thesfruit tree sielxing fzuitnafter his kind
Corrected text (1):
and god caused the dry land earth and she gathering together of the waters called he sees
and god saw that it was good and god said let the earth bring forth grass the memb yielding
peed and the fruit tree fielding fruit after his kind
Corrupted text (2):
andhgodpcilledjthesdryj landbeasthcandmthelgatceringhlogetherj fytrezaatersoczlled
xherseasaknddgodbsawwthathitqwasoqoohanwzgodcsaidhletdtheuejrthriringmforth
hbgrasstthexherbyieldingzseedmazdctcybfruitttreeayieldinglfruztbafherihiskind
Corrected text (2):
and god called the dry land earth and the gathering together of the altars called he seasaked
god saw that it was took and god said let the earthriring forth grass the herb yielding seed
and thy fruit treescielding fruit after his kind
Figure 4. Correcting corrupted text.
We compared the performance of the PSA we constructed to the performance of Markov
chains of order 0 - 3. The performance is measured by the negative log-likelihood obtained
by the various models on the (uncorrupted) test data, normalized per observation symbol.
The negative log-likelihood measures the amount of 'statistical surprise' induced by the
model. The results are summarized in Table 1. The first four entries correspond to the
Markov chains of order 0 - 3, and the last entry corresponds to the PSA. The order of
the PSA is defined to be lOgl~l(IQI). These empirical results imply that using a PSA of
reasonable size, we get a better model of the data than if we had used a much larger full
order Markov chain.
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
Table 1. Comparison of full order Markov chains versus a PSA (a Markov
model with variable memory).
Fixed Order Markov
Model Order
Number of States
Negative Log-Likelihood
0.853 0.681 0.560 0.555
Building A Simple Model for E.coli DNA
The DNA alphabet is composed of four nucleotides denoted by: A, c, w, G. DNA strands are
composed of sequences of protein coding genes and fillers between those regions named
intergenic regions. Locating the coding genes is necessary, prior to any further DNA
analysis. Using manually segmented data of E. coli we built two different
PSAs, one for the coding regions and one for the intergenic regions. We disregarded the
internal (triplet) structure of the coding genes and the existence of start and stop codons
at the beginning and the end of those regions. The models were constructed based on
250 different DNA strands from each type, their lengths ranging from 20 bases to several
thousands. The PSAs built are rather small compared to the HMM model described in
 : the PSA that models the coding regions has 65 states and
the PSA that models the intergenic regions has 81 states.
We tested the performance of the models by calculating the log-likelihood of the two
models obtained on test data drawn from intergenic regions. In 90% of the cases the
log-likelihood obtained by the PSA trained on intergenic regions was higher than the log-
likelihood of the PSA trained on the coding regions. Misclassifications (when the log-
likelihood obtained by the second model was higher) occurred only for sequences shorter
than 100 bases. Moreover, the log-likelihood difference between the models scales linearly
with the sequence length where the slope is close to the KL-divergence between the Markov
models (which can be computed from the parameters of the two PSAs), as depicted in
Figure 5. The main advantage of PSA models is in their simplicity. Moreover, the log-
likelihood of a set of substrings of a given strand can be computed in time linear in the
number of substrings. The latter property combined with the results mentioned above
indicate that the PSA model might be used when performing tasks such as DNA gene
locating. However, we should stress that we have done only a preliminary step in this
direction and the results obtained in as part of a complete
parsing system are better.
Acknowledgments
We would like to thank Anders Krogh and David Haussler for letting us use their E. coli
DNA data and for helpful discussions. Special thanks to Kenn Rudd for supplying the E.
coli sequences used in the DNA experiments. We also would like to thank Ronitt Rubinfeld
and Yoav Freund for their helpful comments. Thanks to Lee Giles for providing us with the
software for plotting finite state machines. This research has been supported in part by a
grant from the Israeli Ministry of Science and Arts and by the Bruno Goldberg endowment
D. RON, Y. SINGER AND N. TtSHBY
Sequence Length
Figure 5. The difference between the log-likelihood induced by a PSA trained on data taken from intergenic
regions and a PSA trained on data taken from coding regions. The test data was taken from intergenic regions. In
90% of the cases the likelihood of the first PSA was higher.
fund. Dana Ron would like to thank the support of the Eshkol fellowship. Yoram Singer
would like to thank the Clore Foundation for its support.
Appendix A
Proof of Theorem I
Theorem 1 For every L-PSA M = (Q, E, ~-, % 7r), there exists an equivalent PST TM, of
maximal depth L and at most L . IQ[ nodes.
Proof: Let TM be the tree whose leaves correspond to the strings in Q (the states of M).
For each leaf s, and for every symbol or, let %(~r) = "y(s, ~r). This ensures that for every
string which is a suffix extension of some leaf in TM, both M and TM generate the next
symbol with the same probability. The remainder of this proof is hence dedicated to defining
the next symbol probability functions for the internal nodes of TM. These functions must
be defined so that TM generates all strings related to nodes in TM, with the same probability
For each node s in the tree, let the weight of s, denoted by w~, be defined as follows
s' EQ ~.t. sESuffix*(s')
In other words, the weight of a leaf in TM is the stationary probability of the corresponding
state in M; and the weight of an internal node labeled by a string s, equals the sum of the
stationary probabilities over all states of which s is a suffix. Note that the weight of any
internal node is the sum of the weights of all the leaves in its subtree, and in particular
We = 1. Using the weights of the nodes we assign values to the 7s's of the internal nodes
s in the tree in the following manner. For every symbol a let
~'~Q ..... es~yfi~* (~')
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
According to the definition of the weights of the nodes, it is clear that for every node s,
% (.) is in fact a probability function on the next Output symbol as required in the definition
of prediction suffix trees.
What is the probability that M generates a string s which is a node in TM (a suffix of a state
in Q)? By definition of the transition function of M, for every s o E Q, if s ~ = "r(s °, s), then
s' must be a suffix extension of s. Thus PM (s) is the sum over all such s ~ of the probability
of reaching s ~, when s o is chosen according to the initial distribution 7r(.) on the starting
states. But if the initial distribution is stationary then at any point the probability of being
at state s ~ is just 7r(s~), and
s' E Q s.~. s E Suyfix* ( s' )
We next prove that PTM (s) equals w~ as well. We do this by showing that for every
s = sl... st in the tree, where Isl >_ 1, ws = w~fi~(~)-~<~)(s~).
Since We = 1, it
follows from a simple inductive argument that PTM (S) = W,.
By our definition of PSAs, re(-) is such that for every s E Q, s = sl ... sz,
s ~ sX ~-(#,st)=s
Hence, if s is a leaf in TM then
s' EI:(TM ) s.t. sE Suffix*(s' sl)
Ws'~[#(Sl)
s'E£(TM(prefi~c(s) ) )
(c) WprCx(s)~pr~fi~(s)(sz)
where (a) follows by substituting ws, for ~r(s') and %, (sl) for ~,(s ~, sl) in Equation (A.4),
and by the definition of T (.,.); (b) follows from our definition of the structure of prediction
suffix trees; and (c) follows from our definition of the weights of internal nodes. Hence, if
s is a leaf, ws = wpreJ~(~)'~pr~J~x(~)(st) as required.
If s is an internal node then using the result above and Equation (A.2) we get that
s'EL(TM(~))
wp,-~s~(s')"/p,-e~(~') (s~)
s'~Z:(T~,~ (s))
= wp~j~(~)%~fix(~)(sl) .
It is left to show that the resulting tree is not bigger than L times the number of states
in M. The number of leaves in TM equals the number of states in M, i.e. IZ:(T)[ = IQ]-
If every internal node in T M is of full degree (i.e.
the probability T M generates any
D. RON, Y. SINGER AND N. TISHBY
string labeling a leaf in the tree is strictly greater than 0) then the number of internal
nodes is bounded by IQI and the total number of nodes is at most 2162 I. In particular,
the above is true when for every state s in M, and every symbol a, 7(s, a) > 0. If
this is not the case then we can simply bound the total number of nodes by L • IQI-
Appendix B
Emulation of PSTs by PFAs
In this section we show that for every PST there exists an equivalent PFA which is not much
larger and which is a slight variant of a PSA. Furthermore, if the PST has a certain property,
defined below and denoted by Property,, then it can be emulated by a PSA.
Property* For every string s labeling a node in the tree, T,
Before we state our theorem, we observe that Property, implies that for every string r,
This is true for the following simple reasoning. If r is a node in T, then Equality (B.1) is
equivalent to Property,. Otherwise let r = rlr2, where rl is the longest prefix of r which
is a leaf in T.
PT(?') = PT(rl)" PT(r21rl)
= EpT(arl).
_PT(r2lrl)
PT(°-rl)" eT(r21crrl)
where Equality (B.2c) follows from the definition of PST's.
THEOREM 3 For every PST, T, of depth L over E there exists an equivalent PFA, MT, with
at most L . [£(T)[ states. Furthermore, if Property. holds for T, then it has an equivalent
Proof: In the proof of Theorem 1, we were given a PSA M and we defined the equivalent
suffix tree TM to be the tree whose leaves correspond to the states of the automaton. Thus,
given a suffix tree T, the natural dual procedure would be to construct a PSA MT whose
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
states correspond to the leaves of T. The first problem with this construction is that we
might not be able to define the transition function r on all pairs of states and symbols. That
is, there might exist a state s and a symbol ~r such that there is no state s' which is a suffix
of s~r. The solution is to extend T to a larger tree T' (of which T is a subtree) such that ~- is
well defined on the leaves of T'. It can easily be verified that the following is an equivalent
requirement on T': for each symbol or, and for every leaf s in T', s~r is either a leaf in the
subtree T'(c 0 rooted at o-, or is a suffix extension of a leaf in T'(o-). In this case we shall
say that T' covers each of its children's subtrees. Viewing this in another way, for every
leaf s, the longest prefix of s must be either a leaf or an internal node in T'. We thus obtain
T' by adding nodes to T until the above property holds.
The next symbol probability functions of the nodes in T' are defined as follows. For every
node s in T f3 T' and for every cr C E, let 7" (a) = % (~r). For each new node s' = sl... s~
in T' - T, let "7's, (c0 = % (cr), where s is the longest suffix of s' in T (i.e. the deepest
ancestor of s' in T). The probability distribution generated by T' is hence equivalent to
that generated by T. From Equality (]3.1) it directly follows that if Property. holds for T,
then it holds for T' as well.
Based on T' we now define MT = (Q, E, % 7, 7r). If Property. holds for T, then we
define MT as follows. Let the states of MT be the leaves of T' and let the transition function
be defined as usual for PSAs (i.e. for every state s and symbol or, r(s, or) is the unique suffix
of sc~.) Note that the number of states in Mr is at most L times the number of leaves in T,
as required. This is true since for each original leaf in the tree T, at most L - 1 prefixes
might be added to T'. For each s E Q and for every ~ E E, let 7(s, o) = "/s(~r), and let
7r(s) = PT(s). It should be noted that MT is not necessarily ergodic. It follows from this
construction that for every string r which is a suffix extension of a leaf in T', and every
symbol or, PM.~ (air) = PT(Cr]r). It remains to show that for every string r which is a node
in T', PMT(r) = PT,(r) (= PT(r)). For a state s E Q, let P~r(r) denote the probability
that r is generated assuming we start at state s. Then,
= ~ 7r(S)PM~(rls)
where Equality (B.3b) follows from the definition of PSAs, Equality (B.3c) follows from our
definition of 7r (-), and Equality (I3.3e) follows from a series of applications of Equality (B. 1).
If T does not have Property,, then we may not be able to define an initial distribution on the
states of the PSA MT such that for every string r which is a node in T', PMr (r) = PT, (r).
We thus define a slight variant of MT as follows. Let the states of MT be the leaves of T'
and all their prefixes, and let r(., .) be defined as follows: for every state s and symbol or,
D. I~ON, Y. SINGER AND N. TISHBY
T(s, a) is the longest suffix of scr. Thus, MT has the structure of a prefix tree combined
with a PSA. If we define 7(', ") as above, and let the empty string, e, be the single starting
state (i.e., 7r(e) = 1), then, by definition, MT is equivalent to T.
An illustration of the constructions described above is given in Figure B. 1.
~tae ..............
ID I .................
~JB ~g ~ ~*t~w
Figure B.1. Left: A Prediction suffix tree. The prediction probabilities of the symbols '0' and '1', respectively,
are depicted beside the nodes, in parentheses. Right: The PFA that is equivalent to the PST on the left. Bold edges
denote transitions with the symbol ' l' and dashed edges denote transitions with '0'. Since Property* holds for the
PST, then it actually has an equivalent PSA which is defined by the circled part of the PFA. The initial probability
distribution of this PSA is: 7r(01) = 3/11, 7r(00) = 2/11, 7r(ll) = 3/11, 7r(010) = 3/22, 7r(110) = 3/'22.
Note that states 'zl' and '0z' in the PSA replaced the node '1' in the tree.
Appendix C
Proofs of Lemma 1 and Lemma 2
1. There exists a polynomial m~o in L, n, [El, !~, and ½, such that the probability that a
sample of re' > m~o(L,n, [~[, 1
7, ~ ) strings each of length at least L + 1 generated
according to M is typical is at least 1 - 6.
2. There exists a polynomial mo in L, n, IEI, 1 1
-2, -g, and 1/(1 - A2(UM)), such that
the probability that a single sample string of length m > too(L, n, 121, 1
A2(UM))) generated according to M is typical is at least i - ~5.
Before proving the lemma we would like to recall that the parameters Co, q, e2,
and "Tm~n, are all polynomial functions of l/e, n, L, and IEI, and were defined in Section 5.
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
Several sample strings
We start with obtaining a lower bound for m', so that the first
property of a typical sample holds. Since the sample strings are generated independently,
we may view P(s), for a given state s, as the average value of m r independent random
variables. Each of these variables is in the range and its expected value is zc(s). Using
Hoeffding's inequality we get that ifm ~ - 2e~-7~o>
In -~, then with probability at least I
[15(s) - 7r(s)] _< ele0. The probability that this inequality holds for every state is hence at
We would like to point out that since our only assumptions on the sample strings are that
they are generated independently, and that their length is at least L + 1, we use only the
independence between the different strings when bounding our error. We do not assume
anything about the random variables related to 15(s) when restricted to any one sample
string, other than that their expected value is 7r(s). If the strings are known to be longer,
then a more careful analysis can be applied as described subsequently for the case of a
single sample string.
We now show that for an appropriate m' the second property holds with probability at
least 1 - -~ as well. Let s be a string in E <-r. In the following lines, when we refer to
appearances of s in the sample we mean in the sense defined by t 5. That is, we count
only appearances of s which end at the Lth or greater symbol of a sample string. For
the ith appearance of s in the sample and for every symbol a, let Xi(als ) be a random
variable which is I if a appears after the ith appearance of s and 0 otherwise. If s is either
a state or a suffix extension of a state, then for every a, the random variables {Xi(~r[s)} are
independent 0/1 random variables with expected value P(cr[s). Let Ns be the total number
of times s appears in the sample, and let Nmin ----
1- 41~ln If Ns > Nmin, then
with probability at least 1 - ~, for every symbol ¢7, [15(otis) - P(~Is)[ _< 7 27,~,~- If s
is a suffix of several states s I ,..., s k, then for every symbol ~r,
(where p(,) =
Recall that el = (e27mi~)/(Sneo). If:
(1) for every state s i, ]P(s ~) - 7r(si)] <_ ~leo;
(2) for each s i satisfying zc(s i) > 2ele0, [15(~r[s i) - P(crlsi)l <_ -~ 2"Ymin for every ~r;
then 115(otis) - P(a[s)l <_ e27mi~, as required.
If the sample has the first property required of a typical sample (i.e., Vs E Q, ]15(s) -
P(s)I _< e,eo), and for every state s such that 15(s) _> ele0, N~ >_ Nmi~, then with
probability at least I - ~ the second property of a typical sample holds for all strings which
are either states or suffixes of states. If for every string s which is a suffix extension a state
such that 15(s) _> (1 - el)e0, Ns _> N,~,
then for all such strings the second property
D. RON, Y. SINGER AND N. TISHBY
holds with probability at least 1 - ~ as well. Putting together all the bounds above, if
In -~ + Nmin/(qeO), then with probability at least 1 - 6 the sample is typical.
A single sample string In this case the analysis is somewhat more involved. We view our
sample string generated according to M as a walk on the markov chain described by RM
(defined in Subsection 3). We may assume that the starting state is visible as well since its
contribution to/5(.) is negligible. We shall need the following theorem from 
which gives bounds on the convergence rate to the stationary distribution of general ergodic
Markov chains. This theorem is partially based on a work by Mihail , who
gives bounds on the convergence in terms of combinatorial properties of the chain.
Markov Chain Convergence Theorem For any state so in the Markov chain
RM, let RtM (So, .) denote the probability distribution over the states in RM, after taking a
walk of length t starting from state so. Then
< (/~2(gM))t
First note that by simply applying Markov's inequality, we get that with probability at
least 1 - ~-~, I/5(s) - 7r(s)[ < qeo, for each state s such that 7r(s) < (6eieo)/(2n). It
thus remains to obtain a lower bound on m, so that the same is true for each s such that
7r(s) _> (6q co)/(2n). We do this by bounding the variance of the random variable related
with/5(s), and applying Chebishev's Inequality.
In (n3/32~%~)
In (1/A2(UM))
We next show that for every s satisfying 7r(s) >_ (6eleo)/(2n),
]Rt~(s, s) - 7r(s)[ _<
T~ 1 o- By the theorem above and our assumption on 7r(s),
- ~(s)) 2 _<
IR~(s, s') - 7r(s')[
< (A2(UM))t°
(;~2(UM)) to
In(I/,%(UM))
Therefore, IRS(s, s)- ~(s)l _< ~1~o-
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
Intuitively, this means that for every two integers, t > to, and i < t - to, the event that s
is the (i + t0)th state passed on a walk of length t, is 'almost independent' of the event that
8 is the ith state passed on the same walk.
For a given state s, satisfying 7r(s) > (CSeleO)/(2n), let Xi be a 0/1 random variable
which is 1/ffs is the ith state on a walk of length t, and g = ~ti= 1 Xi. By our definition
of/5, in the case of a single sample string,/5(s) = Y/t, where t = m - L - 1. Clearly
E(Y/t) = 7r(s), and for every i, Var(Xi) = 7r(s) - 7r2(s). We next bound Var(Y/t).
Var(Y)=~Var(~=~X~)
i,j s.t. [i-jl<to
i,j s.t. li-Jl>_to
If we pick t to be greater than (4nto)/(&~e~)), then Vat(Y/t) < ~-ffnq%, and using
Chebishev's Inequality Pr[IY/t - 7r(s)l > qeo] < E-fin" The probability the above holds
for any s is at most -~. The analysis of the second property required of a typical sample is
identical to that described in the case of a sample consisting of many strings.
Lemma 2 If Learn-PSA is given a typical sample then:
1. For every string s in T, if P(s) > eo then %(~r) _< 1 + e/2 , where s' is the longest
suffix of s corresponding to a node in T.
2. 17 ~]_<(JEI-1).IT I.
1st Claim Assume contrary to the claim that there exists a string labeling a node s in 7 7
such that P(s) > ~0 and for some o- E E
> 1 + E/2,
where s t is the longest suffix of s in 2h. For simplicity of the presentation, let us assume
that there is a node labeled by s t in T. If this is not the case (suffiz(/) is an internal node
in 7 ~, whose son s' is missing), the analysis is very similar. If s = s' then we easily show
below that our counter assumption is false. If s' is a proper suffix of s then we prove the
following. If the counter assumption is true, then we added to 7 ~ a (not necessarily proper)
D. RON: Y. SINGER AND N. TISHBY
suffix of s which is longer than s'. This contradicts the fact that s' is the longest suffix of s
We first achieve a lower bound on the ratio between the two true next symbol probabilities,
% (a) and %, (a). According to our definition of ~, (-),
~,(~r) _> (1 -1~lTm~)P(~l~')
We analyze separately the case in which %, (~7) _> ~[min, and the case in which %, (or) <
"Ymi~. Recall that'ymin = ~/Ir~l . If%,(cr) > 3'mi,,, then
%(0) . (1 - e2)(1 - IElTm~n)
> (1+2)(1-e2)
where Inequality (C.8a) follows from our assumption that the sample is typical, Inequal-
ity (C.8b) follows from our definition of ")~,(a), and Inequality (C.8c) follows from the
counter assumption (C.6), and our choice of%~i~. Since e2 < e/12, and e < 1 then we get
If %, (~r) < 7mi~, then x/s, (or) _> %, (c~), since 5'~' (or) is defined to be at least 7mi~.
Therefore,
%,(~r----~ -
as well. If s = s t then the counter assumption (C.6) is evidently false, and we must only
address the case in which s ~ s', i.e., s ' is a proper suffix of s.
Let s = sis2..,
sl, and let s ~ be si •.. st, for some 2 < i < I. We now show that if the
counter assumption (C.6) is true, then there exists an index 1 < j < i such that sj ... sl
was added to 20. Let 2 < r < i be the first index for which % ..... z (~r) < (1 + 7e2)"/m~.
If there is no such index then let r = i. The reason we need to deal with the prior case is
clarified subsequently. In either case, since e2 < c/48, and e < 1, then
In other words
7,~...,,(~)
7~...8,(~)
7~...~,(~)
This last inequality implies that there must exist an index 1 _< j _< / - 1, for which
LEARNING PROBABILISTIC AUTOMATA WITH VARIABLE MEMORY LENGTH
~Ysj+I .... l(G)
We next show that Inequality (C.13) implies that sj... st was added to 2r. We do this by
showing that sj... st was added to 2~, that we compared P(~lsj
• • • st) to P(,,lsj+x •. • s~),
and that the ratio between these two values is at least (1 + 3ez). Since P(s) > eo then
necessarily
P(sj... st) >_ (1 - £1)(o
and sj ... st must have been added to S. Based on our choice of the index r, and since
7sj...~ (or) _> (1 + 7~2)Tmin.
Since we assume that the sample is typical,
st) _> (1 + 6e2)'Tmin > (1 + e2)frnin ,
which means that we must have compared P(alsj... st) to P(a[sj+l... st).
We now separate the case in which 7s~+~...s~(cr) < ~/min, from the case in which
7sj+~...s, ((r) > 7rnin. If 7sj+ 1...81 (o-) < "~min then
P(~lSj+l... s~) < (1 + e2)%~
Therefore,
> (1 + 6e2)Tmin > (1 + 3e2) ,
P(~lsj+l... sz) -
(1 + e2)')'m~ -
and sj... st would have been added to 2r. On the other hand, if 7sj+l...sL (cr) > 7rain, the
same would hold since
P(~lsj...st)
(1-e2)%~ .... ,(or)
/9(0"18j+1.--8l)
(1 + g2)'Ysj+l...zt(a)
(1 - ~2)(1 + 5)
(1 - ~2)(1 + 6e2)
> 1+ 3e2 ,
where Inequality C.19c follows from our choice of e2 (e2 = 4SL "
This contradicts our
initial assumption that s' is the longest suffix of s added to T.
2nd Claim:
We prove below that 2r is a subtree of T. The claim then follows directly,
since when transforming T into T, we add at most all ]E I - 1 siblings of every node in T.
D. RON, Y. SINGER AND N. TISHBY
Therefore it suffices to show that we did not add to 2P any node which is not in T. Assume
to the contrary that we add to 7 ~ a node s which is not in T. According to the algorithm,
the reason we add s to 2 ~, is that there exists a symbol cr such that/5(~r[s) _> (1 + e2)'Y,~in,
and f'(~rls)/P(cr[suffiz(s))
> 1 + 3e2, while both/5(s) and P(suJfiz(s))
are greater than
(1 - q)eo. If the sample string is typical then
P(crls) -> 7mi,, , P(aIs) < P(crls) + e27m~n _< (1 + 2)r( ls) ,
P(~rlsu~x(s))
Z P(crlsufifix(s) ) - e2~/min .
If P(crlsuflfix(s) ) >_ "ym~n then P(crlsuffiz(s) ) >_ (1 - e2)P(crlsu~cc(s) ), and thus
_> --(1+3e2)
which is greater than i since e2 < 1/3. If P(~rlsu~x(s)) < 3'm~n, since P(~ls) >_ 7m~,
then P(~ls)/P(~ls~ffiz(s)) > 1 as well. In both cases this ratio cannot be greater than 1
if s is not in the tree, contradicting our assumption.