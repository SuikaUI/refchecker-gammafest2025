Survey of Machine Learning Techniques
for Malware Analysis
Daniele Uccia,, Leonardo Aniellob, Roberto Baldonia
aResearch Center of Cyber Intelligence and Information Security, “La Sapienza” University
bCyber Security Research Group, University of Southampton
Coping with malware is getting more and more challenging, given their relentless growth in complexity and volume. One of the most common approaches
in literature is using machine learning techniques, to automatically learn models and patterns behind such complexity, and to develop technologies to keep
pace with malware evolution. This survey aims at providing an overview on
the way machine learning has been used so far in the context of malware analysis in Windows environments, i.e. for the analysis of Portable Executables. We
systematize surveyed papers according to their objectives (i.e., the expected output), what information about malware they speciﬁcally use (i.e., the features),
and what machine learning techniques they employ (i.e., what algorithm is used
to process the input and produce the output). We also outline a number of
issues and challenges, including those concerning the used datasets, and identify
the main current topical trends and how to possibly advance them. In particular, we introduce the novel concept of malware analysis economics, regarding
the study of existing trade-oﬀs among key metrics, such as analysis accuracy
and economical costs.
portable executable, malware analysis, machine learning,
benchmark, malware analysis economics
Email addresses: (Daniele Ucci), 
(Leonardo Aniello), (Roberto Baldoni)
 
November 27, 2018
 
1. Introduction
Despite the signiﬁcant improvement of cyber security mechanisms and their
continuous evolution, malware are still among the most eﬀective threats in the
cyber space. Malware analysis applies techniques from several diﬀerent ﬁelds,
such as program analysis and network analysis, for the study of malicious samples to develop a deeper understanding on several aspects, including their behaviour and how they evolve over time. Within the unceasing arms race between
malware developers and analysts, each advance in security technology is usually
promptly followed by a corresponding evasion. Part of the eﬀectiveness of novel
defensive measures depends on what properties they leverage on. For example, a
detection rule based on the MD5 hash of a known malware can be easily eluded
by applying standard techniques like obfuscation, or more advanced approaches
such as polymorphism or metamorphism. For a comprehensive review of these
techniques, refer to Ye et al. . These methods change the binary of the malware, and thus its hash, but leave its behaviour unmodiﬁed. On the other side,
developing detection rules that capture the semantics of a malicious sample is
much more diﬃcult to circumvent, because malware developers should apply
more complex modiﬁcations. A major goal of malware analysis is to capture
additional properties to be used to improve security measures and make evasion
as hard as possible. Machine learning is a natural choice to support such a
process of knowledge extraction. Indeed, many works in literature have taken
this direction, with a variety of approaches, objectives and results.
This survey aims at reviewing and systematising existing literature where
machine learning is used to support malware analysis of Windows executables,
i.e. Portable Executables (PEs). The intended audience of this survey includes
any security analysts, i.e. security-minded reverse engineer or software developer, who may beneﬁt from applying machine learning to automate part of
malware analysis operations and make the workload more tractable. Although
mobile malware represents an ever growing threat, Windows largely remains
the preferred target among all the existing platforms.
Malware analysis
techniques for PEs are slightly diﬀerent from those for Android apps because
there are signiﬁcant dissimilarities on how operating system and applications
work. As a matter of fact, literature papers on malware analysis commonly
point out what speciﬁc platform they target, so we speciﬁcally focus on works
that consider the analysis of PEs. 64 recent papers have been selected on the
basis of their bibliographic signiﬁcance, reviewed and systematised according
to a taxonomy with three fundamental dimensions: (i) the speciﬁc objective of
the analysis, (ii) what types of features extracted from PEs they consider and
(iii) what machine learning algorithms they use.
We distinguish three main
objectives: malware detection, malware similarity analysis and malware category detection. PE features have been grouped in eight types: byte sequences,
APIs/System calls, opcodes, network, ﬁle system, CPU registers, PE ﬁle characteristics and strings. Machine learning algorithms have been categorized depending on whether the learning is supervised, unsupervised or semi-supervised.
The characterisation of surveyed papers according to such taxonomy allows to
spot research directions that have not been investigated yet, such as the impact
of particular combination of features on analysis accuracy. The analysis of such
a large literature leads to single out three main issues to address. The ﬁrst
concerns overcoming modern anti-analysis techniques such as encryption. The
second regards the inaccuracy of malware behaviour modelling due to the choice
of what operations of the sample are considered for the analysis. The third is
about the obsolescence and unavailability of the datasets used in the evaluation, which aﬀect the signiﬁcance of obtained results and their reproducibility.
In this respect, we propose a few guidelines to prepare suitable benchmarks
for malware analysis through machine learning. We also identify a number of
topical trends that we consider worth to be investigated more in detail, such as
malware attribution and triage. Furthermore, we introduce the novel concept of
malware analysis economics, regarding the existing trade-oﬀs between analysis
accuracy, time and cost, which should be taken into account when designing a
malware analysis environment.
The novel contributions of this work are
• the deﬁnition of a taxonomy to synthesise the state of the art on machine
learning for malware analysis of PEs;
• a detailed comparative analysis of existing literature on that topic, structured according to the proposed taxonomy, which highlights possible new
research directions;
• the determination of present main issues and challenges on that subject,
and the proposal of high-level directions to investigate to overcome them;
• the identiﬁcation of a number of topical trends on machine learning for
malware analysis of PEs, with general guidelines on how to advance them;
• the deﬁnition of the novel concept of malware analysis economics.
The rest of the paper is structured as follows. Related work are described
in Section 2. Section 3 presents the taxonomy we propose to organise reviewed
malware analysis approaches based on machine learning, which are then characterised according to such a taxonomy in Section 4. From this characterisation,
current issues and challenges are pointed out in Section 5. Section 6 highlights
topical trends and how to advance them. Malware analysis economics is introduced in Section 7. Finally, conclusions and future works are presented in
Section 8.
2. Related Work
Other academic works have already addressed the problem of surveying contributions on the usage of machine learning techniques for malware analysis.
The survey written by Shabtai et al. is the ﬁrst one on this topic. It speciﬁcally deals with how classiﬁers are used on static features to detect malware. As
most of the other surveys mentioned in this subsection, the main diﬀerence with
our work is that our scope is wider as we target other objectives besides malware
detection, such as similarities analysis and category detection. Furthermore, a
novel contribution we provide is the idea of malware economics, which is not
mentioned by any related work. Also in , the authors provide a comparative study on papers using pattern matching to detect malware, by reporting
their advantages, disadvantages and problems. Souri and Hosseini proposes
a taxonomy of malware detection approaches based on machine learning. In
addition to consider detection only, their work diﬀers from ours because they do
not investigate what features are taken into account. LeDoux and Lakhotia 
describe how machine learning is used for malware analysis, whose end goal is
deﬁned there as “automatically detect malware as soon as possible, remove it,
and repair any damage it has done”.
Bazrafshan et al. focus on malware detection and identify three main
methods for detecting malicious software, i.e. based on signatures, behaviours
and heuristics, the latter using also machine learning techniques.
identify what classes of features are used by reviewed heuristics for malware
detection, i.e.
API calls, control ﬂow graphs, n-grams, opcodes and hybrid
features. In addition to going beyond malware detection, we propose a larger
number of feature types, which reﬂects the wider breadth of our research.
Basu et al. examine diﬀerent works relying on data mining and machine
learning techniques for the detection of malware. They identify ﬁve types of
features: API call graph, byte sequence, PE header and sections, opcode sequence frequency and kernel, i.e. system calls. In our survey we establish more
feature types, such as strings, ﬁle system and CPU registers. They also compare
surveyed papers by used features, used dataset and mining method.
Ye et al. examine diﬀerent aspects of malware detection processes, focusing on feature extraction/selection and classiﬁcation/clustering algorithms.
Also in this case, our survey looks at a larger range of papers by also including
many works on similarity analysis and category detection. They also highlight a
number of issues, mainly dealing with machine learning aspects (i.e. incremental
learning, active learning and adversarial learning). We instead look at current
issues and limitations from a distinct angle, indeed coming to a diﬀerent set of
identiﬁed problems that complement theirs. Furthermore, they outline several
trends on malware development, while we rather report on trends about machine
learning for malware analysis, again complementing their contributions.
Barriga and Yoo brieﬂy survey literature on malware detection and malware evasion techniques, to discuss how machine learning can be used by malware to bypass current detection mechanisms. Our survey focuses instead on
how machine learning can support malware analysis, even when evasion techniques are used. Gardiner and Nagaraja concentrate their survey on the
detection of command and control centres through machine learning.
3. Taxonomy of Machine Learning Techniques for Malware Analysis
This section introduces the taxonomy on how machine learning is used for
malware analysis in the reviewed papers. We identify three major dimensions
along which surveyed works can be conveniently organised. The ﬁrst one characterises the ﬁnal objective of the analysis, e.g. malware detection. The second
dimension describes the features that the analysis is based on in terms of how
they are extracted, e.g. through dynamic analysis, and what features are considered, e.g. CPU registers. Finally, the third dimension deﬁnes what type of
machine learning algorithm is used for the analysis, e.g. supervised learning.
Figure 1 shows a graphical representation of the taxonomy. The rest of this
section is structured according to the taxonomy. Subsection 3.1 describes in
details the objective dimension, features are pointed out in subsection 3.2 and
machine learning algorithms are reported in subsection 3.3.
3.1. Malware Analysis Objectives
Malware analysis, in general, demands for strong detection capabilities to
ﬁnd matches with the knowledge developed by investigating past samples. Anyway, the ﬁnal goal of searching for those matches diﬀers. For example, a malware
analyst may be speciﬁcally interested in determining whether new suspicious
samples are malicious or not, while another may be rather inspecting new malware looking for what family they likely belong to.
This subsection details
the analysis goals of the surveyed papers, organized in three main objectives:
Figure 1: Taxonomy of machine learning techniques for malware analysis
malware detection (§ 3.1.1), malware similarity analysis (§ 3.1.2) and malware
category detection (§ 3.1.3).
3.1.1. Malware Detection
The most common objective in the context of malware analysis is detecting
whether a given sample is malicious. This objective is also the most important
because knowing in advance that a sample is dangerous allows to block it before
it becomes harmful. Indeed, the majority of reviewed works has this as main
goal . Depending on what machine learning technique is used,
the generated output can be provided with a conﬁdence value that can be used
by analysts to understand if a sample needs further inspection.
3.1.2. Malware Similarity Analysis
Another relevant objective is spotting similarities among malware, for example to understand how novel samples diﬀer from previous, known ones. We
ﬁnd four slightly diﬀerent versions of this objective: variants detection, families
detection, similarities detection and diﬀerences detection.
Variants Detection. Developing variants is one of the most eﬀective and cheapest strategies for an attacker to evade detection mechanisms, while reusing as
much as possible already available codes and resources. Recognizing that a sample is actually a variant of a known malware prevents such strategy to succeed,
and paves the way to understand how malware evolve over time through the
development of new variants. Also this objective has been deeply studied in
literature, and several reviewed papers target the detection of variants. Given
a malicious sample m, variants detection consists in selecting from the available knowledge base the samples that are variants of m .
Considering the huge number of malicious samples received daily from major security ﬁrms, recognising variants of already known malware is crucial to reduce
the workload for human analysts.
Families Detection. Given a malicious sample m, families detection consists in
selecting from the available knowledge base the families that m likely belongs
to . In this way, it
is possible to associate unknown samples to already known families and, by
consequence, provide an added-value information for further analyses.
Similarities Detection. Analysts can be interested in identifying the speciﬁc
similarities and diﬀerences of the binaries to analyse with respect to those already analysed. Similarities detection consists in discovering what parts and
aspects of a sample are similar to something that has been already examined
in the past. It enables to focus on what is really new, and hence to discard the
rest as it does not deserve further investigation .
Diﬀerences Detection. As a complement, also identifying what is diﬀerent from
everything else already observed in the past results worthwhile. As a matter
of fact, diﬀerences can guide towards discovering novel aspects that should be
analysed more in depth .
3.1.3. Malware Category Detection
Malware can be categorized according to their prominent behaviours and
objectives. They can be interested in spying on users’ activities and stealing
their sensitive information (i.e., spyware), encrypting documents and asking for
a ransom (i.e., ransomware), or gaining remote control of an infected machine
(i.e., remote access toolkits).
Using these categories is a coarse-grained yet
signiﬁcant way of describing malicious samples . Although
cyber security ﬁrms have not still agreed upon a standardized taxonomy of
malware categories, eﬀectively recognising the categories of a sample can add
valuable information for the analysis.
3.2. Malware Analysis Features
This subsection deals with the features of samples that are considered for
the analysis. How features are extracted from executables is reported in subsection 3.2.1, while subsection 3.2.2 details which speciﬁc features are taken into
3.2.1. Feature Extraction
The information extraction process is performed through either static or dynamic analysis, or a combination of both, while examination and correlation are
carried out by using machine learning techniques. Approaches based on static
analysis look at the content of samples without requiring their execution, while
dynamic analysis works by running samples to examine their behaviour. Several
techniques can be used for dynamic malware analysis. Debuggers are used for
instruction level analysis. Simulators model and show a behaviour similar to the
environment expected by the malware, while emulators replicate the behaviour
of a system with higher accuracy but require more resources. Sandboxes are virtualised operating systems providing an isolated and reliable environment where
to detonate malware. Refer to Ye et al. for a more detailed description of
these techniques. Execution traces are commonly used to extract features when
dynamic analysis is employed. Reviewed articles generate execution traces by
using either sandboxes or emulators . Also program analysis tools and techniques can be useful in
the feature extraction process by providing, for example, disassembly code and
control- and data-ﬂow graphs. An accurate disassembly code is important for
obtaining correct Byte sequences and Opcodes features (§ 3.2.2), while controland data-ﬂow graphs can be employed in the extraction of API and System
Calls (§ 3.2.2). For an extensive dissertation on dynamic analyses, refer to .
Among reviewed works, the majority relies on dynamic analyses , while the
others use, in equal proportions, either static analyses alone or a
combination of static and dynamic techniques .
Depending on the speciﬁc features, extraction processes can be performed by
applying either static, dynamic, or hybrid analysis.
3.2.2. Portable Executable Features
This section provides an overview on what features are used by reviewed
papers to achieve the objectives outlined in section 3.1. In many cases, surveyed
works only refer to macro-classes without mentioning the speciﬁc features they
employed. As an example, when n-grams are used, only a minority of works
mention the size of n.
Byte Sequences. A binary can be characterised by computing features on its
byte-level content. Analysing the speciﬁc sequences of bytes in a PE is a widely
employed static technique. A few works use chunks of bytes of speciﬁc sizes , while many others rely on n-grams .
An n-gram is a sequence of n bytes, and features correspond to the diﬀerent
combination of these n bytes, namely each feature represents how many times
a speciﬁc combination of n bytes occurs in the binary. The majority of works
that speciﬁed the size of used n-grams relies on sequences no longer than 3 (i.e.
trigrams) . Indeed, the number of features to
consider grows exponentially with n.
Opcodes. Opcodes identify the machine-level operations executed by a PE, and
can be extracted through static analyses by examining the assembly code . Opcode frequency is one
of the most commonly used feature.
It measures the number of times each
speciﬁc opcode appears within the assembly or is executed by a PE .
Others count opcode occurrences by aggregating them by operation
type, e.g., mathematical instructions, memory access instructions. Similarly to
n-grams, also sequences of opcodes are used as features .
API and System Calls. Similarly to opcodes, APIs and system calls enable the
analysis of samples’ behaviour, but at a higher level. They can be either extracted statically or dynamically by analysing the disassembly code (to get the
list of all calls that can be potentially executed) or the execution traces (for the
list of calls actually invoked). While APIs allow to characterise what actions
are executed by a sample , looking at system call
invocations provides a view on the interaction of the PE with the operating system . Data extracted by observing
APIs and system calls can be really large, and many works carry out additional
processing to reduce feature space by using convenient data structures. One of
the most popular data structures to represent PE behaviour and extract program structure is the control ﬂow graph. This data structure allows compilers
to produce an optimized version of the program itself and model control ﬂow relationships . Several works employ control ﬂow graphs and their extensions
for sample analysis, in combination with other feature classes .
Network Activity. A huge number of key information can be obtained by observing how the PE interacts with the network.
Contacted addresses and
generated traﬃc can unveil valuable aspects, e.g. regarding the communication with a command and control centre. Relevant features include statistics
on used protocols, TCP/UDP ports, HTTP requests, DNS-level interactions.
Many surveyed works require dynamic analysis to extract this kind of information . Other papers extract network-related
inputs by monitoring the network and analysing incoming and outgoing traf-
ﬁc . A complementary approach consists in analysing download patterns of network users in a monitored network . It does not require sample
execution and focuses on network features related to the download of a sample,
such as the website from which the ﬁle has been downloaded.
File System. What ﬁle operations are executed by samples is fundamental to
grasp evidence about the interaction with the environment and possibly detect
attempts to gain persistence. Features of interest mainly concern how many
ﬁles are read or modiﬁed, what types of ﬁles and in what directories, and which
ﬁles appear in not-infected/infected machines .
Sandboxes and memory analysis toolkits include modules for monitoring interactions with the ﬁle system, usually modelled by counting the number of ﬁles
created/deleted/modiﬁed by the PE. In , the size of these ﬁles is considered
as well, while Lin et al. leverage the number of created hidden ﬁles .
A particularly relevant type of ﬁle system features are those extracted from
the Windows Registry. The registry is one of the main sources of information
for a PE about the environment, and also represents a fundamental tool to
hook into the operating system, for example to gain persistence. Discovering
what keys are queried, created, deleted and modiﬁed can shed light on many
signiﬁcant characteristics of a sample . Usually, works relying on
ﬁle system inputs monitor also the Windows Registry.
CPU Registers. The way CPU registers are used can also be a valuable indication, including whether any hidden register is used, and what values are stored
in the registers, especially in the FLAGS register .
PE ﬁle characteristics. A static analysis of a PE can provide a large set of
valuable information such as sections, imports, symbols, used compilers .
Strings. A PE can be statically inspected to explicitly look for the strings it
contains, such as code fragments, author signatures, ﬁle names, system resource
information .
3.3. Malware Analysis Algorithms
This subsection reports what machine learning algorithms are used in surveyed works by organising them on the basis of whether the learning is supervised (§ 3.3.1), unsupervised (§ 3.3.2) or semi-supervised (§ 3.3.3).
3.3.1. Supervised Learning
Supervised learning is the task of gaining knowledge by providing statistical models with correct instance examples, during a preliminary phase called
The supervised algorithms used by reviewed papers are rule-based
classiﬁer , Bayes classiﬁer ,
Na¨ıve Bayes , Bayesian Network , Support Vector Machine (SVM) , Multiple Kernel Learning , Prototype-based Classi-
ﬁcation , Decision Tree ,
Random Forest , Gradient Boosting Decision Tree , Logistic Model Tree , k-Nearest Neighbors
(k-NN) , Artiﬁcial Neural Network ,
Multilayer Perceptron Neural Network .
3.3.2. Unsupervised Learning
Unsupervised approaches do not rely on any training phase and learn directly from unlabeled data. Reviewed papers use these unsupervised learning
algorithms: Clustering with locality sensitive hashing , Clustering with
Distance and Similarity Metrics (using either Euclidean or Hamming
distances , or cosine or Jaccard similarities ), Expectation Maximization , k-Means Clustering , k-Medoids , Density-based Spa-
tial Clustering of Applications with Noise , Hierarchical Clustering ,
Prototype-based Clustering , Self-Organizing Maps .
3.3.3. Semi-supervised Learning
Semi-supervised learning combines both labeled and unlabeled data for feeding statistical models to acquire knowledge.
Learning with Local and Global
Consistency is used in while Belief Propagation in .
4. Characterization of Surveyed Papers
In this section we characterize each reviewed paper on the basis of analysis
objective, used machine learning algorithm and features. Several details are
also reported on the dataset used for the evaluation, including whether it is
publicly available (Public column), where samples have been collected from
(Source column) and whether the speciﬁc set of samples considered for the
experiment is available (Available column). Indeed, many works declare they do
not use all the executables in the dataset but they do not specify what samples
they choose, which prevents to reproduce their results. The Label column states
how samples have been labelled. Finally, Benign, Malicious and Total columns
report benign executables count, malware count and their sum, respectively.
Malware detection.
Table 1 lists all the reviewed works having malware
detection as objective. Most used features are byte sequences and API/system
call invocations, derived by executing the samples. Most of the works use more
than one algorithm to ﬁnd out the one guaranteeing more accurate results.
Malware similarity analysis. A table is provided for each version of this
objective (§ 3.1.2). Tables 2 and 3 describe the works dealing with variants
detection and families detection, respectively. For both, APIs and system calls
are largely used, as well as malware interactions with the environment, i.e.
memory, ﬁle system, and CPU registers.
Tables 4 and 5 report the papers
on similarities and diﬀerences detection, respectively. All the analysed papers
but rely on APIs and system calls collection. Works on diﬀerences detection,
in general, do not take into account the interactions with the hosting system,
while those on similarities detection do.
Malware category detection. These articles focus on the identiﬁcation of
speciﬁc threats and, thus, on particular features such as byte sequences, opcodes,
function lengths and network activity. Table 6 reports the works whose objective
is the detection of malware category.
By reasoning on what algorithms and features have been used and what
have not for speciﬁc objectives, the provided characterisation allows to easily
identify gaps in the literature and, thus, possible research directions to investigate. For instance, all works on diﬀerences detection (see Table 5) but ,
rely on dynamically extracted APIs and system calls for building their machine
learning models. Novel approaches can be explored by taking into account other
features that capture malware interactions with the environment (e.g., memory,
ﬁle system, CPU registers and Windows Registry).
Table 1: Characterization of surveyed papers having malware detection as objective.
Algorithms
Limitations
Dataset samples
Schultz et al 
Rule-based
classifier,
Na¨ıve Bayes
Proposed solutions are not effective
executables and the dataset used in the
evaluations is small.
Kolter and
Maloof 
Bayes, SVM
Byte sequences
classification
obfuscation
and the dataset used in the evaluations is very small.
VX Heavens,
Ahmed et al. 
Bayes, SVM
APIs/System calls
The dataset used in the experimental evaluations is very small.
Legitimate apps
VX Heavens
Chau et al. 
Belief propagation
File system
Rare and new files cannot be accurately
classified
malicious.
Symantec’s
Firdausi et al. 
Multilayer
Perceptron
Neural Network
APIs/System calls, file
The dataset used in the experimental evaluations is very small.
Anderson et al. 
APIs/system calls
The dataset used in the evaluations is small.
Santos et al. 
and Global Consistency
Byte sequences
Proposed approach is not effective against packed malware and
requires manual labeling of a portion of the small dataset. In particular, the dataset used in the
experimental evaluations is small.
VX Heavens
Anderson et al. 
Multiple Kernel Learning
sequences,
opcodes, and APIs/system
Instruction categorization is not
Yonts 
Rule-based classifier
PE file characteristics
Only a subset of all the potential
low level attributes is considered.
25.65 · 105
Continue on the next page
Table 1: Characterization of surveyed papers having malware detection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Eskandari et al. 
Bayesian Network
APIs/System calls
Ignore specific instructions. Evasion/obfuscation techniques and
interactions reduce the effectiveness of
dataset is small.
Laboratory at
University
Santos et al. 
Bayesian Network, Decision Tree, k-NN, SVM
APIs/system
calls, and raised exceptions
techniques,
user interactions reduce the accuracy of the proposed solution.
The dataset is small.
VX Heavens
Vadrevu et al. 
Random Forest
characteristics
and network
Requires a huge number of samples labeled either as malicious or
Institute of
Technology
Bai et al. 
Decision Tree, Random
PE file characteristics
packed and malware authors can
properly modify PE header to remain undetected.
Windows and
Program Files
folders and
Kruczkowski
Szynkiewicz 
The dataset used in the experimental evaluations is small.
N6 Platform
Tamersoy et al. 
Clustering with locality
sensitive hashing
File system
Rare and new files cannot be accurately
classified
malicious.
Symantec’s
1, 663, 506
4, 970, 865
Uppal et al. 
Decision Tree, Random
APIs/system calls
The dataset used in the experimental evaluations is very small.
Legitimate apps
VX Heavens
Chen et al. 
Belief propagation
File system
Rare and new files cannot be accurately
classified
malicious.
Comodo Cloud
Security Center
Elhadi et al. 
Malicious graph matching
APIs/System calls
The dataset used in the experimental evaluations is extremely
VX Heavens
Table 1: Characterization of surveyed papers having malware detection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Feng et al. 
Rule-based
classifier,
Byte sequences
Only specific malware classes are
considered for the approach evaluation.
Windows system
files and own
AV platform
Ghiasi et al. 
Rule-based classifier
APIs/System calls and
CPU registers
APIs/System calls categorization
dataset size is small.
Windows XP
system and
Program Files
folders and
private repository
Kwon et al. 
Random Forest
rootkit capabilities.
Symantec’s
Intelligence
Environment
Mao et al. 
Random Forest
APIs/System calls, file
Evasion techniques and samples
requiring user interactions reduce
the accuracy of the proposed approach. The dataset is small.
XP SP3 and
VX Heavens
Berlin 
Neural Networks
characteristics
may be inaccurate and the accuracy of the proposed approach decreases substantially when samples are obfuscated.
Legitimate apps
and own malware
Srakaew et al. 
Decision Tree
Byte sequences and opcodes
Obfuscation
techniques
detection accuracy.
Legitimate files
and apps and
W¨uchner et al. 
Forest, SVM
sequences,
APIs/system
Windows Registry
Obfuscation
techniques
by the authors may not reflect
real-world
The dataset is small.
Legitimate app
downloads and
Nicholas 
Lempel-Ziv
Jaccard distance
Byte sequences
Obfuscation
techniques
detection accuracy.
Industry partner
Table 2: Characterization of surveyed papers having malware variants selection as objective. 1Instead of using machine learning techniques, Gharacheh
et al. rely on Hidden Markov Models to detect variants of the same malicious sample .
Algorithms
Limitations
Dataset samples
Available Labeling Benign
et al. 
Opcode sequence is not
optimal and the dataset
size is very small.
Cygwin and
VX Heavens
Ghiasi et al. 
Rule-based classi-
APIs/System
and CPU registers
APIs/System calls categorization could be not
optimal and the dataset
size is small.
Windows XP
system and
Program Files
folders and
private repository
Khodamoradi
et al. 
Random Forest
Opcode sequence is not
optimal and the dataset
size is very small.
Windows XP
system and
Program Files
folders and
self-generated
metamorphic
Upchurch and
Clustering
Byte sequences
The dataset size is extremely small.
Sampled from
Liang et al. 
Rule-based classi-
APIs/System
Windows Registry, and
API/system
call set could be not optimal
size is small.
Anubis website
Continue on the next page
Table 2: Characterization of surveyed papers having malware detection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Available Labeling Benign
Vadrevu and
Perdisci 
DBSCAN clustering
APIs/System
PE ﬁle characteristics, and network
Evasion techniques and
interactions reduce the
accuracy of the proposed
Security company
1, 651, 906 1, 651, 906
Table 3: Characterization of surveyed papers having malware families selection as objective.
2Asquith describes aggregation overlay graphs for
storing PE metadata, without further discussing any machine learning technique that could be applied on top of these new data structures.
Algorithms
Limitations
Dataset samples
Huang et al. 
k-Means-like
Byte sequences
Instruction sequence categorization could be not optimal
and the dataset size is small.
Kingsoft Corporation
Park et al. 
APIs/System calls
vulnerable
APIs/system calls injection
and the dataset used in the
experimental
evaluations
very small.
Legitimate apps and
Anubis Sandbox
Ye et al. 
k-Medoids variants
Instruction
categorization
could be not optimal.
Kingsoft Corporation
Dahl et al. 
Regression,
Neural Networks
APIs/system calls
The authors obtain a high
two-class error rate.
Mostly manual
1, 843, 359
3, 760, 844
Hu et al. 
Prototype-based
clustering
Obfuscation
techniques
effectiveness
their prototype for malware
family selection.
Continue on the next page
Table 3: Characterization of surveyed papers having malware families selection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Islam et al. 
Decision Tree, k-NN,
Strings, byte sequences
and APIs/system calls
less effective novel samples.
The dataset is small.
system, and CPU registers
Significant
differences
proposed approach accuracy.
Offensive Computing
Nari and Ghorbani 
Decision Tree
commercial
traffic analyzer. The dataset
experimental
evaluations is small.
Communication
Research Center
Ahmadi et al. 
Forest, Gradient Boosting Decision Tree
sequences,
APIs/system
registers,
and PE file characteristics
clearer view of the reasons
behind sample classification.
Microsoft’s malware
classification
Asquith 
APIs/System
PE file characteristics,
and raised exceptions
Lin et al. 
sequences,
APIs/system
Selected API/system call set
could be not optimal.
techniques
samples requiring user interactions reduce the accuracy of
the proposed approach. The
dataset is small.
Own sandbox
Continue on the next page
Table 3: Characterization of surveyed papers having malware families selection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Kawaguchi and
Omote 
Decision Tree,
Na¨ıve Bayes
APIs/System calls
This classification approach
can be easily evaded by realworld malware. The dataset
experimental
evaluations is very small.
Mohaisen et al. 
Decision Tree, k-NN,
Clustering
similarity
Hierarchical
clustering
registers, and network
techniques
the accuracy of the proposed
AMAL system
Pai et al. 
Expectation Maximization
Obfuscation
techniques
reduce the effectiveness of the
dataset is small.
Cygwin utility
files and Malicia
Nicholas 
Ziv Jaccard distance
Byte sequences
Obfuscation
techniques
reduce detection accuracy.
Industry partner
Table 4: Characterization of surveyed papers having malware similarities detection as objective. 3SVM is used only for computing the optimal values
of weight factors associated to each feature chosen to detect similarities among malicious samples.
Algorithms
Limitations
Dataset samples
Benign Malicious
Bailey et al. 
Hierarchical
clustering
normalized
compression distance
APIs/System
Windows Registry, and
Evasion techniques and
samples requiring user
interactions
classiﬁcation
method. The dataset is
Albor Malware
Library and
repository
Bayer et al. 
Clustering with locality sensitive hashing
APIs/System calls
Evasion techniques and
samples requiring user
interactions reduce the
approach accuracy.
Anubis website
Rieck et al. 
Prototype-based classiﬁcation and clustering
Byte sequences and
APIs/system calls
Evasion techniques and
samples requiring user
interactions reduce the
proposed framework.
and Sunbelt
Continue on the next page
Table 4: Characterization of surveyed papers having malware similarities detection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Benign Malicious
Palahan et al. 
Logistic Regression
APIs/System calls
Evasion techniques and
samples requiring user
interactions reduce the
proposed framework, while
unknown observed behaviors are classiﬁed as
malicious. The dataset
used in the experimental evaluations is very
Own honeypot
Egele et al. 
APIs/System
The accuracy of computed
similarities drops when
toolchains or aggressive
optimization levels are
The dataset is
coreutils-8.13
program suite
Table 5: Characterization of surveyed papers having malware diﬀerences detection as objective.
Algorithms
Limitations
Dataset samples
Benign Malicious
Bayer et al. 
Clustering with locality sensitive hashing
APIs/System calls
Evasion techniques and
samples requiring user
interactions reduce the
approach accuracy.
Anubis website
Lindorfer et al. 
Rule-based classiﬁer
APIs/System
and network
Sophisticated
techniques and samples
requiring user interactions
processes.
experimental
evaluations is small.
Rieck et al. 
Prototype-based classiﬁcation and clustering
Byte sequences and
APIs/system calls
Evasion techniques and
samples requiring user
interactions reduce the
proposed framework.
and Sunbelt
Continue on the next page
Table 5: Characterization of surveyed papers having malware diﬀerences detection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Benign Malicious
Palahan et al. 
Logistic Regression
APIs/System calls
Evasion techniques and
samples requiring user
interactions reduce the
proposed framework, while
unknown observed behaviors are classiﬁed as
malicious. The dataset
used in the experimental evaluations is small.
Own honeypot
Santos et al. 
Decision Tree, k-NN,
Random Forest
Opcode sequence is not
optimal and the dataset
size is small.
The proposed method is not effective
The dataset
Own machines
Continue on the next page
Table 5: Characterization of surveyed papers having malware diﬀerences detection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Benign Malicious
Polino et al. 
Clustering with Jaccard similarity
APIs/System calls
techniques,
samples requiring user
interactions reduce the
proposed framework.
calls sequence used to
identify sample behaviors is not optimal. The
dataset size is small.
Table 6: Characterization of surveyed papers having malware category detection as objective. 4Instead of using machine learning techniques, these
articles rely on Hidden Markov Models to detect metamorphic viruses .
Algorithms
Limitations
Dataset samples
Stamp 
Detection fails if metamorphic
similar to benign ﬁles.
The dataset is extremely
VX Heavens
generators
Table 6: Characterization of surveyed papers having malware category detection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Attaluri et al. 
The proposed approach
is not eﬀective against
all types of metamorphic
viruses. The dataset size
is very small.
legitimate
VX Heavens
generators
Tian et al. 
Rule-based classi-
Function length
are not suﬃcient to detect
dataset used in the experimental evaluations is
very small.
Siddiqui et al. 
Random Forest
Advanced packing techniques could reduce detection accuracy.
dataset used in the experimental evaluations is
Windows XP
VX Heavens
Chen et al. 
Byte sequences
The proposed framework
security companies’ encyclopedias.
Trend Micro
Continue on the next page
Table 6: Characterization of surveyed papers having malware category detection as objective. (Continued)
Algorithms
Limitations
Dataset samples
Comar et al. 
Network features are extracted by a commercial
traﬃc analyzer.
Internet Service
Manual and
Kwon et al. 
Random Forest
Not able to detect bots
with rootkit capabilities.
Symantec’s
Intelligence
Environment
Sexton et al. 
Rule-based
classiﬁer,
Regression,
Byte sequences and
Obfuscation
techniques
The dataset used
in the experimental evaluations is small.
5. Issues and Challenges
Based on the characterization detailed in section 4, this section identiﬁes
the main issues and challenges of surveyed papers. In the speciﬁc, the main
problems regard the usage of anti-analysis techniques by malware (§ 5.1), what
operation set to consider 5.2 and used dataset 5.3.
5.1. Anti-analysis Techniques
Malware developers want to avoid their samples to be analysed, so they
devise and reﬁne several anti-analysis techniques that are eﬀective in hindering
the reverse engineering of executables. Indeed many surveyed works claim that
the solution they propose does not work or loses in accuracy when samples using
such techniques are considered (§ 4).
Static analysis (§ 3.2.1) is commonly prevented by rendering sample binary
and resources unreadable through obfuscation, packing or encryption. Anyway,
at runtime, code and any other concealed data has to be either deobfuscated,
unpacked or decrypted to enable the correct execution of the payload. This
implies that such a kind of anti-analysis techniques can be overcome by using
dynamic analysis (§ 3.2.1) to make the sample unveil hidden information and
load them in memory, where they can then be extracted by creating a dump.
Refer to Ye et al. for a detailed disquisition on how obfuscation, packing and
encryption are used by malware developers.
More advanced anti-analysis techniques exist to keep malware internals secret even when dynamic analysis is used. One approach, commonly referred to
as environmental awareness, consists in the malware trying to detect whether
it is being executed in a controlled setting where an analyst is trying to dissect
it, for example by using a virtual machine or by running the sample in debug
mode. If any cue is found of possibly being under analysis, then the malware
does not execute its malicious payload. Miramirkhani et al. show that a
malware can easily understand if it is running into an artiﬁcial environment.
Other approaches rely on timing-based evasion, i.e. they only show their malicious behaviour at predetermined dates and times.
Other malware instead
require or wait for some user interaction to start their intended activity, in
order to make any kind of automatic analysis infeasible.
Identifying and overcoming these anti-analysis techniques is an important
direction to investigate to improve the eﬀectiveness of malware analysis. Recent academic and not-academic literature are aligned on this aspect. Karpin
and Dorfman highlight the need to address very current problems such
as discovering where malware conﬁguration ﬁles are stored and whether standard or custom obfuscation/packing/encryption algorithms are employed. Deobfuscation and other operations aimed at supporting binary reverse
engineering, such as function similarity identiﬁcation , are still very active
research directions. Symbolic execution techniques are promising means to
understand what execution paths trigger the launch of the malicious payload.
5.2. Operation Set
Opcodes, instructions, APIs and system calls (hereinafter, we refer to them
in general as operations) are the most used and powerful features employed for
malware analysis (§ 4), as they allow to directly and accurately model sample
behaviour. Normally, to reduce complexity and required computational power,
only a subset of all the available operations is considered. This choice of ignoring
part of the operations at disposal can reduce the accuracy of malware behaviour
model, which in turn reﬂects on the reliability of analysis outcomes. This issue
has been raised explicitly in some surveyed papers, including , while
others are anyway aﬀected although they do not mention it, such as .
On one hand, this challenge can be addressed by either improving or using diﬀerent machine learning techniques to achieve a more eﬀective feature
selection. On the other hand, program analysis advances can be leveraged to
enhance the accuracy of disassemblers and decompilers, indeed these tools are
known to be error-prone and are thus likely to aﬀect negatively the
whole analyses. Approaches that improve the quality of generated disassembly
and decompiled code, as in , can reduce the impact due to these errors.
5.3. Datasets
More than 72% of surveyed works use datasets with both malicious and
benign samples, while about 28% rely on datasets with malware only.
two works rely on benign datasets only , because their objectives are
identifying sample similarities and attributing the ownership of some source
codes under analysis, respectively.
Figure 2 shows the dataset sources for malicious and benign samples. It is
worth noting that most of benign datasets consists of legitimate applications
(e.g. software contained in “Program Files” or “system” folders), while most
of malware have been obtained from public repositories, security vendors and
popular sandboxed analysis services. The most popular public repository in the
examined works is VX Heavens , followed by Oﬀensive Computing and
Malicia Project . The ﬁrst two repositories are still actively maintained at
the time of writing, while Malicia Project has been permanently shut down due
to dataset ageing and lack of maintainers.
Legitimate applications
Public repositories
Security vendors
AV companies
Research Centers
Written by authors
Figure 2: Frequency histogram showing how many reviewed papers use each type of source
(e.g. public repositories, honeypot) to collect their datasets, and whether it is used to gather
malware or benign samples.
Security vendors, popular sandboxed analysis services, and AV companies
have access to a huge number of samples. Surveyed works rely on CWSandbox,
developed by ThreatTrack Security , and Anubis . As can be observed
from Figure 2, these sandboxes are mainly used for obtaining malicious samples. Internet Service Providers (ISPs), honeypots and Computer Emergency
Response Teams (CERTs) share with researchers both benign and malicious
datasets. A few works use malware developed by the authors , created
using malware toolkits such as Next Generation Virus Constrution Kit,
Virus Creation Lab, Mass Code Generator and Second Generation Virus Generator, all available on VX Heavens . A minority of analysed papers do not
mention the source of their datasets.
Among surveyed papers, a recurring issue is the size of used dataset. Many
works, including , carry out evaluations on less than 1, 000 samples.
Just 39% of reviewed studies test their approaches on a population greater than
10, 000 samples.
When both malicious and benign samples are used for the evaluation, it is
crucial to reﬂect their real distribution .
Indeed, there needs to be a huge imbalance because non-malware executables
are the overwhelming majority.
48% of surveyed works do not take care of
this aspect and use datasets that either are balanced between malware and non
malicious software or, even, have more of the former than the latter. In ,
Yonts supports his choice of using a smaller benign dataset by pointing out
that changes in standard system ﬁles and legitimate applications are little. 38%
of examined papers employ instead datasets having a proper distribution of
malware and non-malware, indeed they are either unbalanced towards benign
samples or use exclusively benign or malicious software. As an example, the
majority of surveyed papers having malware similarities detection as objective
(see Table 4) contains exclusively either malware or legitimate applications . The remaining 14% does not describe how datasets are composed.
Diﬀerently from other research ﬁelds, no reference benchmark is available for
malware analysis to compare accuracy and performance with other works. Furthermore, published results are known to be biased towards good results .
In addition, since the datasets used for evaluations are rarely shared, it is
nearly impossible to compare works.
Only two surveyed works have shared
their dataset , while a third one plans to share it in the future . It
is worth mentioning that one of the shared dataset is from 2001, hence almost
useless today. Indeed, temporal information is crucial to evaluate malware analysis results and determine whether machine learning models have become
obsolete .
Given such lack of reference datasets, we propose three desiderata for malware analysis benchmarks.
1. Benchmarks should be labeled accordingly to the speciﬁc objectives to
achieve. As an example, benchmarks for families selection should be labeled with samples’ families.
2. Benchmarks should model realistically the sample distributions of realworld scenarios, considering the objectives to attain. For example, benchmarks for malware detection should contain a set of legitimate applications
orders of magnitude greater than the number of malware samples.
3. Benchmarks should be actively maintained and updated over time with
new samples, trying to keep pace with the malware industry. Samples
should also be provided with temporal information, e.g., when they have
been spotted ﬁrst.
Datasets used in and are correctly labeled according to malware detection and malware variants selection objectives, respectively. Both datasets
are not balanced. In Shultz et al. , the described dataset is biased towards
malicious programs, while in diverse groups of variants contain a diﬀerent
number of samples, ranging from 3 to 20. Finally, analysed datasets are not
actively maintained and do not contain any temporal information (in , the
authors do not mention if such information has been included into the dataset).
6. Topical Trends
This section outlines a list of topical trends in malware analysis, i.e. topics
that are currently being investigated but have not reached the same level of
maturity of the other areas described in previous sections.
6.1. Malware Development Detection
Malware developers can use online public services like VirusTotal and
Malwr to test the eﬀectiveness of their samples in evading most common
antiviruses. Malware analysts can leverage such behaviour by querying these
online services to obtain additional information useful for the analysis, such as
submission time and how many online antiviruses classify a sample as malicious.
Graziano et al. leverage submissions to an online sandbox for identifying
cases where new samples are being tested, with the ﬁnal aim to detect novel
malware during their development process.
Surprisingly, it turned out that
samples used in infamous targeted campaigns had been submitted to public
sandboxes months or years before.
With reference to the proposed taxonomy, advances in the state of the art in
malware analysis could be obtained by analysing submissions to online malware
analysis services, to extract additional machine learning features and gather
intelligence on what next malware are likely to be.
6.2. Malware Attribution
Another aspect of interest for malware analysts is the identiﬁcation of who
developed a given sample, i.e. the attribution of a malware to a speciﬁc malicious actor. There are a number of features in a binary to support this process:
used programming language, included IP addresses and URLs, and the language
of comments and resources. Additional, recently proposed features which can
be used for attribution are the time slot when the malware communicates with
a command and control centre and what digital certiﬁcates are used . Features related to the coding style can also reveal important details on developer’s
identity, at least for arguing whether diﬀerent malware have been developed
by the same person or group. In , the author’s coding style of a generic
software (i.e. not necessarily malicious) is accurately proﬁled through syntactic,
lexical, and layout features. Unfortunately, this approach requires the availability of source code, which happens only occasionally, e.g. in case of leaks and/or
public disclosures.
Malware attribution can be seen as an additional analysis objective, according to the proposed taxonomy. Progresses in this direction through machine
learning techniques are currently hindered by the lack of ground truth on malware authors, which proves to be really hard to provision. Recent approaches
leverage on public reports referring to APT groups and detailing what malware they are supposed to have developed: those reports are parsed to mine
the relationships between malicious samples and corresponding APT group authors . The state of the art in malware attribution through machine learning can be advanced by researching alternative methods to generate reliable
ground truth on malware developers, or on what malware have been developed
by the same actor.
6.3. Malware Triage
Given the huge amount of new malware that need to be analysed, a fast and
accurate prioritisation is required to identify what samples deserve more in depth
analyses. This can be decided on the basis of the level of similarity with already
known samples. If a new malware resembles very closely other binaries that
have been analysed before, then its examination is not a priority. Otherwise,
further analyses can be advised if a new malware really looks diﬀerently from
everything else observed so far. This process is referred to as malware triage
and shares some aspects with malware similarity analysis, as they both provide
key information to support malware analysis prioritisation. Anyway, they are
diﬀerent because triage requires faster results at the cost of worse accuracy,
hence diﬀerent techniques are usually employed .
Likewise attribution, triage can be considered as another malware analysis
objective.
One important challenge of malware triage is ﬁnding the proper
trade-oﬀbetween accuracy and performance, which ﬁts with the problems we
address in the context of malware analysis economics (see Section 7).
6.4. Prediction of Future Variants
Compared to malware analysts, malware developers have the advantage of
knowing current anti-malware measures and thus novel variants can be designed
accordingly. A novel trend in malware analysis is investigating the feasibility to
ﬁll that gap by predicting how future malware will look like, so as to allow analysts to update anti-malware measures ahead. Howard et al. use machine
learning techniques to model patterns in malware family evolutions and predict
future variants.
This problem can be seen as yet another objective in the malware analysis
taxonomy. It has not been investigated much yet, only a couple of works seem
to address that topic . Given its great potential to proactively identify
novel malware, and considering the opportunity to exploit existing malware
families datasets, we claim the worthiness to boost the research on malware
evolution prediction through machine learning techniques.
6.5. Other Features
This section describes features diﬀerent from those analysed in Section 3.2.2
and that have been used by just a few papers so far.
In view of advancing
the state of the art in malware analysis, additional research is required on the
eﬀectiveness of using such features to improve the accuracy of machine learning
techniques.
6.5.1. Memory Accesses
Any data of interest, such as user generated content, is temporary stored
in main memory, hence analysing how memory is accessed can reveal important information about the behaviour of an executable . Kong et al. rely
on statically trace reads and writes in main memory , while Egele et al.
dynamically trace values read from and written to stack and heap .
6.5.2. Function Length
Another characterising feature is the function length, measured as the number of bytes contained in a function. This input alone is not suﬃcient to discriminate malicious executables from benign software, indeed it is usually combined
with other features. This idea, formulated in , is adopted in , where
function length frequencies, extracted through static analysis, are used together
with other static and dynamic features.
6.5.3. Raised Exceptions
The analysis of the exceptions raised during the execution can help understanding what strategies a malware adopts to evade analysis systems .
A common trick to deceive analysts is throwing an exception to run a malicious handler, registered at the beginning of malware execution. In this way,
examining the control ﬂow becomes much more complex.
7. Malware Analysis Economics
Analysing samples through machine learning techniques requires complex
computations for extracting desired features and running chosen algorithms.
The time complexity of these computations has to be carefully taken into account to ensure they complete fast enough to keep pace with the speed new
malware are developed. Space complexity has to be considered as well, indeed
feature space can easily become excessively large (e.g., using n-grams), and also
the memory required by machine learning algorithms can grow to the point of
saturating available resources.
Time and space complexities can be either reduced to adapt to processing
and storage capacity at disposal, or they can be accommodated by supplying
more resources. In the former case, the analysis accuracy is likely to worsen,
while, in the latter, accuracy levels can be preserved at the cost of providing
more computing machines, storage and network. There exist therefore tradeoﬀs between maintaining high accuracy and performance of malware analysis
on one hand, and supplying the required equipment on the other. We refer to
the study of these trade-oﬀs as malware analysis economics, and in this section
we provide some initial qualitative discussions on this novel topic.
The time needed to analyse a sample through machine learning is mainly
spent in feature extraction and algorithm execution. While time complexity
of machine learning algorithms is widely discussed in literature, the same does
not apply for the study of feature extraction execution time. The main aspect
to take into account is whether desired features come from static or dynamic
analysis, which considerably aﬀects execution time because the former does not
require to run the samples, while the latter does.
To deepen even further this point, Table 7 reports for each feature type
whether it can be extracted through static or dynamic analysis. It is interesting
to note that certain types of features can be extracted both statically and dynamically, with signiﬁcant diﬀerences on execution time as well as on malware
analysis accuracy. Indeed, while certainly more time-consuming, dynamic analysis enables to gather features that contribute relevantly to the overall analysis
eﬀectiveness . As an example, we can consider the features derived from
API calls (see Table 7), which can be obtained both statically and dynamically.
Tools like IDA provide the list of imports used by a sample and can statically
trace what API calls are present in the sample code. Malware authors usually
hide their suspicious API calls by inserting in the source code a huge number of
legitimate APIs. By means of dynamic analysis, it is possible to obtain the list
Table 7: Type of analysis required for extracting the inputs presented in Sections 3.2.2 and 6.5:
strings, byte sequences, opcodes, APIs/system calls, ﬁle system, CPU registers, PE ﬁle characteristics, network, AV/Sandbox submissions, code stylometry, memory accesses, function
length, and raised exceptions.
of the APIs that the sample has actually invoked, thus simplifying the identiﬁcation of those suspicious APIs. By consequences, in this case dynamic analysis
is likely to generate more valuable features compared to static analysis. Maze-
Walker is a typical example of how dynamic information can integrate
static analysis.
Although choosing dynamic analysis over, or in addition to, static seems obvious, its inherently higher time complexity constitutes a potential performance
bottleneck for the whole malware analysis process, which can undermine the
possibility to keep pace with malware evolution speed. The natural solution is
to provision more computational resources to parallelise analysis tasks and thus
remove bottlenecks. In turn, such solution has a cost to be taken into account
when designing a malware analysis environment, such as the one presented by
Laurenza et al. .
The qualitative trade-oﬀs we have identiﬁed are between accuracy and time
complexity (i.e., higher accuracy requires larger times), between time complexity
and analysis pace (i.e., larger times implies slower pace), between analysis pace
and computational resources (faster analysis demands using more resources),
and between computational resources and economic cost (obviously, additional
equipment has a cost). Similar trade-oﬀs also hold for space complexity. As an
example, when using n-grams as features, it has been shown that larger values
of n lead to more accurate analysis, at cost of having the feature space grow
exponentially with n . As another example, using larger datasets in general enables more accurate machine learning models and thus better accuracy,
provided the availability of enough space to store all the samples of the dataset
and the related analysis reports.
Table 8: Relationship between n and number of features.
feature count
accuracy (%)
execution time (ms)
n-grams size
execution time
target accuracy
Figure 3: Relationship between execution time (in logarithmic scale) and detection accuracy
as n varies. The target accuracy of 86% is also reported.
We present a qualitative, simpliﬁed example of analysis that leverages on the
trade-oﬀs just introduced. The scenario we target regards detecting malware
families of new malicious samples (§ 3.1.2) using as features n-grams computed
over invoked APIs (§ 3.2.2), recorded through dynamic analysis (§ 3.2.1). We
want here to explore the trade-oﬀs between family detection accuracy, execution
time, analysis pace and cost, in terms of required computational resources. For
what concerns the scenario and qualitative numbers on the relationships between
n, the number of features, accuracy and execution time, we take inspiration
from the experimental evaluation presented by Lin et al. . Table 8 shows
the relationship between n and feature count. We introduce a few simplifying
assumptions and constraints to make this qualitative example as consistent as
possible. We assume that the algorithm used to detect families is parallelisable
and ideally scalable, meaning that by doubling available machines we also double
the throughput, i.e. the number of malware analysed per second. We want to
process one million malware per day with an accuracy of at least 86%.
Figure 3 highlights the trade-oﬀbetween execution time (in logarithmic
scale) and detection accuracy as n is varied.
As n grows, the accuracy in-
malware throughput (malware per day)
machine count
malware load
Figure 4: Relationship between machine count and malware throughput (in logarithmic scale)
for diﬀerent n-grams sizes. The one million malware per day to sustain is also reported.
creases almost linearly while the execution time has an exponential rise, which
translates to an exponential decrease of how many malware per second can be
processed. It can be noted that the minimum n-grams size to meet the accuracy
requirement of 86% is 3. The trade-oﬀbetween analysis pace and cost can be
observed in Figure 4 where, by leveraging on the assumption of ideal scalability
of the detection algorithm, it is shown that sustainable malware throughput (in
logarithmic scale) increases linearly as the algorithm is parallelised on more machines. 4-grams and 5-grams cannot be used to cope with the expected malware
load of one million per day, at least when considering up to ﬁve machines. On
the other hand, by using four machines and 3-grams, we can sustain the target
load and at the same time meet the constraint on detection accuracy.
The presented toy example is just meant to better explain how malware
analysis economics can be used in practical scenarios. We claim the signiﬁcance
of investigating these trade-oﬀs more in detail, with the aim of outlining proper
guidelines and strategies to design a malware analysis environment in compliance with requirements on analysis accuracy and pace, while respecting budget
constraints.
8. Conclusion
We presented a survey on existing literature on malware analysis through
machine learning techniques. There are ﬁve main contributions of our work.
First, we proposed an organization of reviewed works according to three orthogonal dimensions: the objective of the analysis, the type of features extracted
from samples, the machine learning algorithms used to process these features.
Such characterization provides an overview on how machine learning algorithms
can be employed in malware analysis, emphasising which speciﬁc feature classes
allow to achieve the objective(s) of interest. Second, we have arranged existing
literature on PE malware analysis through machine learning according the proposed taxonomy, providing a detailed comparative analysis of surveyed works.
Third, we highlighted the current issues of machine learning for malware analysis: anti-analysis techniques used by malware, what operation set to consider
for the features and used datasets. Fourth, we identiﬁed topical trends on interesting objectives and features, such as malware attribution and triage. Fifth, we
introduced the novel concept of malware analysis economics, concerning the investigation and exploitation of existing trade-oﬀs between performance metrics
of malware analysis (e.g., analysis accuracy and execution time) and economical
Noteworthy research directions to investigate can be linked to those contributions. Novel combinations of objectives, features and algorithms can be
investigated to achieve better accuracy compared to the state of the art. Moreover, observing that some classes of algorithms have never been used for a certain objective may suggest novel directions to examine further. The discussion
on malware analysis issues can provide further ideas worth to be explored. In
particular, deﬁning appropriate benchmarks for malware analysis is a priority
of the whole research area. The novel concept of malware analysis economics
can encourage further research directions, where appropriate tuning strategies
can be provided to balance competing metrics (e.g. accuracy and cost) when
designing a malware analysis environment.
Acknowledgment
This work has been partially supported by a grant of the Italian Presidency
of Ministry Council and by the Laboratorio Nazionale of Cyber Security of the
CINI (Consorzio Interuniversitario Nazionale Informatica).