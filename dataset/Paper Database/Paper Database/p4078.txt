Reinforcement Learning in Robotics:
Jens Kober∗†
J. Andrew Bagnell‡
Jan Peters§¶
email: , , 
Reinforcement learning oﬀers to robotics a framework and set of tools for
the design of sophisticated and hard-to-engineer behaviors. Conversely, the
challenges of robotic problems provide both inspiration, impact, and validation for developments in reinforcement learning. The relationship between
disciplines has suﬃcient promise to be likened to that between physics and
mathematics.
In this article, we attempt to strengthen the links between
the two research communities by providing a survey of work in reinforcement
learning for behavior generation in robots. We highlight both key challenges
in robot reinforcement learning as well as notable successes. We discuss how
contributions tamed the complexity of the domain and study the role of algorithms, representations, and prior knowledge in achieving these successes.
As a result, a particular focus of our paper lies on the choice between modelbased and model-free as well as between value function-based and policy
search methods. By analyzing a simple problem in some detail we demonstrate how reinforcement learning approaches may be proﬁtably applied, and
we note throughout open questions and the tremendous potential for future
keywords: reinforcement learning, learning control, robot, survey
1 Introduction
A remarkable variety of problems in robotics may be naturally phrased as ones of reinforcement learning.
Reinforcement learning (RL) enables a robot to autonomously
∗Bielefeld University, CoR-Lab Research Institute for Cognition and Robotics, Universitätsstr.
33615 Bielefeld, Germany
†Honda Research Institute Europe, Carl-Legien-Str. 30, 63073 Oﬀenbach/Main, Germany
‡Carnegie Mellon University, Robotics Institute, 5000 Forbes Avenue, Pittsburgh, PA 15213, USA
§Max Planck Institute for Intelligent Systems, Department of Empirical Inference, Spemannstr. 38,
72076 Tübingen, Germany
¶Technische Universität Darmstadt, FB Informatik, FG Intelligent Autonomous Systems, Hochschulstr.
10, 64289 Darmstadt, Germany
(a) OBELIX robot
(b) Zebra Zero robot
(c) Autonomous helicopter
(d) Sarcos humanoid DB
Figure 1: This ﬁgure illustrates a small sample of robots with behaviors that were reinforcement learned. These cover the whole range of aerial vehicles, robotic
arms, autonomous vehicles, and humanoid robots. (a) The OBELIX robot is
a wheeled mobile robot that learned to push boxes with a value function-based approach (Picture reprint with permission of
Sridhar Mahadevan). (b) A Zebra Zero robot arm learned a peg-in-hole insertion task with a model-free policy gradient approach
(Picture reprint with permission of Rod Grupen). (c) Carnegie Mellon’s autonomous helicopter leveraged a model-based policy search approach to learn
a robust ﬂight controller . (d) The Sarcos humanoid DB learned a pole-balancing task using forward models
(Picture reprint with permission of Stefan Schaal).
discover an optimal behavior through trial-and-error interactions with its environment.
Instead of explicitly detailing the solution to a problem, in reinforcement learning the
designer of a control task provides feedback in terms of a scalar objective function that
measures the one-step performance of the robot. Figure 1 illustrates the diverse set of
robots that have learned tasks using reinforcement learning.
Consider, for example, attempting to train a robot to return a table tennis ball over
the net . In this case, the robot might make an observations of
dynamic variables specifying ball position and velocity and the internal dynamics of the
joint position and velocity. This might in fact capture well the state s of the system –
providing a complete statistic for predicting future observations. The actions a available
to the robot might be the torque sent to motors or the desired accelerations sent to
an inverse dynamics control system. A function π that generates the motor commands
(i.e., the actions) based on the incoming ball and current internal arm observations (i.e.,
Figure 2: A illustration of the inter-relations between well-studied learning problems in
the literature along axes that attempt to capture both the information and
complexity available in reward signals and the complexity of sequential interaction between learner and environment. Each problem subsumes those to the
left and below; reduction techniques provide methods whereby harder problems
(above and right) may be addressed using repeated application of algorithms
built for simpler problems. 
the state) would be called the policy.
A reinforcement learning problem is to ﬁnd a
policy that optimizes the long term sum of rewards R(s, a); a reinforcement learning
algorithm is one designed to ﬁnd such a (near)-optimal policy. The reward function in
this example could be based on the success of the hits as well as secondary criteria like
energy consumption.
1.1 Reinforcement Learning in the Context of Machine Learning
In the problem of reinforcement learning, an agent explores the space of possible strategies
and receives feedback on the outcome of the choices made. From this information, a
“good” – or ideally optimal – policy (i.e., strategy or controller) must be deduced.
Reinforcement learning may be understood by contrasting the problem with other
areas of study in machine learning.
In supervised learning , an agent is directly presented a sequence of independent examples of correct
predictions to make in diﬀerent circumstances. In imitation learning, an agent is provided
demonstrations of actions of a good strategy to follow in given situations .
To aid in understanding the RL problem and its relation with techniques widely used
within robotics, Figure 2 provides a schematic illustration of two axes of problem variability: the complexity of sequential interaction and the complexity of reward structure.
This hierarchy of problems, and the relations between them, is a complex one, varying in
manifold attributes and diﬃcult to condense to something like a simple linear ordering on
problems. Much recent work in the machine learning community has focused on understanding the diversity and the inter-relations between problem classes. The ﬁgure should
be understood in this light as providing a crude picture of the relationship between areas
of machine learning research important for robotics.
Each problem subsumes those that are both below and to the left in the sense that one
may always frame the simpler problem in terms of the more complex one; note that some
problems are not linearly ordered. In this sense, reinforcement learning subsumes much
of the scope of classical machine learning as well as contextual bandit and imitation
learning problems. Reduction algorithms are used to
convert eﬀective solutions for one class of problems into eﬀective solutions for others,
and have proven to be a key technique in machine learning.
At lower left, we ﬁnd the paradigmatic problem of supervised learning, which plays
a crucial role in applications as diverse as face detection and spam ﬁltering. In these
problems (including binary classiﬁcation and regression), a learner’s goal is to map observations (typically known as features or covariates) to actions which are usually a discrete
set of classes or a real value. These problems possess no interactive component: the
design and analysis of algorithms to address these problems rely on training and testing
instances as independent and identical distributed random variables. This rules out any
notion that a decision made by the learner will impact future observations: supervised
learning algorithms are built to operate in a world in which every decision has no eﬀect
on the future examples considered. Further, within supervised learning scenarios, during
a training phase the “correct” or preferred answer is provided to the learner, so there is
no ambiguity about action choices.
More complex reward structures are also often studied: one such is known as costsensitive learning, where each training example and each action or prediction is annotated
with a cost for making such a prediction. Learning techniques exist that reduce such
problems to the simpler classiﬁcation problem, and active research directly addresses
such problems as they are crucial in practical learning applications.
Contextual bandit or associative reinforcement learning problems begin to address
the fundamental problem of exploration-vs-exploitation, as information is provided only
about a chosen action and not what-might-have-been. These ﬁnd wide-spread application
in problems as diverse as pharmaceutical drug discovery to ad placement on the web,
and are one of the most active research areas in the ﬁeld.
Problems of imitation learning and structured prediction may be seen to vary from
supervised learning on the alternate dimension of sequential interaction.
Structured
prediction, a key technique used within computer vision and robotics, where many predictions are made in concert by leveraging inter-relations between them, may be seen
as a simpliﬁed variant of imitation learning .
In imitation learning, we assume that an expert (for example, a human pilot) that we
wish to mimic provides demonstrations of a task. While “correct answers” are provided
to the learner, complexity arises because any mistake by the learner modiﬁes the future
observations from what would have been seen had the expert chosen the controls. Such
problems provably lead to compounding errors and violate the basic assumption of independent examples required for successful supervised learning. In fact, in sharp contrast
with supervised learning problems where only a single data-set needs to be collected, repeated interaction between learner and teacher appears to both necessary and suﬃcient
 to provide performance guarantees in both theory and practice in
imitation learning problems.
Reinforcement learning embraces the full complexity of these problems by requiring
both interactive, sequential prediction as in imitation learning as well as complex reward
structures with only “bandit” style feedback on the actions actually chosen. It is this
combination that enables so many problems of relevance to robotics to be framed in these
terms; it is this same combination that makes the problem both information-theoretically
and computationally hard.
We note here brieﬂy the problem termed “Baseline Distribution RL”: this is the standard RL problem with the additional beneﬁt for the learner that it may draw initial
states from a distribution provided by an expert instead of simply an initial state chosen
by the problem. As we describe further in Section 5.1, this additional information of
which states matter dramatically aﬀects the complexity of learning.
1.2 Reinforcement Learning in the Context of Optimal Control
Reinforcement Learning (RL) is very closely related to the theory of classical optimal control, as well as dynamic programming, stochastic programming, simulation-optimization,
stochastic search, and optimal stopping . Both RL and optimal control address the problem of ﬁnding an optimal policy (often also called the controller or control
policy) that optimizes an objective function (i.e., the accumulated cost or reward), and
both rely on the notion of a system being described by an underlying set of states, controls
and a plant or model that describes transitions between states. However, optimal control
assumes perfect knowledge of the system’s description in the form of a model (i.e., a function T that describes what the next state of the robot will be given the current state and
action). For such models, optimal control ensures strong guarantees which, nevertheless,
often break down due to model and computational approximations. In contrast, reinforcement learning operates directly on measured data and rewards from interaction with
the environment. Reinforcement learning research has placed great focus on addressing
cases which are analytically intractable using approximations and data-driven techniques.
One of the most important approaches to reinforcement learning within robotics centers
on the use of classical optimal control techniques (e.g. Linear-Quadratic Regulation and
Diﬀerential Dynamic Programming) to system models learned via repeated interaction
with the environment .
A concise discussion of viewing reinforcement learning as “adaptive optimal control” is
presented in .
1.3 Reinforcement Learning in the Context of Robotics
Robotics as a reinforcement learning domain diﬀers considerably from most well-studied
reinforcement learning benchmark problems. In this article, we highlight the challenges
faced in tackling these problems. Problems in robotics are often best represented with
high-dimensional, continuous states and actions ). In robotics, it is often unrealistic to assume that the true state is completely
observable and noise-free. The learning system will not be able to know precisely in
which state it is and even vastly diﬀerent states might look very similar. Thus, robotics
reinforcement learning are often modeled as partially observed, a point we take up in
detail in our formal model description below. The learning system must hence use ﬁlters
to estimate the true state. It is often essential to maintain the information state of the
environment that not only contains the raw observations but also a notion of uncertainty
on its estimates (e.g., both the mean and the variance of a Kalman ﬁlter tracking the
ball in the robot table tennis example).
Experience on a real physical system is tedious to obtain, expensive and often hard to
reproduce. Even getting to the same initial state is impossible for the robot table tennis
system. Every single trial run, also called a roll-out, is costly and, as a result, such
applications force us to focus on diﬃculties that do not arise as frequently in classical
reinforcement learning benchmark examples. In order to learn within a reasonable time
frame, suitable approximations of state, policy, value function, and/or system dynamics
need to be introduced. However, while real-world experience is costly, it usually cannot
be replaced by learning in simulations alone.
In analytical or learned models of the
system even small modeling errors can accumulate to a substantially diﬀerent behavior,
at least for highly dynamic tasks. Hence, algorithms need to be robust with respect
to models that do not capture all the details of the real system, also referred to as
under-modeling, and to model uncertainty. Another challenge commonly faced in robot
reinforcement learning is the generation of appropriate reward functions. Rewards that
guide the learning system quickly to success are needed to cope with the cost of realworld experience. This problem is called reward shaping and represents a
substantial manual contribution. Specifying good reward functions in robotics requires
a fair amount of domain knowledge and may often be hard in practice.
Not every reinforcement learning method is equally suitable for the robotics domain. In
fact, many of the methods thus far demonstrated on diﬃcult problems have been modelbased and
robot learning systems often employ policy search methods rather than value functionbased approaches . Such design choices stand in contrast to possibly
the bulk of the early research in the machine learning community . We attempt to give a fairly complete overview on real robot
reinforcement learning citing most original papers while grouping them based on the key
insights employed to make the Robot Reinforcement Learning problem tractable. We
isolate key insights such as choosing an appropriate representation for a value function
or policy, incorporating prior knowledge, and transfer knowledge from simulations.
This paper surveys a wide variety of tasks where reinforcement learning has been
successfully applied to robotics. If a task can be phrased as an optimization problem and
exhibits temporal structure, reinforcement learning can often be proﬁtably applied to
both phrase and solve that problem. The goal of this paper is twofold. On the one hand,
we hope that this paper can provide indications for the robotics community which type
of problems can be tackled by reinforcement learning and provide pointers to approaches
that are promising. On the other hand, for the reinforcement learning community, this
paper can point out novel real-world test beds and remarkable opportunities for research
on open questions. We focus mainly on results that were obtained on physical robots
with tasks going beyond typical reinforcement learning benchmarks.
We concisely present reinforcement learning techniques in the context of robotics in
Section 2. The challenges in applying reinforcement learning in robotics are discussed in
Section 3. Diﬀerent approaches to making reinforcement learning tractable are treated in
Sections 4 to 6. In Section 7, the example of ball-in-a-cup is employed to highlight which
of the various approaches discussed in the paper have been particularly helpful to make
such a complex task tractable. Finally, in Section 8, we summarize the speciﬁc problems
and beneﬁts of reinforcement learning in robotics and provide concluding thoughts on
the problems and promise of reinforcement learning in robotics.
2 A Concise Introduction to Reinforcement Learning
In reinforcement learning, an agent tries to maximize the accumulated reward over its
life-time. In an episodic setting, where the task is restarted after each end of an episode,
the objective is to maximize the total reward per episode. If the task is on-going without
a clear beginning and end, either the average reward over the whole life-time or a discounted return (i.e., a weighted average where distant rewards have less inﬂuence) can be
optimized. In such reinforcement learning problems, the agent and its environment may
be modeled being in a state s ∈S and can perform actions a ∈A, each of which may be
members of either discrete or continuous sets and can be multi-dimensional. A state s
contains all relevant information about the current situation to predict future states (or
observables); an example would be the current position of a robot in a navigation task1.
An action a is used to control (or change) the state of the system. For example, in the
navigation task we could have the actions corresponding to torques applied to the wheels.
For every step, the agent also gets a reward R, which is a scalar value and assumed to
be a function of the state and observation. (It may equally be modeled as a random
variable that depends on only these variables.) In the navigation task, a possible reward
could be designed based on the energy costs for taken actions and rewards for reaching
targets. The goal of reinforcement learning is to ﬁnd a mapping from states to actions,
called policy π, that picks actions a in given states s maximizing the cumulative expected
reward. The policy π is either deterministic or probabilistic. The former always uses the
exact same action for a given state in the form a = π(s), the later draws a sample from
a distribution over actions when it encounters a state, i.e., a ∼π (s, a) = P (a|s). The
reinforcement learning agent needs to discover the relations between states, actions, and
rewards. Hence exploration is required which can either be directly embedded in the
policy or performed separately and only as part of the learning process.
Classical reinforcement learning approaches are based on the assumption that we have
a Markov Decision Process (MDP) consisting of the set of states S, set of actions A,
the rewards R and transition probabilities T that capture the dynamics of a system.
1When only observations but not the complete state is available, the suﬃcient statistics of the ﬁlter
can alternatively serve as state s. Such a state is often called information or belief state.
Transition probabilities (or densities in the continuous state case) T(s′, a, s) = P(s′|s, a)
describe the eﬀects of the actions on the state. Transition probabilities generalize the
notion of deterministic dynamics to allow for modeling outcomes are uncertain even
given full state. The Markov property requires that the next state s′ and the reward
only depend on the previous state s and action a , and not on
additional information about the past states or actions. In a sense, the Markov property
recapitulates the idea of state – a state if a suﬃcient statistic for predicting the future,
rendering previous observations irrelevant. In general in robotics, we may only be able
to ﬁnd some approximate notion of state.
Diﬀerent types of reward functions are commonly used, including rewards depending
only on the current state R = R(s), rewards depending on the current state and action
R = R(s, a), and rewards including the transitions R = R(s′, a, s). Most of the theoretical
guarantees only hold if the problem adheres to a Markov structure, however in practice,
many approaches work very well for many problems that do not fulﬁll this requirement.
2.1 Goals of Reinforcement Learning
The goal of reinforcement learning is to discover an optimal policy π∗that maps states
(or observations) to actions so as to maximize the expected return J, which corresponds
to the cumulative expected reward.
There are diﬀerent models of optimal behavior
 which result in diﬀerent deﬁnitions of the expected return. A
ﬁnite-horizon model only attempts to maximize the expected reward for the horizon H,
i.e., the next H (time-)steps h
This setting can also be applied to model problems where it is known how many steps
are remaining.
Alternatively, future rewards can be discounted by a discount factor γ (with 0 ≤γ < 1)
This is the setting most frequently discussed in classical reinforcement learning texts. The
parameter γ aﬀects how much the future is taken into account and needs to be tuned
manually. As illustrated in , this parameter often qualitatively
changes the form of the optimal solution. Policies designed by optimizing with small γ
are myopic and greedy, and may lead to poor performance if we actually care about longer
term rewards. It is straightforward to show that the optimal control law can be unstable
if the discount factor is too low (e.g., it is not diﬃcult to show this destabilization even
for discounted linear quadratic regulation problems). Hence, discounted formulations are
frequently inadmissible in robot control.
In the limit when γ approaches 1, the metric approaches what is known as the averagereward criterion ,
This setting has the problem that it cannot distinguish between policies that initially gain
a transient of large rewards and those that do not. This transient phase, also called preﬁx,
is dominated by the rewards obtained in the long run. If a policy accomplishes both an
optimal preﬁx as well as an optimal long-term behavior, it is called bias optimal Lewis
and Puterman . An example in robotics would be the transient phase during the
start of a rhythmic movement, where many policies will accomplish the same long-term
reward but diﬀer substantially in the transient (e.g., there are many ways of starting the
same gait in dynamic legged locomotion) allowing for room for improvement in practical
application.
In real-world domains, the shortcomings of the discounted formulation are often more
critical than those of the average reward setting as stable behavior is often more important
than a good transient . We also often encounter an episodic control
task, where the task runs only for H time-steps and then reset (potentially by human
intervention) and started over. This horizon, H, may be arbitrarily large, as long as the
expected reward over the episode can be guaranteed to converge. As such episodic tasks
are probably the most frequent ones, ﬁnite-horizon models are often the most relevant.
Two natural goals arise for the learner. In the ﬁrst, we attempt to ﬁnd an optimal
strategy at the end of a phase of training or interaction. In the second, the goal is to
maximize the reward over the whole time the robot is interacting with the world.
In contrast to supervised learning, the learner must ﬁrst discover its environment and
is not told the optimal action it needs to take. To gain information about the rewards
and the behavior of the system, the agent needs to explore by considering previously
unused actions or actions it is uncertain about. It needs to decide whether to play it safe
and stick to well known actions with (moderately) high rewards or to dare trying new
things in order to discover new strategies with an even higher reward. This problem is
commonly known as the exploration-exploitation trade-oﬀ.
In principle, reinforcement learning algorithms for Markov Decision Processes with
performance guarantees are known with polynomial scaling in the size of the state and action spaces, an
additive error term, as well as in the horizon length ). However, state spaces in
robotics problems are often tremendously large as they scale exponentially in the number
of state variables and often are continuous. This challenge of exponential growth is often
referred to as the curse of dimensionality (also discussed in Section 3.1).
Oﬀ-policy methods learn independent of the employed policy, i.e., an explorative strategy that is diﬀerent from the desired ﬁnal policy can be employed during the learning
process. On-policy methods collect sample information about the environment using the
current policy.
As a result, exploration must be built into the policy and determine
the speed of the policy improvements.
Such exploration and the performance of the
policy can result in an exploration-exploitation trade-oﬀbetween long- and short-term
improvement of the policy. Modeling exploration models with probability distributions
has surprising implications, e.g., stochastic policies have been shown to be the optimal
stationary policies for selected problems and
can even break the curse of dimensionality . Furthermore, stochastic policies
often allow the derivation of new policy update steps with surprising ease.
The agent needs to determine a correlation between actions and reward signals. An
action taken does not have to have an immediate eﬀect on the reward but can also
inﬂuence a reward in the distant future. The diﬃculty in assigning credit for rewards is
directly related to the horizon or mixing time of the problem. It also increases with the
dimensionality of the actions as not all parts of the action may contribute equally.
The classical reinforcement learning setup is a MDP where additionally to the states
S, actions A, and rewards R we also have transition probabilities T(s′, a, s). Here, the
reward is modeled as a reward function R (s, a). If both the transition probabilities and
reward function are known, this can be seen as an optimal control problem (Powell,
2.2 Reinforcement Learning in the Average Reward Setting
We focus on the average-reward model in this section. Similar derivations exist for the
ﬁnite horizon and discounted reward cases. In many instances, the average-reward case
is often more suitable in a robotic setting as we do not have to choose a discount factor
and we do not have to explicitly consider time in the derivation.
To make a policy able to be optimized by continuous optimization techniques, we write
a policy as a conditional probability distribution π (s, a) = P (a|s). Below, we consider
restricted policies that are paramertized by a vector θ. In reinforcement learning, the
policy is usually considered to be stationary and memory-less. Reinforcement learning
and optimal control aim at ﬁnding the optimal policy π∗or equivalent policy parameters
θ∗which maximize the average return J (π) = $
s,a µπ (s) π (s, a) R (s, a) where µπ is
the stationary state distribution generated by policy π acting in the environment, i.e.,
the MDP. It can be shown that such policies that map states (even
deterministically) to actions are suﬃcient to ensure optimality in this setting – a policy
needs neither to remember previous states visited, actions taken, or the particular time
step. For simplicity and to ease exposition, we assume that this distribution is unique.
Markov Decision Processes where this fails (i.e., non-ergodic processes) require more care
in analysis, but similar results exist . The transitions between states
s caused by actions a are modeled as T(s, a, s′) = P(s′|s, a). We can then frame the
control problem as an optimization of
s,aµπ (s) π (s, a) R (s, a) ,
s.t. µπ(s′)
s,aµπ (s) π (s, a) T
s,aµπ (s) π (s, a)
0, ∀s ∈S, a ∈A.
Here, Equation (2) deﬁnes stationarity of the state distributions µπ (i.e., it ensures that
it is well deﬁned) and Equation (3) ensures a proper state-action probability distribution.
This optimization problem can be tackled in two substantially diﬀerent ways . We can search the optimal solution directly in this original, primal problem
or we can optimize in the Lagrange dual formulation. Optimizing in the primal formulation is known as policy search in reinforcement learning while searching in the dual
formulation is known as a value function-based approach.
2.2.1 Value Function Approaches
Much of the reinforcement learning literature has focused on solving the optimization
problem in Equations (1-3) in its dual form 2. Using
Lagrange multipliers V π (s′) and ¯R, we can express the Lagrangian of the problem by
µπ (s) π (s, a) R (s, a)
µπ (s) π (s, a) T
µπ (s) π (s, a)
µπ (s) π (s, a)
R (s, a) +
Using the property $
s′,a′ V (s′) µπ (s′) π (s′, a′) = $
s,a V (s) µπ (s) π (s, a), we can obtain
the Karush-Kuhn-Tucker conditions by diﬀerentiating with
respect to µπ (s) π (s, a) which yields extrema at
∂µππL = R (s, a) +
−¯R −V π (s) = 0.
This statement implies that there are as many equations as the number of states multiplied by the number of actions. For each state there can be one or several optimal
actions a∗that result in the same maximal value, and, hence, can be written in terms
of the optimal action a∗as V π∗(s) = R (s, a∗) −¯R + $
s′ V π∗(s′) T (s, a∗, s′). As a∗is
generated by the same optimal policy π∗, we know the condition for the multipliers at
2For historical reasons, what we call the dual is often referred to in the literature as the primal. We
argue that problem of optimizing expected reward is the fundamental problem, and values are an
auxiliary concept.
optimality is
V ∗(s) = max
R (s, a∗) −¯R +
s, a∗, s′&
where V ∗(s) is a shorthand notation for V π∗(s). This statement is equivalent to the
Bellman Principle of Optimality 3 that states “An optimal policy has the
property that whatever the initial state and initial decision are, the remaining decisions
must constitute an optimal policy with regard to the state resulting from the ﬁrst decision.” Thus, we have to perform an optimal action a∗, and, subsequently, follow the
optimal policy π∗in order to achieve a global optimum. When evaluating Equation (4),
we realize that optimal value function V ∗(s) corresponds to the long term additional
reward, beyond the average reward ¯R, gained by starting in state s while taking optimal
actions a∗(according to the optimal policy π∗). This principle of optimality has also
been crucial in enabling the ﬁeld of optimal control .
Hence, we have a dual formulation of the original problem that serves as condition for
optimality. Many traditional reinforcement learning approaches are based on identifying (possibly approximate) solutions to this equation, and are known as value function
methods. Instead of directly learning a policy, they ﬁrst approximate the Lagrangian multipliers V ∗(s), also called the value function, and use it to reconstruct the optimal policy.
The value function V π (s) is deﬁned equivalently, however instead of always taking the
optimal action a∗, the action a is picked according to a policy π
R (s, a) −¯R +
Instead of the value function V π (s) many algorithms rely on the state-action value
function Qπ(s, a) instead, which has advantages for determining the optimal policy as
shown below. This function is deﬁned as
Qπ (s, a) = R (s, a) −¯R +
In contrast to the value function V π (s), the state-action value function Qπ (s, a) explicitly
contains the information about the eﬀects of a particular action. The optimal state-action
value function is
R (s, a) −¯R +
R (s, a) −¯R +
3This optimality principle was originally formulated for a setting with discrete time steps and continuous
states and actions but is also applicable for discrete states and actions.
It can be shown that an optimal, deterministic policy π∗(s) can be reconstructed by
always picking the action a∗in the current state that leads to the state s with the highest
value V ∗(s)
π∗(s) = arg max
R (s, a) −¯R +
If the optimal value function V ∗(s′) and the transition probabilities T (s, a, s′) for the
following states are known, determining the optimal policy is straightforward in a setting with discrete actions as an exhaustive search is possible. For continuous spaces,
determining the optimal action a∗is an optimization problem in itself. If both states
and actions are discrete, the value function and the policy may, in principle, be represented by tables and picking the appropriate action is reduced to a look-up. For large or
continuous spaces representing the value function as a table becomes intractable. Function approximation is employed to ﬁnd a lower dimensional representation that matches
the real value function as closely as possible, as discussed in Section 2.4.
state-action value function Q∗(s, a) instead of the value function V ∗(s)
π∗(s) = arg max
(Q∗(s, a)) ,
avoids having to calculate the weighted sum over the successor states, and hence no
knowledge of the transition function is required.
A wide variety of methods of value function based reinforcement learning algorithms
that attempt to estimate V ∗(s) or Q∗(s, a) have been developed and can be split mainly
into three classes: (i) dynamic programming-based optimal control approaches such as
policy iteration or value iteration, (ii) rollout-based Monte Carlo methods and (iii) temporal diﬀerence methods such as TD(λ), Q-learning, and SARSA.
Dynamic Programming-Based Methods
require a model of the transition probabilities T(s′, a, s) and the reward function R(s, a) to calculate the value function. The model
does not necessarily need to be predetermined but can also be learned from data, potentially incrementally. Such methods are called model-based. Typical methods include
policy iteration and value iteration.
Policy iteration alternates between the two phases of policy evaluation and policy
improvement. The approach is initialized with an arbitrary policy. Policy evaluation
determines the value function for the current policy. Each state is visited and its value
is updated based on the current value estimates of its successor states, the associated
transition probabilities, as well as the policy. This procedure is repeated until the value
function converges to a ﬁxed point, which corresponds to the true value function. Policy
improvement greedily selects the best action in every state according to the value function
as shown above. The two steps of policy evaluation and policy improvement are iterated
until the policy does not change any longer.
Policy iteration only updates the policy once the policy evaluation step has converged.
In contrast, value iteration combines the steps of policy evaluation and policy improve-
ment by directly updating the value function based on Eq. (4) every time a state is
Monte Carlo Methods
use sampling in order to estimate the value function.
procedure can be used to replace the policy evaluation step of the dynamic programmingbased methods above. Monte Carlo methods are model-free, i.e., they do not need an
explicit transition function. They perform roll-outs by executing the current policy on
the system, hence operating on-policy. The frequencies of transitions and rewards are
kept track of and are used to form estimates of the value function. For example, in an
episodic setting the state-action value of a given state action pair can be estimated by
averaging all the returns that were received when starting from them.
Temporal Diﬀerence Methods,
unlike Monte Carlo methods, do not have to wait
until an estimate of the return is available (i.e., at the end of an episode) to update
the value function. Rather, they use temporal errors and only have to wait until the
next time step. The temporal error is the diﬀerence between the old estimate and a new
estimate of the value function, taking into account the reward received in the current
sample. These updates are done iterativley and, in contrast to dynamic programming
methods, only take into account the sampled successor states rather than the complete
distributions over successor states. Like the Monte Carlo methods, these methods are
model-free, as they do not use a model of the transition function to determine the value
function. In this setting, the value function cannot be calculated analytically but has
to be estimated from sampled transitions in the MDP. For example, the value function
could be updated iteratively by
V ′ (s) = V (s) + α
R (s, a) −¯R + V
where V (s) is the old estimate of the value function, V ′ (s) the updated one, and α
is a learning rate.
This update step is called the TD(0)-algorithm in the discounted
reward case. In order to perform action selection a model of the transition function is
still required.
The equivalent temporal diﬀerence learning algorithm for state-action value functions
is the average reward case version of SARSA with
Q′ (s, a) = Q (s, a) + α
R (s, a) −¯R + Q
where Q (s, a) is the old estimate of the state-action value function and Q′ (s, a) the
updated one. This algorithm is on-policy as both the current action a as well as the
subsequent action a′ are chosen according to the current policy π. The oﬀ-policy variant
is called R-learning , which is closely related to Q-learning, with the
Q′ (s, a) = Q (s, a) + α
R (s, a) −¯R + max
Value Function Approaches
Employed by. . .
Model-Based
Bakker et al. ; Hester et al. ; Kalmár et al.
 ; Martínez-Marín and Duckett ; Schaal ; Touzet
Model-Free
Asada et al. ; Bakker et al. ; Benbrahim et al. ;
Benbrahim and Franklin ; Birdwell and Livingston ;
Bitzer et al. ; Conn and Peters II ; Duan et al. ; Fagg et al. ; Gaskett et al. ; Gräve et al. ;
Hafner and Riedmiller ; Huang and Weng ; Huber and
Grupen ; Ilg et al. ; Katz et al. ; Kimura et al.
 ; Kirchner ; Konidaris et al. ; Kroemer
et al. ; Kwok and Fox ; Latzke et al. ; Mahadevan and Connell ; Matarić ; Morimoto and Doya
 ; Nemec et al. ; Oßwald et al. ; Paletta
et al. ; Pendrith ; Platt et al. ; Riedmiller et al.
 ; Rottmann et al. ; Smart and Kaelbling ;
Soni and Singh ; Tamoši¯unait˙e et al. ; Thrun ;
Tokic et al. ; Touzet ; Uchibe et al. ; Wang et al.
 ; Willgoss and Iqbal 
Table 1: This table illustrates diﬀerent value function based reinforcement learning methods employed for robotic tasks (both average and discounted reward cases) and
associated publications.
These methods do not require a model of the transition function for determining the
deterministic optimal policy π∗(s). H-learning is a related
method that estimates a model of the transition probabilities and the reward function in
order to perform updates that are reminiscent of value iteration.
An overview of publications using value function based methods is presented in Table 1.
Here, model-based methods refers to all methods that employ a predetermined or a
learned model of system dynamics.
2.2.2 Policy Search
The primal formulation of the problem in terms of policy rather then value oﬀers many
features relevant to robotics. It allows for a natural integration of expert knowledge, e.g.,
through both structure and initializations of the policy. It allows domain-appropriate prestructuring of the policy in an approximate form without changing the original problem.
Optimal policies often have many fewer parameters than optimal value functions. For
example, in linear quadratic control, the value function has quadratically many parameters in the dimensionality of the state-variables while the policy requires only linearly
many parameters. Local search in policy space can directly lead to good results as exhibited by early hill-climbing approaches , as well as more recent successes
(see Table 2). Additional constraints can be incorporated naturally, e.g., regularizing the
change in the path distribution. As a result, policy search often appears more natural to
Nevertheless, policy search has been considered the harder problem for a long time
as the optimal solution cannot directly be determined from Equations (1-3) while the
solution of the dual problem leveraging Bellman Principle of Optimality 
enables dynamic programming based solutions.
Notwithstanding this, in robotics, policy search has recently become an important
alternative to value function based methods due to better scalability as well as the convergence problems of approximate value function methods (see Sections 2.3 and 4.2).
Most policy search methods optimize locally around existing policies π, parametrized by
a set of policy parameters θi, by computing changes in the policy parameters ∆θi that
will increase the expected return and results in iterative updates of the form
θi+1 = θi + ∆θi.
The computation of the policy update is the key step here and a variety of updates
have been proposed ranging from pairwise comparisons over gradient estimation using ﬁnite policy diﬀerences , and general stochastic optimization methods , cross entropy and
population-based methods ) to approaches coming from optimal control
such as diﬀerential dynamic programming (DDP) and multiple shooting
approaches . We may broadly break down policy-search methods into “black
box” and “white box” methods. Black box methods are general stochastic optimization
algorithms using only the expected return of policies, estimated by sampling,
and do not leverage any of the internal structure of the RL problem. These may be very
sophisticated techniques that use response surface estimates and
bandit-like strategies to achieve good performance. White box methods take advantage
of some of additional structure within the reinforcement learning domain, including,
for instance, the (approximate) Markov structure of problems, developing approximate
models, value-function estimates when available , or even
simply the causal ordering of actions and rewards. A major open issue within the ﬁeld is
the relative merits of the these two approaches: in principle, white box methods leverage
more information, but with the exception of models (which have been demonstrated
repeatedly to often make tremendous performance improvements, see Section 6), the
performance gains are traded-oﬀwith additional assumptions that may be violated and
less mature optimization algorithms. Some recent work including suggest that much of the beneﬁt of policy search is achieved by
black-box methods.
Some of the most popular white-box general reinforcement learning techniques that
have translated particularly well into the domain of robotics include: (i) policy gradient
approaches based on likelihood-ratio estimation , (ii) policy updates
inspired by expectation-maximization , and (iii) the path integral
methods .
Let us brieﬂy take a closer look at gradient-based approaches ﬁrst. The updates of the
policy parameters are based on a hill-climbing approach, that is following the gradient
of the expected return J for a deﬁned step-size α
θi+1 = θi + α∇θJ.
Diﬀerent methods exist for estimating the gradient ∇θJ and many algorithms require
tuning of the step-size α.
In ﬁnite diﬀerence gradients P perturbed policy parameters are evaluated to obtain
an estimate of the gradient. Here we have ∆ˆJp ≈J(θi + ∆θp) −Jref, where p = [1..P]
are the individual perturbations, ∆ˆJp the estimate of their inﬂuence on the return, and
Jref is a reference return, e.g., the return of the unperturbed parameters. The gradient
can now be estimated by linear regression
&−1 ∆ΘT∆ˆJ,
where the matrix ∆Θ contains all the stacked samples of the perturbations ∆θp and
∆ˆJ contains the corresponding ∆ˆJp. In order to estimate the gradient the number of
perturbations needs to be at least as large as the number of parameters. The approach is
very straightforward and even applicable to policies that are not diﬀerentiable. However,
it is usually considered to be very noisy and ineﬃcient. For the ﬁnite diﬀerence approach
tuning the step-size α for the update, the number of perturbations P, and the type and
magnitude of perturbations are all critical tuning factors.
Likelihood ratio methods rely on the insight that in an episodic setting where the
episodes τ are generated according to the distribution P θ (τ) = P (τ|θ) with the return
of an episode Jτ = $H
h=1 Rh and number of steps H the expected return for a set of
policy parameter θ can be expressed as
P θ (τ) Jτ.
The gradient of the episode distribution can be written as4
∇θP θ (τ) = P θ (τ) ∇θ log P θ (τ) ,
which is commonly known as the the likelihood ratio or REINFORCE 
trick. Combining Equations (5) and (6) we get the gradient of the expected return in
∇θP θ (τ) Jτ =
P θ (τ) ∇θ log P θ (τ) Jτ = E
∇θ log P θ (τ) Jτ2
If we have a stochastic policy πθ (s, a) that generates the episodes τ, we do not need to
keep track of the probabilities of the episodes but can directly express the gradient in
4From multi-variate calculus we have ∇θ log P θ (τ) = ∇θP θ (τ) /P θ (τ).
terms of the policy as ∇θ log P θ (τ) = $H
h=1 ∇θ log πθ (s, a). Finally the gradient of the
expected return with respect to the policy parameters can be estimated as
∇θ log πθ (sh, ah)
If we now take into account that rewards at the beginning of an episode cannot be
caused by actions taken at the end of an episode, we can replace the return of the episode
Jτ by the state-action value function Qπ (s, a) and get 
∇θ log πθ (sh, ah) Qπ (sh, ah)
which is equivalent to the policy gradient theorem .
In practice,
it is often advisable to subtract a reference Jref, also called baseline, from the return
of the episode Jτ or the state-action value function Qπ (s, a) respectively to get better
estimates, similar to the ﬁnite diﬀerence approach. In these settings, the exploration is
automatically taken care of by the stochastic policy.
Initial gradient-based approaches such as ﬁnite diﬀerences gradients or REINFORCE
 have been rather slow. The weight perturbation algorithm is related to
REINFORCE but can deal with non-Gaussian distributions which signiﬁcantly improves
the signal to noise ratio of the gradient . Recent natural policy
gradient approaches have allowed for faster convergence
which may be advantageous for robotics as it reduces the learning time and required
real-world interactions.
A diﬀerent class of safe and fast policy search methods, that are inspired by expectationmaximization, can be derived when the reward is treated as an improper probability
distribution .
Some of these approaches have proven successful in robotics, e.g., reward-weighted regression , Policy
Learning by Weighting Exploration with the Returns , Monte
Carlo Expectation-Maximization , and Cost-regularized Kernel Regression . Algorithms with closely related update rules can also be
derived from diﬀerent perspectives including Policy Improvements with Path Integrals
 and Relative Entropy Policy Search .
Finally, the Policy Search by Dynamic Programming method
is a general strategy that combines policy search with the principle of optimality. The
approach learns a non-stationary policy backward in time like dynamic programming
methods, but does not attempt to enforce the Bellman equation and the resulting approximation instabilities (See Section 2.4). The resulting approach provides some of the
strongest guarantees that are currently known under function approximation and limited
observability It has been demonstrated in learning walking controllers and in ﬁnding nearoptimal trajectories for map exploration . The resulting method
is more expensive than the value function methods because it scales quadratically in the
eﬀective time horizon of the problem. Like DDP methods , it is tied to
a non-stationary (time-varying) policy.
Policy Search
Employed by. . .
Deisenroth and Rasmussen ; Deisenroth et al. ; Endo
et al. ; Fidelman and Stone ; Geng et al. ;
Guenter et al. ; Gullapalli et al. ; Hailu and Sommer
 ; Ko et al. ; Kohl and Stone ; Kolter and Ng
 ; Michels et al. ; Mitsunaga et al. ; Miyamoto
et al. ; Ng et al. ; Peters and Schaal ;
Roberts et al. ; Rosenstein and Barto ; Tamei and
Shibata ; Tedrake ; Tedrake et al. 
Abbeel et al. ; Atkeson and Schaal ; Atkeson
 ; Bagnell and Schneider ; Bagnell ; Buchli et al.
 ; Coates et al. ; Daniel et al. ; Donnart and
Meyer ; Dorigo and Colombetti ; Erden and Leblebicioğlu ; Kalakrishnan et al. ; Kober and Peters ;
Kober et al. ; Kolter et al. ; Kuindersma et al. ;
Lizotte et al. ; Matarić ; Pastor et al. ; Peters and Schaal ; Peters et al. ; Schaal and Atkeson
 ; Stulp et al. ; Svinin et al. ; Tamoši¯unait˙e et al.
 ; Yasuda and Ohkura ; Youssef 
Table 2: This table illustrates diﬀerent policy search reinforcement learning methods employed for robotic tasks and associated publications.
An overview of publications using policy search methods is presented in Table 2.
One of the key open issues in the ﬁeld is determining when it is appropriate to use
each of these methods. Some approaches leverage signiﬁcant structure speciﬁc to the
RL problem ), including reward structure, Markovanity,
causality of reward signals , and value-function estimates when available
 . Others embed policy search as a generic, black-box, problem
of stochastic optimization .
Signiﬁcant open questions remain regarding which
methods are best in which circumstances and further, at an even more basic level, how
eﬀective leveraging the kinds of problem structures mentioned above are in practice.
2.3 Value Function Approaches versus Policy Search
Some methods attempt to ﬁnd a value function or policy which eventually can be employed without signiﬁcant further computation, whereas others (e.g., the roll-out methods) perform the same amount of computation each time.
If a complete optimal value function is known, a globally optimal solution follows
simply by greedily choosing actions to optimize it. However, value-function based approaches have thus far been diﬃcult to translate into high dimensional robotics as they
require function approximation for the value function. Most theoretical guarantees no
longer hold for this approximation and even ﬁnding the optimal action can be a hard
problem due to the brittleness of the approximation and the cost of optimization. For
high dimensional actions, it can be as hard computing an improved policy for all states
in policy search as ﬁnding a single optimal action on-policy for one state by searching
the state-action value function.
In principle, a value function requires total coverage of the state space and the largest
local error determines the quality of the resulting policy. A particularly signiﬁcant problem is the error propagation in value functions. A small change in the policy may cause a
large change in the value function, which again causes a large change in the policy. While
this may lead more quickly to good, possibly globally optimal solutions, such learning
processes often prove unstable under function approximation and are considerably more dangerous
when applied to real systems where overly large policy deviations may lead to dangerous
decisions.
In contrast, policy search methods usually only consider the current policy and its
neighborhood in order to gradually improve performance. The result is that usually only
local optima, and not the global one, can be found. However, these methods work well
in conjunction with continuous features.
Local coverage and local errors results into
improved scaleability in robotics.
Policy search methods are sometimes called actor-only methods; value function methods are sometimes called critic-only methods. The idea of a critic is to ﬁrst observe and
estimate the performance of choosing controls on the system (i.e., the value function),
then derive a policy based on the gained knowledge. In contrast, the actor directly tries
to deduce the optimal policy. A set of algorithms called actor-critic methods attempt
to incorporate the advantages of each: a policy is explicitly maintained, as is a valuefunction for the current policy. The value function (i.e., the critic) is not employed for
action selection.
Instead, it observes the performance of the actor and decides when
the policy needs to be updated and which action should be preferred. The resulting
update step features the local convergence properties of policy gradient algorithms while
reducing update variance . There is a trade-oﬀbetween the
beneﬁt of reducing the variance of the updates and having to learn a value function as
the samples required to estimate the value function could also be employed to obtain
better gradient estimates for the update step. Rosenstein and Barto propose an
actor-critic method that additionally features a supervisor in the form of a stable policy.
2.4 Function Approximation
Function approximation is a family of mathematical and statistical techniques used to represent a function of interest when it is computationally or informationtheoretically intractable to represent the function exactly or explicitly (e.g. in tabular
form). Typically, in reinforcement learning te function approximation is based on sample data collected during interaction with the environment. Function approximation is
critical in nearly every RL problem, and becomes inevitable in continuous state ones. In
large discrete spaces it is also often impractical to visit or even represent all states and
actions, and function approximation in this setting can be used as a means to generalize
to neighboring states and actions.
Function approximation can be employed to represent policies, value functions, and
forward models. Broadly speaking, there are two kinds of function approximation methods: parametric and non-parametric. A parametric function approximator uses a ﬁnite
set of parameters or arguments with the goal is to ﬁnd parameters that make this approximation ﬁt the observed data as closely as possible. Examples include linear basis
functions and neural networks. In contrast, non-parametric methods expand representational power in relation to collected data and hence are not limited by the representation
power of a chosen parametrization . A prominent example that has found
much use within reinforcement learning is Gaussian process regression . A fundamental problem with using supervised learning methods developed in the literature for function approximation is that most such methods are designed
for independently and identically distributed sample data. However, the data generated
by the reinforcement learning process is usually neither independent nor identically distributed. Usually, the function approximator itself plays some role in the data collection
process (for instance, by serving to deﬁne a policy that we execute on a robot.)
Linear basis function approximators form one of the most widely used approximate
value function techniques in continuous (and discrete) state spaces. This is largely due
to the simplicity of their representation as well as a convergence theory, albeit limited, for
the approximation of value functions based on samples .
Let us brieﬂy take a closer look at a radial basis function network to illustrate this
approach. The value function maps states to a scalar value. The state space can be
covered by a grid of points, each of which correspond to the center of a Gaussian-shaped
basis function. The value of the approximated function is the weighted sum of the values
of all basis functions at the query point. As the inﬂuence of the Gaussian basis functions
drops rapidly, the value of the query points will be predominantly inﬂuenced by the
neighboring basis functions. The weights are set in a way to minimize the error between
the observed samples and the reconstruction. For the mean squared error, these weights
can be determined by linear regression. Kolter and Ng discuss the beneﬁts of
regularization of such linear function approximators to avoid over-ﬁtting.
Other possible function approximators for value functions include wire ﬁtting, which-
Baird and Klopf suggested as an approach that makes continuous action selection
feasible. The Fourier basis had been suggested by Konidaris et al. . Even discretizing the state-space can be seen as a form of function approximation where coarse
values serve as estimates for a smooth continuous function. One example is tile coding
 , where the space is subdivided into (potentially irregularly
shaped) regions, called tiling. The number of diﬀerent tilings determines the resolution
of the ﬁnal approximation. For more examples, please refer to Sections 4.1 and 4.2.
Policy search also beneﬁts from a compact representation of the policy as discussed in
Section 4.3.
Models of the system dynamics can be represented using a wide variety of techniques.
In this case, it is often important to model the uncertainty in the model (e.g., by a
stochastic model or Bayesian estimates of model parameters) to ensure that the learn-
ing algorithm does not exploit model inaccuracies. See Section 6 for a more detailed
discussion.
3 Challenges in Robot Reinforcement Learning
Reinforcement learning is generally a hard problem and many of its challenges are particularly apparent in the robotics setting. As the states and actions of most robots are
inherently continuous, we are forced to consider the resolution at which they are represented. We must decide how ﬁne grained the control is that we require over the robot,
whether we employ discretization or function approximation, and what time step we
establish. Additionally, as the dimensionality of both states and actions can be high,
we face the “Curse of Dimensionality” as discussed in Section 3.1. As
robotics deals with complex physical systems, samples can be expensive due to the long
execution time of complete tasks, required manual interventions, and the need maintenance and repair. In these real-world measurements, we must cope with the uncertainty
inherent in complex physical systems. A robot requires that the algorithm runs in realtime. The algorithm must be capable of dealing with delays in sensing and execution that
are inherent in physical systems (see Section 3.2). A simulation might alleviate many
problems but these approaches need to be robust with respect to model errors as discussed in Section 3.3. An often underestimated problem is the goal speciﬁcation, which
is achieved by designing a good reward function. As noted in Section 3.4, this choice can
make the diﬀerence between feasibility and an unreasonable amount of exploration.
3.1 Curse of Dimensionality
When Bellman explored optimal control in discrete high-dimensional spaces, he
faced an exponential explosion of states and actions for which he coined the term “Curse
of Dimensionality”. As the number of dimensions grows, exponentially more data and
computation are needed to cover the complete state-action space.
For example, if
we assume that each dimension of a state-space is discretized into ten levels, we have 10
states for a one-dimensional state-space, 103 = 1000 unique states for a three-dimensional
state-space, and 10n possible states for a n-dimensional state space. Evaluating every
state quickly becomes infeasible with growing dimensionality, even for discrete states.
Bellman originally coined the term in the context of optimization, but it also applies
to function approximation and numerical integration . While supervised
learning methods have tamed this exponential growth by considering only competitive
optimality with respect to a limited class of function approximators, such results are much
more diﬃcult in reinforcement learning where data must collected throughout state-space
to ensure global optimality.
Robotic systems often have to deal with these high dimensional states and actions
due to the many degrees of freedom of modern anthropomorphic robots. For example,
in the ball-paddling task shown in Figure 3, a proper representation of a robot’s state
would consist of its joint angles and velocities for each of its seven degrees of freedom as
well as the Cartesian position and velocity of the ball. The robot’s actions would be the
Figure 3: This Figure illustrates the state space used in the modeling of a robot reinforcement learning task of paddling a ball.
generated motor commands, which often are torques or accelerations. In this example, we
have 2× (7+ 3) = 20 state dimensions and 7-dimensional continuous actions. Obviously,
other tasks may require even more dimensions. For example, human-like actuation often
follows the antagonistic principle which additionally
enables control of stiﬀness. Such dimensionality is a major challenge for both the robotics
and the reinforcement learning communities.
In robotics, such tasks are often rendered tractable to the robot engineer by a hierarchical task decomposition that shifts some complexity to a lower layer of functionality.
Classical reinforcement learning approaches often consider a grid-based representation
with discrete states and actions, often referred to as a grid-world. A navigational task
for mobile robots could be projected into this representation by employing a number of
actions like “move to the cell to the left” that use a lower level controller that takes care of
accelerating, moving, and stopping while ensuring precision. In the ball-paddling example, we may simplify by controlling the robot in racket space (which is lower-dimensional
as the racket is orientation-invariant around the string’s mounting point) with an operational space control law . Many commercial robot systems also
encapsulate some of the state and action components in an embedded control system
(e.g., trajectory fragments are frequently used as actions for industrial robots). However,
this form of a state dimensionality reduction severely limits the dynamic capabilities of
the robot according to our experience .
The reinforcement learning community has a long history of dealing with dimensionality using computational abstractions. It oﬀers a larger set of applicable tools ranging from
adaptive discretizations and function approximation approaches
 to macro-actions or options . Options allow a task to be decomposed into elementary components
and quite naturally translate to robotics. Such options can autonomously achieve a subtask, such as opening a door, which reduces the planning horizon . The automatic generation of such sets of options is a key issue in order to enable such approaches. We will discuss approaches that have been successful in robot
reinforcement learning in Section 4.
3.2 Curse of Real-World Samples
Robots inherently interact with the physical world. Hence, robot reinforcement learning
suﬀers from most of the resulting real-world problems. For example, robot hardware is
usually expensive, suﬀers from wear and tear, and requires careful maintenance. Repairing a robot system is a non-negligible eﬀort associated with cost, physical labor and
long waiting periods. To apply reinforcement learning in robotics, safe exploration becomes a key issue of the learning process , a problem often neglected in the
general reinforcement learning community. Perkins and Barto have come up with
a method for constructing reinforcement learning agents based on Lyapunov functions.
Switching between the underlying controllers is always safe and oﬀers basic performance
guarantees.
However, several more aspects of the real-world make robotics a challenging domain.
As the dynamics of a robot can change due to many external factors ranging from temperature to wear, the learning process may never fully converge, i.e., it needs a “tracking
solution” . Frequently, the environment settings during an earlier
learning period cannot be reproduced. External factors are not always clear – for example, how light conditions aﬀect the performance of the vision system and, as a result,
the task’s performance. This problem makes comparing algorithms particularly hard.
Furthermore, the approaches often have to deal with uncertainty due to inherent measurement noise and the inability to observe all states directly with sensors.
Most real robot learning tasks require some form of human supervision, e.g., putting
the pole back on the robot’s end-eﬀector during pole balancing (see Figure 1d) after a
failure. Even when an automatic reset exists (e.g., by having a smart mechanism that
resets the pole), learning speed becomes essential as a task on a real robot cannot be
sped up. In some tasks like a slowly rolling robot, the dynamics can be ignored; in others
like a ﬂying robot, they cannot. Especially in the latter case, often the whole episode
needs to be completed as it is not possible to start from arbitrary states.
For such reasons, real-world samples are expensive in terms of time, labor and, potentially, ﬁnances. In robotic reinforcement learning, it is often considered to be more
important to limit the real-world interaction time instead of limiting memory consumption or computational complexity.
Thus, sample eﬃcient algorithms that are able to
learn from a small number of trials are essential. In Section 6 we will point out several
approaches that allow the amount of required real-world interactions to be reduced.
Since the robot is a physical system, there are strict constraints on the interaction
between the learning algorithm and the robot setup. For dynamic tasks, the movement
cannot be paused and actions must be selected within a time-budget without the opportunity to pause to think, learn or plan between actions. These constraints are less severe
in an episodic setting where the time intensive part of the learning can be postponed to
the period between episodes. Hester et al. has proposed a real-time architecture
for model-based value function reinforcement learning methods taking into account these
challenges.
As reinforcement learning algorithms are inherently implemented on a digital computer, the discretization of time is unavoidable despite that physical systems are inherently continuous time systems. Time-discretization of the actuation can generate undesirable artifacts (e.g., the distortion of distance between states) even for idealized physical
systems, which cannot be avoided. As most robots are controlled at ﬁxed sampling frequencies (in the range between 500Hz and 3kHz) determined by the manufacturer of the
robot, the upper bound on the rate of temporal discretization is usually pre-determined.
The lower bound depends on the horizon of the problem, the achievable speed of changes
in the state, as well as delays in sensing and actuation.
All physical systems exhibit such delays in sensing and actuation. The state of the
setup (represented by the ﬁltered sensor signals) may frequently lag behind the real state
due to processing and communication delays. More critically, there are also communication delays in actuation as well as delays due to the fact that neither motors, gear boxes
nor the body’s movement can change instantly. Due to these delays, actions may not
have instantaneous eﬀects but are observable only several time steps later. In contrast,
in most general reinforcement learning algorithms, the actions are assumed to take eﬀect
instantaneously as such delays would violate the usual Markov assumption. This eﬀect
can be addressed by putting some number of recent actions into the state. However, this
signiﬁcantly increases the dimensionality of the problem.
The problems related to time-budgets and delays can also be avoided by increasing
the duration of the time steps. One downside of this approach is that the robot cannot
be controlled as precisely; another is that it may complicate a description of system
3.3 Curse of Under-Modeling and Model Uncertainty
One way to oﬀset the cost of real-world interaction is to use accurate models as simulators. In an ideal setting, this approach would render it possible to learn the behavior in
simulation and subsequently transfer it to the real robot. Unfortunately, creating a suﬃciently accurate model of the robot and its environment is challenging and often requires
very many data samples. As small model errors due to this under-modeling accumulate,
the simulated robot can quickly diverge from the real-world system. When a policy is
trained using an imprecise forward model as simulator, the behavior will not transfer
without signiﬁcant modiﬁcations as experienced by Atkeson when learning the
underactuated pendulum swing-up. The authors have achieved a direct transfer in only
a limited number of experiments; see Section 6.1 for examples.
For tasks where the system is self-stabilizing (that is, where the robot does not require
active control to remain in a safe state or return to it), transferring policies often works
well. Such tasks often feature some type of dampening that absorbs the energy introduced
by perturbations or control inaccuracies. If the task is inherently stable, it is safer to
assume that approaches that were applied in simulation work similarly in the real world
 . Nevertheless, tasks can often be learned better in the real
world than in simulation due to complex mechanical interactions (including contacts
and friction) that have proven diﬃcult to model accurately. For example, in the ballpaddling task (Figure 3) the elastic string that attaches the ball to the racket always pulls
back the ball towards the racket even when hit very hard. Initial simulations (including
friction models, restitution models, dampening models, models for the elastic string, and
air drag) of the ball-racket contacts indicated that these factors would be very hard to
control. In a real experiment, however, the reﬂections of the ball on the racket proved
to be less critical than in simulation and the stabilizing forces due to the elastic string
were suﬃcient to render the whole system self-stabilizing.
In contrast, in unstable tasks small variations have drastic consequences. For example,
in a pole balancing task, the equilibrium of the upright pole is very brittle and constant
control is required to stabilize the system. Transferred policies often perform poorly in
this setting. Nevertheless, approximate models serve a number of key roles which we
discuss in Section 6, including verifying and testing the algorithms in simulation, establishing proximity to theoretically optimal solutions, calculating approximate gradients for
local policy improvement, identiﬁng strategies for collecting more data, and performing
“mental rehearsal”.
3.4 Curse of Goal Speciﬁcation
In reinforcement learning, the desired behavior is implicitly speciﬁed by the reward function. The goal of reinforcement learning algorithms then is to maximize the accumulated
long-term reward. While often dramatically simpler than specifying the behavior itself,
in practice, it can be surprisingly diﬃcult to deﬁne a good reward function in robot
reinforcement learning. The learner must observe variance in the reward signal in order
to be able to improve a policy: if the same return is always received, there is no way to
determine which policy is better or closer to the optimum.
In many domains, it seems natural to provide rewards only upon task achievement –
for example, when a table tennis robot wins a match. This view results in an apparently
simple, binary reward speciﬁcation.
However, a robot may receive such a reward so
rarely that it is unlikely to ever succeed in the lifetime of a real-world system. Instead
of relying on simpler binary rewards, we frequently need to include intermediate rewards
in the scalar reward function to guide the learning process to a reasonable solution, a
process known as reward shaping .
Beyond the need to shorten the eﬀective problem horizon by providing intermediate
rewards, the trade-oﬀbetween diﬀerent factors may be essential. For instance, hitting a
table tennis ball very hard may result in a high score but is likely to damage a robot or
shorten its life span. Similarly, changes in actions may be penalized to avoid high frequency controls that are likely to be very poorly captured with tractable low dimensional
state-space or rigid-body models. Reinforcement learning algorithms are also notorious
for exploiting the reward function in ways that are not anticipated by the designer. For
example, if the distance between the ball and the desired highest point is part of the
reward in ball paddling (see Figure 3), many locally optimal solutions would attempt
to simply move the racket upwards and keep the ball on it. Reward shaping gives the
system a notion of closeness to the desired behavior instead of relying on a reward that
only encodes success or failure .
Often the desired behavior can be most naturally represented with a reward function
in a particular state and action space. However, this representation does not necessarily
correspond to the space where the actual learning needs to be performed due to both
computational and statistical limitations.
Employing methods to render the learning
problem tractable often result in diﬀerent, more abstract state and action spaces which
might not allow accurate representation of the original reward function. In such cases,
a rewardartfully speciﬁedin terms of the features of the space in which the learning
algorithm operates can prove remarkably eﬀective.
There is also a trade-oﬀbetween
the complexity of the reward function and the complexity of the learning problem. For
example, in the ball-in-a-cup task (Section 7) the most natural reward would be a binary
value depending on whether the ball is in the cup or not. To render the learning problem
tractable, a less intuitive reward needed to be devised in terms of a Cartesian distance
with additional directional information (see Section 7.1 for details). Another example is
Crusher , an outdoor robot, where the human designer was interested
in a combination of minimizing time and risk to the robot. However, the robot reasons
about the world on the long time horizon scale as if it was a very simple, deterministic,
holonomic robot operating on a ﬁne grid of continuous costs. Hence, the desired behavior
cannot be represented straightforwardly in this state-space. Nevertheless, a remarkably
human-like behavior that seems to respect time and risk priorities can be achieved by
carefully mapping features describing each state (discrete grid location with features
computed by an on-board perception system) to cost.
Inverse optimal control, also known as inverse reinforcement learning ,
is a promising alternative to specifying the reward function manually. It assumes that a
reward function can be reconstructed from a set of expert demonstrations. This reward
function does not necessarily correspond to the true reward function, but provides guarantees on the resulting performance of learned behaviors . Inverse optimal control was initially studied in the control community
 and in the ﬁeld of economics . The initial results were only applicable to limited domains (linear quadratic regulator problems) and
required closed form access to plant and controller, hence samples from human demonstrations could not be used. Russell brought the ﬁeld to the attention of the
machine learning community. Abbeel and Ng deﬁned an important constraint
on the solution to the inverse RL problem when reward functions are linear in a set of
features: a policy that is extracted by observing demonstrations has to earn the same
reward as the policy that is being demonstrated. Ratliﬀet al. demonstrated that
inverse optimal control can be understood as a generalization of ideas in machine learning
of structured prediction and introduced eﬃcient sub-gradient based algorithms with regret bounds that enabled large scale application of the technique within robotics. Ziebart
et al. extended the technique developed by Abbeel and Ng by rendering
the idea robust and probabilistic, enabling its eﬀective use for both learning policies and
predicting the behavior of sub-optimal agents. These techniques, and many variants,
have been recently successfully applied to outdoor robot navigation , manipulation , and quadruped locomotion
 .
More recently, the notion that complex policies can be built on top of simple, easily
solved optimal control problems by exploiting rich, parametrized reward functions has
been exploited within reinforcement learning more directly. In , complex policies are derived by adapting a reward function for simple
optimal control problems using policy search techniques.
Zucker and Bagnell 
demonstrate that this technique can enable eﬃcient solutions to robotic marble-maze
problems that eﬀectively transfer between mazes of varying design and complexity. These
works highlight the natural trade-oﬀbetween the complexity of the reward function and
the complexity of the underlying reinforcement learning problem for achieving a desired
4 Tractability Through Representation
As discussed above, reinforcement learning provides a framework for a remarkable variety of problems of signiﬁcance to both robotics and machine learning. However, the
computational and information-theoretic consequences that we outlined above accompany this power and generality. As a result, naive application of reinforcement learning
techniques in robotics is likely to be doomed to failure. The remarkable successes that
we reference in this article have been achieved by leveraging a few key principles – effective representations, approximate models, and prior knowledge or information. In the
following three sections, we review these principles and summarize how each has been
made eﬀective in practice. We hope that understanding these broad approaches will lead
to new successes in robotic reinforcement learning by combining successful methods and
encourage research on novel techniques that embody each of these principles.
Much of the success of reinforcement learning methods has been due to the clever use
of approximate representations. The need of such approximations is particularly pronounced in robotics, where table-based representations (as discussed in Section 2.2.1) are
rarely scalable. The diﬀerent ways of making reinforcement learning methods tractable in
robotics are tightly coupled to the underlying optimization framework. Reducing the dimensionality of states or actions by smart state-action discretization is a representational
simpliﬁcation that may enhance both policy search and value function-based methods
(see 4.1). A value function-based approach requires an accurate and robust but general
function approximator that can capture the value function with suﬃcient precision (see
Section 4.2) while maintaining stability during learning. Policy search methods require
a choice of policy representation that controls the complexity of representable policies to
enhance learning speed (see Section 4.3). An overview of publications that make particular use of eﬃcient representations to render the learning problem tractable is presented
in Table 3.
4.1 Smart State-Action Discretization
Decreasing the dimensionality of state or action spaces eases most reinforcement learning
problems signiﬁcantly, particularly in the context of robotics.
Here, we give a short
overview of diﬀerent attempts to achieve this goal with smart discretization.
Hand Crafted Discretization.
A variety of authors have manually developed discretizations so that basic tasks can be learned on real robots. For low-dimensional tasks, we
can generate discretizations straightforwardly by splitting each dimension into a number
of regions. The main challenge is to ﬁnd the right number of regions for each dimension
that allows the system to achieve a good ﬁnal performance while still learning quickly.
Example applications include balancing a ball on a beam , one
degree of freedom ball-in-a-cup , two degree of freedom crawling motions , and gait patterns for four legged walking .
Much more human experience is needed for more complex tasks. For example, in a basic
navigation task with noisy sensors , only some combinations
of binary state or action indicators are useful (e.g., you can drive left and forward at the
same time, but not backward and forward). The state space can also be based on vastly
diﬀerent features, such as positions, shapes, and colors, when learning object aﬀordances
 where both the discrete sets and the mapping from sensor values
to the discrete values need to be crafted. Kwok and Fox use a mixed discrete
and continuous representation of the state space to learn active sensing strategies in a
RoboCup scenario. They ﬁrst discretize the state space along the dimension with the
strongest non-linear inﬂuence on the value function and subsequently employ a linear
value function approximation (Section 4.2) for each of the regions.
Learned from Data.
Instead of specifying the discretizations by hand, they can also
be built adaptively during the learning process. For example, a rule based reinforcement
learning approach automatically segmented the state space to learn a cooperative task
with mobile robots .
Each rule is responsible for a local
region of the state-space. The importance of the rules are updated based on the rewards
and irrelevant rules are discarded. If the state is not covered by a rule yet, a new one is
added. In the related ﬁeld of computer vision, Piater et al. propose an approach
that adaptively and incrementally discretizes a perceptual space into discrete states,
training an image classiﬁer based on the experience of the RL agent to distinguish visual
classes, which correspond to the states.
Meta-Actions.
Automatic construction of meta-actions (and the closely related concept
of options) has fascinated reinforcement learning researchers and there are various examples in the literature. The idea is to have more intelligent actions that are composed of a
sequence of movements and that in themselves achieve a simple task. A simple example
would be to have a meta-action “move forward 5m.” A lower level system takes care of
Smart State-Action Discretization
Employed by. . .
Hand crafted
Benbrahim et al. ; Kimura et al. ; Kwok and Fox
 ; Nemec et al. ; Paletta et al. ; Tokic et al.
 ; Willgoss and Iqbal 
Piater et al. ; Yasuda and Ohkura 
Meta-actions
Asada et al. ; Dorigo and Colombetti ; Fidelman and
Stone ; Huber and Grupen ; Kalmár et al. ;
Konidaris et al. ; Matarić ; Platt et al.
 ; Soni and Singh ; Nemec et al. 
Relational
Representation
Cocora et al. ; Katz et al. 
Value Function Approximation
Employed by. . .
Physics-inspired
An et al. ; Schaal 
Neural Networks
Benbrahim and Franklin ; Duan et al. ; Gaskett et al.
 ; Hafner and Riedmiller ; Riedmiller et al. ;
Thrun 
Hester et al. ; Mahadevan and Connell ; Touzet 
Local Models
Bentivegna ; Schaal ; Smart and Kaelbling 
Gräve et al. ; Kroemer et al. ; Rottmann et al.
Pre-structured Policies
Employed by. . .
Via Points &
Kuindersma et al. ; Miyamoto et al. ; Roberts et al.
Linear Models
Tamei and Shibata 
Motor Primitives
Kohl and Stone ; Kober and Peters ; Peters and
Schaal ; Stulp et al. ; Tamoši¯unait˙e et al. ;
Theodorou et al. 
Deisenroth and Rasmussen ; Deisenroth et al. ;
Guenter et al. ; Lin and Lai ; Peters and Schaal
Neural Networks
Endo et al. ; Geng et al. ; Gullapalli et al. ;
Hailu and Sommer ; Bagnell and Schneider 
Controllers
Bagnell and Schneider ; Kolter and Ng ; Tedrake
 ; Tedrake et al. ; Vlassis et al. ; Zucker and
Bagnell 
Non-parametric
Kober et al. ; Mitsunaga et al. ; Peters et al. 
Table 3: This table illustrates diﬀerent methods of making robot reinforcement learning
tractable by employing a suitable representation.
accelerating, stopping, and correcting errors. For example, in , the
state and action sets are constructed in a way that repeated action primitives lead to a
change in the state to overcome problems associated with the discretization. Q-learning
and dynamic programming based approaches have been compared in a pick-n-place task
 using modules. Huber and Grupen use a set of controllers
with associated predicate states as a basis for learning turning gates with a quadruped.
Fidelman and Stone use a policy search approach to learn a small set of parameters that controls the transition between a walking and a capturing meta-action in a
RoboCup scenario. A task of transporting a ball with a dog robot can be learned with semi-automatically discovered options. Using only the subgoals of primitive motions, a humanoid robot can learn a pouring task . Other examples include foraging and cooperative tasks with multiple robots, grasping with restricted search spaces ,
and mobile robot navigation . If the meta-actions are not
ﬁxed in advance, but rather learned at the same time, these approaches are hierarchical
reinforcement learning approaches as discussed in Section 5.2. Konidaris et al. propose an approach that constructs a skill tree from human demonstrations. Here,
the skills correspond to options and are chained to learn a mobile manipulation skill.
Relational Representations.
In a relational representation, the states, actions, and
transitions are not represented individually. Entities of the same predeﬁned type are
grouped and their relationships are considered. This representation may be preferable
for highly geometric tasks (which frequently appear in robotics) and has been employed
to learn to navigate buildings with a real robot in a supervised setting and to manipulate articulated objects in simulation .
4.2 Value Function Approximation
Function approximation has always been the key component that allowed value function
methods to scale into interesting domains. In robot reinforcement learning, the following
function approximation schemes have been popular and successful. Using function approximation for the value function can be combined with using function approximation
for learning a model of the system (as discussed in Section 6) in the case of model-based
reinforcement learning approaches.
Unfortunately the max-operator used within the Bellman equation and temporaldiﬀerence updates can theoretically make most linear or non-linear approximation schemes
unstable for either value iteration or policy iteration. Quite frequently such an unstable
behavior is also exhibited in practice. Linear function approximators are stable for policy evaluation, while non-linear function approximation (e.g., neural networks) can even
diverge if just used for policy evaluation .
Physics-inspired Features.
If good hand-crafted features are known, value function
approximation can be accomplished using a linear combination of features. However,
good features are well known in robotics only for a few problems, such as features for
Figure 4: The Brainstormer Tribots won the RoboCup 2006 MidSize League (Picture reprint with permission of Martin Riedmiller).
local stabilization and features describing rigid body dynamics showed that such features suﬃce for learning how to stabilize
a pole on the end-eﬀector of a robot when within ±15 −30 degrees of the equilibrium
angle. For suﬃcient features, linear function approximation is likely to yield good results
in an on-policy setting. Nevertheless, it is straightforward to show that impoverished
value function representations (e.g., omitting the cross-terms in quadratic expansion in
Schaal’s set-up) will make it impossible for the robot to learn this behavior. Similarly, it
is well known that linear value function approximation is unstable in the oﬀ-policy case
 .
Neural Networks.
As good hand-crafted features are rarely available, various groups
have employed neural networks as global, non-linear value function approximation. Many
diﬀerent ﬂavors of neural networks have been applied in robotic reinforcement learning.
For example, multi-layer perceptrons were used to learn a wandering behavior and visual servoing .
Fuzzy neural networks and
explanation-based neural networks have allowed robots to learn basic navigation. CMAC neural networks have been used for biped locomotion .
The Brainstormers RoboCup soccer team is a particularly impressive application of
value function approximation.(see Figure 4). It used multi-layer perceptrons to learn
various sub-tasks such as learning defenses, interception, position control, kicking, motor
speed control, dribbling and penalty shots . The resulting components contributed substantially to winning the world cup
several times in the simulation and the mid-size real robot leagues. As neural networks
are global function approximators, overestimating the value function at a frequently
occurring state will increase the values predicted by the neural network for all other
states, causing fast divergence .Riedmiller et al.
 solved this problem by always deﬁning an absorbing state where they set the
value predicted by their neural network to zero, which “clamps the neural network down”
and thereby prevents divergence. It also allows re-iterating on the data, which results
in an improved value function quality. The combination of iteration on data with the
clamping technique appears to be the key to achieving good performance with value
function approximation in practice.
Generalize to Neighboring Cells.
As neural networks are globally aﬀected from local
errors, much work has focused on simply generalizing from neighboring cells. One of the
earliest papers in robot reinforcement learning introduced this idea by statistically clustering states to speed up a box-pushing task with a
mobile robot, see Figure 1a. This approach was also used for a navigation and obstacle
avoidance task with a mobile robot . Similarly, decision trees have been
used to generalize states and actions to unseen ones, e.g., to learn a penalty kick on a
humanoid robot . The core problem of these methods is the lack of
scalability to high-dimensional state and action spaces.
Local Models.
Local models can be seen as an extension of generalization among neighboring cells to generalizing among neighboring data points. Locally weighted regression
creates particularly eﬃcient function approximation in the context of robotics both in
supervised and reinforcement learning.
Here, regression errors are weighted down by
proximity to query point to train local modelsThe predictions of these local models are
combined using the same weighting functions. Using local models for value function approximation has allowed learning a navigation task with obstacle avoidance , a pole swing-up task , and an air hockey task (Bentivegna,
Gaussian Process Regression.
Parametrized global or local models need to pre-specify,
which requires a trade-oﬀbetween representational accuracy and the number of parameters. A non-parametric function approximator like Gaussian Process Regression (GPR)
could be employed instead, but potentially at the cost of a higher computational complexity. GPR has the added advantage of providing a notion of uncertainty about the
approximation quality for a query point. Hovering with an autonomous blimp has been achieved by approximation the state-action value function with a
GPR. Similarly, another paper shows that grasping can be learned using Gaussian process regression by additionally taking into account the uncertainty to
guide the exploration. Grasping locations can be learned by approximating the rewards
with a GPR, and trying candidates with predicted high rewards ,
resulting in an active learning approach. High reward uncertainty allows intelligent exploration in reward-based grasping in a bandit setting.
Figure 5: Boston Dynamics LittleDog jumping (Picture reprint
with permission of Zico Kolter).
4.3 Pre-structured Policies
Policy search methods greatly beneﬁt from employing an appropriate function approximation of the policy.
For example, when employing gradient-based approaches, the
trade-oﬀbetween the representational power of the policy (in the form of many policy
parameters) and the learning speed (related to the number of samples required to estimate the gradient) needs to be considered. To make policy search approaches tractable,
the policy needs to be represented with a function approximation that takes into account
domain knowledge, such as task-relevant parameters or generalization properties. As the
next action picked by a policy depends on the current state and action, a policy can be
seen as a closed-loop controller. Roberts et al. demonstrate that care needs to be
taken when selecting closed-loop parameterizations for weakly-stable systems, and suggest forms that are particularly robust during learning. However, especially for episodic
RL tasks, sometimes open-loop policies (i.e., policies where the actions depend only on
the time) can also be employed.
Via Points & Splines.
An open-loop policy may often be naturally represented as a
trajectory, either in the space of states or targets or directly as a set of controls. Here,
the actions are only a function of time, which can be considered as a component of the
state. Such spline-based policies are very suitable for compressing complex trajectories
into few parameters. Typically the desired joint or Cartesian position, velocities, and/or
accelerations are used as actions. To minimize the required number of parameters, not
every point is stored. Instead, only important via-points are considered and other points
are interpolated.
Miyamoto et al. optimized the position and timing of such
via-points in order to learn a kendama task (a traditional Japanese toy similar to ballin-a-cup). A well known type of a via point representations are splines, which rely on
piecewise-deﬁned smooth polynomial functions for interpolation. For example, Roberts
et al. used a periodic cubic spline as a policy parametrization for a ﬂapping
system and Kuindersma et al. used a cubic spline to represent arm movements in
an impact recovery task.
Linear Models.
If model knowledge of the system is available, it can be used to create
features for linear closed-loop policy representations. For example, Tamei and Shibata
 used policy-gradient reinforcement learning to adjust a model that maps from
human EMG signals to forces that in turn is used in a cooperative holding task.
Motor Primitives.
Motor primitives combine linear models describing dynamics with
parsimonious movement parametrizations.
While originally biologically-inspired, they
have a lot of success for representing basic movements in robotics such as a reaching
movement or basic locomotion. These basic movements can subsequently be sequenced
and/or combined to achieve more complex movements. For both goal oriented and rhythmic movement, diﬀerent technical representations have been proposed in the robotics
community.
Dynamical system motor primitives have become a popular representation for reinforcement learning of discrete movements. The dynamical system motor primitives always have a strong dependence on the
phase of the movement, which corresponds to time. They can be employed as an openloop trajectory representation. Nevertheless, they can also be employed as a closed-loop
policy to a limited extent. In our experience, they oﬀer a number of advantages over
via-point or spline based policy representation (see Section 7.2). The dynamical system
motor primitives have been trained with reinforcement learning for a T-ball batting task
 , an underactuated pendulum swing-up and a ball-in-a-cup
task , ﬂipping a light switch , pouring water
 , and playing pool and manipulating a box . For rhythmic behaviors, a representation based on the same biological motivation
but with a fairly diﬀerent technical implementation (based on half-elliptical locuses) have
been used to acquire the gait patterns for an Aibo robot dog locomotion and to learn the
closed-loop cart-pole swingup task . Globally linear
models were employed in a closed-loop block stacking task .
Neural Networks
are another general function approximation used to represent policies. Neural oscillators with sensor feedback have been used to learn rhythmic movements
where open and closed-loop information were combined, such as gaits for a two legged
robot . Similarly, a peg-in-hole (see Figure 1b), a
ball-balancing task , and a navigation task have been learned with closed-loop neural networks as policy function approximators.
Locally Linear Controllers.
As local linearity is highly desirable in robot movement
generation to avoid actuation diﬃculties, learning the parameters of a locally linear
controller can be a better choice than using a neural network or radial basis function
representation. Several of these controllers can be combined to form a global, inherently
closed-loop policy.
This type of policy has allowed for many applications, including
learning helicopter ﬂight , learning biped walk patterns
 , driving a radio-controlled (RC) car, learning a
jumping behavior for a robot dog (illustrated in Figure 5), and
balancing a two wheeled robot . Operational space control was also
learned by Peters and Schaal using locally linear controller models. In a marble
maze task, Zucker and Bagnell used such a controller as a policy that expressed
the desired velocity of the ball in terms of the directional gradient of a value function.
Non-parametric Policies.
Polices based on non-parametric regression approaches often
allow a more data-driven learning process. This approach is often preferable over the
purely parametric policies listed above becausethe policy structure can evolve during
the learning process. Such approaches are especially useful when a policy learned to
adjust the existing behaviors of an lower-level controller, such as when choosing among
diﬀerent robot human interaction possibilities , selecting among
diﬀerent striking movements in a table tennis task , and setting the
meta-actions for dart throwing and table tennis hitting tasks .
5 Tractability Through Prior Knowledge
Prior knowledge can dramatically help guide the learning process. It can be included in
the form of initial policies, demonstrations, initial models, a predeﬁned task structure,
or constraints on the policy such as torque limits or ordering constraints of the policy
parameters. These approaches signiﬁcantly reduce the search space and, thus, speed up
the learning process. Providing a (partially) successful initial policy allows a reinforcement learning method to focus on promising regions in the value function or in policy
space, see Section 5.1. Pre-structuring a complex task such that it can be broken down
into several more tractable ones can signiﬁcantly reduce the complexity of the learning
task, see Section 5.2. An overview of publications using prior knowledge to render the
learning problem tractable is presented in Table 4. Constraints may also limit the search
space, but often pose new, additional problems for the learning methods. For example,
policy search limits often do not handle hard limits on the policy well. Relaxing such constraints (a trick often applied in machine learning) is not feasible if they were introduced
to protect the robot in the ﬁrst place.
5.1 Prior Knowledge Through Demonstration
People and other animals frequently learn using a combination of imitation and trial
and error.
When learning to play tennis, for instance, an instructor will repeatedly
demonstrate the sequence of motions that form an orthodox forehand stroke. Students
subsequently imitate this behavior, but still need hours of practice to successfully return
balls to a precise location on the opponent’s court. Input from a teacher need not be
limited to initial instruction. The instructor may provide additional demonstrations in
later learning stages and which can also be used
as diﬀerential feedback .
This combination of imitation learning with reinforcement learning is sometimes termed
apprenticeship learning to emphasize the need for learning both
from a teacher and by practice. The term “apprenticeship learning” is often employed to
refer to “inverse reinforcement learning” or “inverse optimal control” but is intended here
to be employed in this original, broader meaning. For a recent survey detailing the state
of the art in imitation learning for robotics, see .
Using demonstrations to initialize reinforcement learning provides multiple beneﬁts.
Perhaps the most obvious beneﬁt is that it provides supervised training data of what
actions to perform in states that are encountered. Such data may be helpful when used
to bias policy action selection.
The most dramatic beneﬁt, however, is that demonstration – or a hand-crafted initial
policy – removes the need for global exploration of the policy or state-space of the RL
problem. The student can improve by locally optimizing a policy knowing what states
are important, making local optimization methods feasible. Intuitively, we expect that
removing the demands of global exploration makes learning easier.
However, we can
only ﬁnd local optima close to the demonstration, that is, we rely on the demonstration
to provide a good starting point.
Perhaps the textbook example of such in human
learning is the rise of the “Fosbury Flop” method of high-jump (see
Figure 6). This motion is very diﬀerent from a classical high-jump and took generations
of Olympians to discover. But after it was ﬁrst demonstrated, it was soon mastered by
virtually all athletes participating in the sport. On the other hand, this example also
illustrates nicely that such local optimization around an initial demonstration can only
ﬁnd local optima.
In practice, both approximate value function based approaches and policy search methods work best for real system applications when they are constrained to make modest
changes to the distribution over states while learning. Policy search approaches implicitly maintain the state distribution by limiting the changes to the policy. On the other
hand, for value function methods, an unstable estimate of the value function can lead to
drastic changes in the policy. Multiple policy search methods used in robotics are based
on this intuition .
2010a; Kober and Peters, 2010).
The intuitive idea and empirical evidence that demonstration makes the reinforcement learning problem simpler can be understood rigorously. In fact, Kakade and Langford ; Bagnell et al. demonstrate that knowing approximately the statedistribution of a good policy5 transforms the problem of reinforcement learning from
one that is provably intractable in both information and computational complexity to a
tractable one with only polynomial sample and computational complexity, even under
function approximation and partial observability. This type of approach can be understood as a reduction from reinforcement learning to supervised learning. Both algorithms
are policy search variants of approximate policy iteration that constrain policy updates.
Kollar and Roy demonstrate the beneﬁt of this RL approach for developing stateof-the-art map exploration policies and Kolter et al., 2008 employed a space-indexed
variant to learn trajectory following tasks with an autonomous vehicle and a RC car.
Demonstrations by a Teacher.
Demonstrations by a teacher can be obtained in two
diﬀerent scenarios. In the ﬁrst, the teacher demonstrates the task using his or her own
body; in the second, the teacher controls the robot to do the task. The ﬁrst scenario is
limited by the embodiment issue, as the movement of a human teacher usually cannot be
mapped directly to the robot due to diﬀerent physical constraints and capabilities. For
example, joint angles of a human demonstrator need to be adapted to account for the
kinematic diﬀerences between the teacher and the robot. Often it is more advisable to
only consider task-relevant information, such asthe Cartesian positions and velocities of
the end-eﬀector and the object. Demonstrations obtained by motion-capture have been
used to learn a pendulum swingup , ball-in-a-cup and grasping .
The second scenario obtains demonstrations by a human teacher directly controlling
the robot. Here the human teacher ﬁrst has to learn how to achieve a task with the
particular robot’s hardware, adding valuable prior knowledge. For example, remotely
5That is, a probability distribution over states that will be encountered when following a good policy.
controlling the robot initialized a Q-table for a navigation task . If the robot is back-drivable, kinesthetic teach-in (i.e., by taking it by the hand
and moving it) can be employed, which enables the teacher to interact more closely with
the robot. This method has resulted in applications including T-ball batting , reaching tasks , ball-in-a-cup
 , ﬂipping a light switch , playing pool and
manipulating a box , and opening a door and picking up objects
 . A marble maze task can be learned using demonstrations
by a human player .
One of the more stunning demonstrations of the beneﬁt of learning from a teacher is
the helicopter airshows of . This approach combines initial human
demonstration of trajectories, machine learning to extract approximate models from multiple trajectories, and classical locally-optimal control methods to achieve state-of-the-art acrobatic ﬂight.
Hand-Crafted Policies.
When human interaction with the system is not straightforward
due to technical reasons or human limitations, a pre-programmed policy can provide alternative demonstrations. For example, a vision-based mobile robot docking task can be
learned faster with such a basic behavior than using Q-learning alone, as demonstrated in
 Providing hand-coded, stable initial gaits can signiﬁcantly help in learning robot locomotion, as shown on a six-legged robot as well as on a biped . Alternatively, hand-crafted policies can yield important corrective actions as prior knowledge
that prevent the robot to deviates signiﬁcantly from the desired behavior and endanger
itself. This approach has been applied to adapt the walking patterns of a robot dog
to new surfaces by Q-learning. Rosenstein and Barto
 employed a stable controller to teach the robot about favorable actions and avoid
risky behavior while learning to move from a start to a goal position.
5.2 Prior Knowledge Through Task Structuring
Often a task can be decomposed hierarchically into basic components or into a sequence
of increasingly diﬃcult tasks. In both cases the complexity of the learning task is significantly reduced.
Hierarchical Reinforcement Learning.
A task can often be decomposed into diﬀerent
levels. For example when using meta-actions (Section 4.1), these meta-actions correspond to a lower level dealing with the execution of sub-tasks which are coordinated by
a strategy level. Hierarchical reinforcement learning does not assume that all but one
levels are ﬁxed but rather learns all of them simultaneously.
For example, hierarchical Q-learning has been used to learn diﬀerent behavioral levels for a six legged robot:
moving single legs, locally moving the complete body, and globally moving the robot
towards a goal . A stand-up behavior considered as a hierarchical reinforcement learning task has been learned using Q-learning in the upper-level and a
Demonstration
Employed by. . .
Atkeson and Schaal ; Bentivegna et al. ; Bitzer et al.
 ; Conn and Peters II ; Gräve et al. ; Kober et al.
 ; Kober and Peters ; Latzke et al. ; Peters and
Schaal 
Birdwell and Livingston ; Erden and Leblebicioğlu ;
Martínez-Marín and Duckett ; Rosenstein and Barto ;
Smart and Kaelbling ; Tedrake ; Tedrake et al. ;
Wang et al. 
Task Structure
Employed by. . .
Hierarchical
Daniel et al. ; Donnart and Meyer ; Hart and Grupen
 ; Huber and Grupen ; Kirchner ; Morimoto and
Doya ; Muelling et al. ; Whitman and Atkeson 
Progressive Tasks
Asada et al. ; Randløv and Alstrøm 
Directed Exploration with Prior Knowledge
Employed by. . .
Exploration
Huang and Weng ; Kroemer et al. ; Pendrith 
Table 4: This table illustrates diﬀerent methods of making robot reinforcement learning
tractable by incorporating prior knowledge.
continuous actor-critic method in the lower level . Navigation in a maze can be learned using an actor-critic architecture by tuning the inﬂuence of
diﬀerent control modules and learning these modules . Huber
and Grupen combine discrete event system and reinforcement learning techniques
to learn turning gates for a quadruped. Hart and Grupen learn to bi-manual manipulation tasks by assembling policies hierarchically. Daniel et al. learn options
in a tetherball scenario and Muelling et al. learn diﬀerent strokes in a table tennis
scenario. Whitman and Atkeson show that the optimal policy for some global
systems (like a walking controller) can be constructed by ﬁnding the optimal controllers
for simpler subsystems and coordinating these.
Progressive Tasks.
Often complicated tasks are easier to learn if simpler tasks can
already be performed. This progressive task development is inspired by how biological
systems learn. For example, a baby ﬁrst learns how to roll, then how to crawl, then
how to walk. A sequence of increasingly diﬃcult missions has been employed to learn a
goal shooting task in using Q-learning. Randløv and Alstrøm 
discuss shaping the reward function to include both a balancing and a goal oriented term
for a simulated bicycle riding task. The reward is constructed in such a way that the
balancing term dominates the other term and, hence, this more fundamental behavior is
learned ﬁrst.
5.3 Directing Exploration with Prior Knowledge
As discussed in Section 2.1, balancing exploration and exploitation is an important consideration. Task knowledge can be employed to guide to robots curiosity to focus on
regions that are novel and promising at the same time. For example, a mobile robot
learns to direct attention by employing a modiﬁed Q-learning approach using novelty
 . Using “corrected truncated returns” and taking into account
the estimator variance, a six legged robot employed with stepping reﬂexes can learn to
walk . Oﬄine search can be used to guide Q-learning during a grasping
task . Using upper conﬁdence bounds to direct exploration into regions with potentially high rewards, grasping can be learned eﬃciently
 .
6 Tractability Through Models
In Section 2, we discussed robot reinforcement learning from a model-free perspective
where the system simply served as a data generating process. Such model-free reinforcement algorithms try to directly learn the value function or the policy without any explicit
modeling of the transition dynamics. In contrast, many robot reinforcement learning
problems can be made tractable by learning forward models, i.e., approximations of the
transition dynamics based on data. Such model-based reinforcement learning approaches
jointly learn a model of the system with the value function or the policy and often allow
for training with less interaction with the the real environment. Reduced learning on the
real robot is highly desirable as simulations are frequently faster than real-time while safer
for both the robot and its environment. The idea of combining learning in simulation
and in the real environment was popularized by the Dyna-architecture ,
prioritized sweeping , and incremental multi-step Q-learning
 in reinforcement learning. In robot reinforcement learning,
the learning step on the simulated system is often called “mental rehearsal”. We ﬁrst
discuss the core issues and techniques in mental rehearsal for robotics (Section 6.1), and,
subsequently, we discuss learning methods that have be used in conjunction with learning with forward models (Section 6.2). An overview of publications using simulations to
render the learning problem tractable is presented in Table 5.
6.1 Core Issues and General Techniques in Mental Rehearsal
Experience collected in the real world can be used to learn a forward model from data. Such forward models allow training by interacting
with a simulated environment. Only the resulting policy is subsequently transferred to
the real environment. Model-based methods can make the learning process substantially
more sample eﬃcient. However, depending on the type of model, these methods may
require a great deal of memory.
In the following paragraphs, we deal with the core
issues of mental rehearsal: simulation biases, stochasticity of the real world, and eﬃcient
optimization when sampling from a simulator.
Dealing with Simulation Biases.
It is impossible to obtain a forward model that is
accurate enough to simulate a complex real-world robot system without error. If the
learning methods require predicting the future or using derivatives, even small inaccuracies can quickly accumulate, signiﬁcantly amplifying noise and errors .
Reinforcement learning approaches exploit such model inaccuracies if they are beneﬁcial
for the reward received in simulation . The resulting policies
may work well with the forward model (i.e., the simulator) but poorly on the real system.
This is known as simulation bias. It is analogous to over-ﬁtting in supervised learning –
that is, the algorithm is doing its job well on the model and the training data, respectively, but does not generalize well to the real system or novel data. Simulation bias often
leads to biased, potentially physically non-feasible solutions while even iterating between
model learning and policy will have slow convergence. Averaging over the model uncertainty in probabilistic models can be used to reduce the bias; see the next paragraph for
examples. Another result from these simulation biases is that relatively few researchers
have successfully demonstrated that a policy learned in simulation can directly be transferred to a real robot while maintaining a high level of performance. The few examples
include maze navigation tasks ,
obstacle avoidance for a mobile robot, very basic robot soccer and multi-legged robot locomotion .
Nevertheless, simulation biases can be addressed by introducing stochastic models or
distributions over models even if the system is very close to deterministic. Artiﬁcially
adding a little noise will smooth model errors and avoid policy over-ﬁtting . On the downside, potentially very precise policies may be eliminated due to their fragility in the presence of noise. This technique can be beneﬁcial in
all of the approaches described in this section. Nevertheless, in recent work, Ross and
Bagnell presented an approach with strong guarantees for learning the model and
policy in an iterative fashion even if the true system is not in the model class, indicating
that it may be possible to deal with simulation bias.
Distributions over Models for Simulation.
Model learning methods that maintain
probabilistic uncertainty about true system dynamics allow the RL algorithm to generate distributions over the performance of a policy. Such methods explicitly model the
uncertainty associated with the dynamics at each state and action. For example, when
using a Gaussian process model of the transition dynamics, a policy can be evaluated by
propagating the state and associated uncertainty forward in time. Such evaluations in
the model can be used by a policy search approach to identify where to collect more data
to improve a policy, and may be exploited to ensure that control is safe and robust to
model uncertainty . When the new policy
is evaluated on the real system, the novel observations can subsequently be incorporated
into the forward model. Bagnell and Schneider showed that maintaining model
uncertainty and using it in the inner-loop of a policy search method enabled eﬀective
ﬂight control using only minutes of collected data, while performance was compromised
by considering a best-ﬁt model. This approach uses explicit Monte-Carlo simulation in
the sample estimates.
By treating model uncertainty as if it were noise as well as employing analytic approximations of forward simulation, a cart-pole task can be solved
with less than 20 seconds of interaction with the physical system ; a visually driven block-stacking task has also been learned data-eﬃciently
 . Similarly, solving a linearized control problem with multiple
probabilistic models and combining the resulting closed-loop control with open-loop control has resulted in autonomous sideways sliding into a parking spot .
Instead of learning a model of the system dynamics, Lizotte et al. directly learned
the expected return as a function of the policy parameters using Gaussian process regression in a black-box fashion, and, subsequently, searched for promising parameters in
this model. The method has been applied to optimize the gait of an Aibo robot.
Sampling by Re-Using Random Numbers.
A forward model can be used as a simulator to create roll-outs for training by sampling. When comparing results of diﬀerent
simulation runs, it is often hard to tell from a small number of samples whether a policy
really worked better or whether the results are an eﬀect of the simulated stochasticity.
Using a large number of samples to obtain proper estimates of the expectations become
prohibitively expensive if a large number of such comparisons need to be performed
(e.g., for gradient estimation within an algorithm). A common technique in the statistics and simulation community to address this problem is to re-use the
Figure 7: Autonomous inverted helicopter ﬂight (Picture reprint with
permission of Andrew Ng).
series of random numbers in ﬁxed models, hence mitigating the noise contribution. Ng
et al. extended this approach for learned simulators. The resulting approach,
PEGASUS, found various applications in the learning of maneuvers for autonomous helicopters , as illustrated
in Figure 7. It has been used to learn control parameters for a RC car and an autonomous blimp .
While mental rehearsal has a long history in robotics, it is currently becoming again a
hot topic, especially due to the work on probabilistic virtual simulation.
6.2 Successful Learning Approaches with Forward Models
Model-based approaches rely on an approach that ﬁnds good policies using the learned
model. In this section, we discuss methods that directly obtain a new policy candidate
directly from a forward model. Some of these methods have a long history in optimal
control and only work in conjunction with a forward model.
Iterative Learning Control.
A powerful idea that has been developed in multiple forms
in both the reinforcement learning and control communities is the use of crude, approximate models to determine gradients, e.g., for an update step. The resulting new policy
is then evaluated in the real world and the model is updated. This approach is known as
iterative learning control . A similar preceding idea was employed
to minimize trajectory tracking errors and is loosely related to feedback
error learning . More recently, variations on the iterative learning control
has been employed to learn robot control , steering
a RC car with a general analysis of approximate models for policy search in , a pick and place task , and an impressive application
of tying knots with a surgical robot at superhuman speeds .
Core Issues and General Techniques in Mental Rehearsal
Employed by. . .
Dealing with
Simulation Biases
An et al. ; Atkeson and Schaal ; Atkeson ;
Bakker et al. ; Duan et al. ; Fagg et al. ; Ilg
et al. ; Jakobi et al. ; Oßwald et al. ; Ross and
Bagnell ; Svinin et al. ; Youssef 
Distributions over
Models for
Simulation
Bagnell and Schneider ; Deisenroth and Rasmussen ;
Deisenroth et al. ; Kolter et al. ; Lizotte et al. 
Sampling by
Re-Using Random
Bagnell and Schneider ; Bagnell ; Ko et al. ;
Michels et al. ; Ng et al. 
Successful Learning Approaches with Forward Models
Employed by. . .
Iterative Learning
Abbeel et al. ; An et al. ; van den Berg et al. ;
Bukkems et al. ; Freeman et al. ; Norrlöf 
Locally Linear
Regulators
Atkeson and Schaal ; Atkeson ; Coates et al. ;
Kolter et al. ; Schaal and Atkeson ; Tedrake et al.
Value Function
Methods with
Learned Models
Bakker et al. ; Nemec et al. ; Uchibe et al. 
Policy Search with
Learned Models
Bagnell and Schneider ; Bagnell ; Deisenroth et al.
 ; Deisenroth and Rasmussen ; Kober and Peters
 ; Ng et al. ; Peters et al. 
Table 5: This table illustrates diﬀerent methods of making robot reinforcement learning
tractable using models.
Locally Linear Quadratic Regulators.
Instead of sampling from a forward model-based
simulator, such learned models can be directly used to compute optimal control policies.
This approach has resulted in a variety of robot reinforcement learning applications that
include pendulum swing-up tasks learned with DDP , devil-sticking (a form of gyroscopic juggling) obtained with local LQR solutions
 , trajectory following with space-indexed controllers trained
with DDP for an autonomous RC car , and the aerobatic helicopter
ﬂight trained with DDP discussed above .
Value Function Methods with Learned Models.
Obviously, mental rehearsal can be
used straightforwardly with value function methods by simply pretending that the simulated roll-outs were generated from the real system. Learning in simulation while the
computer is idle and employing directed exploration allows Q-learning to learn a navigation task from scratch in 20 minutes . Two robots taking turns in
learning a simpliﬁed soccer task were also able to proﬁt from mental rehearsal . Nemec et al. used a value function learned in simulation to initialize the real robot learning. However, it is clear that model-based methods that use the
model for creating more direct experience should potentially perform better.
Policy Search with Learned Models.
Similarly as for value function methods, all
model-free policy search methods can be used in conjunction with learned simulators.
For example, both pairwise comparisons of policies and policy gradient approaches have
been used with learned simulators . Transferring EM-like policy search Kober and Peters and Relative Entropy Policy Search Peters et al. appears to be a natural next step. Nevertheless,
as mentioned in Section 6.1, a series of policy update methods has been suggested that
were tailored for probabilistic simulation Deisenroth et al. ; Deisenroth and Rasmussen ; Lizotte et al. .
There still appears to be the need for new methods that make better use of the model
knowledge, both in policy search and for value function methods.
7 A Case Study: Ball-in-a-Cup
Up to this point in this paper, we have reviewed a large variety of problems and associated solutions within robot reinforcement learning. In this section, we will take a
complementary approach and discuss one task in detail that has previously been studied.
This ball-in-a-cup task due to its relative simplicity can serve as an example to highlight
some of the challenges and methods that were discussed earlier. We do not claim that the
method presented is the best or only way to address the presented problem; instead, our
goal is to provide a case study that shows design decisions which can lead to successful
robotic reinforcement learning.
In Section 7.1, the experimental setting is described with a focus on the task and the
reward. Section 7.2 discusses a type of pre-structured policies that has been particu-
(a) Schematic drawings of the ball-in-a-cup motion
(b) Kinesthetic teach-in
(c) Final learned robot motion
Figure 8: This ﬁgure shows schematic drawings of the ball-in-a-cup motion (a), the ﬁnal
learned robot motion (c), as well as a kinesthetic teach-in (b). The green arrows
show the directions of the current movements in that frame. The human cup
motion was taught to the robot by imitation learning. The robot manages to
reproduce the imitated motion quite accurately, but the ball misses the cup by
several centimeters. After approximately 75 iterations of the Policy learning
by Weighting Exploration with the Returns (PoWER) algorithm the robot has
improved its motion so that the ball regularly goes into the cup.
larly useful in robotics. Inclusion of prior knowledge is presented in Section 7.3. The
advantages of the employed policy search algorithm are explained in Section 7.4. The
use of simulations in this task is discussed in Section 7.5 and results on the real robot
are described in Section 7.6. Finally, an alternative reinforcement learning approach is
brieﬂy explored in Section 7.7.
7.1 Experimental Setting: Task and Reward
The children’s game ball-in-a-cup, also known as balero and bilboquet, is challenging even
for adults. The toy consists of a small cup held in one hand (in this case, it is attached
to the end-eﬀector of the robot) and a small ball hanging on a string attached to the
cup’s bottom (for the employed toy, the string is 40cm long). Initially, the ball is at
rest, hanging down vertically. The player needs to move quickly to induce motion in the
ball through the string, toss the ball in the air, and catch it with the cup. A possible
movement is illustrated in Figure 8a.
The state of the system can be described by joint angles and joint velocities of the
robot as well as the Cartesian coordinates and velocities of the ball (neglecting states
that cannot be observed straightforwardly like the state of the string or global room
air movement). The actions are the joint space accelerations, which are translated into
torques by a ﬁxed inverse dynamics controller.
Thus, the reinforcement learning approach has to deal with twenty state and seven action dimensions, making discretization
infeasible.
An obvious reward function would be a binary return for the whole episode, depending
on whether the ball was caught in the cup or not. In order to give the reinforcement
learning algorithm a notion of closeness, Kober and Peters initially used a reward
function based solely on the minimal distance between the ball and the cup. However, the
algorithm has exploited rewards resulting from hitting the cup with the ball from below
or from the side, as such behaviors are easier to achieve and yield comparatively high
rewards. To avoid such local optima, it was essential to ﬁnd a good reward function that
contains the additional prior knowledge that getting the ball into the cup is only possible
from one direction. Kober and Peters expressed this constraint by computing
the reward as r(tc) = exp
−α(xc −xb)2 −α(yc −yb)2&
while r (t) = 0 for all t ̸= tc.
Here, tc corresponds to the time step when the ball passes the rim of the cup with a
downward direction, the cup position is denoted by [xc, yc, zc] ∈R3, the ball position
is [xb, yb, zb] ∈R3 and the scaling parameter α = 100. This reward function does not
capture the case where the ball does not pass above the rim of the cup, as the reward
will always be zero. The employed approach performs a local policy search, and hence,
an initial policy that brings the ball above the rim of the cup was required.
The task exhibits some surprising complexity as the reward is not only aﬀected by
the cup’s movements but foremost by the ball’s movements. As the ball’s movements
are very sensitive to small perturbations, the initial conditions, or small arm movement
changes will drastically aﬀect the outcome. Creating an accurate simulation is hard due
to the nonlinear, unobservable dynamics of the string and its non-negligible weight.
7.2 Appropriate Policy Representation
The policy is represented by dynamical system motor primitives . The global movement is encoded as a point attractor linear dynamical system with an additional local transformation that allows a very parsimonious
representation of the policy. This framework ensures the stability of the movement and
allows the representation of arbitrarily shaped movements through the primitive’s policy
parameters. These parameters can be estimated straightforwardly by locally weighted
regression. Note that the dynamical systems motor primitives ensure the stability of
the movement generation but cannot guarantee the stability of the movement execution.
These primitives can be modiﬁed through their meta-parameters in order to adapt to
the ﬁnal goal position, the movement amplitude, or the duration of the movement. The
resulting movement can start from arbitrary positions and velocities and go to arbitrary
ﬁnal positions while maintaining the overall shape of the trajectory.
While the original formulation in for discrete dynamical systems
motor primitives used a second-order system to represent the phase z of the movement,
this formulation has proven to be unnecessarily complicated in practice. Since then, it
has been simpliﬁed and, in , it was shown that a single ﬁrst order
system suﬃces
˙z = −ταzz.
This canonical system has the time constant τ = 1/T where T is the duration of the
motor primitive, a parameter αz which is chosen such that z ≈0 at T to ensure that the
inﬂuence of the transformation function, shown in Equation (9), vanishes. Subsequently,
the internal state x of a second system is chosen such that positions q of all degrees of
freedom are given by q = x1, the velocities ˙q by ˙q = τx2 = ˙x1 and the accelerations ¨q
by ¨q = τ ˙x2. Under these assumptions, the learned dynamics of Ijspeert motor primitives
can be expressed in the following form
˙x2 = ταx (βx (g −x1) −x2) + τAf (z) ,
˙x1 = τx2.
This set of diﬀerential equations has the same time constant τ as the canonical system,
parameters αx, βx set such that the system is critically damped, a goal parameter g, a
transformation function f and an amplitude matrix A = diag(a1, a2, . . . , an), with the
amplitude modiﬁer a = [a1, a2, . . . , an]. In , they use a = g −x0
with the initial position x0
1, which ensures linear scaling. Alternative choices are possibly
better suited for speciﬁc tasks, see e.g., . The transformation function
f (z) alters the output of the ﬁrst system, in Equation (7), so that the second system, in
Equation (8), can represent complex nonlinear patterns and it is given by
f (z) = $N
i=1ψi (z) wiz.
Here, wi contains the ith adjustable parameter of all degrees of freedom, N is the number
of parameters per degree of freedom, and ψi(z) are the corresponding weighting functions
 . Normalized Gaussian kernels are used as weighting functions given
−hi (z −ci)24
−hj (z −cj)24.
These weighting functions localize the interaction in phase space using the centers ci and
widths hi. Note that the degrees of freedom (DoF) are usually all modeled as independent
in Equation (8). All DoFs are synchronous as the dynamical systems for all DoFs start
at the same time, have the same duration, and the shape of the movement is generated
using the transformation f (z) in Equation (9). This transformation function is learned
as a function of the shared canonical system in Equation (7).
This policy can be seen as a parameterization of a mean policy in the form ¯a =
θTµ(s, t), which is linear in parameters.
Thus, it is straightforward to include prior
knowledge from a demonstration using supervised learning by locally weighted regression.
This policy is augmented by an additive exploration ϵ(s, t) noise term to make policy
search methods possible. As a result, the explorative policy can be given in the form
a = θTµ(s, t) + ϵ(µ(s, t)). Some policy search approaches have previously used stateindependent, white Gaussian exploration, i.e., ϵ(µ(s, t)) ∼N(0, Σ).
However, such
unstructured exploration at every step has several disadvantages, notably: (i) it causes
a large variance which grows with the number of time-steps, (ii) it perturbs actions too
frequently, thus, “washing out” their eﬀects and (iii) it can damage the system that is
executing the trajectory.
Alternatively, one could generate a form of structured, state-dependent exploration
 ϵ(µ(s, t)) = εT
t µ(s, t) with [εt]ij ∼N(0, σ2
ij), where σ2
meta-parameters of the exploration that can also be optimized. This argument results
in the policy a = (θ + εt)T µ(s, t) corresponding to the distribution a ∼π(at|st, t) =
N(a|θTµ(s, t), µ(s, t)T ˆΣ(s, t)). Instead of directly exploring in action space, this type
of policy explores in parameter space.
7.3 Generating a Teacher Demonstration
Children usually learn this task by ﬁrst observing another person presenting a demonstration. They then try to duplicate the task through trial-and-error-based learning. To
mimic this process, the motor primitives were ﬁrst initialized by imitation. Subsequently,
they were improved them by reinforcement learning.
A demonstration for imitation was obtained by recording the motions of a human
player performing kinesthetic teach-in as shown in Figure 8b. Kinesthetic teach-in means
“taking the robot by the hand”, performing the task by moving the robot while it is in
gravity-compensation mode, and recording the joint angles, velocities and accelerations.
It requires a back-drivable robot system that is similar enough to a human arm to not
cause embodiment issues. Even with demonstration, the resulting robot policy fails to
catch the ball with the cup, leading to the need for self-improvement by reinforcement
learning. As discussed in Section 7.1, the initial demonstration was needed to ensure
that the ball goes above the rim of the cup.
7.4 Reinforcement Learning by Policy Search
Policy search methods are better suited for a scenario like this, where the task is episodic,
local optimization is suﬃcient (thanks to the initial demonstration), and high dimensional, continuous states and actions need to be taken into account. A single update
step in a gradient based method usually requires as many episodes as parameters to be
optimized. Since the expected number of parameters was in the hundreds, a diﬀerent
approach had to be taken because gradient based methods are impractical in this scenario. Furthermore, the step-size parameter for gradient based methods often is a crucial
parameter that needs to be tuned to achieve good performance. Instead, an expectationmaximization inspired algorithm was employed that requires signiﬁcantly less samples
and has no learning rate.
Kober and Peters have derived a framework of reward weighted imitation. Based
on they consider the return of an episode as an improper probability distribution. A lower bound of the logarithm of the expected return is maximized.
Depending on the strategy of optimizing this lower bound and the exploration strategy,
the framework yields several well known policy search algorithms as well as the novel Policy learning by Weighting Exploration with the Returns (PoWER) algorithm. PoWER
is an expectation-maximization inspired algorithm that employs state-dependent exploration (as discussed in Section 7.2). The update rule is given by
θ′ = θ + E
W (st, t) Qπ (st, at, t)
W (st, t) εtQπ(st, at, t)
where W (st, t) = µ(s, t)µ(s, t)T 3
µ(s, t)T ˆΣµ(s, t)
. Intuitively, this update can be
seen as a reward-weighted imitation, (or recombination) of previously seen episodes.
Depending on its eﬀect on the state-action value function, the exploration of each episode
is incorporated more or less strongly into the updated policy. To reduce the number
of trials in this on-policy scenario, the trials are reused through importance sampling
 . To avoid the fragility that sometimes results from importance
sampling in reinforcement learning, samples with very small importance weights were
discarded. In essence, this algorithm performs a local search around the policy learned
from demonstration and prior knowledge.
7.5 Use of Simulations in Robot Reinforcement Learning
The robot is simulated by rigid body dynamics with parameters estimated from data.
The toy is simulated as a pendulum with an elastic string that switches to a ballistic
point mass when the ball is closer to the cup than the string is long. The spring, damper
and restitution constants were tuned to match data recorded on a VICON system. The
SL framework allowed us to switch between the simulated robot and the
real one with a simple recompile. Even though the simulation matches recorded data
very well, policies that get the ball in the cup in simulation usually missed the cup by
several centimeters on the real system and vice-versa. One conceivable approach could
be to ﬁrst improve a demonstrated policy in simulation and only perform the ﬁne-tuning
on the real robot.
However, this simulation was very helpful to develop and tune the algorithm as it
runs faster in simulation than real-time and does not require human supervision or intervention. The algorithm was initially conﬁrmed and tweaked with unrelated, simulated
benchmark tasks ). The use of an importance sampler was essential to achieve good performance and required many tests over the course
of two weeks. A very crude importance sampler that considers only the n best previous
episodes worked suﬃciently well in practice. Depending on the number n the algorithm
exhibits are more or less pronounced greedy behavior. Additionally there are a number
of possible simpliﬁcations for the learning algorithm, some of which work very well in
practice even if the underlying assumption do not strictly hold in reality. The ﬁnally
employed variant
t=1 εtQπ(st, at, t)
t=1 Qπ(st, at, t)
assumes that only a single basis function is active at a given time, while there is actually
some overlap for the motor primitive basis functions. The importance sampler is denoted
by ⟨!⟩ω(τ). The implementation is further simpliﬁed as the reward is zero for all but one
time-step per episode.
To adapt the algorithm to this particular task, the most important parameters to tune
were the “greediness” of the importance sampling, the initial magnitude of the exploration, and the number of parameters for the policy. These parameters were identiﬁed
by a coarse grid search in simulation with various initial demonstrations and seeds for
the random number generator. Once the simulation and the grid search were coded, this
process only took a few minutes. The exploration parameter is fairly robust if it is in the
same order of magnitude as the policy parameters. For the importance sampler, using
the 10 best previous episodes was a good compromise. The number of policy parameters
needs to be high enough to capture enough details to get the ball above the rim of the
cup for the initial demonstration. On the other hand, having more policy parameters will
potentially slow down the learning process. The number of needed policy parameters for
various demonstrations were in the order of 30 parameters per DoF. The demonstration
employed for the results shown in more detail in this paper employed 31 parameters per
DoF for an approximately 3 second long movement, hence 217 policy parameters total.
Having three times as many policy parameters slowed down the convergence only slightly.
7.6 Results on the Real Robot
The ﬁrst run on the real robot used the demonstration shown in Figure 8 and directly
worked without any further parameter tuning. For the ﬁve runs with this demonstration,
which took approximately one hour each, the robot got the ball into the cup for the
ﬁrst time after 42-45 episodes and regularly succeeded at bringing the ball into the cup
after 70-80 episodes. The policy always converged to the maximum after 100 episodes.
Running the real robot experiment was tedious as the ball was tracked by a stereo vision
system, which sometimes failed and required a manual correction of the reward.
the string frequently entangles during failures and the robot cannot unravel it, human
intervention is required. Hence, the ball had to be manually reset after each episode.
If the constraint of getting the ball above the rim of the cup for the initial policy is
fulﬁlled, the presented approach works well for a wide variety of initial demonstrations
including various teachers and two diﬀerent movement strategies (swinging the ball or
pulling the ball straight up).
Convergence took between 60 and 130 episodes, which
largely depends on the initial distance to the cup but also on the robustness of the
demonstrated policy.
7.7 Alternative Approach with Value Function Methods
Nemec et al. employ an alternate reinforcement learning approach to achieve the
ball-in-a-cup task with a Mitsubishi PA10 robot. They decomposed the task into two
sub-tasks, the swing-up phase and the catching phase. In the swing-up phase, the ball
is moved above the cup. In the catching phase, the ball is caught with the cup using
an analytic prediction of the ball trajectory based on the movement of a ﬂying point
mass. The catching behavior is ﬁxed; only the swing-up behavior is learned. The paper
proposes to use SARSA to learn the swing-up movement. The states consist of the cup
positions and velocities as well as the angular positions and velocities of the ball. The
actions are the accelerations of the cup in a single Cartesian direction.
Tractability
is achieved by discretizing both the states (324 values) and the actions (5 values) and
initialization by simulation. The behavior was ﬁrst learned in simulation requiring 220 to
300 episodes. The state-action value function learned in simulation was used to initialize
the learning on the real robot. The robot required an additional 40 to 90 episodes to
adapt the behavior learned in simulation to the real environment.
8 Discussion
We have surveyed the state of the art in robot reinforcement learning for both general
reinforcement learning audiences and robotics researchers to provide possibly valuable
insight into successful techniques and approaches.
From this overview, it is clear that using reinforcement learning in the domain of
robotics is not yet a straightforward undertaking but rather requires a certain amount
of skill. Hence, in this section, we highlight several open questions faced by the robotic
reinforcement learning community in order to make progress towards “oﬀ-the-shelf” approaches as well as a few current practical challenges.
Finally, we try to summarize
several key lessons from robotic reinforcement learning for the general reinforcement
learning community.
8.1 Open Questions in Robotic Reinforcement Learning
Reinforcement learning is clearly not applicable to robotics “out of the box” yet, in
contrast to supervised learning where considerable progress has been made in large-scale,
easy deployment over the last decade. As this paper illustrates, reinforcement learning
can be employed for a wide variety of physical systems and control tasks in robotics. It
is unlikely that single answers do exist for such a heterogeneous ﬁeld, but even for very
closely related tasks, appropriate methods currently need to be carefully selected. The
user has to decide when suﬃcient prior knowledge is given and learning can take over. All
methods require hand-tuning for choosing appropriate representations, reward functions,
and the required prior knowledge. Even the correct use of models in robot reinforcement
learning requires substantial future research. Clearly, a key step in robotic reinforcement
learning is the automated choice of these elements and having robust algorithms that
limit the required tuning to the point where even a naive user would be capable of using
robotic RL.
How to choose representations automatically?
The automated selection of appropriate representations remains a diﬃcult problem as the action space in robotics often is
inherently continuous and multi-dimensional. While there are good reasons for using
the methods presented in Section 4 in their respective domains, the question whether
to approximate states, value functions, policies – or a mix of the three – remains open.
The correct methods to handle the inevitability of function approximation remain under
intense study, as does the theory to back it up.
How to generate reward functions from data?
Good reward functions are always essential to the success of a robot reinforcement learning approach (see Section 3.4). While
inverse reinforcement learning can be used as an alternative to manually designing the reward function, it relies on the design of features that capture the important aspects of the
problem space instead. Finding feature candidates may require insights not altogether
diﬀerent from the ones needed to design the actual reward function.
How much can prior knowledge help? How much is needed?
Incorporating prior
knowledge is one of the main tools to make robotic reinforcement learning tractable (see
Section 5). However, it is often hard to tell in advance how much prior knowledge is
required to enable a reinforcement learning algorithm to succeed in a reasonable number
of episodes. For such cases, a loop of imitation and reinforcement learning may be a
desirable alternative. Nevertheless, sometimes, prior knowledge may not help at all. For
example, obtaining initial policies from human demonstrations can be virtually impossible if the morphology of the robot is too diﬀerent from a human’s ). Whether alternative forms of prior
knowledge can help here may be a key question to answer.
How to integrate more tightly with perception?
Much current work on robotic reinforcement learning relies on subsystems that abstract away perceptual information, limiting the techniques to simple perception systems and heavily pre-processed data. This
abstraction is in part due to limitations of existing reinforcement learning approaches
at handling inevitably incomplete, ambiguous and noisy sensor data. Learning active
perception jointly with the robot’s movement and semantic perception are open problems that present tremendous opportunities for simplifying as well as improving robot
behavior programming.
How to reduce parameter sensitivity?
Many algorithms work fantastically well for a
very narrow range of conditions or even tuning parameters. A simple example would be
the step size in a gradient based method. However, searching anew for the best parameters for each situation is often prohibitive with physical systems. Instead algorithms
that work fairly well for a large range of situations and parameters are potentially much
more interesting for practical robotic applications.
How to deal with model errors and under-modeling?
Model based approaches can
signiﬁcantly reduce the need for real-world interactions.
Methods that are based on
approximate models and use local optimization often work well (see Section 6). As realworld samples are usually more expensive than comparatively cheap calculations, this
may be a signiﬁcant advantage. However, for most robot systems, there will always be
under-modeling and resulting model errors. Hence, the policies learned only in simulation
frequently cannot be transferred directly to the robot.
This problem may be inevitable due to both uncertainty about true system dynamics,
the non-stationarity of system dynamics6 and the inability of any model in our class
to be perfectly accurate in its description of those dynamics, which have led to robust
control theory . Reinforcement learning approaches mostly require the behavior designer to deal with this problem by incorporating model uncertainty
with artiﬁcial noise or carefully choosing reward functions to discourage controllers that
generate frequencies that might excite unmodeled dynamics.
Tremendous theoretical and algorithmic challenges arise from developing algorithms
that are robust to both model uncertainty and under-modeling while ensuring fast learning and performance. A possible approach may be the full Bayesian treatment of the
impact of possible model errors onto the policy but has the risk of generating overly
conservative policies, as also happened in robust optimal control.
This list of questions is by no means exhaustive, however, it provides a fair impression
of the critical issues for basic research in this area.
8.2 Practical Challenges for Robotic Reinforcement Learning
More applied problems for future research result from practical challenges in robot reinforcement learning:
Exploit Data Sets Better.
Humans who learn a new task build upon previously learned
skills. For example, after a human learns how to throw balls, learning how to throw darts
becomes signiﬁcantly easier. Being able to transfer previously-learned skills to other tasks
and potentially to robots of a diﬀerent type is crucial. For complex tasks, learning cannot
be achieved globally. It is essential to reuse other locally learned information from past
data sets. While such transfer learning has been studied more extensively in other parts
of machine learning, tremendous opportunities for leveraging such data exist within robot
reinforcement learning. Making such data sets with many skills publicly available would
be a great service for robotic reinforcement learning research.
6Both the environment and the robot itself change dynamically; for example, vision systems depend on
the lighting condition and robot dynamics change with wear and the temperature of the grease.
Comparable Experiments and Consistent Evaluation.
The diﬃculty of performing,
and reproducing, large scale experiments due to the expense, fragility, and diﬀerences
between hardware remains a key limitation in robotic reinforcement learning. The current movement towards more standardization within robotics may aid these eﬀorts signiﬁcantly, e.g., by possibly providing a standard robotic reinforcement learning setup to
a larger community – both real and simulated. These questions need to be addressed in
order for research in self-improving robots to progress.
8.3 Robotics Lessons for Reinforcement Learning
Most of the article has aimed equally at both reinforcement learning and robotics researchers as well as practitioners. However, this section attempts to convey a few important, possibly provocative, take-home messages for the classical reinforcement learning
community.
Focus on High-Dimensional Continuous Actions and Constant Adaptation.
problems clearly have driven theoretical reinforcement learning research, particularly in
policy search, inverse optimal control approaches, and model robustness. The practical
impact of robotic reinforcement learning problems (e.g., multi-dimensional continuous
action spaces, continuously drifting noise, frequent changes in the hardware and the environment, and the inevitability of undermodeling), may not yet have been suﬃciently
appreciated by the theoretical reinforcement learning community. These problems have
often caused robotic reinforcement learning to take signiﬁcantly diﬀerent approaches
than would be dictated by theory.
Perhaps as a result, robotic reinforcement learning approaches are often closer to classical optimal control solutions than the methods
typically studied in the machine learning literature.
Exploit Domain Structure for Scalability.
The grounding of RL in robotics alleviates
the general problem of scaling reinforcement learning into high dimensional domains by
exploiting the structure of the physical world. Prior knowledge of the behavior of the
system and the task is often available. Incorporating even crude models and domain
structure into the learning approach (e.g., to approximate gradients) has yielded impressive results .
Local Optimality and Controlled State Distributions.
Much research in classical reinforcement learning aims at ﬁnding value functions that are optimal over the entire
state space, which is most likely intractable. In contrast, the success of policy search
approaches in robotics relies on their implicit maintenance and controlled change of a
state distribution under which the policy can be optimized. Focusing on slowly changing
state distributions may also beneﬁt value function methods.
Reward Design.
It has been repeatedly demonstrated that reinforcement learning approaches beneﬁt signiﬁcantly from reward shaping , and particularly from
using rewards that convey a notion of closeness and are not only based on simple binary
success or failure. A learning problem is potentially diﬃcult if the reward is sparse, there
are signiﬁcant delays between an action and the associated signiﬁcant reward, or if the
reward is not smooth (i.e., very small changes to the policy lead to a drastically diﬀerent
outcome). In classical reinforcement learning, discrete rewards are often considered, e.g.,
a small negative reward per time-step and a large positive reward for reaching the goal.
In contrast, robotic reinforcement learning approaches often need more physically motivated reward-shaping based on continuous values and consider multi-objective reward
functions like minimizing the motor torques while achieving a task.
We hope that these points will help soliciting more new targeted solutions from the
reinforcement learning community for robotics.
Acknowledgments & Funding
We thank the anonymous reviewers for their valuable suggestions of additional papers
and points for discussion. Their input helped us to signiﬁcantly extend and improve the
The was supported by the European Community’s Seventh Framework Programme
[grant numbers ICT-248273 GeRT, ICT-270327 CompLACS]; the Defense Advanced Research Project Agency through Autonomus Robotics Manipulation-Software and the
Oﬃce of Naval Research Multidisciplinary University Research Initiatives Distributed
Reasoning in Reduced Information Spaces and Provably Stable Vision-Based Control of
High-Speed Flight through Forests and Urban Environments.