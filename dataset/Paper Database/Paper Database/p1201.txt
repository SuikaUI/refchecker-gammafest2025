Adversarial Examples: Attacks and Defenses for
Deep Learning
Xiaoyong Yuan, Pan He, Qile Zhu, Xiaolin Li∗
National Science Foundation Center for Big Learning, University of Florida
{chbrian, pan.he, valder}@uﬂ.edu, 
Abstract—With rapid progress and signiﬁcant successes in a
wide spectrum of applications, deep learning is being applied
in many safety-critical environments. However, deep neural networks have been recently found vulnerable to well-designed input
samples, called adversarial examples. Adversarial examples are
imperceptible to human but can easily fool deep neural networks
in the testing/deploying stage. The vulnerability to adversarial
examples becomes one of the major risks for applying deep neural
networks in safety-critical environments. Therefore, attacks and
defenses on adversarial examples draw great attention. In this
paper, we review recent ﬁndings on adversarial examples for
deep neural networks, summarize the methods for generating
adversarial examples, and propose a taxonomy of these methods.
Under the taxonomy, applications for adversarial examples are
investigated. We further elaborate on countermeasures for adversarial examples and explore the challenges and the potential
solutions.
Index Terms—deep neural network, deep learning, security,
adversarial examples
I. INTRODUCTION
Deep learning (DL) has made signiﬁcant progress in a
wide domain of machine learning (ML): image classiﬁcation,
object recognition , , object detection , , speech
recognition , language translation , voice synthesis .
The online Go Master (AlphaGo ) beat more than 50 top
go players in the world. Recently AlphaGo Zero surpassed
its previous version without using human knowledge and a
generic version, AlphaZero , achieved a superhuman level
within 24 hours of cross domains of chess, Shogi, and Go.
Driven by the emergence of big data and hardware acceleration, deep learning requires less hand engineered features
and expert knowledge. The intricacy of data can be extracted
with higher and more abstract level representation from raw
input features .
Constantly increasing number of real-world applications and
systems have been powered by deep learning. For instance,
companies from IT to the auto industry (e.g., Google, Telsa,
Mercedes, and Uber) are testing self-driving cars, which
require plenty of deep learning techniques such as object
recognition, reinforcement learning, and multimodal learning.
Face recognition system has been deployed in ATMs as a
method of biometric authentication . Apple also provides
face authentication to unlock mobile phones . Behavior-
This work is partially supported by National Science Foundation (grants
CNS-1842407, CNS-1747783, CNS-1624782, and OAC-1229576).
∗Corresponding author.
based malware detection and anomaly detection solutions are
built upon deep learning to ﬁnd semantic features – .
Despite great successes in numerous applications, many of
deep learning empowered applications are life crucial, raising
great concerns in the ﬁeld of safety and security. “With great
power comes great responsibility” . Recent studies ﬁnd
that deep learning is vulnerable against well-designed input
samples. These samples can easily fool a well-performed
deep learning model with little perturbations imperceptible to
Szegedy et al. ﬁrst generated small perturbations on the images for the image classiﬁcation problem and fooled state-ofthe-art deep neural networks with high probability . These
misclassiﬁed samples were named as Adversarial Examples.
Extensive deep learning based applications have been used
or planned to be deployed in the physical world, especially
in the safety-critical environments. In the meanwhile, recent
studies show that adversarial examples can be applied to
real world. For instance, an adversary can construct physical adversarial examples and confuse autonomous vehicles
by manipulating the stop sign in a trafﬁc sign recognition
system , or removing the segmentation of pedestrians
in an object recognition system . Attackers can generate
adversarial commands against automatic speech recognition
(ASR) models and Voice Controllable System (VCS) , 
such as Apple Siri , Amazon Alexa , and Microsoft
Cortana .
Deep learning is widely regarded as a “black box” technique
— we all know that it performs well, but with limited
knowledge of the reason , . Many studies have been
proposed to explain and interpret deep neural networks –
 . From inspecting adversarial examples, we may gain
insights on semantic inner levels of neural networks and
ﬁnd problematic decision boundaries, which in turn helps to
increase robustness and performance of neural networks 
and improve the interpretability .
In this paper, we investigate and summarize approaches for
generating adversarial examples, applications for adversarial
examples and corresponding countermeasures. We explore the
characteristics and possible causes of adversarial examples.
Recent advances in deep learning revolve around supervised
learning, especially in the ﬁeld of computer vision task.
Therefore, most adversarial examples are generated against
computer vision models. We mainly discuss adversarial examples for image classiﬁcation/object recognition tasks in this
paper. Adversarial examples for other tasks will be investigated
 
Table I: Notation and symbols used in this paper
Notations and Symbols
Description
original (clean, unmodiﬁed) input data
label of class in the classiﬁcation problem. l =
1, 2, . . . , m, where m is the number of classes
adversarial example (modiﬁed input data)
label of the adversarial class in targeted adversarial examples
deep learning model (for the image classiﬁcation task, f ∈F : Rn →l)
parameters of deep learning model f
loss function (e.g., cross-entropy) of model f
difference between original and modiﬁed input
data: η = x′ −x (the exact same size as the
input data)
Hessian, the second-order of derivatives
Kullback-Leibler (KL) divergence function
in Section V.
Inspired by , we deﬁne the Threat Model as follows:
• The adversaries can attack only at the testing/deploying
stage. They can tamper only the input data in the testing
stage after the victim deep learning model is trained.
Neither the trained model or the training dataset can be
modiﬁed. The adversaries may have knowledge of trained
models (architectures and parameters) but are not allowed
to modify models, which is a common assumption for
many online machine learning services. Attacking at the
training stage (e.g., training data poisoning) is another
interesting topic and has been studied in – . Due
to the limitation of space, we do not include this topic in
the paper.
• We focus on attacks against models built with deep neural
networks, due to their great performance achieved. We
will discuss adversarial examples against conventional
machine learning (e.g., SVM, Random Forest) in Section II. Adversarial examples against deep neural networks proved effective in conventional machine learning
models (see Section VII-A).
• Adversaries only aim at compromising integrity. Integrity
is presented by performance metrics (e.g., accuracy, F1
score, AUC), which is essential to a deep learning model.
Although other security issues pertaining to conﬁdentiality and privacy have been drawn attention in deep learning – , we focus on the attacks that degrade the
performance of deep learning models, cause an increase
of false positives and false negatives.
• The rest of the threat model differs in different adversarial
attacks. We will categorize them in Section III.
Notations and symbols used in this paper are listed in
This paper presents the following contributions:
• To systematically analyze approaches for generating adversarial examples, we taxonomize attack approaches
along different axes to provide an accessible and intuitive
overview of these approaches.
• We investigate recent approaches and their variants for
generating adversarial examples and compare them using the proposed taxonomy. We show examples of selected applications from ﬁelds of reinforcement learning,
generative modeling, face recognition, object detection,
semantic segmentation, natural language processing, and
malware detection. Countermeasures for adversarial examples are also discussed.
• We outline main challenges and potential future research
directions for adversarial examples based on three main
problems: transferability of adversarial examples, existence of adversarial examples, and robustness evaluation
of deep neural networks.
The remaining of this paper is organized as follows. Section II introduces the background of deep learning techniques,
models, and datasets. We discuss adversarial examples raised
in conventional machine learning in Section II. We propose a
taxonomy of approaches for generating adversarial examples
in Section III and elaborate on these approaches in Section IV.
In Section V, we discuss applications for adversarial examples.
Corresponding countermeasures are investigated in Section VI.
We discuss current challenges and potential solutions in Section VII. Section VIII concludes the work.
II. BACKGROUND
In this section, we brieﬂy introduce basic deep learning
techniques and approaches related to adversarial examples.
Next, we review adversarial examples in the era of conventional ML and compare the difference between adversarial
examples in conventional ML and that in DL.
A. Brief Introduction to Deep Learning
This subsection discusses main concepts, existed techniques,
popular architectures, and standard datasets in deep learning,
which, due to the extensive use and breakthrough successes,
have become acknowledged targets of attacks, where adversaries are usually applied to evaluate their attack methods.
1) Main concepts in deep learning: Deep learning is a type
of machine learning methods that makes computers to learn
from experience and knowledge without explicit programming
and extract useful patterns from raw data. For conventional
machine learning algorithms, it is difﬁcult to extract wellrepresented features due to limitations, such as curse of dimensionality , computational bottleneck , and requirement
of the domain and expert knowledge. Deep learning solves
the problem of representation by building multiple simple
features to represent a sophisticated concept. For example,
a deep learning-based image classiﬁcation system represents
an object by describing edges, fabrics, and structures in the
hidden layers. With the increasing number of available training
data, deep learning becomes more powerful. Deep learning
models have solved many complicated problems, with the help
of hardware acceleration in computational time.
A neural network layer is composed of a set of perceptrons
(artiﬁcial neurons). Each perceptron maps a set of inputs to
output values with an activation function. The function of a
neural network is formed in a chain:
f(x) = f (k)(· · · f (2)(f (1)(x))),
where f (i) is the function of the ith layer of the network,
i = 1, 2, · · · k.
Convolutional neural networks (CNNs) and Recurrent neural networks (RNNs) are two most widely used neural networks in recent neural network architectures. CNNs deploy
convolution operations on hidden layers to share weights and
reduce the number of parameters. CNNs can extract local
information from grid-like input data. CNNs have shown
incredible successes in computer vision tasks, such as image
classiﬁcation , , object detection , , and semantic segmentation , . RNNs are neural networks for
processing sequential input data with variable length. RNNs
produce outputs at each time step. The hidden neuron at each
time step is calculated based on current input data and hidden
neurons at previous time step. Long Short-Term Memory
(LSTM) and Gated Recurrent Unit (GRU) with controllable
gates are designed to avoid vanishing/exploding gradients of
RNNs in long-term dependency.
2) Architectures of deep neural networks: Several deep
learning architectures are widely used in computer vision
tasks: LeNet , VGG , AlexNet , GoogLeNet –
 (Inception V1-V4), and ResNet , from the simplest
(oldest) network to the deepest and the most complex (newest)
one. AlexNet ﬁrst showed that deep learning models can
largely surpass conventional machine learning algorithms in
the ImageNet 2012 challenge and led the future study of deep
learning. These architectures made tremendous breakthroughs
in the ImageNet challenge and can be seen as milestones
in image classiﬁcation problem. Attackers usually generate
adversarial examples against these baseline architectures.
3) Standard deep learning datasets: MNIST, CIFAR-10,
ImageNet are three widely used datasets in computer vision tasks. The MNIST dataset is for handwritten digits
recognition . The CIFAR-10 dataset and the ImageNet
dataset are for image recognition task . The CIFAR-10
consists of 60,000 tiny color images (32 × 32) with ten
classes. The ImageNet dataset consists 14,197,122 images
with 1,000 classes . Because of the large number of
images in the ImageNet dataset, most adversarial approaches
are evaluated on only part of the ImageNet dataset. The Street
View House Numbers (SVHN) dataset, similar to the MNIST
dataset, consists of ten digits obtained from real-world house
numbers in Google Street View images. The YoutubeDataset
dataset is gained from Youtube consisting of about ten million
images and used in .
B. Adversarial Examples and Countermeasures in Machine
Adversarial examples in conventional machine learning
models have been discussed since decades ago. Machine
learning-based systems with handcrafted features are primary
targets, such as spam ﬁlters, intrusion detection, biometric
authentication, fraud detection, etc. . For example, spam
emails are often modiﬁed by adding characters to avoid
detection – .
Dalvi et al. ﬁrst discussed adversarial examples and formulated this problem as a game between adversary and classiﬁer
(Naïve Bayes), both of which are sensitive to cost . The
attack and defense on adversarial examples became an iterative
game. Biggio et al. ﬁrst tried a gradient-based approach to
generate adversarial examples against linear classiﬁer, support
vector machine (SVM), and a neural network . Compared
with deep learning adversarial examples, their methods allow
more freedom to modify the data. The MNIST dataset was
ﬁrst evaluated under their attack, although a human could
easily distinguish the adversarial digit images. Biggio et al.
also reviewed several proactive defenses and discussed reactive approaches to improve the security of machine learning
models .
Barreno et al. presented an initial investigation on the security problems of machine learning , . They categorized
attacking against machine learning system into three axes: 1)
inﬂuence: whether attacks can poison the training data; 2)
security violation: whether an adversarial example belongs to
false positive or false negative; 3) speciﬁcity: attack is targeted
to a particular instance or a wide class. We discuss these axes
for deep learning area in Section III. Barreno et al. compared
attacks against SpamBayes spam ﬁlter and defenses as a study
case. However, they mainly focused on binary classiﬁcation
problem such as virus detection system, intrusion detection
system (IDS), and intrusion prevention system (IPS).
Adversarial examples in conventional machine learning require knowledge of feature extraction, while deep learning
usually needs only raw data input. In conventional ML,
both attacking and defending methods paid great attention to
features, even the previous step (data collection), giving less
attention to the impact of humans. Then the target becomes
a fully automatic machine learning system. Inspired by these
studies on conventional ML, in this paper, we review recent
security issues in the deep learning area.
 provided a comprehensive overview of security issues
in machine learning and recent ﬁndings in deep learning. 
established a unifying threat model. A “no free lunch” theorem
was introduced: the tradeoff between accuracy and robustness.
Compared to their work, our paper focuses on adversarial
examples in deep learning and has a detailed discussion on
recent studies and ﬁndings.
For example, adversarial examples in an image classiﬁcation
task can be described as follows: Using a trained image
classiﬁer published by a third party, a user inputs one image
to get the prediction of class label. Adversarial images are
original clean images with small perturbations, often barely
recognizable by humans. However, such perturbations misguide the image classiﬁer. The user will get a response of an
incorrect image label. Given a trained deep learning model f
and an original input data sample x, generating an adversarial
example x′ can generally be described as a box-constrained
optimization problem:
f(x′) = l′,
x′ ∈ ,
where l and l′ denote the output label of x and x′, ∥· ∥
denotes the distance between two data sample. Let η = x′ −x
be the perturbation added on x. This optimization problem
minimizes the perturbation while misclassifying the prediction
with a constraint of input data. In the rest of the paper, we
will discuss variants of generating adversarial images and
adversarial examples in other tasks.
III. TAXONOMY OF ADVERSARIAL EXAMPLES
To systematically analyze approaches for generating adversarial examples, we analyze the approaches for generating
adversarial examples (see details in Section IV) and categorize
them along three dimensions: threat model, perturbation, and
benchmark.
A. Threat Model
We discuss the threat model in Section I. Based on different
scenarios, assumptions, and quality requirements, adversaries
decide the attributes they need in adversarial examples and
then deploy speciﬁc attack approaches. We further decompose
the threat model into four aspects: adversarial falsiﬁcation,
adversary’s knowledge, adversarial speciﬁcity, and attack frequency. For example, if an adversarial example is required to
be generated in real-time, adversaries should choose a onetime attack instead of an iterative attack, in order to complete
the task (see Attack Frequency).
• Adversarial Falsiﬁcation
– False positive attacks generate a negative sample which
is misclassiﬁed as a positive one (Type I Error). In a
malware detection task, a benign software being classiﬁed
as malware is a false positive. In an image classiﬁcation
task, a false positive can be an adversarial image unrecognizable to human, while deep neural networks predict it to
a class with a high conﬁdence score. Figure 2 illustrates
a false positive example of image classiﬁcation.
– False negative attacks generate a positive sample which
is misclassiﬁed as a negative one (Type II Error). In
a malware detection task, a false negative can be the
condition that a malware (usually considered as positive)
cannot be identiﬁed by the trained model. False negative
attack is also called machine learning evasion. This error
is shown in most adversarial images, where human can
recognize the image, but the neural networks cannot
identify it.
• Adversary’s Knowledge
– White-box attacks assume the adversary knows everything
related to trained neural network models, including training data, model architectures, hyper-parameters, numbers
of layers, activation functions, model weights. Many
adversarial examples are generated by calculating model
gradients. Since deep neural networks tend to require only
raw input data without handcrafted features and to deploy
end-to-end structure, feature selection is not necessary
compared to adversarial examples in machine learning.
– Black-box attacks assume the adversary has no access to
the trained neural network model. The adversary, acting
as a standard user, only knows the output of the model
(label or conﬁdence score). This assumption is common
for attacking online Machine Learning services (e.g.,
Machine Learning on AWS1, Google Cloud AI2, BigML3,
Clarifai4, Microsoft Azure5, IBM Bluemix6, Face++7).
Most adversarial example attacks are white-box attacks.
However, they can be transferred to attack black-box
services due to the transferability of adversarial examples
proposed by Papernot et al. . We will elaborate on it
in Section VII-A.
• Adversarial Speciﬁcity
– Targeted attacks misguide deep neural networks to a
speciﬁc class. Targeted attacks usually occur in the multiclass classiﬁcation problem. For example, an adversary
fools an image classiﬁer to predict all adversarial examples as one class. In a face recognition/biometric system,
an adversary tries to disguise a face as an authorized user
(Impersonation) . Targeted attacks usually maximize
the probability of targeted adversarial class.
– Non-targeted attacks do not assign a speciﬁc class to the
neural network output. The adversarial class of output
can be arbitrary except the original one. For example, an
adversary makes his/her face misidentiﬁed as an arbitrary
face in face recognition system to evade detection (dodging) . Non-targeted attacks are easier to implement
compared to targeted attacks since it has more options
and space to redirect the output. Non-targeted adversarial
examples are usually generated in two ways: 1) running
several targeted attacks and taking the one with the
smallest perturbation from the results; 2) minimizing the
probability of the correct class.
Some generation approaches (e.g., extended BIM, ZOO)
can be applied to both targeted and non-targeted attacks.
For binary classiﬁcation, targeted attacks are equivalent
to non-targeted attacks.
• Attack Frequency
– One-time attacks take only one time to optimize the
adversarial examples.
– Iterative attacks take multiple times to update the adversarial examples.
Compared with one-time attacks, iterative attacks usually
perform better adversarial examples, but require more
interactions with victim classiﬁer (more queries) and
cost more computational time to generate them. For
some computational-intensive tasks (e.g., reinforcement
learning), one-time attacking may be the only feasible
1 
2 
3 
4 
5 
6 
7 
B. Perturbation
Small perturbation is a fundamental premise for adversarial
examples. Adversarial examples are designed to be close to
the original samples and imperceptible to a human, which
causes the performance degradation of deep learning models
compared to that of a human. We analyze three aspects of
perturbation: perturbation scope, perturbation limitation, and
perturbation measurement.
• Perturbation Scope
– Individual attacks generate different perturbations for
each clean input.
– Universal attacks only create a universal perturbation for
the whole dataset. This perturbation can be applied to all
clean input data.
Most of the current attacks generate adversarial examples
individually. However, universal perturbations make it
easier to deploy adversary examples in the real world.
Adversaries do not require to change the perturbation
when the input sample changes.
• Perturbation Limitation
– Optimized Perturbation sets perturbation as the goal of
the optimization problem. These methods aim to minimize the perturbation so that humans cannot recognize
the perturbation.
– Constraint Perturbation sets perturbation as the constraint
of the optimization problem. These methods only require
the perturbation to be small enough.
• Perturbation Measurement
– ℓp measures the magnitude of perturbation by p-norm
ℓ0, ℓ2, ℓ∞are three commonly used ℓp metrics. ℓ0 counts
the number of pixels changed in the adversarial examples;
ℓ2 measures the Euclidean distance between the adversarial example and the original sample; ℓ∞denotes the
maximum change for all pixels in adversarial examples.
– Psychometric perceptual adversarial similarity score
(PASS) is a new metric introduced in , consistent with
human perception.
C. Benchmark
Adversaries show the performance of their adversarial attacks based on different datasets and victim models. This inconsistency brings obstacles to evaluate the adversarial attacks
and measure the robustness of deep learning models. Large
and high-quality datasets, complex and high-performance deep
learning models usually make adversaries/defenders hard to
attack/defend. The diversity of datasets and victim models
also makes researchers hard to tell whether the existence of
adversarial examples is due to datasets or models. We will
discuss this problem in Section VII-C.
• Datasets
MNIST, CIFAR-10, and ImageNet are three most widely
used image classiﬁcation datasets to evaluate adversarial
attacks. Because MNIST and CIFAR-10 are proved easy
to attack and defend due to its simplicity and small size,
ImageNet is the best dataset to evaluate adversarial attacks
so far. A well-designed dataset is required to evaluate
adversarial attacks.
• Victim Models
Adversaries usually attack several well-known deep learning
models, such as LeNet, VGG, AlexNet, GoogLeNet, CaffeNet, and ResNet.
In the following sections, we will investigate recent studies
on adversarial examples according to this taxonomy.
IV. METHODS FOR GENERATING ADVERSARIAL
In this section, we illustrate several representative approaches for generating adversarial examples. Although many
of these approaches are defeated by a countermeasure in later
studies, we present these methods to show how the adversarial
attacks improved and to what extent state-of-the-art adversarial
attacks can achieve. The existence of these methods also
requires investigation, which may improve the robustness of
deep neural networks.
Table II summaries the methods for generating adversarial
examples in this section based on the proposed taxonomy.
A. L-BFGS Attack
Szegedy et al. ﬁrst introduced adversarial examples against
deep neural networks in 2014 . They generated adversarial
examples using a L-BFGS method to solve the general targeted
c∥η∥+ Jθ(x′, l′)
x′ ∈ .
To ﬁnd a suitable constant c, L-BFGS Attack calculated
approximate values of adversarial examples by line-searching
c > 0. The authors showed that the generated adversarial
examples could also be generalized to different models and
different training datasets. They suggested that adversarial
examples are never/rarely seen examples in the test datasets.
L-BFGS Attack was also used in , which implemented
a binary search to ﬁnd the optimal c.
B. Fast Gradient Sign Method (FGSM)
L-BFGS Attack used an expensive linear search method
to ﬁnd the optimal value, which was time-consuming and
impractical. Goodfellow et al. proposed a fast method called
Fast Gradient Sign Method to generate adversarial examples . They only performed one step gradient update along
the direction of the sign of gradient at each pixel. Their
perturbation can be expressed as:
η = ϵsign(∇xJθ(x, l)),
where ϵ is the magnitude of the perturbation. The generated
adversarial example x′ is calculated as: x′ = x + η. This
perturbation can be computed by using back-propagation.
Figure 1 shows an adversarial example on ImageNet.
Table II: Taxonomy of Adversarial Examples
Threat Model
Adversarial Falsiﬁcation
False Negative
 , , – 
False Positive
Adversary’s Knowledge
 , , – , , , – 
 , , , 
Adversarial Speciﬁcity
 , , , , , , , – 
Non-Targeted
 , , , – , , , , 
Attack Frequency
 , 
 , , – 
Perturbation
Perturbation Scope
Individual
 , , – , – , , 
Perturbation Limitation
 , , – , , , 
Constraint
 , , , , 
 , , , 
Perturbation Measurement
Element-wise
 , , 
ℓ0: , ,
ℓ2: , – , – , , ,
ℓ∞: , , , , ,
 , – , , , , 
 – , 
 , , , , – , , , – 
YoutubeDataset: 
LSUN, SNLI: 
Victim Models
 , , , , 
 – , 
 , 
 , , , – , – , , 
 , , 
 , , , 
Figure 1: An adversarial image generated by Fast Gradient Sign Method :
left: a clean image of a panda; middle: the perturbation; right: one sample
adversarial image, classiﬁed as a gibbon.
They claimed that the linear part of the high dimensional
deep neural network could not resist adversarial examples, although the linear behavior speeded up training. Regularization
approaches are used in deep neural networks such as dropout.
Pre-training could not improve the robustness of networks.
 proposed a new method, called Fast Gradient Value
method, in which they replaced the sign of the gradient with
the raw gradient: η = ∇xJ(θ, x, l). Fast Gradient Value
method has no constraints on each pixel and can generate
images with a larger local difference.
According to , one-step attack is easy to transfer but also
easy to defend (see Section VII-A). applied momentum
to FGSM to generate adversarial examples more iteratively.
The gradients were calculated by:
gt+1 = µgt +
then the adversarial example is derived by x′
ϵsigngt+1. The authors increased the effectiveness of attack
by introducing momentum and improved the transferability by
applying the one-step attack and the ensembling method.
 extended FGSM to a targeted attack by maximizing
the probability of the target class:
x′ = x −ϵsign(∇xJ(θ, x, l′)).
The authors refer to this attack as One-step Target Class
Method (OTCM).
 found that FGSM with adversarial training is more
robust to white-box attacks than to black-box attacks due to
gradient masking. They proposed a new attack, RAND-FGSM,
which added random when updating the adversarial examples
to defeat adversarial training:
xtmp = x + α · sign(N(0d, Id)),
x′ = xtmp + (ϵ −α) · sign(∇xtmpJ(xtmp, l)),
where α, ϵ are the parameters, α < ϵ.
C. Basic Iterative Method (BIM) and Iterative Least-Likely
Class Method (ILLC)
Previous methods assume adversarial data can be directly
fed into deep neural networks. However, in many applications,
people can only pass data through devices (e.g., cameras,
sensors). Kurakin et al. applied adversarial examples to the
physical world . They extended Fast Gradient Sign method
by running a ﬁner optimization (smaller change) for multiple
iterations. In each iteration, they clipped pixel values to avoid
large change on each pixel:
Clipx,ξ{x′} = min{255, x + ξ, max{0, x −ϵ, x′}},
where Clipx,ξ{x′} limits the change of the generated adversarial image in each iteration. The adversarial examples were
generated in multiple iterations:
xn+1 = Clipx,ξ{xn + ϵsign(∇xJ(xn, y))}.
The authors referred to this method as Basic Iterative method.
To further attack a speciﬁc class, they chose the least-likely
class of the prediction and tried to maximize the cross-entropy
loss. This method is referred to as Iterative Least-Likely Class
yLL = arg miny{p(y|x)},
xn+1 = Clipx,ϵ{xn −ϵsign(∇xJ(xn, yLL))}.
They successfully fooled the neural network with a crafted
image taken from a cellphone camera. They also found that
Fast Gradient Sign method is robust to phototransformation,
while iterative methods cannot resist phototransformation.
D. Jacobian-based Saliency Map Attack (JSMA)
Papernot et al. designed an efﬁcient saliency adversarial
map, called Jacobian-based Saliency Map Attack . They
ﬁrst computed Jacobian matrix of given sample x, which is
JF (x) = ∂F(x)
According to , F denotes the second-to-last layer (logits)
in . Carlini and Wagner modify this approach by using the
output of the softmax layer as F . In this way, they found
the input features of x that made most signiﬁcant changes to
the output. A small perturbation was designed to successfully
induce large output variations so that change in a small portion
of features could fool the neural network.
Then the authors deﬁned two adversarial saliency maps to
select the feature/pixel to be crafted in each iteration. They
achieved 97% adversarial success rate by modifying only
4.02% input features per sample. However, this method runs
very slow due to its signiﬁcant computational cost.
E. DeepFool
Moosavi-Dezfooli et al. proposed DeepFool to ﬁnd the closest distance from the original input to the decision boundary
of adversarial examples . To overcome the non-linearity
in high dimension, they performed an iterative attack with a
linear approximation. Starting from an afﬁne classiﬁer, they
found that the minimal perturbation of an afﬁne classiﬁer is
the distance to the separating afﬁne hyperplane F = {x :
wT x + b = 0} . The perturbation of an afﬁne classiﬁer f can
be η∗(x) = −f(x)
If f is a binary differentiable classiﬁer, they used an iterative
method to approximate the perturbation by considering f is
linearized around xi at each iteration. The minimal perturbation is computed as:
f(xi) + ∇f(xi)T ηi = 0.
Figure 2: Unrecognizable examples to humans, but deep neural networks
classify them to a class with high certainty (≥99.6%) 
This result can also be extended to the multi-class classiﬁer
by ﬁnding the closest hyperplanes. It can also be extended to
a more general ℓp norm, p ∈[0, ∞). DeepFool provided less
perturbation compared to FGSM and JSMA did. Compared
to JSMA, DeepFool also reduced the intensity of perturbation
instead of the number of selected features.
F. CPPN EA Fool
Nguyen et al. discovered a new type of attack, compositional pattern-producing network-encoded EA (CPPN EA),
where adversarial examples are classiﬁed by deep neural
networks with high conﬁdence (99%), which is unrecognizable
to human . We categorize this kind of attack as a False
positive attack. Figure 2 illustrates false-positive adversarial
They used evolutionary algorithms (EAs) algorithm to produce the adversarial examples. To solve multi-class classi-
ﬁcation problem using EA algorithms, they applied multidimensional archive of phenotypic elites MAP-Elites .
The authors ﬁrst encoded images with two different methods: direct encoding (grayscale or HSV value) and indirect
encoding (compositional pattern-producing network). Then in
each iteration, MAP-Elites, like general EA algorithm, chose a
random organism, mutated them randomly, and replaced with
the current ones if the new ones have higher ﬁtness (high
certainty for a class of a neural network). In this way, MAP-
Elites can ﬁnd the best individual for each class. As they
claimed, for many adversarial images, CPPN could locate the
critical features to change outputs of deep neural networks
just like JSMA did. Many images from same evolutionary are
found similar on closely related categories. More interestingly,
CPPN EA fooling images are accepted by an art contest with
35.5% acceptance rate.
G. C&W’s Attack
Carlini and Wagner launched a targeted attack to defeat
Defensive distillation (Section VI-A) . According to their
further study , , C&W’s Attack is effective for most
of existing adversarial detecting defenses. The authors made
several modiﬁcations in Equation 2.
They ﬁrst deﬁned a new objective function g, so that:
∥η∥p + c · g(x + η)
x + η ∈ n,
where g(x′) ≥0 if and only if f(x′) = l′. In this way, the
distance and the penalty term can be better optimized. The
authors listed seven objective function candidates g. One of
the effective functions evaluated by their experiments can be:
g(x′) = max(max
i̸=l′ (Z(x′)i) −Z(x′)t, −κ),
where Z denotes the Softmax function, κ is a constant to
control the conﬁdence (κ is set to 0 in ).
Second, instead of using box-constrained L-BFGS to ﬁnd
minimal perturbation in L-BFGS Attack method, the authors
introduced a new variant w to avoid the box constraint, where
w satisﬁes η = 1
2(tanh(w)+1)−x. General optimizers in deep
learning like Adam and SGD were used to generate adversarial
examples and performed 20 iterations of such generation to
ﬁnd an optimal c by binary searching. However, they found
that if the gradients of ∥η∥p and g(x + η) are not in the same
scale, it is hard to ﬁnd a suitable constant c in all of the
iterations of the gradient search and get the optimal result.
Due to this reason, two of their proposed functions did not
ﬁnd optimal solutions for adversarial examples.
Third, three distance measurements of perturbation were
discussed in the paper: ℓ0, ℓ2, and ℓ∞. The authors provided
three kinds of attacks based on the distance metrics: ℓ0 attack,
ℓ2 attack, and ℓ∞attack.
ℓ2 attack can be described by:
2(tanh(w) + 1)∥2 + c · g(1
2 tanh(w) + 1).
The authors showed that the distillation network could not help
defend ℓ2 attack.
ℓ0 attack was conducted iteratively since ℓ0 is not differentiable. In each iteration, a few pixels are considered trivial for
generating adversarial examples and removed. The importance
of pixels is determined by the gradient of ℓ2 distance. The
iteration stops if the remaining pixels can not generate an
adversarial example.
ℓ∞attack was also an iterative attack, which replaced the
ℓ2 term with a new penalty in each iteration:
c · g(x + η) +
[(ηi −τ)+].
For each iteration, they reduced τ by a factor of 0.9, if all
ηi < τ. ℓ∞attack considered τ as an estimation of ℓ∞.
H. Zeroth Order Optimization (ZOO)
Different from gradient-based adversarial generating approaches, Chen et al. proposed a Zeroth Order Optimization
(ZOO) based attack . Since this attack does not require
gradients, it can be directly deployed in a black-box attack
without model transferring. Inspired by , the authors
modiﬁed g(·) in as a new hinge-like loss function:
g(x′) = max(max
i̸=l′ (log[f(x)]i) −log[f(x)]l′, −κ),
and used symmetric difference quotient to estimate the gradient and Hessian:
≈f(x + hei) −f(x −hei)
≈f(x + hei) −2f(x) + f(x −hei)
Figure 3: A universal adversarial example fools the neural network on
images. Left images: original labeled natural images; center image: universal
perturbation; right images: perturbed images with wrong labels. 
where ei denotes the standard basis vector with the ith
component as 1, h is a small constant.
Through employing the gradient estimation of gradient and
Hessian, ZOO does not need the access to the victim deep
learning models. However, it requires expensive computation
to query and estimate the gradients. The authors proposed
ADAM like algorithms, ZOO-ADAM, to randomly select a
variable and update adversarial examples. Experiments showed
that ZOO achieved the comparable performance as C&W’s
I. Universal Perturbation
Leveraging their previous method on DeepFool, Moosavi-
Dezfooli et al. developed a universal adversarial attack .
The problem they formulated is to ﬁnd a universal perturbation
vector satisfying
 x′ ̸= f(x)
ϵ limits the size of universal perturbation, and δ controls the
failure rate of all the adversarial samples.
For each iteration, they use DeepFool method to get a
minimal sample perturbation against each input data and
update the perturbation to the total perturbation η. This loop
will not stop until most data samples are fooled (P < 1 −δ).
From experiments, the universal perturbation can be generated
by using a small part of data samples instead of the entire
dataset. Figure 3 illustrates a universal adversarial example
can fool a group of images. The universal perturbations were
shown to be generalized well across popular deep learning
architectures (e.g., VGG, CaffeNet, GoogLeNet, ResNet).
J. One Pixel Attack
To avoid the problem of measurement of perceptiveness, Su
et al. generated adversarial examples by only modifying one
pixel . The optimization problem becomes:
J(f(x′), l′)
where ϵ0 = 1 for modifying only one pixel. The new constraint
made it hard to optimize the problem.
Su et al. applied differential evolution (DE), one of the
evolutionary algorithms, to ﬁnd the optimal solution. DE does
not require the gradients of the neural networks and can be
used in non-differential objective functions. They evaluated the
proposed method on the CIFAR-10 dataset using three neural
networks: All convolution network (AllConv) , Network
in Network (NiN) , and VGG16. Their results showed that
70.97% of images successfully fooled deep neural networks
with at least one target class with conﬁdence 97.47% on
K. Feature Adversary
Sabour et al. performed a targeted attack by minimizing
the distance of the representation of internal neural network
layers instead of the output layer . We refer to this attack
as Feature Adversary. The problem can be described by:
∥φk(x) −φk(x′)∥
∥x −x′∥∞< δ,
where φk denotes a mapping from image input to the output
of the kth layer. Instead of ﬁnding a minimal perturbation,
δ is used as a constraint of perturbation. They claimed that
a small ﬁxed value δ is good enough for human perception.
Similar to , they used L-BFGS-B to solve the optimization
problem. The adversarial images are more natural and closer
to the targeted images in the internal layers.
L. Hot/Cold
Rozsa et al. proposed a Hot/Cold method to ﬁnd multiple
adversarial examples for every single image input . They
thought small translations and rotations should be allowed as
long as they were imperceptible.
They deﬁned a new metric, Psychometric Perceptual Adversarial Similarity Score (PASS), to measure the noticeable
similarity to humans. Hot/Cold neglected the unnoticeable difference based on pixels and replaced widely used ℓp distance
with PASS. PASS includes two stages: 1) aligning the modiﬁed
image with the original image; 2) measuring the similarity
between the aligned image and the original one.
Let φ(x′, x) be a homography transform from the adversarial example x′ to the original example x. H is the homography
matrix, with size 3 × 3. H is solved by maximizing the
enhanced correlation coefﬁcient (ECC) between x′ and
x. The optimization function is:
∥φ(x′, x)∥
where · denotes the normalization of an image.
Structural SIMilarity (SSIM) index was adopted to measure the just noticeable difference of images. leveraged
SSIM and deﬁned a new measurement, regional SSIM index
(RSSIM) as:
RSSIM(xi,j, x′
i,j) = L(xi,j, x′
i,j)αC(xi,j, x′
i,j)βS(xi,j, x′
where α, β, γ are weights of importance for luminance
(L(·, ·)), contrast (C(·, ·)), and structure (S(·, ·)). The SSIM
can be calculated by averaging RSSIM:
SSIM(xi,j, x′
RSSIM(xi,j, x′
PASS is deﬁned by combination of the alignment and the
similarity measurement:
PASS(x′, x) = SSIM(φ∗(x′, x), x).
The adversarial problem with the new distance is described
f(x′) = y′,
PASS(x, x′) ≥γ.
D(x, x′) denotes a measure of distance (e.g., 1−PASS(x, x′)
or ∥x −x′∥p).
To generate a diverse set of adversarial examples, the authors deﬁned the targeted label l′ as hot class, and the original
label l as cold class. In each iteration, they moved toward a
target (hot) class while moving away from the original (cold)
class. Their results showed that generated adversarial examples
are comparable to FGSM, and with more diversity.
M. Natural GAN
Zhao et al. utilized Generative Adversarial Networks
(GANs) as part of their approach to generate adversarial
examples of images and texts , which made adversarial
examples more natural to human. We name this approach
Natural GAN. The authors ﬁrst trained a WGAN model on the
dataset, where the generator G maps random noise to the input
domain. They also trained an “inverter” I to map input data to
dense inner representations. Hence, the adversarial noise was
generated by minimizing the distance of the inner representations like “Feature Adversary.” The adversarial examples were
generated using the generator: x′ = G(z′):
f(G(z)) ̸= f(x).
Both the generator G and the inverter I were built to make
adversarial examples natural. Natural GAN was a general
framework for many deep learning ﬁelds. applied Natural
GAN to image classiﬁcation, textual entailment, and machine
translation. Since Natural GAN does not require gradients of
original neural networks, it can also be applied to Black-box
N. Model-based Ensembling Attack
Liu et al. conducted a study of transferability (Section VII-A) over deep neural networks on ImageNet and
proposed a Model-based Ensembling Attack for targeted adversarial examples . The authors argued that compared to nontargeted adversarial examples, targeted adversarial examples
are much harder to transfer over deep models. Using Modelbased Ensembling Attack, they can generate transferable adversarial examples to attack a black-box model.
The authors generated adversarial examples on multiple
deep neural networks with full knowledge and tested them
on a black-box model. Model-based Ensembling Attack was
derived by the following optimization problem:
αiJi(x′, l′))
+ λ∥x′ −x∥,
where k is the number of deep neural networks in the
generation, fi is the function of each network, and αi is
the ensemble weight (Pk
i αi = 1). The results showed that
Model-based Ensembling Attack could generate transferable
targeted adversarial images, which enhanced the power of
adversarial examples for black-box attacks. They also proved
that this method performs better in generating non-targeted
adversarial examples than previous methods. The authors
successfully conducted a black-box attack against Clarifai.com
using Model-based Ensembling Attack.
O. Ground-Truth Attack
Formal veriﬁcation techniques aim to evaluate the robustness of a neural network even against zero-day attacks (Section VI-F). Carlini et al. constructed a ground-truth attack,
which provided adversarial examples with minimal perturbation (ℓ1, ℓ∞) . Network Veriﬁcation always checks whether
an adversarial example violates a property of a deep neural
network and whether there exists an example changes the label
within a certain distance. Ground-Truth Attack conducted a
binary search and found such an adversarial example with the
smallest perturbation by invoking Reluplex iteratively.
The initial adversarial example is found using C&W’s Attack to improve the performance.
V. APPLICATIONS FOR ADVERSARIAL EXAMPLES
We have investigated adversarial examples for image classiﬁcation task. In this section, we review adversarial examples
against the other tasks. We mainly focus on three questions:
What scenarios are adversarial examples applied in new tasks?
How to generate adversarial examples in new tasks? Whether
to propose a new method or to translate the problem into the
image classiﬁcation task and solve it by the aforementioned
methods? Table III summarizes the applications for adversarial
examples in this section.
A. Reinforcement Learning
Deep neural networks have been used in reinforcement
learning by training policies on raw input (e.g., images). ,
 generated adversarial examples on deep reinforcement
learning policies. Since the inherent intensive computation of
reinforcement learning, both of them performed fast One-time
Huang et al. applied FGSM to attack deep reinforcement
learning networks and algorithms : deep Q network
(DQN), trust region policy optimization(TRPO), and asynchronous advantage actor-critic (A3C) . Similarly to ,
they added small perturbations on the input of policy by
calculating the gradient of the cross-entropy loss function:
Figure 4: Adversarial attacks for autoencoders . Perturbations are added
to the input the encoder. After encoding and decoding, the decoder will output
an adversarial image presenting an incorrect class
∇xJ(θ, x, ℓ)). Since DQN does not have stochastic policy
input, softmax of Q-values is considered to calculate the loss
function. They evaluated adversarial examples on four Atari
2600 games with three norm constraints ℓ1, ℓ2, ℓ∞. They found
Huang’s Attack with ℓ1 norm conducted a successful attack on
both White-box attack and Black-box attack (no access to the
training algorithms, parameters, and hyper-parameters).
 used FGSM to attack A3C algorithm and Atari Pong
task. found that injecting perturbations in a fraction of
frames is sufﬁcient.
B. Generative Modeling
Kos et al. and Tabacof et al. proposed adversarial
examples for generative models. An adversary for autoencoder
can inject perturbations into the input of encoder and generate
a targeted class after decoding. Figure 4 depicts a targeted adversarial example for an autoencoder. Adding perturbations on
the input image of the encoder can misguide the autoencoder
by making decoder to generating a targeted adversarial output
Kos et al. described a scenario to apply adversarial examples against autoencoder. Autoencoders can be used to
compress data by an encoder and decompress by a decoder.
For example, Toderici et al. use RNN-based AutoEncoder
to compress image . Ledig et al. used GAN to superresolve images . Adversaries can leverage autoencoder
to reconstruct an adversarial image by adding perturbation to
the input of the encoder.
Tabacof et al. used Feature Adversary Attack against AE
and VAE. The adversarial examples were formulated as follows :
D(zx′, zx) + c∥η∥
x′ ∈[L, U]
zx′ = Encoder(x′)
zx = Encoder(x),
where D(·) is the distance between latent encoding representation zx and zx′. Tabacof et al. chose KL-divergence to measure
D(·) in . They tested their attacks on the MNIST and
SVHN dataset and found that generating adversarial examples
for autoencoder is much harder than for classiﬁers. VAE is
even slightly more robust than deterministic autoencoder.
Table III: Summary of Applications for Adversarial Examples
Applications
Representative
Adversarial
Falsiﬁcation
Adversary’s
Adversarial
Speciﬁcity
Perturbation
Perturbation
Limitation
Perturbation
Measurement
Architecture
Reinforcement
White-box &
Individual
ℓ1, ℓ2, ℓ∞
Individual
Atari Pong
Generative
Adversary,
Individual
Individual
Face Recognition
Impersonation
white-box &
Targeted &
negative &
White-box &
Individual
Segmentation
negative &
White-box &
Individual
Individual
Cityscapes
Cityscapes
Comprehension
Individual
One-time &
twelve other
Reinforcement
Individual
TripAdvisor
Individual
2-layer FC
Reinforcement
Individual
Individual
Multi-layer
Perceptron
Individual
Generic Programming
Individual
Forest, SVM
Figure 5: An example of adversarial eyeglass frame against Face Recognition
System 
Kos et al. extended Tabacof et al.’s work by designing another two kinds of distances. Hence, the adversarial examples
can be generated by optimizing:
c∥η∥+ J(x′, l′).
The loss function J can be cross-entropy (refer to “Classiﬁer
Attack” in ), VAE loss function (“LV AE Attck”), and
distance between the original latent vector z and modiﬁed
encoded vector x′ (“Latent Attack”, similar to Tabacof et al.’s
work ). They tested VAE and VAE-GAN on the
MNIST, SVHN, and CelebA datasets. In their experimental
results, “Latent Attack” achieved the best result.
C. Face Recognition
Deep neural network based Face Recognition System (FRS)
and Face Detection System have been widely deployed in
commercial products due to their high performance. ﬁrst
provided a design of eyeglass frames to attack a deep neural
network based FRS , which composes 11 blocks with
38 layers and one triplet loss function for feature embedding.
Based on the triplet loss function, designed a softmaxloss
J(x) = −log
e<hcx,f(x)>
c=1 e<hc,f(x)>
where hc is a one-hot vector of class c, < ·, · > denotes inner
product. Then they used L-BFGS Attack to generate adversarial
In a further step, implemented adversarial eyeglass
frames to achieve attack in the physical world: the perturbations can only be injected into the area of eyeglass frames.
They also enhanced the printability of adversarial images
on the frame by adding a penalty of non-printability score
(NPS) to the optimized objective. Similarly to Universal
Perturbation, they optimize the perturbation to be applied to
a set of face images. They successfully dodged (non-targeted
attack) against FRS (over 80 % time) and misguided FRS
as a speciﬁc face (targeted attack) with a high success rate
(depending on the target). Figure 5 illustrates an example of
adversarial eyeglass frames.
Leveraging the approach of printability, proposed an
attack algorithm, Robust Physical Perturbations (RP2), to
modify a stop sign as a speed limit sign) 8. They changed
the physical road signs by two kinds of attacks: 1) overlaying
an adversarial road sign over a physical sign; 2) sticking perturbations on an existing sign. included a non-printability
score in the optimization objective to improve the printability.
8This method was shown not effective for standard detectors (YOLO and
Faster RCNN) in .
Figure 6: An adversarial example for object detection task . Left: object
detection on a clean image. Right: object detection on an adversarial image.
D. Object Detection
The object detection task is to ﬁnd the proposal of an
object (bounding box), which can be viewed as an image
classiﬁcation task for every possible proposal. proposed a
universal algorithm called Dense Adversary Generation (DAG)
to generate adversarial examples for both object detection
and semantic segmentation. The authors aimed at making the
prediction (detection/segmentation) incorrect (non-targeted).
Figure 6 illustrates an adversarial example for the object
detection task.
 deﬁned T = t1, t2, . . . , tN as the recognition targets.
For image classiﬁcation, the classiﬁer only needs one target
– entire image (N = 1); For semantic segmentation, targets
consist of all pixels (N = #ofpixels); For object detection,
targets consist of all possible proposals (N = (#ofpixels)2).
Then the objective function sums up the loss from all targets.
Instead of optimizing the loss from all targets, the authors
performed an iterative optimization and only updated the loss
for the targets correctly predicted in the previous iteration.
The ﬁnal perturbation sums up normalized perturbations in
all iterations. To deal with a large number of targets for
objective detection problem, the authors used regional proposal
network (RPN) to generate possible targets, which greatly
decreases the computation for targets in object detection. DAG
also showed the capability of generating images which are
unrecognizable to human but deep learning could predict (false
positives).
E. Semantic Segmentation
Image segmentation task can be viewed as an image classiﬁcation task for every pixel. Since each perturbation is
responsible for at least one pixel segmentation, this makes
the space of perturbations for segmentation much smaller
than that for image classiﬁcation . , , 
generated adversarial examples against the semantic image
segmentation task. However, their attacks are proposed under
different scenarios. As we just discussed, performed
a non-targeted segmentation. , both performed a
targeted segmentation and tried to removed a certain class by
making deep learning model to misguide it as background
 generated adversarial examples by assigning pixels
with the adversarial class that their nearest neighbor belongs
to. The success rate was measured by the percentage of pixels
of chosen class to be changed or of the rest classes to be
preserved.
 presented a method to generate universal adversarial
perturbations against semantic image segmentation task. They
assigned the primary objective of adversarial examples and
Figure 7: Adversary examples of hiding pedestrians in the semantic segmentation task . Left image: original image; Middle image: the segmentation
of the original image predicted by DNN; Right image: the segmentation of
the adversarial image predicted by DNN.
hid the objects (e.g., pedestrians) while keeping the rest
segmentation unchanged. Metzen et al. deﬁned background
classes and targeted classes (not targeted adversarial classes).
Targeted classes are classes to be removed. Similar to ,
pixels which belong to the targeted classes would be assigned
to their nearest background classes:
∀(i, j) ∈Itargeted,
∀(i, j) ∈Ibackground,
(i′, j′) =
(i′,j′)∈Ibackground
∥i′ −i∥+ ∥j′ −j∥,
where Itargeted = (i, j)|f(xij) = l∗denotes the area to be
removed. Figure 7 illustrates an adversarial example to hide
pedestrians. They used ILLC attack to solve this problem
and also extended Universal Perturbation method to get the
universal perturbation. Their results showed the existence of
universal perturbation for semantic segmentation task.
F. Natural Language Processing (NLP)
Many tasks in natural language processing can be attacked
by adversarial examples. People usually generate adversarial
examples by adding/deleting words in the sentences.
The task of reading comprehension (a.k.a. question answering) is to read paragraphs and answer questions about
the paragraphs. To generate adversarial examples that are
consistent with the correct answer and do not confuse human,
Jia and Liang added distracting (adversarial) sentences to the
end of paragraph . They found that models for the reading
comprehension task are overstable instead of oversensitivity,
which means deep learning models cannot tell the subtle but
critical difference in the paragraphs.
They proposed two kinds of methods to generate adversarial examples: 1) adding grammatical sentences similar
to the question but not contradictory to the correct answer
(AddSent); 2) adding a sentence with arbitrary English words
(AddAny). successfully fooled all the models (sixteen
models) they tested on Stanford Question Answering Dataset
(SQuAD) . The adversarial examples also have the capability of transferability and cannot be improved by adversarial
training. However, the adversarial sentences require manpower
to ﬁx the errors in the sentences.
 aimed to fool a deep learning-based sentiment classiﬁer by removing the minimum subset of words in the given
text. Reinforcement learning was used to ﬁnd an approximate
subset, where the reward function was proposed as
the sentiment label changes, and 0 otherwise. ∥D∥denotes
the number of removing word set D. The reward function
also included a regularizer to make sentence contiguous.
Table IV: Summary of Countermeasures for Adversarial Examples
Defensive Strategies
Representative Studies
Adversarial Detecting
 , , – 
Input Reconstruction
 , , 
Network Veriﬁcation
 , , 
Network Distillation
Adversarial (Re)Training
 , , , , ,
Classiﬁer Robustifying
 , 
The changes in , can easily be recognized by
humans. More natural adversarial examples for texture data
was proposed by Natural GAN (Section IV-M).
G. Malware Detection
Deep learning has been used in static and behavioral-based
malware detection due to its capability of detecting zeroday malware – . Recent studies generated adversarial
malware samples to evade deep learning-based malware detection – , .
 adapted JSMA method to attack Android malware
detection model. evaded two PDF malware classiﬁer,
PDFrate and Hidost, by modifying PDF. parsed the PDF
ﬁle and changed its object structure using genetic programming. The adversarial PDF ﬁle was then packed with new
 used GAN to generate adversarial domain names
to evade detection of domain generation algorithms. 
proposed a GAN based algorithm, MalGan, to generate malware examples and evade black-box detection. used a
substitute detector to simulate the real detector and leveraged the transferability of adversarial examples to attack
the real detector. MalGan was evaluated by 180K programs
with API features. However, required the knowledge
of features used in the model. used a large number
of features (2,350) to cover the required feature space of
portable executable (PE) ﬁles. The features included PE header
metadata, section metadata, import & export table metadata.
 also deﬁned several modiﬁcations to generate malware
evading deep learning detection. The solution was trained by
reinforcement learning, where the evasion rate is considered
as a reward.
VI. COUNTERMEASURES FOR ADVERSARIAL EXAMPLES
Countermeasures for adversarial examples have two types
of defense strategies: 1) reactive: detect adversarial examples
after deep neural networks are built; 2) proactive: make
deep neural networks more robust before adversaries generate
adversarial examples. In this section, we discuss three reactive
countermeasures (Adversarial Detecting, Input Reconstruction, and Network Veriﬁcation) and three proactive countermeasures (Network Distillation, Adversarial (Re)training, and
Classiﬁer Robustifying). We will also discuss an ensembling
method to prevent adversarial examples. Table IV summarizes
the countermeasures.
Figure 8: Network distillation of deep neural networks 
A. Network Distillation
Papernot et al. used network distillation to defend deep
neural networks against adversarial examples . Network
distillation was originally designed to reduce the size of
deep neural networks by transferring knowledge from a large
network to a small one , (Figure 8). The probability
of classes produced by the ﬁrst DNN is used as inputs to
train the second DNN. The probability of classes extracts the
knowledge learned from the ﬁrst DNN. Softmax is usually
used to normalize the last layer of DNN and produce the
probability of classes. The softmax output of the ﬁrst DNN,
also the input of the next DNN, can be described as:
j exp(zj/T),
where T is a temperature parameter to control the level of
knowledge distillation. In deep neural networks, temperature
T is set to 1. When T is large, the output of softmax will be
vague (when T →∞, the probability of all classes →
When T is small, only one class is close to 1 while the
rest goes to 0. This schema of network distillation can be
duplicated several times and connects several deep neural
In , network distillation extracted knowledge from
deep neural networks to improve robustness. The authors
found that attacks primarily aimed at the sensitivity of networks and then proved that using high-temperature softmax
reduced the model sensitivity to small perturbations. Network
Distillation defense was tested on the MNIST and CIFAR-10
datasets and reduced the success rate of JSMA attack by 0.5%
and 5% respectively. “Network Distillation” also improved the
generalization of the neural networks.
B. Adversarial (Re)training
Training with adversarial examples is one of the countermeasures to make neural networks more robust. Goodfellow et
al. and Huang et al. included adversarial examples
in the training stage. They generated adversarial examples in
every step of training and inject them into the training set. ,
 showed that adversarial training improved the robustness
of deep neural networks. Adversarial training could provide
regularization for deep neural networks and improve the
precision as well .
 and were evaluated only on the MNIST dataset.
A comprehensive analysis of adversarial training methods on
the ImageNet dataset was presented in . They used half
adversarial examples and half origin examples in each step
of training. From the results, adversarial training increased
the robustness of neural networks for one-step attacks (e.g.,
FGSM) but would not help under iterative attacks (e.g., BIM
and ILLC methods). suggested that adversarial training is
used for regularization only to avoid overﬁtting (e.g., the case
in with the small MNIST dataset).
 found that the adversarial trained models on the
MNIST and ImageNet datasets are more robust to white-box
adversarial examples than to the transferred examples (blackbox).
 minimized both the cross-entropy loss and internal
representation distance during adversarial training, which can
be seen as a defense version of Feature Adversary.
To deal with the transferred black-box model, proposed Ensembling Adversarial Training method that trained
the model with adversarial examples generated from multiple
sources: the models being trained and also pre-trained external
C. Adversarial Detecting
Many research projects tried to detect adversarial examples
in the testing stage , , – , .
 , , trained deep neural network-based binary
classiﬁers as detectors to classify the input data as a legitimate
(clean) input or an adversarial example. Metzen et al. created
a detector for adversarial examples as an auxiliary network
of the original neural network . The detector is a small
and straightforward neural network predicting on binary classiﬁcation, i.e., the probability of the input being adversarial.
SafetyNet extracted the binary threshold of each ReLU
layer’s output as the features of the adversarial detector and
detects adversarial images by an RBF-SVM classiﬁer. The
authors claimed that their method is hard to be defeated by
adversaries even when adversaries know the detector, since
it is difﬁcult for adversaries to ﬁnd an optimal value, for
both adversarial examples and new features of SafetyNet
detector. added an outlier class to the original deep
learning model. The model detected the adversarial examples
by classifying it as an outlier. They found that the measurement
of maximum mean discrepancy (MMD) and energy distance
(ED) could distinguish the distribution of adversarial datasets
and clean datasets.
 provided a Bayesian view of detecting adversarial
examples. claimed that the uncertainty of adversarial
examples is higher than the clean data. Hence, they deployed
a Bayesian neural network to estimate the uncertainty of input
data and distinguish adversarial examples and clean input data
based on uncertainty estimation.
Similarly,
probability
divergence
Shannon divergence) as one of its detectors. showed
that after whitening by Principal Component Analysis (PCA),
adversarial examples have different coefﬁcients in low-ranked
components.
 trained a PixelCNN neural network and found
that the distribution of adversarial examples is different from
clean data. They calculated p-value based on the rank of
PixelCNN and rejected adversarial examples using the pvalues. The results showed that this approach could detect
FGSM, BIM, DeepFool, and C&W attack.
 trained neural networks with “reverse cross-entropy”
to better distinguish adversarial examples from clean data
in the latent layers and then detected adversarial examples
using a method called “Kernel density” in the testing stage.
The “reverse cross-entropy” made the deep neural network to
predict with high conﬁdence on the true class and uniform
distribution on the other classes. In this way, the deep neural network was trained to map the clean input close to a
low-dimensional manifold in the layer before softmax. This
brought great convenience for further detection of adversarial
 leveraged multiple previous images to predict future
input and detect adversarial examples, in the task of reinforcement learning.
However, Carlini and Wagner summarized most of these
adversarial detecting methods ( , – ) and showed
that these methods could not defend against their previous
attack C&W’s Attack with slight changes of loss function ,
D. Input Reconstruction
Adversarial examples can be transformed to clean data via
reconstruction. After transformation, the adversarial examples
will not affect the prediction of deep learning models. Gu
and Rigazio proposed a variant of autoencoder network with
a penalty, called deep contractive autoencoder, to increase
the robustness of neural networks . A denoising autoencoder network is trained to encode adversarial examples
to original ones to remove adversarial perturbations. 
reconstructed the adversarial examples by 1) adding Gaussian
noise or 2) encoding them with autoencoder as a plan B in
MagNet (Section VI-G).
PixelDefend reconstructed the adversarial images back to
the training distribution using PixelCNN. PixelDefend
changed all pixels along each channel to maximize the probability distribution:
∥x′ −x∥∞≤ϵdefend,
where Pt denotes the training distribution, ϵdefend controls
the new changes on the adversarial examples. PixelDefend
also leveraged adversarial detecting, so that if an adversarial
example is not detected as malicious, no change will be made
to the adversarial examples (ϵdefend = 0).
E. Classiﬁer Robustifying
 , design robust architectures of deep neural
networks to prevent adversarial examples.
Due to the uncertainty from adversarial examples, Bradshaw
et al. leveraged Bayesian classiﬁers to build more robust neural
networks . Gaussian processes (GPs) with RBF kernels
were used to provide uncertainty estimation. The proposed
neural networks were called Gaussian Process Hybrid Deep
Neural Networks (GPDNNs). GPs expressed the latent variables as a Gaussian distribution parameterized by the functions
of mean and covariance and encoded them with RBF kernels.
 showed that GPDNNs achieved comparable performance
with general DNNs and more robust to adversarial examples.
The authors claimed that GPDNNs “know when they do not
 observed that adversarial examples usually went into
a small subset of incorrect classes. separated the classes
into sub-classes and ensembled the result from all sub-classes
by voting to prevent adversarial examples misclassiﬁed.
F. Network Veriﬁcation
Verifying properties of deep neural networks is a promising
solution to defend adversarial examples, because it may detect the new unseen attacks. Network veriﬁcation checks the
properties of a neural network: whether an input violates or
satisﬁes the property.
Katz et al. proposed a veriﬁcation method for neural networks with ReLU activation function, called Reluplex .
They used Satisﬁability Modulo Theory (SMT) solver to verify
the neural networks. The authors showed that within a small
perturbation, there was no existing adversarial example to
misclassify the neural networks. They also proved that the
problem of network veriﬁcation is NP-complete. Carlini et al.
extended their assumption of ReLU function by presenting
max(x, y) = ReLU(x−y)+y and ∥x∥= ReLU(2x)−x .
However, Reluplex runs very slow due to the large computation of verifying the networks and only works for DNNs with
several hundred nodes . proposed two potential
solutions: 1) prioritizing the order of checking nodes 2) sharing
information of veriﬁcation.
Instead of checking each point individually, Gopinath et al.
proposed DeepSafe to provide safe regions of a deep neural
network using Reluplex. They also introduced targeted
robustness a safe region only regarding a targeted class.
G. Ensembling Defenses
Due to the multi-facet of adversarial examples, multiple
defense strategies can be performed together (parallel or
sequential) to defend adversarial examples.
Aforementioned PixelDefend is composed of an adversarial detector and an “input reconstructor” to establish a
defense strategy.
MagNet included one or more detectors and a reconstructor
(“reformer” in the paper) as Plan A and Plan B . The
detectors are used to ﬁnd the adversarial examples which are
far from the boundary of the manifold. In , they ﬁrst
measured the distance between input and encoded input and
also the probability divergence (Jensen-Shannon divergence)
between softmax output of input and encoded input. The
adversarial examples were expected a large distance and
probability divergence. To deal with the adversarial examples
close to the boundary, MagNet used a reconstructor built by
neural network based autoencoders. The reconstructor will
map adversarial examples to legitimate examples. Figure 9
illustrates the workﬂow of the defense of two phases.
After investigating several defensive approaches, 
showed that the ensemble of those defensive approaches does
not make the neural networks strong.
Figure 9: MagNet workﬂow: one or more detectors ﬁrst detects if input x
is adversarial; If not, reconstruct x to x∗before feeding it to the classiﬁer.
(modiﬁed from )
H. Summary
Almost all defenses are shown to be effective only for part
of attacks. They tend not to be defensive for some strong
(fail to defend) and unseen attacks. Most defenses target
adversarial examples in the computer vision task. However,
with the development of adversarial examples in other areas,
new defenses for these areas, especially for safety-critical
systems, are urgently required.
VII. CHALLENGES AND DISCUSSIONS
In this section, we discuss the current challenges and the
potential solutions for adversarial examples. Although many
methods and theorems have been proposed and developed
recently, a lot of fundamental questions need to be well explained and many challenges need to be addressed. The reason
for the existence of adversarial examples is an interesting and
one of the most fundamental problems for both adversaries
and researchers, which exploits the vulnerability of neural
networks and help defenders to resist adversarial examples. We
will discuss the following questions in this section: Why do
adversarial examples transfer? How to stop the transferability?
Why are some defenses effective and others not? How to
measure the strength of an attack as well as a defense? How
to evaluate the robustness of a deep neural network against
seen/unseen adversarial examples?
A. Transferability
Transferability is a common property for adversarial examples. Szegedy et al. ﬁrst found that adversarial examples
generated against a neural network can fool the same neural
networks trained by different datasets. Papernot et al. found
that adversarial examples generated against a neural network
can fool other neural networks with different architectures,
even other classiﬁers trained by different machine learning algorithms . Transferability is critical for Black-Box attacks
where the victim deep learning model and the training dataset
are not accessible. Attackers can train a substitute neural
network model and then generate adversarial examples against
substitute model. Then the victim model will be vulnerable
to these adversarial examples due to transferability. From a
defender’s view, if we hinder transferability of adversarial
examples, we can defend all white-box attackers who need
to access the model and require transferability.
We deﬁne the transferability of adversarial examples in three
levels from easy to hard: 1) transfer among the same neural
network architecture trained with different data; 2) transfer
among different neural network architectures trained for the
same task; 3) transfer among deep neural networks for different tasks. To our best knowledge, there is no existing solution
on the third level yet (for instance, transfer an adversarial
image from object detection to semantic segmentation).
Many studies examined transferability to show the ability
of adversarial examples , . Papernot et al. studied the
transferability between conventional machine learning techniques (i.e., logistic regression, SVM, decision tree, kNN)
and deep neural networks. They found that adversarial examples can be transferred between different parameters, training
dataset of a machine learning models and even across different
machine learning techniques.
Liu et al. investigated transferability of targeted and nontargeted adversarial examples on complex models and large
datasets (e.g., the ImageNet dataset) . They found that
non-targeted adversarial examples are much more transferable
than targeted ones. They observed that the decision boundaries
of different models aligned well with each other. Thus they
proposed Model-Based Ensembling Attack to create transferable targeted adversarial examples.
Tramèr et al. found that the distance to the model’s decision
boundary is on average larger than the distance between two
models’ boundaries in the same direction . This may
explain the existence of transferability of adversarial examples.
Tramèr et al. also claimed that transferability might not be
an inherent property of deep neural networks by showing a
counter-example.
B. The existence of Adversarial Examples
The reason for the existence of adversarial examples is
still an open question. Are adversarial examples an inherent
property of deep neural networks? Are adversarial examples
the “Achilles’ heel” of deep neural networks with high performance? Many hypotheses have been proposed to explain the
existence.
Data incompletion One assumption is that adversarial
examples are of low probability and low test coverage of
corner cases in the testing dataset , . From training
a PixelCNN, found that the distribution of adversarial
examples was different from clean data. Even for a simple
Gaussian model, a robust model can be more complicated and
requires much more training data than that of a “standard”
model .
Model capability Adversarial examples are a phenomenon
not only for deep neural networks but also for all classi-
ﬁers , . suggested that adversarial examples are
the results of models being too linear in high dimensional
manifolds. showed that in the linear case, the adversarial
examples exist when the decision boundary is close to the
manifold of the training data.
Contrary to , believed that adversarial examples
are due to the “low ﬂexibility” of the classiﬁer for certain
tasks. Linearity is not an “obvious explanation” . 
blamed adversarial examples for the sparse and discontinuous
manifold which makes classiﬁer erratic.
No robust model suggested that the decision boundaries of deep neural networks are inherently incorrect, which
do not detect semantic objects. showed that if a dataset
is generated by a smooth generative model with large latent
space, there is no robust classiﬁer to adversarial examples.
Similarly, prove that if a model is trained on a sphere
dataset and misclassiﬁes a small part of the dataset, then there
exist adversarial examples with a small perturbation.
In addition to adversarial examples for image classiﬁcation
task, as discussed in Section V, adversarial examples have
been generated in various applications. Many of them deployed utterly different methods. Some applications can use
the same method used in image classiﬁcation task. However,
some need to propose a novel method. Current studies on adversarial examples mainly focus on image classiﬁcation task.
No existing paper explains the relationship among different
applications and existence of a universal attacking/defending
method to be applied to all the applications.
C. Robustness Evaluation
The competition between attacks and defenses for adversarial examples becomes an “arms race”: a defensive method that
was proposed to prevent existing attacks was later shown to
be vulnerable to some new attacks, and vice versa , .
Some defenses showed that they could defend a particular
attack, but later failed with a slight change of the attack ,
 . Hence, the evaluation on the robustness of a deep
neural network is necessary. For example, provided an
upper bound of robustness for linear classiﬁer and quadratic
classiﬁer. The following problems for robustness evaluation of
deep neural networks require further exploration.
1) A methodology for evaluation on the robustness
of deep neural networks: Many deep neural networks are
planned to be deployed in safety-critical settings. Defending
only existing attacks is not sufﬁcient. Zero-day (new) attacks
would be more harmful to deep neural networks. A methodology for evaluating the robustness of deep neural networks is
required, especially for zero-day attacks, which helps people
understand the conﬁdence of model prediction and how much
we can rely on them in the real world. , , ,
 conducted initial studies on the evaluation. Moreover,
this problem lies not only in the performance of deep neural
network models but also in the conﬁdentiality and privacy.
2) A benchmark platform for attacks and defenses:
Most attacks and defenses described their methods without
publicly available code, not to mention the parameters used
in their methods. This brings difﬁculties for other researchers
to reproduce their solutions and provide the corresponding
attacks/defenses. For example, Carlini tried his best to “ﬁnd
the best possible defense parameters + random initialization”9.
Some researchers even drew different conclusions because
of different settings in their experiments. If there exists any
benchmark, where both adversaries and defenders conduct
experiments in a uniform way (i.e., the same threat model,
dataset, classiﬁer, attacking/defending approach), we can make
a more precise comparison between different attacking and
defending techniques.
9Code repository used in : 
Figure 10: Workﬂow of a benchmark platform for attackers and defenders:
1) attackers and defenders update/train their strategies on training dataset; 2)
attackers generate adversarial examples on the clean data; 3) the adversarial
examples are veriﬁed by crowdsourcing whether recognizable to human; 4)
defenders generate a deep neural network as a defensive strategy; 5) evaluate
the defensive strategy.
Cleverhans and Foolbox are open-source libraries to benchmark the vulnerability of deep neural networks
against adversarial images. They build frameworks to evaluate
the attacks. However, defensive strategies are missing in both
tools. Providing a dataset of adversarial examples generated
by different methods will make it easy for ﬁnding the blind
point of deep neural networks and developing new defense
strategies. This problem also occurs in other areas in deep
Google Brain organized three competitions in NIPS 2017
competition track, including targeted adversarial attack, nontargeted adversarial attack, and defense against adversarial
attack . The dataset in the competition consisted of a
set of images never used before and manually labeled the
images, 1,000 images for development and 5,000 images for
ﬁnal testing. The submitted attacks and competitions are used
as benchmarks to evaluate themselves. The adversarial attacks
and defenses are scored by the number of runs to fool the
defenses/correctly classify images.
We present workﬂow of a benchmark platform for attackers
and defenders (Figure 10).
3) Various applications for robustness evaluation: Similar
to the existence of adversarial examples for various applications, a wide range of applications make it hard to evaluate
the robustness, of a deep neural network architecture. How
to compare methods generating adversarial example under
different threat models? Do we have a universal methodology
to evaluate the robustness under all scenarios? Tackling these
unsolved problems is a future direction.
VIII. CONCLUSION
In this paper, we reviewed recent ﬁndings of adversarial
examples in deep neural networks. We investigated existing
methods for generating adversarial examples10. A taxonomy
of adversarial examples was proposed. We also explored the
applications and countermeasures for adversarial examples.
This paper attempted to cover state-of-the-art studies for
adversarial examples in the deep learning domain. Compared
with recent work on adversarial examples, we analyzed and
10Due to the rapid development of adversarial examples (attacks and
defenses), we only considered the papers published before November 2017.
We will update the survey with new methodologies and papers in our future
discussed current challenges and potential solutions in adversarial examples.