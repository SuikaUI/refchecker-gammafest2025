Give to AgEcon Search
The Worldâ€™s Largest Open Access Agricultural & Applied Economics Digital Library
This document is discoverable and free to researchers across the
globe due to the work of AgEcon Search.
Help ensure our sustainability.
AgEcon Search
 
 
Papers downloaded from AgEcon Search may be used for non-commercial purposes and personal study only.
No other use, including posting to another Internet site, is permitted without permission from the copyright
owner (not AgEcon Search), or as allowed under the provisions of Fair Use, U.S. Copyright Act, Title 17 U.S.C.
No endorsement of AgEcon Search or its fundraising activities by the author(s) of the following work or their
employer(s) is intended or implied.
The Stata Journal 
4, Number 3, pp. 290â€“311
Implementing matching estimators for average
treatment eï¬€ects in Stata
Alberto Abadie1
Harvard University
David Drukker
Jane Leber Herr
UC Berkeley
Guido W. Imbens2
UC Berkeley
This paper presents an implementation of matching estimators for
average treatment eï¬€ects in Stata. The nnmatch command allows you to estimate
the average eï¬€ect for all units or only for the treated or control units; to choose
the number of matches; to specify the distance metric; to select a bias adjustment;
and to use heteroskedastic-robust variance estimators.
Keywords: st0072, nnmatch, average treatment eï¬€ects, matching, exogeneity, unconfoundedness, ignorability
Introduction
This paper provides a brief introduction to matching estimators for average treatment
eï¬€ects and describes the new Stata command nnmatch which implements these estimators. The command implements nearest-neighbor matching estimators for average
treatment eï¬€ects for either the overall sample or a subsample of treated or control
units. While simple matching estimators have been widely used in the program evaluation literature, nnmatch implements the speciï¬c matching estimators developed in
Abadie and Imbens , including their bias-corrected matching estimator. Following Abadie and Imbens , nnmatch allows individual observations to be used as
a match more than once. Compared with matching without replacement, this method
generally lowers the bias but increases the variance.
While nnmatch provides many options for ï¬ne-tuning the estimators, a key feature
of the program is that it requires few decisions by the researcher. The default settings
are generally suï¬ƒcient for many applications. Although theoretically matching on multidimensional covariates can lead to substantial bias, the matching approach combined
with the bias adjustment implemented in nnmatch often leads to estimators with little
remaining bias.
This paper draws heavily on the more theoretical discussion about matching in
Abadie and Imbens and the survey by Imbens . See also Cochran and
Rubin , Rosenbaum and Rubin , Rubin and Thomas , Rosenbaum
 , Heckman, Ichimura, and Todd , and Wooldridge for more background.
1Abadie gratefully acknowledges ï¬nancial support through NSF grant SES-0350645.
Electronic
correspondence: alberto .
2Imbens gratefully acknowledges ï¬nancial support through NSF grant SES-0136789.
Electronic
correspondence: .
câƒ2004 StataCorp LP
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
We are interested in estimating the average eï¬€ect of a binary treatment on a continuous
or discrete scalar outcome. For individual i, i = 1, . . . , N, with all units exchangeable,
let {Yi(0), Yi(1)} denote the two potential outcomes: Yi(1) is the outcome of individual
i when exposed to the treatment, and Yi(0) is the outcome of individual i when not
exposed to the treatment. For instance, the treatment could be participation in a jobtraining program, and the outcome could be income or wages.
If both Yi(0) and Yi(1) were observable, the eï¬€ect of the treatment on unit i would
be directly observable as Yi(1) âˆ’Yi(0). We could then use this information for the full
sample N to either estimate the population average treatment eï¬€ect (PATE)
Y (1) âˆ’Y (0)
or calculate the sample average treatment eï¬€ect (SATE)
Ï„ sample = 1
Yi(1) âˆ’Yi(0)
Whether the average treatment eï¬€ect in the population (PATE) or the sample (SATE)
is of interest depends on the research question. Inference on the PATE is made with
respect to another sample drawn from the same population; inference on the SATE is
made conditional on the sample at hand. (Although this does not aï¬€ect the choice of
estimator, for this reason, the standard error of the estimated PATE is generally larger
than the standard error of the estimated SATE.) See Imbens for a discussion of
the diï¬€erence between these two estimands.
An example may help to illustrate the meaning of the two estimands. While the
SATE is useful for judging how a job-training program has aï¬€ected a particular group of
participants, the PATE can be used to evaluate whether another group of participants
drawn from the same population is likely to beneï¬t from the program. We can also
deï¬ne the population and sample average treatment eï¬€ect for the subpopulation of the
treated, PATT and SATT,
Ï„ pop,t = E
Y (1) âˆ’Y (0)|W = 1
and Ï„ sample,t = 1
Yi(1) âˆ’Yi(0)
and the population and sample average treatment eï¬€ect for the controls, PATC and
Ï„ pop,c = E
Y (1) âˆ’Y (0)|W = 0
and Ï„ sample,c = 1
Yi(1) âˆ’Yi(0)
where Wi, for Wi âˆˆ{0, 1} indicates the treatment received, and N1 = 
i(1 âˆ’Wi) are the number of treated and control units, respectively.
Abadie and Imbens and Imbens for more details.
Matching estimators for average treatment eï¬€ects
When we estimate average treatment eï¬€ects, only one of the two outcomes is observed. Let the observed outcome be denoted by Yi:
Yi = Yi(Wi) =
To estimate the average treatment eï¬€ect, we will estimate the unobserved potential outcome for each observation in the sample. Consider estimating the untreated outcome,
Yi(0), for person i with covariates Xi, who was exposed to the treatment. If the decision to take the treatment is â€œpurely randomâ€ for individuals with similar values of the
pretreatment variables or covariates, we could use the average outcome of some similar
individuals who were not treated to estimate the untreated outcome. This is the basic
idea behind matching estimators. For each i, matching estimators impute the missing outcome by ï¬nding other individuals in the data whose covariates are similar but
who were exposed to the other treatment. The process of matching similar individuals
who chose the opposite treatment causes these estimators to be known as â€œmatching
estimatorsâ€.
To ensure that the matching estimators identify and consistently estimate the treatment eï¬€ect of interest, we assume that assignment to treatment is independent of
the outcomes, conditional on the covariates, and that the probability of assignment
is bounded away from zero and one.
For all x in the support of X,
(i) W is independent of (Y (0), Y (1)) conditional on X = x;
(ii) c < Pr(W = 1|X = x) < 1 âˆ’c, for some c > 0.
Part (i) is a rigorous deï¬nition of the restriction that the choice of participation be
â€œpurely randomâ€ for similar individuals. This assumption is also known as unconfoundedness, or â€œselection on observablesâ€.
Part (ii) is an identiï¬cation assumption. If all the individuals with a given covariate
pattern chose the treatment, there would be no observations on similar individuals who
chose not to accept the treatment against which to compare them.
For details on these regularity conditions, see Abadie and Imbens .
In their seminal article, Rosenbaum and Rubin deï¬ne the treatment to be
â€œstrongly ignorableâ€ when both parts of assumption 2 are true. They also provide an
explanation for these two conditions, showing how â€œstrong ignorabilityâ€ allows you to
analyze a nonrandomized experiment as if it had come from a randomized experiment.
These conditions are strong and, in many cases, may not be satisï¬ed. In various studies, however, researchers have found it useful to consider estimators based on these or
similar conditions. Imbens argues that most studies will want to proceed under
assumption 2 at some stage of the analysis.
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
Estimators
For each observation i, the unit-level treatment eï¬€ect is Ï„i = Yi(1) âˆ’Yi(0); however,
as discussed above, only one of the potential outcomes Yi(0) or Yi(1) is observed, and
the other is unobserved or missing. The matching estimators we consider impute the
missing potential outcome by using average outcomes for individuals with â€œsimilarâ€
values for the covariates.
Considering the set of observed covariates for an individual i, Xi, let âˆ¥xâˆ¥V
(xâ€²V x)1/2 be the vector norm with positive deï¬nite matrix V . We deï¬ne âˆ¥z âˆ’xâˆ¥V
as the distance between the vectors x and z, where z represents the covariate values for
a potential match for observation i. Let dM(i) be the distance from the covariates for
unit i, Xi, to the Mth nearest match with the opposite treatment. Allowing for the
possibility of ties, at this distance fewer than M units are closer to unit i than dM(i)
and at least M units are as close as dM(i). Formally, dM(i) > 0 is the real number
satisfying
âˆ¥Xlâˆ’Xiâˆ¥V < dM(i)
âˆ¥Xlâˆ’Xiâˆ¥V â‰¤dM(i)
where 1{Â·} is the indicator function, which is equal to one if the expression in brackets
is true and zero otherwise.
Let JM(i) denote the set of indices for the matches for unit i that are at least as
close as the Mth match:
l = 1, . . . , N
Wl = 1 âˆ’Wi, âˆ¥Xl âˆ’Xiâˆ¥V â‰¤dM(i)
If there are no ties, the number of elements in JM(i) is M but may be larger. Let the
number of elements of JM(i) be denoted by #JM(i). Finally, let KM(i) denote the
number of times i is used as a match for all observations l of the opposite treatment
group, each time weighted by the total number of matches for observation l. Let Kâ€²
represent a comparable measure in which the square of the number of matches is used
as the weight.
1{i âˆˆJM(l)}
1{i âˆˆJM(l)}
Note that 
i KM(i) = N, 
i:Wi=1 KM(i) = N0, and 
i:Wi=0 KM(i) = N1.
Matching estimators for average treatment eï¬€ects
The simple matching estimator
The ï¬rst estimator that we consider, the simple matching estimator, uses the following
approach to estimate the pair of potential outcomes:
Namely, given that only one potential outcome is observed for each observation i, the
observed outcome Yi = Yi(0) or Yi(1) represents one potential outcome. The unobserved
outcome is estimated by averaging the observed outcomes for the observations l of the
opposite treatment group that are chosen as matches for i.
Using these estimates of the potential outcomes, the simple matching estimator is
Yi(1) âˆ’Yi(0)
(2Wi âˆ’1) {1 + KM(i)} Yi
This estimator can be modiï¬ed easily to estimate the average treatment eï¬€ect for the
Yi âˆ’Yi(0)
{Wi âˆ’(1 âˆ’Wi)KM(i)} Yi
or the average treatment eï¬€ect for the controls
Yi(1) âˆ’Yi
{WiKM(i) âˆ’(1 âˆ’Wi)} Yi
Some useful examples
In this section, we use a small artiï¬cial dataset to illustrate the concepts discussed above.
The variables for the seven observations are presented in table 1. In this table, we also
present the set of matches for each unit for the case in which M = 1 (a single match)
and, given these matches, the predicted values for the potential outcomes. Note that,
although we search for the single closest match, for some units there is a tie. Consider
the second unit, a control observation with Xi = 4. Treated units 4 and 6, both with
Xi = 3, are equally close, so the predicted outcome, given treatment, is equal to the
average of the outcomes for units 4 and 6, namely, (9 + 6)/2 = 7.5.
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
Table 1: A matching estimator with seven observations, m = 1
Since this dataset is small enough, we can calculate by hand that the SATE for this
data is .14285714. Now letâ€™s compute the estimates using the nnmatch command. While
the complete syntax for nnmatch is given in section 5.1, the basic syntax of nnmatch is
nnmatch depvar treatvar varlist
, tc({ att | atc }) m(#)
tc({ att | atc }) speciï¬es the estimand.
By default, nnmatch estimates the average
treatment eï¬€ect, ATE. Specifying tc(att) causes nnmatch to estimate the average
treatment eï¬€ect for the treated, ATT. Specifying tc(atc) causes nnmatch to estimate
the average eï¬€ect for the controls, ATC.
m(#) speciï¬es the number of matches.
See section 5.1 for a more detailed discussion of the syntax and options available.
In the output below, we estimate the SATE for the artiï¬cial dataset.
. use artificial
. nnmatch y w x
Matching estimator:
Average Treatment Effect
Number of obs
Number of matches
[95% Conf. Interval]
Matching variables:
Note that nnmatch conï¬rms our hand calculation.
Matching estimators for average treatment eï¬€ects
Now letâ€™s consider an example with real data. We use a subset of the experimental dataset used by Lalonde . The particular subset is the one constructed by
Dehejia and Wahba and described there in more detail.
In this example, we are interested in the possible eï¬€ect of participation in a jobtraining program on individualsâ€™ earnings in 1978. In the data, participation in the jobtraining program is recorded in the variable t, and the 1978 earnings of the individuals in
the sample are recorded in the variable re78 . The observable covariates
that we use to match similar individuals are given in table 2.
Variable description
Variable name
years of education
indicator for African-American
indicator for Hispanic
indicator for married
indicator for more than grade school but
less than high-school education
earnings in 1974 
earnings in 1975 
indicator for unemployed in 1974
indicator for unemployed in 1975
In the output below, we estimate the SATE using this data:
. use ldw_exper
. nnmatch re78 t age educ black hisp married re74 re75 u74 u75, m(4)
Matching estimator:
Average Treatment Effect
Weighting matrix: inverse variance
Number of obs
Number of matches
[95% Conf. Interval]
Matching variables:
age educ black hisp married re74 re75 u74 u75
When more than one covariate is speciï¬ed, the matching depends on the weighting
matrix used to deï¬ne a vector norm.
The output reï¬‚ects our choice of the inverse
variance weighting matrix, which accounts for diï¬€erences in the scale of the covariates.
Since 1978 earnings are recorded in thousands this output implies that, for the
individuals in our sample, the average eï¬€ect of participating in the job-training program
is an increase in an individualâ€™s 1978 earnings of $1,903.
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
As noted above, the population and sample average treatment eï¬€ects are useful for
answering diï¬€erent questions.
For instance, the SATE is useful for judging whether
this particular job-training program was successful. In contrast, if we were considering
launching another job-training program in which we would obtain a second sample from
the same population, the PATE would be more useful. For the speciï¬cation at hand,
we conclude that the sample average is signiï¬cantly diï¬€erent from zero at the 1% level.
Since the standard error of the SATE is in large samples less than or equal to the standard
error of the PATE, the PATE might not be signiï¬cantly diï¬€erent from zero at either the
5% or the 1% level. In the output below, we estimate the PATE:
. nnmatch re78 t age educ black hisp married re74 re75 u74 u75, m(4) pop
Matching estimator: Population Average Treatment Effect
Weighting matrix: inverse variance
Number of obs
Number of matches
[95% Conf. Interval]
Matching variables:
age educ black hisp married re74 re75 u74 u75
As expected, the point estimate is exactly the same as for the SATE. We also see that
the standard error of the PATE is slightly smaller than that of the SATE, so we can
still reject the null hypothesis of no eï¬€ect; however, our conclusion is diï¬€erent. Instead
of concluding that the job-training program had a signiï¬cant eï¬€ect on this group of
participants, we now conclude that the job-training program is likely to have an eï¬€ect
on another group of individuals drawn from the same population.
We also need to point out that the eï¬€ect size, as well as the statistical signiï¬cance,
is important in interpreting the results in most treatment-eï¬€ect studies. For instance,
if our earnings data were in terms of dollars instead of thousands of dollars, our results
would indicate a statistically signiï¬cant but economically unimportant impact of the
job-training program.
As discussed in Imbens and Heckman, Ichimura, and Todd , the eï¬€ect
of the treatment on the subpopulation of treated units is frequently more important
than the eï¬€ect on the population as a whole, when evaluating the importance of a narrowly targeted labor-market program. For instance, when evaluating the importance of
a program aimed at increasing the postgraduation earnings of youth from bad neighborhoods, the potential impact of the program on youth from good neighborhoods is
not relevant.
In the output below, we therefore use nnmatch to estimate the SATT using our extract
from the Lalonde data:
Matching estimators for average treatment eï¬€ects
. nnmatch re78 t age educ black hisp married re74 re75 u74 u75, tc(att) m(4)
Matching estimator:
Average Treatment Effect for the Treated
Weighting matrix: inverse variance
Number of obs
Number of matches
[95% Conf. Interval]
Matching variables:
age educ black hisp married re74 re75 u74 u75
The output indicates that the eï¬€ect of the job-training program on the participants in
this sample is statistically diï¬€erent from zero but, perhaps surprisingly, is not much
larger than the SATE.
In most of the examples given in this paper, we use four matches because it oï¬€ers
the beneï¬t of not relying on too little information without incorporating observations
that are not suï¬ƒciently similar. Like all smoothing parameters, the ï¬nal inference can
depend on the choice of the number of matches. For instance, in the output below, we
show that relying on a single match makes the SATT statistically insigniï¬cant:
. nnmatch re78 t age educ black hisp married re74 re75 u74 u75, tc(att)
Matching estimator:
Average Treatment Effect for the Treated
Weighting matrix: inverse variance
Number of obs
Number of matches
[95% Conf. Interval]
Matching variables:
age educ black hisp married re74 re75 u74 u75
Note, however, that the lack of statistical signiï¬cance is due largely to the change in
the point estimate, rather than to the change in the standard error. It is not entirely
clear which estimate is more reliable in this case.
The bias-corrected matching estimator
The simple matching estimator will be biased in ï¬nite samples when the matching is not
exact. Abadie and Imbens show that, with k continuous covariates, the estimator
will have a term corresponding to the matching discrepancies (the diï¬€erence in covariates
between matched units and their matches) that will be of the order Op(N âˆ’1/k). In
practice, we may therefore attempt to remove some of this bias term that remains after
The bias-corrected matching estimator (nnmatch using the biasadj() option) adjusts the diï¬€erence within the matches for the diï¬€erences in their covariate values.
The adjustment is based on an estimate of the two regression functions, Âµw(x) =
E{Y (w)|X = x} for w = 0 or 1.
Following Rubin and Abadie and Imbens
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
 , we approximate these regression functions by linear functions and estimate
them using least squares on the matched observations.
First suppose that we are estimating the average treatment eï¬€ect. In this case, we
estimate the regression functions using only the data in the matched sample
Âµw(x) = Î²w0 + Î²â€²
for w = 0, 1, where
(Î²w0, Î²w1) = argmin{Î²w0,Î²w1}
KM(i) (Yi âˆ’Î²w0 âˆ’Î²â€²
If we are interested in estimating the SATT or PATT, we need only estimate the regression
function for the controls, Âµ0(x). Similarly, for the SATC and PATC we need only estimate
We weight the observations in these regressions by KM(i), the number of times
the unit is used as a match, because the weighted empirical distribution is closer to
the distribution of covariates in which we are ultimately interested.
For this same
reason, we use the matched sample only in this step; using the full sample would include
observations suï¬ƒciently dissimilar from our sample of interest. For example, when we
are estimating the SATT, control units that are not used as matches have potentially
very diï¬€erent covariate values than the treated units we are trying to match. Hence
using these controls to predict outcomes for the treated units leads to results that can
be very sensitive to the exact speciï¬cation applied.
Given the estimated regression functions, for the bias-corrected matching estimator
we predict the missing potential outcomes as
{Yl + Âµ0(Xi) âˆ’Âµ0(Xl)}
{Yl + Âµ1(Xi) âˆ’Âµ1(Xl)}
with the corresponding estimator for the ATE
ËœYi(1) âˆ’ËœYi(0)
Matching estimators for average treatment eï¬€ects
The bias-adjusted matching estimators for the ATT and ATC are
Yi âˆ’ËœYi(0)
and Ï„ bcm,c
ËœYi(1) âˆ’Yi
Now letâ€™s return to our extract from the Lalonde data. In this example, we estimate
the ATT with bias adjustment:
. nnmatch re78 t age educ black hisp married re74 re75 u74 u75, tc(att)
> m(4) bias(bias)
Matching estimator:
Average Treatment Effect for the Treated
Weighting matrix: inverse variance
Number of obs
Number of matches
[95% Conf. Interval]
Matching variables:
age educ black hisp married re74 re75 u74 u75
Bias-adj variables:
age educ black hisp married re74 re75 u74 u75
The above output indicates that using bias adjustment decreases the size of the estimated SATE slightly, thus reducing the signiï¬cance level. We can conclude that the
treatment had an eï¬€ect on its participants that is signiï¬cant at the 5% but not at the
Variance estimation
In this section, we describe the variance estimators implemented in nnmatch. Note that
the bias adjustment does not aï¬€ect the form of the estimator for the variance, although
it may aï¬€ect the numerical value. In contrast, the form of the estimator of the variance
diï¬€ers between the sample and population average treatment eï¬€ects (or the average
eï¬€ect for the treated or controls). In addition, nnmatch oï¬€ers an option for a robust
estimator that allows for heteroskedasticity. Bootstrapping methods for estimating the
variance of matching estimators do not necessarily give correct results. For details on
the theoretical justiï¬cation for the various variance estimators, see Abadie and Imbens
The estimator for the variance of the sample average treatment eï¬€ect (SATE) is
V sample =
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
(Below we discuss estimating the conditional error variance, Ïƒ2
Similarly, the
estimator for the variance of the estimator for SATT is
V sample,t =
{Wi âˆ’(1 âˆ’Wi)KM(i)}2 Ïƒ2
and for the SATC
V sample,c =
{WiKM(i) âˆ’(1 âˆ’Wi)}2 Ïƒ2
As an estimator for the variance of the matching estimator for the population average
treatment eï¬€ect, we use
Yi(1) âˆ’Yi(0) âˆ’Ï„
M(i) + 2KM(i) âˆ’Kâ€²
In large samples, this will be at least as large as the estimator for the variance of the
matching estimator for the SATE. Asymptotically, V pop exceeds V sample by 
Âµ0(Xi)}2/N 2. However, in small samples, V pop need not be larger than V sample. In
practice, we may therefore want to take the maximum of V pop and V sample as the
estimator for the variance of the estimator for the PATE.
As an estimator for the variance of the matching estimator for the PATT, we use
V pop,t =
Yi(1) âˆ’Yi(0) âˆ’Ï„ t2
(Continued on next page)
Matching estimators for average treatment eï¬€ects
Finally, as an estimator for the variance of the matching estimator for the population
average treatment eï¬€ect for the controls, we use
V pop,c =
Yi(1) âˆ’Yi(0) âˆ’Ï„ t2
Estimating these variances requires estimating the conditional outcome variance Ïƒ2
The matching program allows to assume that this variance, Ïƒ2
w(x), is constant for both
treatment groups and all values of the covariates or that it is not.
Assuming a constant treatment eï¬€ect and homoskedasticity
Here we discuss estimating the variance under two assumptions: ï¬rst, that the treatment
eï¬€ect, Yi(1)âˆ’Yi(0), is constant; and second, that the conditional variance of Yi(w) given
Xi does not vary with either the covariates x or the treatment w (homoskedasticity).
Under these two assumptions, for the constant average treatment eï¬€ect, we estimate
the outcome variance Ïƒ2 as
Wi(Yi âˆ’Yl âˆ’Ï„) + (1 âˆ’Wi)(Yl âˆ’Yi âˆ’Ï„)
We then substitute Ïƒ2 for Ïƒ2
Wi(Xi) into the relevant variance formula, (4) or (7). For
the ATT, we estimate Ïƒ2 as
(Yi âˆ’Yl âˆ’Ï„)2
and substitute this for Ïƒ2
Wi(Xi) into (5) or (8). Finally, for the ATC, we estimate Ïƒ2 as
(Yl âˆ’Yi âˆ’Ï„)2
and substitute this for Ïƒ2
Wi(Xi) into (6) or (9).
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
Variance estimation allowing for heteroskedasticity
w(x) instead varies by w and x, we must estimate it for all sample points. nnmatch
does this using a second matching procedure, matching treated units to treated units
and control units to controls. Deï¬ne dâ€²
M(i) as the distance to the Mth closest unit with
the same treatment indicator. More formally, let
l:Wl=Wi,lÌ¸=i
âˆ¥Xl âˆ’Xiâˆ¥V < dâ€²
l:Wl=Wi,lÌ¸=i
âˆ¥Xl âˆ’Xiâˆ¥V â‰¤dâ€²
M(i) denotes the set of indices for the ï¬rst M matches for unit i
j = 1, . . . , N
Wj = Wi, j Ì¸= i, âˆ¥Xj âˆ’Xiâˆ¥V â‰¤dâ€²
where the number of elements of J â€²
M(i) is denoted by #J â€²
M(i). We estimate the conditional variance as the sample variance in this set, augmented with the outcome for unit
i itself, J â€²
M(i)âˆª(i) =
is the average outcome in this set. The overall variance is estimated by plugging this
unit-level variance estimate into the relevant variance expressions (4) through (9).
Now we return to our Lalondeâ€“Dehejiaâ€“Wahba data extract.
In the output below, we re-estimate the SATT, but this time we estimate the standard error allowing
for heteroskedasticity. We specify four matches in estimating the conditional variance
functions (robusth(4)) for the same reason that we allow four matches in estimating
the conditional mean functions: given our data, four matches seem to include suï¬ƒcient
information without matching unlike individuals.
(Continued on next page)
Matching estimators for average treatment eï¬€ects
. nnmatch re78 t age educ black hisp married re74 re75 u74 u75, tc(att)
> m(4) robusth(4)
Matching estimator:
Average Treatment Effect for the Treated
Weighting matrix: inverse variance
Number of obs
Number of matches
Number of matches,
robust std. err. (h) =
[95% Conf. Interval]
Matching variables:
age educ black hisp married re74 re75 u74 u75
The output indicates that our estimated SATT remains signiï¬cant at the 1% level,
even when the standard error is estimated under these weaker conditions. Thus in this
sample, the job-training program appears to have had a signiï¬cant impact on the 1978
earnings of its participants.
The nnmatch command
Here we discuss the formal syntax of the nnmatch command.
Syntax of nnmatch
The complete syntax of nnmatch is as follows:
nnmatch depvar treatvar varlist
, tc({ ate | att | atc }) m(#) metric(maha|matname) exact(varlistex)
biasadj(bias | varlistadj) robusth(#) population level(#) keep(ï¬lename)
pweights are allowed. See [U] 14.1.6 weight for more information about weights. See section 5.2 for information about how nnmatch handles weights.
Description
nnmatch estimates the average treatment eï¬€ect for the treated, the controls, or the
sample as a whole and their standard errors. depvar is the outcome variable. treatvar
is a binary variable treatment indicator. varlist speciï¬es the covariates to be used in
the matching.
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
tc({ ate | att | atc }) speciï¬es the estimand. By default, nnmatch estimates the average
treatment eï¬€ect, ATE. Specifying tc(att) causes nnmatch to estimate the average
treatment eï¬€ect for the treated, ATT. Specifying tc(atc) causes nnmatch to estimate
the average eï¬€ect for the controls, ATC.
m(#) speciï¬es the number of matches to be made per observation. If two observations
are equally close to that being matched, both will be used. Thus, the number of
matches per observation will be greater than or equal to the number speciï¬ed in
The default number of matches is 1, a single match. If we are estimating the average
treatment eï¬€ect, any integer less than or equal to the minimum of the number of
treated and controls in the sample can be chosen, M â‰¤min(N0, N1). If tc(att) is
speciï¬ed, the limit is the number of controls in the sample, M â‰¤N0. If tc(atc) is
speciï¬ed, the limit is the number of treated in the sample, M â‰¤N1.
Typically, we should choose a small number. In simulations in Abadie and Imbens
 , using four matches performed well in terms of mean-squared error.
metric(maha | matname) speciï¬es the metric for measuring the distance between two
vectors of covariates. Letting âˆ¥xâˆ¥V = (xâ€²V x)1/2 be the vector norm with positive
deï¬nite matrix V , we deï¬ne âˆ¥z âˆ’xâˆ¥V to be the distance between the vectors x
and z. There are three choices for V . First, by default V is the diagonal matrix
constructed of the inverses of the variances of each element of Xi (the elements
of varlist).
Second, specifying metric(maha) causes nnmatch to use to use the
Mahalanobis metric, in which V = Sâˆ’1, where S is the sample covariance matrix of
the covariates Xi. Third, specifying metric(matname) causes nnmatch to use the
user-deï¬ned matrix matname. This third option allows you to choose any positive
deï¬nite matrix.
exact(varlistex) allows you to specify exact matching (or as exact as possible) on one or
more variables. As constructed, the exact-matching variables need not overlap with
the elements of varlist. In practice, however, the exact() option adds these variables
to the original k Ã— k varlist matrix and multiplies the corresponding elements in the
weight matrix by 1,000 relative to the weights placed on the elements of varlist.
(Regardless of the metric() option chosen for the varlist variables, the exact-match
variables are normalized via the default optionâ€”the inverse sample variance of the
exact-matching variables.)
Because for each matched observation there may not
exist a member of the opposite treatment group with equal value, matching may
not be exact across the full dataset. The output therefore lists the percentage of
matches (across the paired sample of observations, greater than or equal to N Ã— M
in number) that match exactly.
Matching estimators for average treatment eï¬€ects
biasadj(bias | varlistadj) speciï¬es that the bias-corrected matching estimator be used.
By default, nnmatch uses the simple matching estimator.
The ï¬rst alternative,
biasadj(bias), uses the bias-corrected matching estimator, using the same set of
matching covariates, varlist, entered linearly in the regression function. However,
you might wish to use only a subset of the covariates for this bias adjustment, or
even an alternate set, so the second alternative, biasadj(varlistadj), is to use the
bias-corrected matching estimator with a set of covariates distinct from the set used
in matching.
robusth(#) speciï¬es that nnmatch estimate heteroskedasticity-consistent standard errors using # matches in the second matching stage (across observations of the same
treatment level). The number of matches used in estimating the standard error,
#, need not be the same as the number of matches used in estimating the treatment eï¬€ect itself. By default, nnmatch uses the homoskedastic/constant variance
estimator.
population speciï¬es whether the estimand is a sample or population average treatment
eï¬€ect. This aï¬€ects only the choice of estimator for the variance. By default, nnmatch
estimates a sample average treatment eï¬€ectâ€”SATE, SATT, or SATCâ€”using one of the
variance estimators from (4) through (6). Specifying population causes nnmatch to
estimate the variance for the population average treatment eï¬€ectâ€”PATE, PATT, or
PATCâ€”using one of the estimators from (7) through (9), as appropriate.
level(#) speciï¬es the conï¬dence level, as a percentage, for conï¬dence intervals. The
default is level(95) or as set by set level.
keep(ï¬lename) saves the temporary matching dataset in the ï¬le ï¬lename.dta.
the estimation process, nnmatch creates a temporary dataset holding, for each observation i being matched, a new observation containing the values of iâ€™s outcome
variable, the matching variable(s), and the outcome and matching variable(s) for
its M closest matches. The new dataset will hold at least N Ã— M observations.
If biasadj(varlistadj) or exact(varlistex) are selected, the temporary dataset will
also hold these values for each observation i and its match(es). The variables in this
dataset are discussed in greater detail in section (6).
replace replaces the dataset speciï¬ed in keep(ï¬lename) if it already exists.
How nnmatch handles weights
nnmatch allows probability weights. Under this assumption, an observation represents a
part of the population proportional to its weight. For example, if all observations have
weight 1 other than observation i, which has weight 2, the weighted nnmatch estimates
are identical to those that would be obtained by using the unweighted estimator on
a sample in which observation i is duplicated once. The standard errors are updated
to account for the weighting. The weights are allowed to be noninteger but must be
nonnegative.
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
Formally, with the weight for individual i equal to Ï‰i, the estimator is calculated as
follows. The deï¬nition of the distance dM(i) to the Mth closest match is modiï¬ed to
ensure that the sum of the weights of the matches adds up to M. Thus, dÏ‰
M(i) satisï¬es
âˆ¥Xl âˆ’Xiâˆ¥V < dÏ‰
âˆ¥Xl âˆ’Xiâˆ¥V â‰¤dÏ‰
The deï¬nition of the set JM(i) is unchanged. The KM(i) and Kâ€²
M(i) are changed from
(1) and (2) to
Ï‰l1{i âˆˆJM(l)}
jâˆˆJM(l) Ï‰j
Ï‰l1{i âˆˆJM(l)}
jâˆˆJM(l) Ï‰j
The simple matching estimator is now deï¬ned as
Yi(1) âˆ’Yi(0)
with a similar modiï¬cation for the ATT and ATC. The bias correction is as described
above, except that in (3) the weighted version KÏ‰
M(i) is used.
Matching estimators for average treatment eï¬€ects
The variance formulas change from (4) through (9) to
V sample =
V sample,t =
{WiÏ‰i âˆ’(1 âˆ’Wi)KÏ‰
M(i)}2 Ïƒ2
V sample,c =
i(1 âˆ’Wi)Ï‰i)2
M(i) âˆ’(1 âˆ’Wi)Ï‰i}2 Ïƒ2
Yi(1) âˆ’Yi(0) âˆ’Ï„
M(i)}2 + 2KÏ‰
V pop,t =
Yi(1) âˆ’Yi(0) âˆ’Ï„ c2
M(i)}2 âˆ’KÏ‰â€²
V pop,c =
i(1 âˆ’Wi)Ï‰i)2
Yi(1) âˆ’Yi(0) âˆ’Ï„ c2
M(i)}2 âˆ’KÏ‰â€²
As always, we must pay attention to the interpretation of these weighted estimators.
In the population variance estimators, the weights correct any bias introduced by the
sampling design so that inference is made with respect to the underlying population
of interest. The weighted sample variances can thus be interpreted as providing inference about another sample of identical individuals drawn from the population that
corresponds to the weights.
Wi(Xi), we modify the earlier estimators. In the homoskedastic case, the errorvariance estimator is changed from (10) to
lâˆˆJM (i) Ï‰l
Wi(Yi âˆ’Yl âˆ’Ï„) + (1 âˆ’Wi)(Yl âˆ’Yi âˆ’Ï„)
with similar modiï¬cations for the ATT and ATC cases.
A. Abadie, D. Drukker, J. L. Herr, and G. W. Imbens
In the heteroskedastic case, the conditional variance Ïƒ2
w(x) is estimated using matching with some modiï¬cation for the weights. First, dÏ‰â€²
M(x) is deï¬ned as
l:Wl=Wi,lÌ¸=i
âˆ¥Xl âˆ’Xiâˆ¥V < dÏ‰â€²
l:Wl=Wi,lÌ¸=i
âˆ¥Xl âˆ’Xiâˆ¥V â‰¤dÏ‰â€²
with the set J â€²
M(i) containing the indices for the matches for unit i:
j = 1, . . . , N
Wj = Wi, j Ì¸= i, âˆ¥Xj âˆ’Xiâˆ¥V â‰¤dÏ‰â€²
We estimate the conditional variance, Ïƒ2
Wi(Xi), as the sample variance in this set,
augmented with the outcome for unit i itself, U = J â€²
M(i) âˆª{i}, taking into account the
is the average outcome in this set. The overall variance is estimated by plugging this
unit-level variance estimate into the relevant variance expression (4â€²) through (9â€²).
The matching dataset
If keep(ï¬lename) is selected, each observation of ï¬lename.dta will hold the following
variables:
(Continued on next page)
Matching estimators for average treatment eï¬€ects
The treatment group indicator for the observation being matched.
The observed outcome variable for observation i.
The values of the covariates, varlist, for observation i.
The identiï¬cation code for the observation being matched. (When the
command nnmatch is given, the program creates a temporary variable,
id = 1, 2, . . . , N, based on the original sort order.)
The identiï¬cation code for j, the match for observation i.
The estimated distance between observation i and its match j, based on
the values of the varlist and the selected weight matrix.
The number of times observation i is used as a match for any observation
l of the opposite treatment level, each time weighted by the total
number of matches for the given observation l. For example, if
observation i is one of three matches for observation l, it receives a
value of 1/3 for that match. k m is the sum across all observations l of
this value. Thus the sum of k m across all observations will equal N
(or N0 or N1, if the ATC or ATT, respectively, are estimated). Note that
this value refers to iâ€™s use as a match, not to its matches j, so the value
of k m is equal across all observations in the temporary dataset that
pertain to the matching of observation i.
Weight for observation i, if weights are selected.
Weight of observation j, the match for observation i, if weights are
The estimated value of the dependent variable if observation i were in the
control group. If observation i is a control observation, y 0 = y(i). If i
is a treated observation, y 0 = y(j).
Estimated value of the dependent variable if i were in the treated group.
Values of varlist for iâ€™s control observation. Namely, if i is a control
observation, x 0m = xi for each element x of varlist. If i is a
treated observation, x 0m = xj.
Values of varlist for iâ€™s treatment observation.
Values of the bias-adjustment variables, if biasadj() is selected, for iâ€™s
control observation, where b represents each element of the
bias-adjustment variables.
Bias-adjustment variables for iâ€™s treatment observation.
Values of the exact-matching variables, if exact() is selected, for iâ€™s
control observation, where e represents each element of the
exact-matching variables.
Exact-matching variables for iâ€™s treatment observation.