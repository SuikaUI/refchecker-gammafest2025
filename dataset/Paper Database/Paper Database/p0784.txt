Unsupervised Pixel–Level Domain Adaptation
with Generative Adversarial Networks
Konstantinos Bousmalis
Google Brain
London, UK
 
Nathan Silberman
Google Research
New York, NY
 
David Dohan∗
Google Brain
Mountain View, CA
 
Dumitru Erhan
Google Brain
San Francisco, CA
 
Dilip Krishnan
Google Research
Cambridge, MA
 
Collecting well-annotated image datasets to train modern machine learning algorithms is prohibitively expensive
for many tasks. An appealing alternative is to render synthetic data where ground-truth annotations are generated
automatically. Unfortunately, models trained purely on rendered images often fail to generalize to real images. To address this shortcoming, prior work introduced unsupervised
domain adaptation algorithms that attempt to map representations between the two domains or learn to extract features that are domain–invariant. In this work, we present
a new approach that learns, in an unsupervised manner, a
transformation in the pixel space from one domain to the
other. Our generative adversarial network (GAN)–based
model adapts source-domain images to appear as if drawn
from the target domain. Our approach not only produces
plausible samples, but also outperforms the state-of-the-art
on a number of unsupervised domain adaptation scenarios
by large margins. Finally, we demonstrate that the adaptation process generalizes to object classes unseen during
1. Introduction
Large and well–annotated datasets such as ImageNet ,
COCO and Pascal VOC are considered crucial
to advancing computer vision research. However, creating
such datasets is prohibitively expensive. One alternative is
the use of synthetic data for model training. It has been
a long-standing goal in computer vision to use game engines or renderers to produce virtually unlimited quantities
∗Google Brain Residency Program: g.co/brainresidency.
(a) Image examples from the Linemod dataset.
(b) Examples generated by our model, trained on Linemod.
Figure 1. RGBD samples generated with our model vs real RGBD
samples from the Linemod dataset . In each subﬁgure the
top row is the RGB part of the image, and the bottom row is the
corresponding depth channel. Each column corresponds to a speciﬁc object in the dataset. See Sect. 4 for more details.
of labeled data. Indeed, certain areas of research, such as
deep reinforcement learning for robotics tasks, effectively
require that models be trained in synthetic domains as training in real–world environments can be excessively expensive . Consequently, there has been a renewed interest in training models in the synthetic domain and applying
them in real–world settings .
Unfortunately, models naively trained on synthetic data do
not typically generalize to real images.
A solution to this problem is using unsupervised domain
 
adaptation. In this setting, we would like to transfer knowledge learned from a source domain, for which we have labeled data, to a target domain for which we have no labels.
Previous work either attempts to ﬁnd a mapping from representations of the source domain to those of the target ,
or seeks to ﬁnd domain-invariant representations that are
shared between the two domains . While
such approaches have shown good progress, they are still
not on par with purely supervised approaches trained only
on the target domain.
In this work, we train a model to change images from the
source domain to appear as if they were sampled from the
target domain while maintaining their original content. We
propose a novel Generative Adversarial Network (GAN)–
based architecture that is able to learn such a transformation
in an unsupervised manner, i.e. without using corresponding pairs from the two domains. Our unsupervised pixellevel domain adaptation method (PixelDA) offers a number
of advantages over existing approaches:
Decoupling from the Task-Speciﬁc Architecture:
most domain adaptation approaches, the process of domain
adaptation and the task-speciﬁc architecture used for inference are tightly integrated. One cannot switch a task–
speciﬁc component of the model without having to re-train
the entire domain adaptation process. In contrast, because
our PixelDA model maps one image to another at the pixel
level, we can alter the task-speciﬁc architecture without
having to re-train the domain adaptation component.
Generalization Across Label Spaces:
Because previous
models couple domain adaptation with a speciﬁc task, the
label spaces in the source and target domain are constrained
to match. In contrast, our PixelDA model is able to handle
cases where the target label space at test time differs from
the label space at training time.
Training Stability:
Domain adaptation approaches that
rely on some form of adversarial training are sensitive to random initialization. To address this, we incorporate
a task–speciﬁc loss trained on both source and generated
images and a pixel similarity regularization that allows us
to avoid mode collapse and stabilize training. By using
these tools, we are able to reduce variance of performance
for the same hyperparameters across different random initializations of our model (see section 4).
Data Augmentation:
Conventional domain adaptation
approaches are limited to learning from a ﬁnite set of source
and target data. However, by conditioning on both source
images and a stochastic noise vector, our model can be used
to create virtually unlimited stochastic samples that appear
similar to images from the target domain.
Interpretability:
The output of PixelDA, a domain–
adapted image, is much more easily interpreted than a domain adapted feature vector.
To demonstrate the efﬁcacy of our strategy, we focus on
the tasks of object classiﬁcation and pose estimation, where
the object of interest is in the foreground of a given image,
for both source and target domains. Our method outperforms the state-of-the-art unsupervised domain adaptation
techniques on a range of datasets for object classiﬁcation
and pose estimation, while generating images that look very
similar to the target domain (see Figure 1).
2. Related Work
Learning to perform unsupervised domain adaptation is
an open theoretical and practical problem.
While much
prior work exists, our literature review focuses primarily on
Convolutional Neural Network (CNN) methods due to their
empirical superiority on the problem .
Unsupervised Domain Adaptation:
Ganin et al. 
and Ajakan et al. introduced the Domain–Adversarial
Neural Network (DANN): an architecture trained to extract
domain-invariant features. Their model’s ﬁrst few layers
are shared by two classiﬁers: the ﬁrst predicts task-speciﬁc
class labels when provided with source data while the second is trained to predict the domain of its inputs. DANNs
minimize the domain classiﬁcation loss with respect to parameters speciﬁc to the domain classiﬁer, while maximizing
it with respect to the parameters that are common to both
classiﬁers. This minimax optimization becomes possible in
a single step via the use of a gradient reversal layer. While
DANN’s approach to domain adaptation is to make the features extracted from both domains similar, our approach is
to adapt the source images to look as if they were drawn
from the target domain. Tzeng et al. and Long et al.
 proposed versions of DANNs where the maximization
of the domain classiﬁcation loss is replaced by the minimization of the Maximum Mean Discrepancy (MMD) metric , computed between features extracted from sets of
samples from each domain. Ghifary et al. [?] propose an alternative model in which the task loss for the source domain
is combined with a reconstruction loss for the target domain, which results in learning domain-invariant features.
Bousmalis et al. introduce a model that explicitly separates the components that are private to each domain from
those that are common to both domains. They make use of
a reconstruction loss for each domain, a similarity loss (eg.
DANN, MMD) which encourages domain invariance, and a
difference loss which encourages the common and private
representation components to be complementary.
Other related techniques involve learning a mapping
from one domain to the other at a feature level. In such a
setup, the feature extraction pipeline is ﬁxed during the domain adaptation optimization. This has been applied in various non-CNN based approaches as well as the
more recent CNN-based Correlation Alignment (CORAL)
 algorithm.
Generative Adversarial Networks:
Our model uses
GANs conditioned on source images and noise vectors. Other recent works have also attempted to use GANs
conditioned on images. Ledig et al. used an imageconditioned GAN for super-resolution. Yoo et al. introduce the task of generating images of clothes from images of models wearing them, by training on corresponding
pairs of the clothes worn by models and on a hanger. In contrast to our work, neither method conditions on both images
and noise vectors, and ours is also applied to an entirely
different problem space.
The work perhaps most similar to ours is that of Liu and
Tuzel who introduce an architecture of a pair of coupled GANs, one for the source and one for the target domain, whose generators share their high-layer weights and
whose discriminators share their low-layer weights. In this
manner, they are able to generate corresponding pairs of
images which can be used for unsupervised domain adaptation. on the ability to generate high quality samples from
noise alone.
Style Transfer:
The popular work of Gatys et al. 
introduced a method of style transfer, in which the style of
one image is transferred to another while holding the content ﬁxed. The process requires backpropagating back to
the pixels. Johnson et al. introduce a model for feed
forward style transfer. They train a network conditioned on
an image to produce an output image whose activations on a
pre-trained model are similar to both the input image (highlevel content activations) and a single target image (lowlevel style activations). However, both of these approaches
are optimized to replicate the style of a single image as opposed to our work which seeks to replicate the style of an
entire domain of images.
We begin by explaining our model for unsupervised
pixel-level domain adaptation (PixelDA) in the context of
image classiﬁcation, though our method is not speciﬁc to
this particular task.
Given a labeled dataset in a source
domain and an unlabeled dataset in a target domain, our
goal is to train a classiﬁer on data from the source domain
that generalizes to the target domain. Previous work performs this task using a single network that performs both
domain adaptation and image classiﬁcation, making the domain adaptation process speciﬁc to the classiﬁer architecture. Our model decouples the process of domain adaptation from the process of task-speciﬁc classiﬁcation, as its
primary function is to adapt images from the source domain
to make them appear as if they were sampled from the target domain. Once adapted, any off-the-shelf classiﬁer can
be trained to perform the task at hand as if no domain adaptation were required. Note that we assume that the differences between the domains are primarily low-level (due to
noise, resolution, illumination, color) rather than high-level
(types of objects, geometric variations, etc).
More formally, let Xs = {xs
i=0 represent a labeled
dataset of N s samples from the source domain and let Xt =
i=0 represent an unlabeled dataset of N t samples from
the target domain. Our pixel adaptation model consists of
a generator function G(xs, z; θG) →xf, parameterized by
θG, that maps a source domain image xs ∈Xs and a noise
vector z ∼pz to an adapted, or fake, image xf. Given the
generator function G, it is possible to create a new dataset
Xf = {G(xs, z), ys} of any size. Finally, given an adapted
dataset Xf, the task-speciﬁc classiﬁer can be trained as if
the training and test data were from the same distribution.
3.1. Learning
To train our model, we employ a generative adversarial
objective to encourage G to produce images that are similar
to the target domain images. During training, our generator G(xs, z; θG) →xf maps a source image xs and a
noise vector z to an adapted image xf. Furthermore, the
model is augmented by a discriminator function D(x; θD)
that outputs the likelihood d that a given image x has been
sampled from the target domain. The discriminator tries to
distinguish between ‘fake’ images Xf produced by the generator, and ‘real’ images from the target domain Xt. Note
that in contrast to the standard GAN formulation in
which the generator is conditioned only on a noise vector,
our model’s generator is conditioned on both a noise vector and an image from the source domain. In addition to
the discriminator, the model is also augmented with a classiﬁer T(x; θT ) →ˆy which assigns task-speciﬁc labels ˆy to
images x ∈{Xf, Xt}.
Our goal is to optimize the following minimax objective:
α Ld(D, G) + βLt(G, T)
where α and β are weights that control the interaction of the
losses. Ld represents the domain loss:
Ld(D, G) = Ext[log D(xt; θD)]+
Exs,z[log(1 −D(G(xs, z; θG); θD))]
Lt is a task-speciﬁc loss, and in the case of classiﬁcation we
use a typical softmax cross–entropy loss:
Lt(G, T) = Exs,ys,z
−ys⊤log T (G(xs, z; θG); θT )
−ys⊤log T(xs); θT
where ys is the one-hot encoding of the class label for
source input xs. Notice that we train T with both adapted
and non-adapted source images.
When training T only
on adapted images, it’s possible to achieve similar performance, but doing so may require many runs with different
initializations due to the instability of the model. Indeed,
Discriminator D
Generator G
xs (synthetic)
Residual Block
Residual Block
Residual Block
fc:sigmoid
Figure 2. An overview of the model architecture. On the left, we depict the overall model architecture following the style in . On the
right, we expand the details of the generator and the discriminator components. The generator G generates an image conditioned on a
synthetic image xs and a noise vector z. The discriminator D discriminates between real and fake images. The task–speciﬁc classiﬁer T
assigns task–speciﬁc labels y to an image. A convolution with stride 1 and 64 channels is indicated as n64s1 in the image. lrelu stands for
leaky ReLU nonlinearity. BN stands for a batch normalization layer and FC for a fully connected layer. Note that we are not displaying
the speciﬁcs of T as those are different for each task and decoupled from the domain adaptation process.
without training on source as well, the model is free to shift
class assignments (e.g. class 1 becomes 2, class 2 becomes
3 etc) while still being successful at optimizing the training
objective. We have found that training classiﬁer T on both
source and adapted images avoids this scenario and greatly
stabilizes training (See Table 5). might use a different label
space (See Table 4).
In our implementation, G is a convolutional neural network with residual connections that maintains the resolution of the original image as illustrated in ﬁgure 2. Our discriminator D is also a convolutional neural network. The
minimax optimization of Equation 1 is achieved by alternating between two steps.
During the ﬁrst step, we update the discriminator and task-speciﬁc parameters θD, θT ,
while keeping the generator parameters θG ﬁxed. During
the second step we ﬁx θD, θT and update θG.
3.2. Content–similarity loss
In certain cases, we have prior knowledge regarding the
low-level image adaptation process. For example, we may
expect the hues of the source and adapted images to be the
same. In our case, for some of our experiments, we render
single objects on black backgrounds and consequently we
expect images adapted from these renderings to have similar foregrounds and different backgrounds from the equivalent source images. Renderers typically provide access to
z-buffer masks that allow us to differentiate between foreground and background pixels. This prior knowledge can
be formalized via the use of an additional loss that penalizes large differences between source and generated images
for foreground pixels only. Such a similarity loss grounds
the generation process to the original image and helps stabilize the minimax optimization, as shown in Sect. 4.4 and
Table 5. Our optimization objective then becomes:
αLd(D, G) + βLt(T, G) + γLc(G)
where α, β, and γ are weights that control the interaction of
the losses, and Lc is the content–similarity loss.
A number of losses could anchor the generated image
to the original image in some meaningful way (e.g. L1,
or L2 loss, similarity in terms of the activations of a pretrained VGG network). In our experiments for learning object instance classiﬁcation from rendered images, we use a
masked pairwise mean squared error, which is a variation
of the pairwise mean squared error (PMSE) . This loss
penalizes differences between pairs of pixels rather than absolute differences between inputs and outputs. Our masked
version calculates the PMSE between the generated foreground and the source foreground. Formally, given a binary
mask m ∈Rk, our masked-PMSE loss is:
Lc(G) = Exs,z
k ∥(xs −G(xs, z; θG)) ◦m∥2
 (xs −G(xs, z; θG))⊤m
Figure 3. Visualization of our model’s ability to generate samples
when trained to adapt MNIST to MNIST-M. (a) Source images xs
from MNIST; (b) The samples adapted with our model G(xs, z)
with random noise z; (c) The nearest neighbors in the MNIST-M
training set of the generated samples in the middle row. Differences between the middle and bottom rows suggest that the model
is not memorizing the target dataset.
where k is the number of pixels in input x, ∥· ∥2
squared L2-norm, and ◦is the Hadamard product. This loss
allows the model to learn to reproduce the overall shape of
the objects being modeled without wasting modeling power
on the absolute color or intensity of the inputs, while allowing our adversarial training to change the object in a
consistent way. Note that the loss does not hinder the foreground from changing but rather encourages the foreground
to change in a consistent way. In this work, we apply a
masked PMSE loss for a single foreground object because
of the nature of our data, but one can trivially extend this to
multiple foreground objects.
4. Evaluation
We evaluate our method on object classiﬁcation datasets
used in previous work1, including MNIST, MNIST-M ,
and USPS as well as a variation of the LineMod
dataset , a standard for object instance recognition
and 3D pose estimation, for which we have synthetic and
real data. Our evaluation is composed of qualitative and
quantitative components, using a number of unsupervised
domain adaptation scenarios. The qualitative evaluation involves the examination of the ability of our method to learn
the underlying pixel adaptation process from the source to
the target domain by visually inspecting the generated images.
The quantitative evaluation involves a comparison
of the performance of our model to previous work and to
“Source Only” and “Target Only” baselines that do not use
any domain adaptation.
In the ﬁrst case, we train models only on the unaltered source training data and evaluate on the target test data. In the “Target Only” case we
train task models on the target domain training set only and
evaluate on the target domain test set. The unsupervised
domain adaptation scenarios we consider are listed below:
MNIST to USPS: Images of the 10 digits (0-9) from the
MNIST dataset are used as the source domain and im-
1The most commonly used dataset for visual domain adaptation in the
context of object classiﬁcation is Ofﬁce . However, we do not use
it in this work as there are signiﬁcant high–level variations due to label
pollution. For more information, see the relevant explanation in .
ages of the same 10 digits from the USPS dataset represent the target domain. To ensure a fair comparison between
the “Source–Only” and domain adaptation experiments, we
train our models on a subset of 50,000 images from the original 60,000 MNIST training images. The remaining 10,000
images are used as validation set for the “Source–Only” experiment. The standard splits for USPS are used, comprising of 6,562 training, 729 validation, and 2,007 test images.
MNIST to MNIST-M: MNIST digits represent the
source domain and MNIST-M digits represent the target domain. MNIST-M is a variation on MNIST proposed
for unsupervised domain adaptation. Its images were created by using each MNIST digit as a binary mask and inverting with it the colors of a background image. The background images are random crops uniformly sampled from
the Berkeley Segmentation Data Set (BSDS500) . All
our experiments follow the experimental protocol by .
We use the labels for 1,000 out of the 59,001 MNIST-M
training examples to ﬁnd optimal hyperparameters.
Synthetic Cropped LineMod to Cropped LineMod:
The LineMod dataset is a dataset of small objects in
cluttered indoor settings imaged in a variety of poses. We
use a cropped version of the dataset , where each image
is cropped with one of 11 objects in the center. The 11 objects used are ‘ape’, ‘benchviseblue’, ‘can’, ‘cat’, ‘driller’,
‘duck’, ‘holepuncher’, ‘iron’, ‘lamp’, ‘phone’, and ‘cam’.
A second component of the dataset consists of CAD models of these same 11 objects in a large variety of poses rendered on a black background, which we refer to as Synthetic
Cropped LineMod. We treat Synthetic Cropped LineMod as
the source dataset and the real Cropped LineMod as the target dataset. We train our model on 109,208 rendered source
images and 9,673 real-world target images for domain adaptation, 1,000 for validation, and a target domain test set of
2,655 for testing. Using this scenario, our task involves both
classiﬁcation and pose estimation. Consequently, our task–
speciﬁc network T(x; θT ) →{ˆy, ˆq} outputs both a class ˆy
and a 3D pose estimate in the form of a positive unit quaternion vector ˆq. The task loss becomes:
Lt(G, T) =
−ys⊤log ˆys −ys⊤log ˆyf+
where the ﬁrst and second terms are the classiﬁcation loss,
similar to Equation 3, and the third and fourth terms are
the log of a 3D rotation metric for quaternions .
is the weight for the pose loss, qs represents the ground
truth 3D pose of a sample, {ˆys, ˆqs}
T(xs; θT ),
{ˆyf, ˆqf} = T(G(xs, z; θG); θT ). Table 2 reports the mean
angle the object would need to be rotated (on a ﬁxed 3D
axis) to move from predicted to ground truth pose .
Figure 4. Visualization of our model’s ability to generate samples when trained to adapt Synth Cropped Linemod to Cropped Linemod. Top
Row: Source RGB and Depth image pairs from Synth Cropped LineMod xs; Middle Row: The samples adapted with our model G(xs, z)
with random noise z; Bottom Row: The nearest neighbors between the generated samples in the middle row and images from the target
training set. Differences between the generated and target images suggest that the model is not memorizing the target dataset.
4.1. Implementation Details
All the models are implemented using TensorFlow2 
and are trained with the Adam optimizer . We optimize the objective in Equation 1 for “MNIST to USPS” and
“MNIST to MNIST-M” scenarios and the one in Equation 4
for the “Synthetic Cropped Linemod to Cropped Linemod”
We use batches of 32 samples from each domain and the input images are zero-centered and rescaled
to [−1, 1]. In our implementation, we let G take the form of
a convolutional residual neural network that maintains the
resolution of the original image as shown in Figure 2. z
is a vector of N z elements, each sampled from a uniform
distribution zi ∼U(−1, 1). It is fed to a fully connected
layer which transforms it to a channel of the same resolution as that of the image channels, and is subsequently
concatenated to the input as an extra channel. In all our experiments we use a z with N z = 10. The discriminator D is
a convolutional neural network where the number of layers
depends on the image resolution: the ﬁrst layer is a stride
1x1 convolution (motivated by ), which is followed by
repeatedly stacking stride 2x2 convolutions until we reduce
the resolution to less or equal to 4x4. The number of ﬁlters is 64 in all layers of G, and is 64 in the ﬁrst layer of D
and repeatedly doubled in subsequent layers. The output of
this pyramid is fed to a fully–connected layer with a single
activation for the domain classiﬁcation loss. 3 For all our
experiments, the CNN topologies used for the task classiﬁer
T are identical to the ones used in to be comparable
to previous work in unsupervised domain adaptation.
4.2. Quantitative Results
We have not found a universally applicable way to optimize hyperparameters for unsupervised domain adaptation.
Consequently, we follow the experimental protocol of 
2Our code is available here: 
3Our architecture details can be found in the supplementary material.
Table 1. Mean classiﬁcation accuracy (%) for digit datasets. The
“Source-only” and “Target-only” rows are the results on the target
domain when using no domain adaptation and training only on the
source or the target domain respectively. We note that our Source
and Target only baselines resulted in different numbers than previously published works which we also indicate in parenthesis.
Source Only
63.6 (56.6)
CORAL 
MMD 
CoGAN 
Our PixelDA
Target-only
96.4 (95.9)
and use a small set (∼1,000) of labeled target domain data
as a validation set for the hyperparameters of all the methods we compare. We perform all experiments using the
same protocol to ensure fair and meaningful comparison.
The performance on this validation set can serve as an upper bound of a satisfactory validation metric for unsupervised domain adaptation. As we discuss in section 4.5, we
also evaluate our model in a semi-supervised setting with
1,000 labeled examples in the target domain, to conﬁrm that
PixelDA is still able to improve upon the naive approach of
training on this small set of target labeled examples.
We evaluate our model using the aforementioned combinations of source and target datasets, and compare the performance of our model’s task architecture T to that of other
state-of-the-art unsupervised domain adaptation techniques
based on the same task architecture T. As mentioned above,
in order to evaluate the efﬁcacy of our model, we ﬁrst compare with the accuracy of models trained in a “Source Only”
setting for each domain adaptation scenario. This setting
represents a lower bound on performance. Next we compare
models in a “Target Only” setting for each scenario. This
setting represents a weak upper bound on performance—as
it is conceivable that a good unsupervised domain adaptation model might improve on these results, as we do in this
work for “MNIST to MNIST-M”.
Quantitative results of these comparisons are presented
in Tables 1 and 2.
Our method is able to not just
achieve better results than previous work on the “MNIST to
MNIST-M” scenario, it is also able to outperform the “Target Only” performance we are able to get with the same task
classiﬁer. Furthermore, we are also able to achieve stateof-the art results for the “MNIST to USPS” scenario. Finally, PixelDA is able to reduce the mean angle error for the
“Synth Cropped Linemod to Cropped Linemod” scenario to
more than half compared to the previous state-of-the-art.
4.3. Qualitative Results
The qualitative results of our model are illustrated in ﬁgures 1, 3, and 4. In ﬁgures 3 and 4 one can see the visualization of the generation process, as well as the nearest neighbors of our generated samples in the target domain. In both
scenarios, it is clear that our method is able to learn the underlying transformation process that is required to adapt the
original source images to images that look like they could
belong in the target domain. As a reminder, the MNIST-M
digits have been generated by using MNIST digits as a binary mask to invert the colors of a background image. It is
clear from ﬁgure 3 that in the “MNIST to MNIST-M” case,
our model is able to not only generate backgrounds from
different noise vectors z, but it is also able to learn this inversion process. This is clearly evident from e.g. digits 3
and 6 in the ﬁgure. In the “Synthetic Cropped Linemod to
Cropped Linemod” case, our model is able to sample, in the
RGB channels, realistic backgrounds and adjust the photometric properties of the foreground object. In the depth
channel it is able to learn a plausible noise model.
Table 2. Mean classiﬁcation accuracy and pose error for the “Synth
Cropped Linemod to Cropped Linemod” scenario.
Classiﬁcation
Mean Angle
Source-only
MMD 
Our PixelDA
Target-only
4.4. Model Analysis
We present a number of additional experiments that
demonstrate how the model works and to explore potential
limitations of the model.
Sensitivity to Used Backgrounds
In both the “MNIST to
MNIST-M” and “Synthetic-Cropped LineMod to Cropped
Table 3. Mean classiﬁcation accuracy and pose error when varying the background of images from the source domain. For these
experiments we used only the RGB portions of the images, as
there is no trivial or typical way with which we could have added
backgrounds to depth images. For comparison, we display results
with black backgrounds and Imagenet backgrounds (INet), with
the “Source Only” setting and with our model for the RGB-only
Model–RGB-only
Classiﬁcation
Mean Angle
Source-Only–Black
PixelDA–Black
Source-Only–INet
PixelDA–INet
LineMod” scenarios, the source domains are images of digits or objects on black backgrounds. Our quantitative evaluation (Tables 1 and 2) illustrates the ability of our model
to adapt the source images to the target domain style but
raises two questions: Is it important that the backgrounds
of the source images are black and how successful are dataaugmentation strategies that use a randomly chosen background image instead?
To that effect we ran additional
experiments where we substituted various backgrounds in
place of the default black background for the Synthetic
Cropped Linemod dataset. The backgrounds are randomly
selected crops of images from the ImageNet dataset.
these experiments we used only the RGB portion of the images —for both source and target domains— since we don’t
have equivalent “backgrounds” for the depth channel. As
demonstrated in Table 3, PixelDA is able to improve upon
training ‘Source-only’ models on source images of objects
on either black or random Imagenet backgrounds.
Generalization of the Model
Two additional aspects of
the model are relevant to understanding its performance.
Firstly, is the model actually learning a successful pixellevel data adaptation process, or is it simply memorizing the
target images and replacing the source images with images
from the target training set? Secondly, is the model able to
generalize about the two domains in a fashion not limited to
the classes of objects seen during training?
To answer the ﬁrst question, we ﬁrst run our generator
G on images from the source images to create an adapted
dataset. Next, for each transferred image, we perform a
pixel-space L2 nearest neighbor lookup in the target training images to determine whether the model is simply memorizing images from the target dataset or not. Illustrations
are shown in ﬁgures 3 and 4, where the top rows are samples
from xs, the middle rows are generated samples G(xs, z),
and the bottom rows are the nearest neighbors of the generated samples in the target training set. It is clear from the
ﬁgures that the model is not memorizing images from the
target training set.
Table 4. Performance of our model trained on only 6 out of 11
Linemod objects. The ﬁrst row, ‘Unseen Classes,’ displays the performance on all the samples of the remaining 5 Linemod objects
not seen during training. The second row, ‘Full test set,’ displays
the performance on the target domain test set for all 11 objects.
Classiﬁcation
Mean Angle
Unseen Classes
Full test set
Table 5. The effect of using the task and content losses Lt, Lc on
the standard deviation (std) of the performance of our model on the
“Synth Cropped Linemod to Linemod” scenario. Lsource
we use source data to train T; Ladapted
means we use generated
data to train T; Lc means we use our content–similarity loss. A
lower std on the performance metrics means that the results are
more easily reproducible.
Classiﬁcation
Mean Angle
Accuracy std
Next, we evaluate our model’s ability to generalize to
classes unseen during training. To do so, we retrain our best
model using a subset of images from the source and target
domains which includes only half of the object classes for
the “Synthetic Cropped Linemod” to “Cropped Linemod”
scenario. Speciﬁcally, the objects ‘ape’, ‘benchviseblue’,
‘can’, ‘cat’, ‘driller’, and ‘duck’ are observed during the
training procedure, and the other objects are only used during testing. Once G is trained, we ﬁx its weights and pass
the full training set of the source domain to generate images
used for training the task-classiﬁer T. We then evaluate the
performance of T on the entire set of unobserved objects
(6,060 samples), and the test set of the target domain for all
objects for direct comparison with Table 2.
Stability Study
We also evaluate the importance of the
different components of our model. We demonstrate that
while the task and content losses do not improve the overall performance of the model, they dramatically stabilize
Training instability is a common characteristic
of adversarial training, necessitating various strategies to
deal with model divergence and mode collapse . We
measure the standard deviation of the performance of our
models by running each model 10 times with different random parameter initialization but with the same hyperparameters. Table 5 illustrates that the use of the task and content–
similarity losses reduces the level of variability across runs.
4.5. Semi-supervised Experiments
Finally, we evaluate the usefulness of our model in a
semi–supervised setting, in which we assume we have a
small number of labeled target training examples.
Table 6. Semi-supervised experiments for the “Synthetic Cropped
Linemod to Cropped Linemod” scenario. When a small set of
1,000 target data is available to our model, it is able to improve
upon baselines trained on either just these 1,000 samples or the
synthetic training set augmented with these labeled target samples.
Classiﬁcation
Mean Angle
Synth+1000
Our PixelDA
semi-supervised version of our model simply uses these additional training samples as extra input to classiﬁer T during training. We sample 1,000 examples from the Cropped
Linemod not used in any previous experiment and use them
as additional training data. We evaluate the semi-supervised
version of our model on the test set of the Cropped Linemod
target domain against the 2 following baselines: (a) training
a classiﬁer only on these 1,000 target samples without any
domain adaptation, a setting we refer to as ‘1,000-only’; and
(b) training a classiﬁer on these 1,000 target samples and the
entire Synthetic Cropped Linemod training set with no domain adaptation, a setting we refer to as ‘Synth+1000’. As
one can see from Table 6 our model is able to greatly improve upon the naive setting of incorporating a few target
domain samples during training. We also note that PixelDA
leverages these samples to achieve an even better performance than in the fully unsupervised setting (Table 2).
5. Conclusion
We present a state-of-the-art method for performing unsupervised domain adaptation. Our PixelDA models outperform previous work on a set of unsupervised domain adaptation scenarios, and in the case of the challenging “Synthetic Cropped Linemod to Cropped Linemod” scenario,
our model more than halves the error for pose estimation
compared to the previous best result. They are able to do
so by using a GAN–based technique, stabilized by both a
task-speciﬁc loss and a novel content–similarity loss. Furthermore, our model decouples the process of domain adaptation from the task-speciﬁc architecture, and provides the
added beneﬁt of being easy to understand via the visualization of the adapted image outputs of the model.
Acknowledgements
The authors would like to thank
Luke Metz, Kevin Murphy, Augustus Odena, Ben Poole,
Alex Toshev, and Vincent Vanhoucke for suggestions on
early drafts of the paper.