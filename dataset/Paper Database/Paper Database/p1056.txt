An introduction to ROC analysis
Tom Fawcett
Institute for the Study of Learning and Expertise, 2164 Staunton Court, Palo Alto, CA 94306, USA
Available online 19 December 2005
Receiver operating characteristics (ROC) graphs are useful for organizing classiﬁers and visualizing their performance. ROC graphs
are commonly used in medical decision making, and in recent years have been used increasingly in machine learning and data mining
research. Although ROC graphs are apparently simple, there are some common misconceptions and pitfalls when using them in practice.
The purpose of this article is to serve as an introduction to ROC graphs and as a guide for using them in research.
 2005 Elsevier B.V. All rights reserved.
Keywords: ROC analysis; Classiﬁer evaluation; Evaluation metrics
1. Introduction
A receiver operating characteristics (ROC) graph is a
technique for visualizing, organizing and selecting classiﬁers based on their performance. ROC graphs have long
been used in signal detection theory to depict the tradeoﬀ
between hit rates and false alarm rates of classiﬁers . ROC analysis has been extended
for use in visualizing and analyzing the behavior of diagnostic systems . The medical decision making
community has an extensive literature on the use of ROC
graphs for diagnostic testing . Swets et al.
 brought ROC curves to the attention of the wider
public with their Scientiﬁc American article.
One of the earliest adopters of ROC graphs in machine
learning was Spackman , who demonstrated the
value of ROC curves in evaluating and comparing algorithms. Recent years have seen an increase in the use of
ROC graphs in the machine learning community, due in
part to the realization that simple classiﬁcation accuracy
is often a poor metric for measuring performance . In addition to
being a generally useful performance graphing method,
they have properties that make them especially useful for
domains with skewed class distribution and unequal classiﬁcation error costs. These characteristics have become
increasingly important as research continues into the areas
of cost-sensitive learning and learning in the presence of
unbalanced classes.
ROC graphs are conceptually simple, but there are some
non-obvious complexities that arise when they are used in
research. There are also common misconceptions and pitfalls when using them in practice. This article attempts to
serve as a basic introduction to ROC graphs and as a guide
for using them in research. The goal of this article is to
advance general knowledge about ROC graphs so as to
promote better evaluation practices in the ﬁeld.
2. Classiﬁer performance
We begin by considering classiﬁcation problems using
only two classes. Formally, each instance I is mapped to
one element of the set {p,n} of positive and negative class
labels. A classiﬁcation model (or classiﬁer) is a mapping
from instances to predicted classes. Some classiﬁcation
models produce a continuous output (e.g., an estimate of
an instances class membership probability) to which diﬀerent thresholds may be applied to predict class membership.
Other models produce a discrete class label indicating only
the predicted class of the instance. To distinguish between
0167-8655/$ - see front matter  2005 Elsevier B.V. All rights reserved.
doi:10.1016/j.patrec.2005.10.010
E-mail addresses: , 
www.elsevier.com/locate/patrec
Pattern Recognition Letters 27 861–874
the actual class and the predicted class we use the labels
{Y,N} for the class predictions produced by a model.
Given a classiﬁer and an instance, there are four possible
outcomes. If the instance is positive and it is classiﬁed as
positive, it is counted as a true positive; if it is classiﬁed
as negative, it is counted as a false negative. If the instance
is negative and it is classiﬁed as negative, it is counted as a
true negative; if it is classiﬁed as positive, it is counted as a
false positive. Given a classiﬁer and a set of instances (the
test set), a two-by-two confusion matrix (also called a contingency table) can be constructed representing the dispositions of the set of instances. This matrix forms the basis for
many common metrics.
Fig. 1 shows a confusion matrix and equations of several
common metrics that can be calculated from it. The numbers along the major diagonal represent the correct decisions made, and the numbers of this diagonal represent
the errors—the confusion—between the various classes.
The true positive rate1 (also called hit rate and recall) of a
classiﬁer is estimated as
tp rate  Positives correctly classified
Total positives
The false positive rate (also called false alarm rate) of the
classiﬁer is
fp rate  Negatives incorrectly classified
Total negatives
Additional terms associated with ROC curves are
sensitivity ¼ recall
specificity ¼
True negatives
False positives þ True negatives
¼ 1  fp rate
positive predictive value ¼ precision
3. ROC space
ROC graphs are two-dimensional graphs in which tp
rate is plotted on the Y axis and fp rate is plotted on the
X axis. An ROC graph depicts relative tradeoﬀs between
beneﬁts (true positives) and costs (false positives). Fig. 2
shows an ROC graph with ﬁve classiﬁers labeled A through
A discrete classiﬁer is one that outputs only a class label.
Each discrete classiﬁer produces an (fp rate,tp rate) pair
corresponding to a single point in ROC space. The classiﬁers in Fig. 2 are all discrete classiﬁers.
Several points in ROC space are important to note. The
lower left point (0,0) represents the strategy of never issuing a positive classiﬁcation; such a classiﬁer commits no
false positive errors but also gains no true positives. The
opposite strategy, of unconditionally issuing positive classi-
ﬁcations, is represented by the upper right point (1,1).
The point (0,1) represents perfect classiﬁcation. Ds performance is perfect as shown.
Informally, one point in ROC space is better than
another if it is to the northwest (tp rate is higher, fp rate
is lower, or both) of the ﬁrst. Classiﬁers appearing on the
left-hand side of an ROC graph, near the X axis, may be
Hypothesized
Column totals:
True class
Fig. 1. Confusion matrix and common performance metrics calculated from it.
1 For clarity, counts such as TP and FP will be denoted with upper-case
letters and rates such as tp rate will be denoted with lower-case.
False positive rate
True positive rate
Fig. 2. A basic ROC graph showing ﬁve discrete classiﬁers.
T. Fawcett / Pattern Recognition Letters 27 861–874
thought of as ‘‘conservative’’: they make positive classiﬁcations only with strong evidence so they make few false positive errors, but they often have low true positive rates as
well. Classiﬁers on the upper right-hand side of an ROC
graph may be thought of as ‘‘liberal’’: they make positive
classiﬁcations with weak evidence so they classify nearly
all positives correctly, but they often have high false positive rates. In Fig. 2, A is more conservative than B. Many
real world domains are dominated by large numbers of
negative instances, so performance in the far left-hand side
of the ROC graph becomes more interesting.
3.1. Random performance
The diagonal line y = x represents the strategy of randomly guessing a class. For example, if a classiﬁer randomly guesses the positive class half the time, it can be
expected to get half the positives and half the negatives
correct; this yields the point (0.5,0.5) in ROC space. If it
guesses the positive class 90% of the time, it can be
expected to get 90% of the positives correct but its false
positive rate will increase to 90% as well,
(0.9,0.9) in ROC space. Thus a random classiﬁer will produce a ROC point that ‘‘slides’’ back and forth on the diagonal based on the frequency with which it guesses the
positive class. In order to get away from this diagonal into
the upper triangular region, the classiﬁer must exploit some
information in the data. In Fig. 2, Cs performance is virtually random. At (0.7,0.7), C may be said to be guessing the
positive class 70% of the time.
Any classiﬁer that appears in the lower right triangle
performs worse than random guessing. This triangle is
therefore usually empty in ROC graphs. If we negate a
classiﬁer—that is, reverse its classiﬁcation decisions on
every instance—its true positive classiﬁcations become false
negative mistakes, and its false positives become true negatives. Therefore, any classiﬁer that produces a point in
the lower right triangle can be negated to produce a point
in the upper left triangle. In Fig. 2, E performs much worse
than random, and is in fact the negation of B. Any classiﬁer
on the diagonal may be said to have no information about
the class. A classiﬁer below the diagonal may be said to
have useful information, but it is applying the information
incorrectly .
Given an ROC graph in which a classiﬁers performance
appears to be slightly better than random, it is natural to
ask: ‘‘is this classiﬁers performance truly signiﬁcant or is
it only better than random by chance?’’ There is no conclusive test for this, but Forman has shown a methodology that addresses this question with ROC curves.
4. Curves in ROC space
Many classiﬁers, such as decision trees or rule sets, are
designed to produce only a class decision, i.e., a Y or N
on each instance. When such a discrete classiﬁer is applied
to a test set, it yields a single confusion matrix, which in
turn corresponds to one ROC point. Thus, a discrete classiﬁer produces only a single point in ROC space.
Some classiﬁers, such as a Naive Bayes classiﬁer or a
neural network, naturally yield an instance probability or
score, a numeric value that represents the degree to which
an instance is a member of a class. These values can be
strict probabilities, in which case they adhere to standard
theorems of probability; or they can be general, uncalibrated scores, in which case the only property that holds
is that a higher score indicates a higher probability. We
shall call both a probabilistic classiﬁer, in spite of the fact
that the output may not be a proper probability.2
Such a ranking or scoring classiﬁer can be used with a
threshold to produce a discrete (binary) classiﬁer: if the
classiﬁer output is above the threshold, the classiﬁer produces a Y, else a N. Each threshold value produces a diﬀerent point in ROC space. Conceptually, we may imagine
varying a threshold from 1 to +1 and tracing a curve
through ROC space. Computationally, this is a poor way
of generating an ROC curve, and the next section describes
a more eﬃcient and careful method.
Fig. 3 shows an example of an ROC ‘‘curve’’ on a test
set of 20 instances. The instances, 10 positive and 10 negative, are shown in the table beside the graph. Any ROC
curve generated from a ﬁnite set of instances is actually a
step function, which approaches a true curve as the number
of instances approaches inﬁnity. The step function in Fig. 3
is taken from a very small instance set so that each points
derivation can be understood. In the table of Fig. 3, the
instances are sorted by their scores, and each point in the
ROC graph is labeled by the score threshold that produces
it. A threshold of +1 produces the point (0,0). As we
lower the threshold to 0.9 the ﬁrst positive instance is classiﬁed positive, yielding (0,0.1). As the threshold is further
reduced, the curve climbs up and to the right, ending up
at (1,1) with a threshold of 0.1. Note that lowering this
threshold corresponds to moving from the ‘‘conservative’’
to the ‘‘liberal’’ areas of the graph.
Although the test set is very small, we can make some
tentative observations about the classiﬁer. It appears to
perform better in the more conservative region of the
graph; the ROC point at (0.1,0.5) produces its highest
accuracy (70%). This is equivalent to saying that the classi-
ﬁer is better at identifying likely positives than at identifying likely negatives. Note also that the classiﬁers best
accuracy occurs at a threshold of P0.54, rather than at
P0.5 as we might expect with a balanced distribution.
The next section discusses this phenomenon.
4.1. Relative versus absolute scores
An important point about ROC graphs is that they measure the ability of a classiﬁer to produce good relative
2 Techniques exist for converting an uncalibrated score into a proper
probability but this conversion is unnecessary for ROC curves.
T. Fawcett / Pattern Recognition Letters 27 861–874
instance scores. A classiﬁer need not produce accurate, calibrated probability estimates; it need only produce relative
accurate scores that serve to discriminate positive and negative instances.
Consider the simple instance scores shown in Fig. 4,
which came from a Naive Bayes classiﬁer. Comparing the
hypothesized class (which is Y if score > 0.5, else N) against
the true classes, we can see that the classiﬁer gets instances
7 and 8 wrong, yielding 80% accuracy. However, consider
the ROC curve on the left side of the ﬁgure. The curve rises
vertically from (0,0) to (0,1), then horizontally to (1,1).
This indicates perfect classiﬁcation performance on this test
set. Why is there a discrepancy?
The explanation lies in what each is measuring. The
ROC curve shows the ability of the classiﬁer to rank the
positive instances relative to the negative instances, and it
is indeed perfect in this ability. The accuracy metric
imposes a threshold (score > 0.5) and measures the resulting classiﬁcations with respect to the scores. The accuracy
measure would be appropriate if the scores were proper
probabilities, but they are not. Another way of saying this
is that the scores are not properly calibrated, as true probabilities are. In ROC space, the imposition of a 0.5 threshold results in the performance designated by the circled
‘‘accuracy point’’ in Fig. 4. This operating point is suboptimal. We could use the training set to estimate a prior for
p(p) = 6/10 = 0.6 and use this as a threshold, but it would
still produce suboptimal performance (90% accuracy).
One way to eliminate this phenomenon is to calibrate
the classiﬁer scores. There are some methods for doing this
 . Another approach is to use
an ROC method that chooses operating points based on
their relative performance, and there are methods for doing
this as well . These latter
methods are discussed brieﬂy in Section 6.
A consequence of relative scoring is that classiﬁer scores
should not be compared across model classes. One model
class may be designed to produce scores in the range
 while another produces scores in [1,+1] or .
Comparing model performance at a common threshold will
be meaningless.
4.2. Class skew
ROC curves have an attractive property: they are insensitive to changes in class distribution. If the proportion of
positive to negative instances changes in a test set, the
ROC curves will not change. To see why this is so, consider
the confusion matrix in Fig. 1. Note that the class distribution—the proportion of positive to negative instances—is
the relationship of the left (+) column to the right () column. Any performance metric that uses values from both
columns will be inherently sensitive to class skews. Metrics
such as accuracy, precision, lift and F score use values from
both columns of the confusion matrix. As a class distribution changes these measures will change as well, even if the
fundamental classiﬁer performance does not. ROC graphs
are based upon tp rate and fp rate, in which each dimension
is a strict columnar ratio, so do not depend on class
distributions.
To some researchers, large class skews and large changes
in class distributions may seem contrived and unrealistic.
However, class skews of 101 and 102 are very common in
real world domains, and skews up to 106 have been
observed in some domains . Substantial changes in class distributions are
not unrealistic either. For example, in medical decision
making epidemics may cause the incidence of a disease to
increase over time. In fraud detection, proportions of fraud
varied signiﬁcantly from month to month and place to
place . Changes in a manufacturing practice may cause the proportion of defective units
False positive rate
True positive rate
Fig. 3. The ROC ‘‘curve’’ created by thresholding a test set. The table
shows 20 data and the score assigned to each by a scoring classiﬁer. The
graph shows the corresponding ROC curve with each point labeled by the
threshold that produces it.
T. Fawcett / Pattern Recognition Letters 27 861–874
produced by a manufacturing line to increase or decrease.
In each of these examples the prevalence of a class may
change drastically without altering the fundamental characteristic of the class, i.e., the target concept.
Precision and recall are common in information retrieval for evaluating retrieval (classiﬁcation) performance
 . Precision-recall graphs are commonly
assumed; however, they are also used in dynamic environments such as web page retrieval, where the number of
pages irrelevant to a query (N) is many orders of magnitude greater than P and probably increases steadily over
time as web pages are created.
To see the eﬀect of class skew, consider the curves in
Fig. 5, which show two classiﬁers evaluated using ROC
curves and precision-recall curves. In Fig. 5a and b, the test
False positive rate
True positive rate
Accuracy point (threshold = 0.5)
Accuracy point (threshold = 0.6)
Inst Class
Fig. 4. Scores and classiﬁcations of 10 instances, and the resulting ROC curve.
‘insts.roc.+’
‘insts2.roc.+’
‘insts.precall.+’
‘insts2.precall.+’
‘instsx10.roc.+’
‘insts2x10.roc.+’
‘instsx10.precall.+’
‘insts2x10.precall.+’
Fig. 5. ROC and precision-recall curves under class skew. (a) ROC curves, 1:1; (b) precision-recall curves, 1:1; (c) ROC curves, 1:10 and (d) precisionrecall curves, 1:10.
T. Fawcett / Pattern Recognition Letters 27 861–874
set has a balanced 1:1 class distribution. Graph 5c and d
shows the same two classiﬁers on the same domain, but
the number of negative instances has been increased 10fold. Note that the classiﬁers and the underlying concept
has not changed; only the class distribution is diﬀerent.
Observe that the ROC graphs in Fig. 5a and c are identical,
while the precision-recall graphs in Fig. 5b and d diﬀer substantially. In some cases, the conclusion of which classiﬁer
has superior performance can change with a shifted
distribution.
4.3. Creating scoring classiﬁers
Many classiﬁer models are discrete: they are designed
to produce only a class label from each test instance.
However, we often want to generate a full ROC curve from
a classiﬁer instead of just a single point. To this end we
want to generate scores from a classiﬁer rather than just
a class label. There are several ways of producing such
Many discrete classiﬁer models may easily be converted
to scoring classiﬁers by ‘‘looking inside’’ them at the
instance statistics they keep. For example, a decision tree
determines a class label of a leaf node from the proportion
of instances at the node; the class decision is simply the
most prevalent class. These class proportions may serve
as a score . A rule learner
keeps similar statistics on rule conﬁdence, and the conﬁdence of a rule matching an instance can be used as a score
 .
Even if a classiﬁer only produces a class label, an
aggregation of them may be used to generate a score.
MetaCost employs bagging to generate
an ensemble of discrete classiﬁers, each of which produces
a vote. The set of votes could be used to generate a
Finally, some combination of scoring and voting can be
employed. For example, rules can provide basic probability
estimates, which may then be used in weighted voting
 .
5. Eﬃcient generation of ROC curves
Given a test set, we often want to generate an ROC
curve eﬃciently from it. We can exploit the monotonicity
of thresholded classiﬁcations: any instance that is classiﬁed
positive with respect to a given threshold will be classiﬁed
positive for all lower thresholds as well. Therefore, we
can simply sort the test instances decreasing by f scores
and move down the list, processing one instance at a time
and updating TP and FP as we go. In this way an ROC
graph can be created from a linear scan.
The algorithm is shown in Algorithm 1. TP and FP
both start at zero. For each positive instance we increment
TP and for every negative instance we increment FP. We
maintain a stack R of ROC points, pushing a new point
onto R after each instance is processed. The ﬁnal output
is the stack R, which will contain points on the ROC
Let n be the number of points in the test set. This algorithm requires an O(nlogn) sort followed by an O(n) scan
down the list, resulting in O(nlogn) total complexity.
Statements 7–10 need some explanation. These are
necessary in order to correctly handle sequences of equally
scored instances. Consider the ROC curve shown in Fig. 6.
Assume we have a test set in which there is a sequence of
instances, four negatives and six positives, all scored
equally by f. The sort in line 1 of Algorithm 1 does not
impose any speciﬁc ordering on these instances since their
f scores are equal. What happens when we create an
ROC curve? In one extreme case, all the positives end up
at the beginning of the sequence and we generate the ‘‘optimistic’’ upper L segment shown in Fig. 6. In the opposite
Algorithm 1. Eﬃcient method for generating ROC points
Inputs: L, the set of test examples; f(i), the probabilistic
classiﬁers estimate that example i is positive; P and N, the
number of positive and negative examples.
Outputs: R, a list of ROC points increasing by fp rate.
Require: P > 0 and N > 0
1: Lsorted L sorted decreasing by f scores
2: FP TP 0
4: fprev 1
6: while i 6 jLsortedj do
if f(i) 5 fprev then
fprev f(i)
if Lsorted[i] is a positive example then
/* i is a negative example */
17: end while
/* This is (1,1) */
3 MetaCost actually works in the opposite direction because its goal is to
generate a discrete classiﬁer. It ﬁrst creates a probabilistic classiﬁer, then
applies knowledge of the error costs and class skews to relabel the
instances so as to ‘‘optimize’’ their classiﬁcations. Finally, it learns a
speciﬁc discrete classiﬁer from this new instance set. Thus, MetaCost is not
a good method for creating a scoring classiﬁer, though its bagging method
T. Fawcett / Pattern Recognition Letters 27 861–874
extreme, all the negatives end up at the beginning of the
sequence and we get the ‘‘pessimistic’’ lower L shown in
Fig. 6. Any mixed ordering of the instances will give a different set of step segments within the rectangle formed by
these two extremes. However, the ROC curve should represent the expected performance of the classiﬁer, which, lacking any other information, is the average of the pessimistic
and optimistic segments. This average is the diagonal of the
rectangle, and can be created in the ROC curve algorithm
by not emitting an ROC point until all instances of equal f
values have been processed. This is what the fprev variable
and the if statement of line 7 accomplish.
Instances that are scored equally may seem unusual
but with some classiﬁer models they are common. For
example, if we use instance counts at nodes in a decision
tree to score instances, a large, high-entropy leaf node
may produce many equally scored instances of both classes. If such instances are not averaged, the resulting ROC
curves will be sensitive to the test set ordering, and diﬀerent
orderings can yield very misleading curves. This can be
especially critical in calculating the area under an ROC
curve, discussed in Section 7. Consider a decision tree containing a leaf node accounting for n positives and m negatives. Every instance that is classiﬁed to this leaf node will
be assigned the same score. The rectangle of Fig. 6 will be
of size nm
PN, and if these instances are not averaged this one
leaf may account for errors in ROC curve area as high
6. The ROC convex hull
One advantage of ROC graphs is that they enable visualizing and organizing classiﬁer performance without regard
to class distributions or error costs. This ability becomes very
important when investigating learning with skewed distributions or cost-sensitive learning. A researcher can graph the
performance of a set of classiﬁers, and that graph will remain
invariant with respect to the operating conditions (class skew
and error costs). As these conditions change, the region of
interest may change, but the graph itself will not.
Provost and Fawcett show that a set of
operating conditions may be transformed easily into a
so-called iso-performance line in ROC space. Two points
in ROC space, (FP1,TP1) and (FP2,TP2), have the same
performance if
TP 2  TP 1
FP 2  FP 1
¼ cðY; nÞpðnÞ
cðN; pÞpðpÞ ¼ m
This equation deﬁnes the slope of an iso-performance line.
All classiﬁers corresponding to points on a line of slope m
have the same expected cost. Each set of class and cost distributions deﬁnes a family of iso-performance lines. Lines
‘‘more northwest’’ (having a larger TP-intercept) are better
because they correspond to classiﬁers with lower expected
cost. More generally, a classiﬁer is potentially optimal if
and only if it lies on the convex hull of the set of points
in ROC space. The convex hull of the set of points in
ROC space is called the ROC convex hull (ROCCH) of
the corresponding set of classiﬁers.
Fig. 7a shows four ROC curves (A through D) and their
convex hull (labeled CH). D is not on the convex hull and is
clearly sub-optimal. B is also not optimal for any conditions because it is not on the convex hull either. The convex
hull is bounded only by points from curves A and C. Thus,
if we are seeking optimal classiﬁcation performance, classi-
ﬁers B and D may be removed entirely from consideration.
In addition, we may remove any discrete points from A and
C that are not on the convex hull.
Fig. 7b shows the A and C curves again with two explicit
iso-performance lines, a and b. Consider a scenario in
which negatives outnumber positives by 10 to 1, but false
positives and false negatives have equal cost. By Eq. (1)
m = 10, and the most northwest line of slope m = 10 is a,
tangent to classiﬁer A, which would be the best performing
classiﬁer for these conditions.
Consider another scenario in which the positive and
negative example populations are evenly balanced but a
false negative is 10 times as expensive as a false positive.
By Eq. (1) m = 1/10. The most northwest line of slope 1/
10 would be line b, tangent to classiﬁer C. C is the optimal
classiﬁer for these conditions.
If we wanted to generate a classiﬁer somewhere on the
convex hull between A and C, we could interpolate
between the two. Section 10 explains how to generate such
a classiﬁer.
This ROCCH formulation has a number of useful
implications. Since only the classiﬁers on the convex hull
are potentially optimal, no others need be retained. The
operating conditions of the classiﬁer may be translated into
an iso-performance line, which in turn may be used to identify a portion of the ROCCH. As conditions change, the
hull itself does not change; only the portion of interest
False positive rate
True positive rate
Optimistic
Pessimistic
Fig. 6. The optimistic, pessimistic and expected ROC segments resulting
from a sequence of 10 equally scored instances.
T. Fawcett / Pattern Recognition Letters 27 861–874
7. Area under an ROC curve (AUC)
An ROC curve is a two-dimensional depiction of classi-
ﬁer performance. To compare classiﬁers we may want to
reduce ROC performance to a single scalar value representing expected performance. A common method is to calculate the area under the ROC curve, abbreviated AUC
 . Since the
AUC is a portion of the area of the unit square, its value
will always be between 0 and 1.0. However, because random guessing produces the diagonal line between (0,0)
and (1,1), which has an area of 0.5, no realistic classiﬁer
should have an AUC less than 0.5.
The AUC has an important statistical property: the
AUC of a classiﬁer is equivalent to the probability that
the classiﬁer will rank a randomly chosen positive instance
higher than a randomly chosen negative instance. This is
equivalent to the Wilcoxon test of ranks . The AUC is also closely related to the Gini
coeﬃcient , which is twice the area
between the diagonal and the ROC curve. Hand and Till
 point out that Gini + 1 = 2 · AUC.
Fig. 8a shows the areas under two ROC curves, A and
B. Classiﬁer B has greater area and therefore better average
performance. Fig. 8b shows the area under the curve of a
binary classiﬁer A and a scoring classiﬁer B. Classiﬁer A
represents the performance of B when B is used with a single, ﬁxed threshold. Though the performance of the two is
equal at the ﬁxed point (As threshold), As performance
becomes inferior to B further from this point.
It is possible for a high-AUC classiﬁer to perform worse
in a speciﬁc region of ROC space than a low-AUC classi-
ﬁer. Fig. 8a shows an example of this: classiﬁer B is generally better than A except at FPrate > 0.6 where A has a
False positive rate
True positive rate
False positive rate
True positive rate
Fig. 7. (a) The ROC convex hull identiﬁes potentially optimal classiﬁers. (b) Lines a and b show the optimal classiﬁer under diﬀerent sets of conditions.
False positive rate
False positive rate
True positive rate
True positive rate
Fig. 8. Two ROC graphs. The graph on the left shows the area under two ROC curves. The graph on the right shows the area under the curves of a
discrete classiﬁer (A) and a probabilistic classiﬁer (B).
T. Fawcett / Pattern Recognition Letters 27 861–874
slight advantage. But in practice the AUC performs very
well and is often used when a general measure of predictiveness is desired.
The AUC may be computed easily using a small modi-
ﬁcation of algorithm 1, shown in Algorithm 2. Instead of
collecting ROC points, the algorithm adds successive areas
of trapezoids to A. Trapezoids are used rather than rectangles in order to average the eﬀect between points, as
illustrated in Fig. 6. Finally, the algorithm divides A by
the total possible area to scale the value to the unit
8. Averaging ROC curves
Although ROC curves may be used to evaluate classiﬁers, care should be taken when using them to make conclusions about classiﬁer superiority. Some researchers have
assumed that an ROC graph may be used to select the best
classiﬁers simply by graphing them in ROC space and seeing which ones dominate. This is misleading; it is analogous to taking the maximum of a set of accuracy ﬁgures
from a single test set. Without a measure of variance we
cannot compare the classiﬁers.
Averaging ROC curves is easy if the original instances
are available. Given test sets T1,T2,. . .,Tn, generated from
cross-validation or the bootstrap method, we can simply
merge sort the instances together by their assigned scores
into one large test set TM. We then run an ROC curve generation algorithm such as algorithm 1 on TM and plot the
result. However, the primary reason for using multiple test
sets is to derive a measure of variance, which this simple
merging does not provide. We need a more sophisticated
method that samples individual curves at diﬀerent points
and averages the samples.
ROC space is two-dimensional, and any average is necessarily one-dimensional. ROC curves can be projected
onto a single dimension and averaged conventionally, but
this leads to the question of whether the projection is
appropriate, or more precisely, whether it preserves characteristics of interest. The answer depends upon the reason
for averaging the curves. This section presents two methods
for averaging ROC curves: vertical and threshold averaging.
Fig. 9a shows ﬁve ROC curves to be averaged. Each
contains a thousand points and has some concavities.
Fig. 9b shows the curve formed by merging the ﬁve test sets
and computing their combined ROC curve. Fig. 9c and d
shows average curves formed by sampling the ﬁve individual ROC curves. The error bars are 95% conﬁdence
intervals.
8.1. Vertical averaging
Vertical averaging takes vertical samples of the ROC
curves for ﬁxed FP rates and averages the corresponding
TP rates. Such averaging is appropriate when the FP
rate can indeed be ﬁxed by the researcher, or when a
single-dimensional measure of variation is desired. Provost et al. used this method in their work of
averaging ROC curves of a classiﬁer for k-fold crossvalidation.
In this method each ROC curve is treated as a function,
Ri, such that tp rate = Ri(fp rate). This is done by choosing
the maximum tp rate for each fp rate and interpolating
between points when necessary. The averaged ROC curve
is the function ^Rðfp rateÞ ¼ mean½Riðfp rateÞ. To plot an
average ROC curve we can sample from ^R at points regularly spaced along the fp rate-axis. Conﬁdence intervals of
the mean of tp rate are computed using the common
assumption of a binomial distribution.
Algorithm 3
set of ROC points. It leaves the means in the array
Several extensions have been left out of this algorithm
for clarity. The algorithm may easily be extended to
Algorithm 2. Calculating the area under an ROC curve
Inputs: L, the set of test examples; f(i), the probabilistic
classiﬁers estimate that example i is positive; P and N, the
number of positive and negative examples.
Outputs: A, the area under the ROC curve.
Require: P > 0 and N > 0
1: Lsorted L sorted decreasing by f scores
2: FP TP 0
3: FPprev TPprev 0
5: fprev 1
7: while i 6 jLsortedj do
if f(i) 5 fprev then
A A + TRAPEZOID_AREA(FP,FPprev,
TP,TPprev)
fprev f(i)
if i is a positive example then
/* i is a negative example */
20: end while
21: A A + TRAPEZOID_AREA(N,FPprev,N,TPprev)
22: A A/(P · N)
/* scale from P · N onto the unit
1: function TRAPEZOID_AREA(X1,X2,Y1,Y2)
2: Base jX1  X2j
3: Heightavg (Y1 + Y2)/2
4: return Base · Heightavg
5: end function
T. Fawcett / Pattern Recognition Letters 27 861–874
compute standard deviations of the samples in order to
draw conﬁdence bars. Also, the function TP_FOR_FP may
be optimized somewhat. Because it is only called on monotonically increasing values of FP, it need not scan each
ROC array from the beginning every time; it could keep
a record of the last point seen and initialize i from this
Fig. 9c shows the vertical average of the ﬁve curves in
Fig. 9a. The vertical bars on the curve show the 95% con-
ﬁdence region of the ROC mean. For this average curve,
the curves were sampled at FP rates from 0 through 1 by
0.1. It is possible to sample curves much more ﬁnely but
the conﬁdence bars may become diﬃcult to read.
8.2. Threshold averaging
Vertical averaging has the advantage that averages are
made of a single dependent variable, the true positive rate,
which simpliﬁes computing conﬁdence intervals. However,
Holte has pointed out that the independent variable,
false positive rate, is often not under the direct control of
the researcher. It may be preferable to average ROC points
using an independent variable whose value can be controlled directly, such as the threshold on the classiﬁer scores.
Threshold averaging accomplishes this. Instead of sampling points based on their positions in ROC space, as vertical averaging does, it samples based on the thresholds
that produced these points. The method must generate a
set of thresholds to sample, then for each threshold it ﬁnds
the corresponding point of each ROC curve and averages
Algorithm 4 shows the basic method for doing this. It
generates an array T of classiﬁer scores which are sorted
from largest to smallest and used as the set of thresholds.
These thresholds are sampled at ﬁxed intervals determined
by samples, the number of samples desired. For a given
threshold, the algorithm selects from each ROC curve the
point of greatest score less than or equal to the threshold.4
These points are then averaged separately along their X
and Y axes, with the center point returned in the Avg array.
Fig. 9d shows the result of averaging the ﬁve curves of
Fig. 9a by thresholds. The resulting curve has average
points and conﬁdence bars in the X and Y directions.
The bars shown are at the 95% conﬁdence level.
There are some minor limitations of threshold averaging
with respect to vertical averaging. To perform threshold
averaging we need the classiﬁer score assigned to each
point. Also, Section 4.1 pointed out that classiﬁer scores
False positive rate
True positive rate
False positive rate
True positive rate
False positive rate
True positive rate
False positive rate
True positive rate
Fig. 9. ROC curve averaging. (a) ROC curves of ﬁve instance samples, (b) ROC curve formed by merging the ﬁve samples, (c) the curves of a averaged
vertically and (d) the curves of a averaged by threshold.
4 We assume the ROC points have been generated by an algorithm like 1
that deals correctly with equally scored instances.
T. Fawcett / Pattern Recognition Letters 27 861–874
should not be compared across model classes. Because of
this, ROC curves averaged from diﬀerent model classes
may be misleading because the scores may be incommensurate.
Finally, Macskassy and Provost have investigated diﬀerent techniques for generating conﬁdence bands
for ROC curves. They investigate conﬁdence intervals from
vertical and threshold averaging, as well as three methods
from the medical ﬁeld for generating bands (simultaneous
join conﬁdence regions, Working-Hotelling based bands,
and ﬁxed-width conﬁdence bands). The reader is referred
to their paper for a much more detailed discussion of the
techniques, their assumptions, and empirical studies.
9. Decision problems with more than two classes
Discussions up to this point have dealt with only two
classes, and much of the ROC literature maintains this
assumption. ROC analysis is commonly employed in medical decision making in which two-class diagnostic problems—presence or absence of an abnormal condition—
are common. The two axes represent tradeoﬀs between
errors (false positives) and beneﬁts (true positives) that a
classiﬁer makes between two classes. Much of the analysis
is straightforward because of the symmetry that exists in
the two-class problem. The resulting performance can be
graphed in two dimensions, which is easy to visualize.
9.1. Multi-class ROC graphs
With more than two classes the situation becomes much
more complex if the entire space is to be managed. With n
classes the confusion matrix becomes an n · n matrix containing the n correct classiﬁcations (the major diagonal
entries) and n2  n possible errors (the oﬀ-diagonal entries).
Instead of managing trade-oﬀs between TP and FP, we
have n beneﬁts and n2  n errors. With only three classes,
the surface becomes a 32  3 = 6-dimensional polytope.
Lane has outlined the issues involved and the prospects for addressing them. Srinivasan has shown
Algorithm 3. Vertical averaging of ROC curves
Inputs: samples, the number of FP samples; nrocs, the
number of ROC curves to be sampled, ROCS[nrocs], an
array of nrocs ROC curves; npts[m], the number of points
in ROC curve m. Each ROC point is a structure of two
members, the rates fpr and tpr.
Output: Array tpravg[samples + 1], containing the vertical
2: for fprsample = 0 to 1 by 1/samples do
for i = 1 to nrocs do
tprsum tprsum + TPR_FOR_FPR(fprsample,
ROCS[i],npts[i])
tpravg[s] tprsum/nrocs
9: end for
1: function TPR_FOR_FPR(fprsample,ROC,npts)
3: while i < npts and ROC [i + 1].fpr 6 fprsample do
5: end while
6: if ROC[i].fpr = fprsample then
return ROC[i].tpr
return INTERPOLATE(ROC[i],ROC [i + 1],fprsample)
10: end if
11: end function
1: function INTERPOLATE(ROCP1,ROCP2,X)
2: slope = (ROCP2.tpr  ROCP1.tpr)/(ROCP2.fpr 
ROCP1.fpr)
3: return ROCP1.tpr + slope Æ (X  ROCP1.fpr)
4: end function
Algorithm 4. Threshold averaging of ROC curves
Inputs: samples, the number of threshold samples; nrocs,
the number of ROC curves to be sampled; ROCS[nrocs], an
array of nrocs ROC curves sorted by score; npts[m], the
number of points in ROC curve m. Each ROC point is a
structure of three members, fpr, tpr and score.
Output: Avg[samples + 1], an array of (X,Y) points
constituting the average ROC curve.
Require: samples > 1
1: initialize array T to contain all scores of all ROC
2: sort T in descending order
4: for tidx = 1 to length(T) by int(length(T)/samples) do
for i = 1 to nrocs do
p ROC_POINT_AT_THRESHOLD(ROCS[i], npts[i],
fprsum fprsum + p.fpr
tprsum tprsum + p.tpr
Avg[s] (fprsum/nrocs,tprsum/nrocs)
14: end for
1: function ROC_POINT_AT_THRESHOLD(ROC,npts,thresh)
3: while i 6 npts and ROC[i]. score > thresh do
5: end while
6: return ROC[i]
7: end function
T. Fawcett / Pattern Recognition Letters 27 861–874
that the analysis behind the ROC convex hull extends to
multiple classes and multi-dimensional convex hulls.
One method for handling n classes is to produce n diﬀerent ROC graphs, one for each class. Call this the class reference formulation. Speciﬁcally, if C is the set of all classes,
ROC graph i plots the classiﬁcation performance using
class ci as the positive class and all other classes as the negative class, i.e.
While this is a convenient formulation, it compromises one
of the attractions of ROC graphs, namely that they are
insensitive to class skew (see Section 4.2). Because each
Ni comprises the union of n  1 classes, changes in prevalence within these classes may alter the cis ROC graph.
For example, assume that some class ck 2 N is particularly
easy to identify. A classiﬁer for class ci, i 5 k may exploit
some characteristic of ck in order to produce low scores for
ck instances. Increasing the prevalence of ck might alter the
performance of the classiﬁer, and would be tantamount to
changing the target concept by increasing the prevalence of
one of its disjuncts. This in turn would alter the ROC
curve. However, with this caveat, this method can work
well in practice and provide reasonable ﬂexibility in
evaluation.
9.2. Multi-class AUC
The AUC is a measure of the discriminability of a pair
of classes. In a two-class problem, the AUC is a single scalar value, but a multi-class problem introduces the issue of
combining multiple pairwise discriminability values. The
reader is referred to Hand and Tills article for an
excellent discussion of these issues.
One approach to calculating multi-class AUCs was
taken by Provost and Domingos in their work on
probability estimation trees. They calculated AUCs for
multi-class problems by generating each class reference
ROC curve in turn, measuring the area under the curve,
then summing the AUCs weighted by the reference classs
prevalence in the data. More precisely, they deﬁne
AUCtotal ¼
AUCðciÞ  pðciÞ
where AUC(ci) is the area under the class reference ROC
curve for ci, as in Eq. (3). This deﬁnition requires only jCj
AUC calculations, so its overall complexity is O(jCjnlogn).
The advantage of Provost and Domingoss AUC formulation is that AUCtotal is generated directly from class reference ROC curves, and these curves can be generated and
visualized easily. The disadvantage is that the class reference ROC is sensitive to class distributions and error costs,
so this formulation of AUCtotal is as well.
Hand and Till take a diﬀerent approach in their
derivation of a multi-class generalization of the AUC. They
desired a measure that is insensitive to class distribution
and error costs. The derivation is too detailed to summarize here, but it is based upon the fact that the AUC is
equivalent to the probability that the classiﬁer will rank a
randomly chosen positive instance higher than a randomly
chosen negative instance. From this probabilistic form,
they derive a formulation that measures the unweighted
pairwise discriminability of classes. Their measure, which
they call M, is equivalent to:
AUCtotal ¼
jCjðjCj  1Þ
AUCðci; cjÞ
where n is the number of classes and AUC(ci,cj) is the area
under the two-class ROC curve involving classes ci and cj.
The summation is calculated over all pairs of distinct
classes, irrespective of order. There are jCj(jCj  1)/2
such pairs, so the time complexity of their measure is
O(jCj2nlogn). While Hand and Tills formulation is well
justiﬁed and is insensitive to changes in class distribution,
there is no easy way to visualize the surface whose area is
being calculated.
10. Interpolating classiﬁers
Sometimes the performance desired of a classiﬁer is not
exactly produced by any available classiﬁer, but lies
between two available classiﬁers. The desired performance
can be obtained by sampling the decisions of each classiﬁer.
The sampling ratio will determine where the resulting
classiﬁcation performance lies.
For a concrete example, consider the decision problem
of the CoIL Challenge 2000 . In this challenge there is a set of 4000 clients to
whom we wish to market a new insurance policy. Our budget dictates that we can aﬀord to market to only 800 of
them, so we want to select the 800 who are most likely to
respond to the oﬀer. The expected class prior of responders
is 6%, so within the population of 4000 we expect to have
responders
(positives)
non-responders
(negatives).
Assume we have generated two classiﬁers, A and B,
which score clients by the probability they will buy the
policy. In ROC space A lies at (0.1,0.2) and B lies at
(0.25,0.6), as shown in Fig. 10. We want to market to
exactly 800 people so our solution constraint is fp
rate · 3760 + tp rate · 240 = 800. If we use A we expect
0.1 · 3760 + 0.2 · 240 = 424 candidates, which is too few.
If we use B we expect 0.25 · 3760 + 0.6 · 240 = 1084
candidates, which is too many. We want a classiﬁer
between A and B.
The solution constraint is shown as a dashed line in
Fig. 10. It intersects the line between A and B at C, approximately (0.18,0.42). A classiﬁer at point C would give the
performance we desire and we can achieve it using linear
interpolation. Calculate k as the proportional distance that
C lies on the line between A and B:
T. Fawcett / Pattern Recognition Letters 27 861–874
k ¼ 0:18  0:1
0:25  0:1  0:53
Therefore, if we sample Bs decisions at a rate of 0.53 and
As decisions at a rate of 1  0.53 = 0.47 we should attain
Cs performance. In practice this fractional sampling can
be done by randomly sampling decisions from each: for
each instance, generate a random number between zero
and one. If the random number is greater than k, apply
classiﬁer A to the instance and report its decision, else pass
the instance to B.
11. Conclusion
ROC graphs are a very useful tool for visualizing and
evaluating classiﬁers. They are able to provide a richer
measure of classiﬁcation performance than scalar measures
such as accuracy, error rate or error cost. Because they decouple classiﬁer performance from class skew and error
costs, they have advantages over other evaluation measures
such as precision-recall graphs and lift curves. However, as
with any evaluation metric, using them wisely requires
knowing their characteristics and limitations. It is hoped
that this article advances the general knowledge about
ROC graphs and helps to promote better evaluation practices in the pattern recognition community.