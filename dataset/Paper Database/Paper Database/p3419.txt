Special Issue on Machine Learning and Dynamical Systems
Fundamentals of Recurrent Neural Network (RNN)
and Long Short-Term Memory (LSTM) Network
Alex Sherstinsky
 
 
Because of their effectiveness in broad practical applications, LSTM networks have received a wealth of coverage in scientific
journals, technical blogs, and implementation guides. However, in most articles, the inference formulas for the LSTM network
and its parent, RNN, are stated axiomatically, while the training formulas are omitted altogether. In addition, the technique of
“unrolling” an RNN is routinely presented without justification throughout the literature. The goal of this tutorial is to explain the
essential RNN and LSTM fundamentals in a single document. Drawing from concepts in Signal Processing, we formally derive
the canonical RNN formulation from differential equations. We then propose and prove a precise statement, which yields the RNN
unrolling technique. We also review the difficulties with training the standard RNN and address them by transforming the RNN
into the “Vanilla LSTM”1 network through a series of logical arguments. We provide all equations pertaining to the LSTM system
together with detailed descriptions of its constituent entities. Albeit unconventional, our choice of notation and the method for
presenting the LSTM system emphasizes ease of understanding. As part of the analysis, we identify new opportunities to enrich
the LSTM system and incorporate these extensions into the Vanilla LSTM network, producing the most general LSTM variant to
date. The target reader has already been exposed to RNNs and LSTM networks through numerous available resources and is open
to an alternative pedagogical approach. A Machine Learning practitioner seeking guidance for implementing our new augmented
LSTM model in software for experimentation and research will find the insights and derivations in this treatise valuable as well.
I. INTRODUCTION
Since the original 1997 LSTM paper , numerous theoretical and experimental works have been published on the subject
of this type of an RNN, many of them reporting on the astounding results achieved across a wide variety of application
domains where data is sequential. The impact of the LSTM network has been notable in language modeling, speech-to-text
transcription, machine translation, and other applications . Inspired by the impressive benchmarks reported in the literature,
some readers in academic and industrial settings decide to learn about the Long Short-Term Memory network (henceforth, “the
LSTM network”) in order to gauge its applicability to their own research or practical use-case. All major open source machine
learning frameworks offer efficient, production-ready implementations of a number of RNN and LSTM network architectures.
Naturally, some practitioners, even if new to the RNN/LSTM systems, take advantage of this access and cost-effectiveness and
proceed straight to development and experimentation. Others seek to understand every aspect of the operation of this elegant
and effective system in greater depth. The advantage of this lengthier path is that it affords an opportunity to build a certain
degree of intuition that can prove beneficial during all phases of the process of incorporating an open source module to suit
the needs of their research effort or a business application, preparing the dataset, troubleshooting, and tuning.
In a common scenario, this undertaking balloons into reading numerous papers, blog posts, and implementation guides in search
of an “A through Z” understanding of the key principles and functions of the system, only to find out that, unfortunately, most
of the resources leave one or more of the key questions about the basics unanswered. For example, the Recurrent Neural
Network (RNN), which is the general class of a neural network that is the predecessor to and includes the LSTM network
as a special case, is routinely simply stated without precedent, and unrolling is presented without justification. Moreover, the
training equations are often omitted altogether, leaving the reader puzzled and searching for more resources, while having to
reconcile disparate notation used therein. Even the most oft-cited and celebrated primers to date have fallen short of providing
a comprehensive introduction. The combination of descriptions and colorful diagrams alone is not actionable, if the architecture
description is incomplete, or if important components and formulas are absent, or if certain core concepts are left unexplained.
As of the timeframe of this writing, a single self-contained primer that provides a clear and concise explanation of the Vanilla
LSTM computational cell with well-labeled and logically composed schematics that go hand-in-hand with the formulas is still
1The nickname “Vanilla LSTM” symbolizes this model’s flexibility and generality .
 
lacking. The present work is motivated by the conviction that a unifying reference, conveying the basic theory underlying the
RNN and the LSTM network, will benefit the Machine Learning (ML) community.
The present article is an attempt to fill in this gap, aiming to serve as the introductory text that the future students and
practitioners of RNN and LSTM network can rely upon for learning all the basics pertaining to this rich system. With the
emphasis on using a consistent and meaningful notation to explain the facts and the fundamentals (while removing mystery
and dispelling the myths), this backgrounder is for those inquisitive researchers and practitioners who not only want to know
“how”, but also to understand “why”.
We focus on the RNN first, because the LSTM network is a type of an RNN, and since the RNN is a simpler system, the
intuition gained by analyzing the RNN applies to the LSTM network as well. Importantly, the canonical RNN equations, which
we derive from differential equations, serve as the starting model that stipulates a perspicuous logical path toward ultimately
arriving at the LSTM system architecture.
The reason for taking the path of deriving the canonical RNN equations from differential equations is that even though
RNNs are expressed as difference equations, differential equations have been indispensable for modeling neural networks and
continue making a profound impact on solving practical data processing tasks with machine learning methods. On one hand,
leveraging the established mathematical theories from differential equations in the continuous-time domain has historically led
to a better understanding of the evolution of the related difference equations, since the difference equations are obtained from
the corresponding original differential equations through discretization of the differential operators acting on the underlying
functions . On the other hand, considering the existing deep neurally-inspired architectures
as the numerical methods for solving their respective differential equations aided by the recent advances in memory-efficient
implementations has helped to successfully stabilize very large models at lower computational costs compared to their original
versions . Moreover, differential equations defined on the continuous time domain are a more natural fit for modeling
certain real-life scenarios than the difference equations defined over the domain of evenly-discretized time intervals .
Our primary aspiration for this document, particularly for the sections devoted to the Vanilla LSTM system and its extensions,
is to fulfill all of the following requirements:
1) Intuitive – the notation and semantics of variables must be descriptive, explicitly and unambiguously mapping to their
respective purposes in the system.
2) Complete – the explanations and derivations must include both the inference equations (“forward pass” or “normal
operation”) and the training equations (“backward pass”), and account for all components of the system.
3) General – the treatment must concern the most inclusive form of the LSTM system (i.e., the “Vanilla LSTM”), specifically
including the influence of the cell’s state on control nodes (“pinhole connections”).
4) Illustrative – the description must include a complete and clearly labeled cell diagram as well as the sequence diagram,
leaving nothing to imagination or guessing (i.e., the imperative is: strive to minimize cognitive strain, do not leave
anything as an “exercise for the reader” – everything should be explained and made explicit).
5) Modular – the system must be described in such a way that the LSTM cell can be readily included as part of a pluggable
architecture, both horizontally (“deep sequence”) and vertically (“deep representation”).
6) Vector notation – the equations should be expressed in the matrix and vector form; it should be straightforward to plug
the equations into a matrix software library (such as numpy) as written, instead of having to iterate through indices.
In all sources to date, one or more of the elements in the above list is not addressed2 . Hence, to serve as a comprehensive introduction, the present tutorial captures all
the essential details. The practice of using a succinct vector notation and meaningful variable names as well as including the
intermediate steps in formulas is designed to build intuition and make derivations easy to follow.
The rest of this document is organized as follows. Section II gives a principled background behind RNN systems. Then
Section III formally arrives at RNN unrolling by proving a precise statement concerning approximating long sequences by
a series of shorter, independent sub-sequences (segments). Section IV presents the RNN training mechanism based on the
technique, known as “Back Propagation Through Time”, and explores the numerical difficulties, which occur when training on
long sequences. To remedy these problems, Section V methodically constructs the Vanilla LSTM cell from the canonical RNN
system (derived in Section II) by reasoning through the ways of making RNN more robust. Section VI provides a detailed
explanation of all aspects of the Vanilla LSTM cell. Even though this section is intended to be self-contained, familiarity
with the material covered in the preceding sections will be beneficial. The Augmented LSTM system, which embellishes the
Vanilla LSTM system with the new computational components, identified as part of the exercise of transforming the RNN to
the LSTM network, is presented in Section VII. Section VIII summarizes the covered topics and proposes future projects.
2An article co-authored by one of the LSTM inventors provides a self-contained summary of the embodiment of an RNN, though not at an introductory
level .
II. THE ROOTS OF RNN
In this section, we will derive the Recurrent Neural Network (RNN) from differential equations . Let ⃗s(t) be the value
of the d-dimensional state signal vector and consider the general nonlinear first-order non-homogeneous ordinary differential
equation, which describes the evolution of the state signal as a function of time, t:
= ⃗f(t) + ⃗ϕ
where ⃗f(t) is a d-dimensional vector-valued function of time, t ∈R+, and ⃗ϕ is a constant d-dimensional vector.
One canonical form of ⃗f(t) is:
⃗f(t) = ⃗h (⃗s(t), ⃗x(t))
where ⃗x(t) is the d-dimensional input signal vector and ⃗h (⃗s(t), ⃗x(t)) is a vector-valued function of vector-valued arguments.
The resulting system,
= ⃗h (⃗s(t), ⃗x(t)) + ⃗ϕ
comes up in many situations in physics, chemistry, biology, and engineering .
In certain cases, one starts with s and x as entirely “analog” quantities (i.e., functions not only of time, t, but also of another
independent continuous variable, ⃗ξ, denoting the coordinates in multi-dimensional space). Using this notation, the intensity of
an input video signal displayed on a flat 2-dimensional screen would be represented as x(⃗ξ, t) with ⃗ξ ∈R2. Sampling x(⃗ξ, t)
on a uniform 2-dimensional grid converts this signal to the representation x(⃗i, t), where ⃗i is now a discrete 2-dimensional
index. Finally, assembling the values of x(⃗i, t) for all permutations of the components of the index, ⃗i, into a column vector,
produces ⃗x(t) as originally presented in Equation 3 above.
One special case of ⃗f(t) in Equation 2 is:
⃗f(t) = ⃗a(t) +⃗b(t) + ⃗c(t)
whose constituent terms, ⃗a(t), ⃗b(t), and ⃗c(t), are d-dimensional vector-valued functions of time, t. Equation 4 is called the
“Additive Model” in Brain Dynamics research literature, because it adds the terms, possibly nonlinear, that determine the rate
of change of neuronal activities, or potentials, ⃗s(t). As a cornerstone of neural network research, the abstract form of the
Additive Model in Equation 4 has been particularized in many ways, including incorporating the effects of delays, imposing
“shunting” (or “saturating”) bounds on the state of the system, and other factors. Biologically motivated uses of the Additive
Model span computational analyses of vision, decision making, reinforcement learning, sensory-motor control, short-term and
long-term memory, and the learning of temporal order in language and speech . It has also been noted that the Additive
Model generalizes the Hopfield model , which, while rooted in biological plausibility, has been influential in physics and
engineering . In fact, a simplified and discretized form of the Additive Model played a key role in linking the nonlinear
dynamical systems governing morphogenesis, one of the fundamental aspects of developmental biology, to a generalized version
of the Hopfield network , and applying it to an engineering problem in image processing .
Consider a saturating Additive Model in Equation 4 with the three constituent terms, ⃗a(t), ⃗b(t), and ⃗c(t), defined as follows:
⃗ak(⃗s(t −τs(k)))
⃗bk(⃗r(t −τr(k)))
⃗r(t −τr(k)) = G (⃗s(t −τr(k)))
⃗ck(⃗x(t −τx(k)))
where ⃗r(t), the readout signal vector, is a warped version of the state signal vector, ⃗s(t). A popular choice for the element-wise
nonlinear, saturating, and invertible “warping” (or “activation”) function, G(z), is an optionally scaled and/or shifted form of
the hyperbolic tangent. Then the resulting system, obtained by substituting Equations 5 – 8 into Equation 4 and inserting into
Equation 1, becomes:
⃗ak(⃗s(t −τs(k))) +
⃗bk(⃗r(t −τr(k))) +
⃗ck(⃗x(t −τx(k))) + ⃗ϕ
⃗r(t −τr(k)) = G (⃗s(t −τr(k)))
Equation 9 is a nonlinear ordinary delay differential equation (DDE) with discrete delays. Delay is a common feature of
many processes in biology, chemistry, mechanics, physics, ecology, and physiology, among others, whereby the nature of the
processes dictates the use of delay equations as the only appropriate means of modeling. In engineering, time delays often
arise in feedback loops involving sensors and actuators .
Hence, the time rate of change of the state signal in Equation 9 depends on three main components plus the constant (“bias”)
term, ⃗ϕ. The first (“analog”) component, PKs−1
k=0 ⃗ak(⃗s(t −τs(k))), is the combination of up to Ks time-shifted (by the delay
time constants, τs(k)) functions, ⃗ak(⃗s(t)), where the term “analog” underscores the fact that each ⃗ak(⃗s(t)) is a function of
the (possibly time-shifted) state signal itself (i.e., not the readout signal, which is the warped version of the state signal). The
second component, PKr−1
k=0 ⃗bk(⃗r(t −τr(k))), is the combination of up to Kr time-shifted (by the delay time constants, τr(k))
functions, ⃗bk(⃗r(t)), of the readout signal, given by Equation 10, the warped (binary-valued in the extreme) version of the state
signal. The third component, PKx−1
⃗ck(⃗x(t −τx(k))), representing the external input, is composed of the combination of up
to Kx time-shifted (by the delay time constants, τx(k)) functions, ⃗ck(⃗x(t)), of the input signal3.
The rationale behind choosing a form of the hyperbolic tangent as the warping function is that the hyperbolic tangent possesses
certain useful properties. On one hand, it is monotonic and negative-symmetric with a quasi-linear region, whose slope can
be regulated . On the other hand, it is bipolarly-saturating (i.e., bounded at both the negative and the positive limits of its
domain). The quasi-linear mode aides in the design of the system’s parameters and in interpreting its behavior in the “small
signal” regime (i.e., when ∥⃗s(t)∥≪1). The bipolarly-saturating (“squashing”) aspect, along with the proper design of the
internal parameters of the functions ⃗ak(⃗s(t)) and⃗bk(⃗r(t)), helps to keep the state of the system (and, hence, its output) bounded.
The dynamic range of the state signals is generally unrestricted, but the readout signals are guaranteed to be bounded, while
still carrying the state information with low distortion in the quasi-linear mode of the warping function (the “small signal”
regime). If the system, described by Equation 9 and Equation 10, is stable, then the state signals are bounded as well .
The time delay terms on the right hand side of Equation 9 comprise the “memory” aspects of the system. They enable the
quantity holding the instantaneous time rate of change of the state signal, d⃗s(t)
dt , to incorporate contributions from the state, the
readout, and the input signal values, measured at different points in time, relative to the current time, t. Qualitatively, these
temporal elements enrich the expressive power of the model by capturing causal and/or contextual information.
In neural networks, the time delay is an intrinsic part of the system and also one of the key factors that determines the
dynamics4. Much of the pioneering research in recurrent networks during the 1970s and the 1980s was founded on the premise
that neuron processes and interactions could be expressed as systems of coupled DDEs . Far from the actual operation
of the human brain, based on what was already known at the time, these “neurally inspired” mathematical models have
been shown to exhibit sufficiently interesting emerging behaviors for both, advancing the knowledge and solving real-world
problems in various practical applications. While the major thrust of research efforts was concerned primarily with continuoustime networks, it was well understood that the learning procedures could be readily adapted to discrete systems, obtained
from the original differential equations through sampling. We will also follow the path of sampling and discretization for
deriving the RNN equations . Over the span of these two decades, pivotal and lasting contributions were made in the
area of training networks containing interneurons5 with “Error Back Propagation” (or “Back Propagation of Error”, or “Back
Propagation” for short), a special case of a more general error gradient computation procedure. To accommodate recurrent
networks, both continuous-time and discrete-time versions of “Back Propagation Through Time” have been developed on the
foundation of Back Propagation and used to train the weights and time delays of these networks to perform a wide variety of
tasks . We will rely on Back Propagation Through Time for training the systems analyzed in this paper.
3The entire input signal, ⃗c(t), in Equation 8 is sometimes referred to as the “external driving force” (or, simply, the “driving force”) in physics.
4In neural networks, time delay occurs in the interaction between neurons; it is induced by the finite switching speed of the neuron and the communication
time between neurons .
5This term from neuroanatomy provides a biological motivation for considering networks containing multiple “hidden” layers, essentially what is dubbed
“deep networks” and “deep learning” today.
The contribution of each term on the right hand side of Equation 9 to the overall system is qualitatively different from that
of the others. The functions, ⃗ak(⃗s(t −τs(k))), of the (“analog”) state signal in the first term have a strong effect on the
stability of the system, while the functions, ⃗bk(⃗r(t −τr(k))), of the (bounded) readout signal in the second term capture most
of the interactions that shape the system’s long-term behavior. If warranted by the modeling requirements of the biological or
physical system and/or of the specific datasets and use-cases in an engineering setting, the explicit inclusion of non-zero delay
time constants in these terms provides the necessary weighting flexibility in the temporal domain (e.g., to account for delayed
neural interactions) . Thus, the parameters, Ks, Kr, and Kx representing the counts of the functions, ⃗ak(⃗s(t −τs(k))),
⃗bk(⃗r(t −τr(k))), and ⃗ck(⃗x(t −τx(k))), respectively (and the counts of the associated delay time constants, τs(k), τr(k), and
τx(k), respectively, of these functions), in the system equations are chosen (or estimated by an iterative procedure) accordingly.
Suppose that ⃗ak(⃗s(t −τs(k))), ⃗bk(⃗r(t −τr(k))), and ⃗ck(⃗x(t −τx(k))) are linear functions of ⃗s, ⃗r, and ⃗x, respectively. Then
Equation 9 becomes a nonlinear DDE with linear (matrix-valued) coefficients:
Ak(⃗s(t −τs(k))) +
Bk(⃗r(t −τr(k))) +
Ck(⃗x(t −τx(k))) + ⃗ϕ
Furthermore, if the matrices, Ak, Bk, and Ck, are circulant (or block circulant), then the matrix-vector multiplication terms in
Equation 11 can be expressed as convolutions in the space of the elements of ⃗s, ⃗r, ⃗x, and ⃗ϕ, each indexed by ⃗i:
ak(⃗i) ∗s(⃗i, t −τs(k)) +
bk(⃗i) ∗r(⃗i, t −τr(k)) +
ck(⃗i) ∗x(⃗i, t −τx(k)) + ϕ(⃗i)
The index,⃗i, is 1-dimensional if the matrices, Ak, Bk, and Ck, are circulant and multi-dimensional if they are block circulant6.
The summations of time delayed terms in Equation 12 represent convolutions in the time domain with finite-sized kernels,
consisting of the spatial convolutions ak(⃗i) ∗s(⃗i), bk(⃗i) ∗r(⃗i), and ck(⃗i) ∗x(⃗i) as the coefficients for the three temporal
components, respectively. In fact, if the entire data set (e.g., the input data set, ⃗x(t)) is available a priori for all time ahead of
the application of Equation 12, then some of the corresponding time delays (e.g., τx(k)) can be negative, thereby allowing the
incorporation of “future” information for computing the state of the system at the present time, t. This will become relevant
further down in the analysis.
Before proceeding, it is interesting to note that earlier studies linked the nonlinear dynamical system, formalized in Equation 9
(with Ks = Kr = Kx = 1 and all τs, τr, and τx set to zero), to the generalization of a type of neural networks7. Specifically the
variant, in which the functions ⃗ak(⃗s(t)),⃗bk(⃗r(t)), and ⃗ck(⃗x(t)) are linear operators as in Equation 11 (with Ks = Kr = Kx = 1
and all τs, τr, and τx set to zero) was shown to include the Continuous Hopfield Network as a special case. Its close
relative, in which these operators are further restricted to be convolutional as in Equation 12 (again, with Ks = Kr = Kx = 1
and all τs, τr, and τx set to zero), was shown to include the Cellular Neural Network as a special case .
Applying the simplifications:
(some of which will be later relaxed) to Equation 11 turns it into:
= A⃗s(t) + B⃗r(t −τ0) + C⃗x(t) + ⃗ϕ
6For example, the 2-dimensional shape of ⃗i is appropriate for image processing tasks.
7As mentioned earlier, a more appropriate phrase would be “neurally inspired” networks.
Equation 11, Equation 12, and, hence, Equation 14 are nonlinear first-order non-homogeneous DDEs. A standard numerical
technique for evaluating these equations, or, in fact, any embodiments of Equation 1, is to discretize them in time and compute
the values of the input signals and the state signals at each time sample up to the required total duration, thereby performing
numerical integration.
Denoting the duration of the sampling time step as △T and the index of the time sample as n in the application of the
backward Euler discretization rule8 to Equation 14 yields9:
≈⃗s(n△T + △T) −⃗s(n△T)
A⃗s(t) + B⃗r(t −τ0) + C⃗x(t) + ⃗ϕ = A⃗s(n△T) + B⃗r(n△T −τ0) + C⃗x(n△T) + ⃗ϕ
A⃗s(t + △T) + B⃗r(t + △T −τ0) + C⃗x(t + △T) + ⃗ϕ = A⃗s(n△T + △T) + B⃗r(n△T + △T −τ0) + C⃗x(n△T + △T) + ⃗ϕ
⃗s(n△T + △T) −⃗s(n△T)
≈A⃗s(n△T + △T) + B⃗r(n△T + △T −τ0) + C⃗x(n△T + △T) + ⃗ϕ
Now set the delay, τ0, equal to the single time step. This can be interpreted as storing the value of the readout signal into
memory at every time step to be used in the above equations at the next time step. After a single use, the memory storage
can be overwritten with the updated value of the readout signal to be used at the next time step, and so forth10. Thus, setting
τ0 = △T and replacing the approximation sign with an equal sign for convenience in Equation 19 gives:
⃗s(n△T + △T) −⃗s(n△T)
= A⃗s(n△T + △T) + B⃗r(n△T) + C⃗x(n△T + △T) + ⃗ϕ
⃗s((n + 1)△T) −⃗s(n△T)
= A⃗s((n + 1)△T) + B⃗r(n△T) + C⃗x((n + 1)△T) + ⃗ϕ
⃗s((n + 1)△T) −⃗s(n△T) = △T
A⃗s((n + 1)△T) + B⃗r(n△T) + C⃗x((n + 1)△T) + ⃗ϕ
After performing the discretization, all measurements of time in Equation 22 become integral multiples of the sampling time
step, △T. Now, △T can be dropped from the arguments, which leaves the time axis dimensionless. Hence, all the signals
are transformed into sequences, whose domain is the discrete index, n, and Equation 14 turns into a nonlinear first-order
non-homogeneous difference equation :
⃗s[n + 1] −⃗s[n] = △T
A⃗s[n + 1] + B⃗r[n] + C⃗x[n + 1] + ⃗ϕ
⃗s[n + 1] = ⃗s[n] + △T
A⃗s[n + 1] + B⃗r[n] + C⃗x[n + 1] + ⃗ϕ
(I −(△T)A)⃗s[n + 1] = ⃗s[n] + ((△T)B)⃗r[n] + ((△T)C) ⃗x[n + 1] + (△T)⃗ϕ
Ws = (I −(△T)A)−1
and multiplying both sides of Equation 24 by Ws leads to:
⃗s[n + 1] = Ws⃗s[n] + ((△T)WsB)⃗r[n] + ((△T)WsC) ⃗x[n + 1]) +
which after shifting the index, n, forward by 1 step becomes:
⃗s[n] = Ws⃗s[n −1] + ((△T)WsB)⃗r[n −1] + ((△T)WsC) ⃗x[n] +
⃗r[n] = G(⃗s[n])
8The backward Euler method is a stable discretization rule used for solving ordinary differential equations numerically . A simple way to express this
rule is to substitute the forward finite difference formula into the definition of the derivative, relax the requirement △T →0, and evaluate the function on
the right hand side (i.e., the quantity that the derivative is equal to) at time, t + △T.
9It is straightforward to extend the application of the discretization rule to the full Equation 11, containing any or all the time delay terms and their
corresponding matrix coefficients, without the above simplifications. So there is no loss of generality.
10Again, the additional terms, containing similarly combined time delayed input signals (as will be shown to be beneficial later in this paper) and state
signals, can be included in the discretization, relaxing the above simplifications as needed to suit the requirements of the particular problem at hand.
Defining two additional weight matrices and a bias vector,
Wr = (△T)WsB
Wx = (△T)WsC
⃗θs = (△T)Ws⃗ϕ
transforms the above system into the canonical Recurrent Neural Network (RNN) form:
⃗s[n] = Ws⃗s[n −1] + Wr⃗r[n −1] + Wx⃗x[n] + ⃗θs
⃗r[n] = G(⃗s[n])
Fig. 1. Canonical RNN cell. The bias parameters, ⃗θs, have been omitted from the figure for brevity. It can be assumed to be included without the loss of
generality by appending an additional element, always set to 1, to the input signal vector, ⃗x[n], and increasing the row dimensions of Wx by 1.
The RNN formulation in Equation 30, diagrammed in Figure 1, will be later logically evolved into the LSTM system. Before
that, it is beneficial to introduce the process of “unrolling”11 and the notion of a “cell” of an RNN. These concepts will be
simpler to describe using the standard RNN definition, which is derived next from Equation 30 based on stability arguments.
11The terms “unrolling” and “unfolding” are used interchangeably in association with RNN systems.
For the system in Equation 30 to be stable, every eigenvalue of ˆW = Ws + Wr must lie within the complex-valued unit
circle . Since there is considerable flexibility in the choice of the elements of A and B to satisfy this requirement,
setting △T = 1 for simplicity is acceptable. As another simplification, let A be a diagonal matrix with large negative entries
(i.e., aii ≪0) on its main diagonal (thereby practically guaranteeing the stability of Equation 14). Then, from Equation 25,
Ws ≈−A−1 will be a diagonal matrix with small positive entries,
|aii|, on its main diagonal, which means that the explicit
effect of the state signal’s value from memory, ⃗s[n−1], on the system’s trajectory will be negligible (the implicit effect through
⃗r[n −1] will still be present as long as ∥Wr∥> 0). Thus, ignoring the first term in Equation 30, reduces it to the standard
RNN definition:
⃗s[n] = Wr⃗r[n −1] + Wx⃗x[n] + ⃗θs
⃗r[n] = G(⃗s[n])
From Equation 32, now only the matrix ˆW ≈Wr ≈−A−1B is responsible for the stability of the RNN. Consider the best
case scenario, where B is a diagonal matrix (B = ΛB). With this simplification, the essential matrix for analyzing the stability
of Equation 32 becomes ˜W = −A−1ΛB, where ΛB is the diagonal matrix (i.e., consisting of only the eigenvalues of B, with
the individual eigenvalues, λi, on the main diagonal of ΛB). Since both A and ΛB are diagonal, ˜W is a diagonal matrix with
the entries µi =
|aii| on its main diagonal. These quantities become the eigenvalues of the overall RNN system in Equation 32
in the “small signal regime” (∥⃗s[n]∥≪1), each adding the mode of (µi)n, multiplied by its corresponding initial condition,
to the trajectory of ⃗s[n]. A necessary and sufficient condition for stability is that 0 < µi < 1, meaning that every eigenvalue,
λi, of B must satisfy the condition 0 < λi < |aii|. If any µi and λi fail to satisfy this condition, the system will be unstable,
causing the elements of ⃗r[n] to either oscillate or saturate (i.e., enter the flat regions of the warping nonlinearity) at some value
of the index, n.
An alternative to choosing the specific convenient form of A in Equation 25 would be to (somewhat arbitrarily) treat Ws, Wr,
Wx, and ⃗θs in Equation 30 as mutually independent parameters and then set Ws = 0 to obtain the standard RNN definition
(as in Equation 32). In this case, the above stability analysis still applies. In particular, the eigenvalues, µi, of Wr are subject
to the same requirement, 0 < µi < 1, as a necessary and sufficient condition for stability.
Stability considerations will be later revisited in order to justify the need to evolve the RNN to a more complex system, namely,
the LSTM network.
We have shown that the RNN, as expressed by Equation 30 (in the canonical form) or by Equation 32 (in the standard form),
essentially implements the backward Euler numerical integration method for the ordinary DDE in Equation 14. This “forward”
direction of starting in the continuous-time domain (differential equation) and ending in the discrete-index domain (difference
equation) implies that the original phenomenon being modeled is assumed to be fundamentally analog in nature, and that it is
modeled in the discrete domain as an approximation for the purpose of realization. For example, the source signal could be
the audio portion of a lecture, recorded on an analog tape (or on digital media as a finely quantized waveform and saved in an
audio file). The original recording thus contains the spoken words as well as the intonation, various emphases, and other vocal
modulations that communicate the content in the speaker’s individual way as expressed through voice. The samples generated
by a hypothetical discretization of this phenomenon, governed in this model by Equation 14, could be captured as the textual
transcript of the speech, saved in a document containing only the words uttered by the speaker, but ignoring all the intonation,
emotion, and other analogous nuances. In this scenario, it is the sequence of words in the transcript of the lecture that the
RNN will be employed to reproduce, not the actual audio recording of the speech. The key subtle point in this scenario is
that applying the RNN as a model implies that the underlying phenomenon is governed by Equation 14, whereby the role
of the RNN is that of implementing the computational method for solving this DDE using the backward Euler discretization
rule, under the restriction that the sampling time step, △T, is equal to the delay, τ0. In contrast, the “reverse” direction would
be a more appropriate model in situations where the discrete signal is the natural starting domain, because the phenomenon
originates as a sequence of samples. For example, a written essay originates as a sequence of words and punctuation, saved
in a document. One can conjure up an analog rendition of this essay as being read by a narrator, giving life to the words
and passages with intonation, pauses, and other expressions not present in the original text of the essay. While the starting
point depends on how the original source of data is generated, both the continuous (“forward”) and the discrete (“reverse”)
representations can serve as tools for gaining insight into the advantages and the limitations of the models under consideration.
III. RNN UNFOLDING/UNROLLING
It is convenient to use the term “cell” when referring to Equation 30 and Equation 32 in the uninitialized state. In other words,
the sequence has been defined by these equations, but its terms not yet computed. Then the cell can be said to be “unfolded”
or “unrolled” by specifying the initial conditions on the state signal, ⃗s[n], and numerically evaluating Equation 30 or
Equation 32 for a finite range of discrete steps, indexed by n. This process is illustrated in Figure 2.
Fig. 2. Sequence of steps generated by unrolling an RNN cell.
Both Equation 30 and Equation 32 are recursive in the state signal, ⃗s[n]. Hence, due to the repeated application of the recurrence
relation as part of the unrolling, the state signal, ⃗s[n], at some value of the index, n, no matter how large, encompasses the
contributions of the state signal, ⃗s[k], and the input signal, ⃗x[k], for all indices, k < n, ending at k = 0, the start of the sequence
 . Because of this attribute, the RNN belongs to the category of the “Infinite Impulse Response” (IIR) systems.
Define the vector-valued unit step function as:
where ⃗0 and ⃗1 denote vectors, all of whose elements are equal to 0 and to 1, respectively. Then the vector-valued unit sample
function, ⃗δ[n], is defined by being ⃗1 at n = 0, and ⃗0 otherwise. In terms of ⃗u[n],
⃗δ[n] = ⃗u[n] −⃗u[n −1]
These functions are depicted in Figure 3.
(a) The unit step function.
(b) The unit sample function.
Fig. 3. The unit step and the unit sample (“impulse”) functions plotted (in one data dimension) against the discrete index, n.
Example 1. The IIR (i.e., unending) nature of the sequences, governed by these equations, can be readily demonstrated by
letting ⃗s[−1] = ⃗0 be the initial condition, setting ⃗x[n] = ⃗δ[n], the unit sample stimulus (i.e., the “impulse”), and computing
the response, ⃗s[n], to this “impulse” for several values of the index, n, in order to try to recognize a pattern. In the case of
Equation 32 with ⃗θs = ⃗0, the sequence of ⃗s[n] values will be:
⃗s[n = −1] = ⃗0
⃗s[n = 0] = Wx⃗1
⃗s[n = 1] = WrG(Wx⃗1)
⃗s[n = 2] = WrG(WrG(Wx⃗1))
⃗s[n = 3] = WrG(WrG(WrG(Wx⃗1)))
⃗s[n = 4] = WrG(WrG(WrG(WrG(Wx⃗1))))
and so forth. Evidently, it is defined for every positive n, even when the input is only a single impulse at n = 0.
In practice, it is desirable to approximate a sequence with an infinite support (IIR), such as Equation 30 or Equation 32, by a
“Finite Impulse Response” (FIR) sequence. The rationale is that FIR systems have certain advantages over IIR systems. One
advantage is guaranteed stability – FIR systems are intrinsically stable. Another advantage is that FIR systems are realizable
with finite computational resources. An FIR system will take a finite number of steps to compute the output from the input
and will require a finite number of memory locations for storing intermediate results and various coefficients. Moreover, the
computational complexity and storage requirements of an FIR system are known at design time.
Denote the sequence of the “ground truth” output values by ⃗v[n] for any value of the index, n, and let N be the length of
the sequence, ⃗v[n], where N can be an arbitrarily large integer (e.g., the total number of samples in the training set, or the
number of inputs presented to the system for inference over the lifetime of the system, etc.). Suppose that ⃗v[n] ⌋0≤n≤N−1 is
subdivided into M non-overlapping varying-length segments with Km samples per segment, where every Km is finite, and
Km ≤N. It can be assumed that M is an integer with M ≥1 (if needed, the RNN system in Equation 32 can be “padded”
with extra ⃗x[n] = ⃗0 input terms for this to hold).
Formally, let ⃗v[n] ⌋0≤n≤N−1 be the sequence of the ground truth output values for any value of the index, n, and assume that
there exists a partitioning of ⃗v[n] ⌋0≤n≤N−1 into M non-overlapping segments, ⃗vm[n], 0 ≤m ≤M −1:
⃗v[n] ⌋0≤n≤N−1 =
For subdividing a sequence into M non-overlapping segments, consider a vector-valued “rectangular” window function, ⃗w0[n],
which has the value of ⃗1 within the window 0 ≤n ≤K0 −1 and ⃗0 otherwise. In terms of the vector-valued unit step function,
⃗u[n], ⃗w0[n] is defined as:
⃗w0[n] = ⃗u[n] −⃗u[n −K0]
Combining Equation 35 with Equation 38 provides an alternative (“sampling”) definition of ⃗w0[n]:
⃗w0[n] = ⃗u[n] −⃗u[n −1]
+ ⃗u[n −1] −⃗u[n −2]
+ ⃗u[n −2] −⃗u[n −3]
+ ⃗u[n −(K0 −2)] −⃗u[n −(K0 −1)]
+ ⃗u[n −(K0 −1)] −⃗u[n −K0]
Then from Equation 39, the RNN sequence can be sampled in its entirety by the full N-samples-long window:
⃗w[n] = ⃗u[n] −⃗u[n −N]
1 ≤m ≤M −1
Under the change of indices,
l = k −j(m)
k = j(m) + l
Equation 43 becomes:
⃗δ[n −j(m) −k]
Equation 44 indicates that each ⃗wm[n] is a rectangular window, whose size is Km samples. Hence, “extracting” a
Km-samples-long segment with the index, m, from the overall ground truth output sequence, ⃗v[n] ⌋0≤n≤N−1 , amounts to
multiplying this sequence by ⃗wm[n]:
⃗vm[n] ⌋0≤n≤N−1 = ⃗wm[n] ⊙⃗v[n] ⌋0≤n≤N−1
j(m) ≤n ≤j(m) + Km −1
where j(m) is given by Equation 42. According to Equation 46, the segment-level ground truth output subsequence,
⃗vm[n] ⌋0≤n≤N−1 , in Equation 45 will have non-zero values for the given value of the segment index, m, where 0 ≤m ≤M −1,
only when the index, n, is in the range j(m) ≤n ≤j(m) + Km −1. This is in agreement with Equation 37.
Define Q(⟨⃗r[n]⟩) as an invertible map that transforms an ensemble of the readout signals of the RNN system, ⟨⃗r[n]⟩, into an
ensemble of observable output signals, ⟨⃗y[n]⟩, for 0 ≤n ≤N −1:
⟨⃗y[n]⟩≡Q(⟨⃗r[n]⟩)
In addition, define L as an “objective function” (or “merit function” ) that measures the cost of the observable output of
the system deviating from the desired ground truth output values, given the input data, supplied over the entire range of the
values of the index, n:
L (⟨⃗y[n]⟩⌋0≤n≤N−1 , ⟨⃗v[n]⟩⌋0≤n≤N−1 )
where ⟨⃗y[n]⟩⌋0≤n≤N−1 denotes the ensemble of all N members of the sequence of the observable output variables, ⃗y[n], and
⟨⃗v[n]⟩⌋0≤n≤N−1 denotes the ensemble of all N members of the sequence of the ground truth output values, ⃗v[n].
As shorthand, combine all parameters of the standard RNN system in Equation 32 under one symbol, Θ:
Wr, Wx, ⃗θs
Proposition 1. Given the standard RNN system in Equation 32 parameterized by Θ, defined in Equation 49, assume that there
exists a value of Θ, at which the objective function, L, defined in Equation 48 for an N-samples-long sequence, is close to an
optimum as measured by some acceptable bound. Further, assume that there exist non-zero finite constants, M and Km, such
that Km < N, where 0 ≤m ≤M −1, and that the ground truth output sequence, ⃗v[n] ⌋0≤n≤N−1 , can be partitioned into
mutually independent segment-level ground truth output subsequences, ⃗vm[n] ⌋0≤n≤N−1 , for different values of the segment
index, m, as specified in Equation 46. Then a single, reusable RNN cell, unrolled for an adjustable number of steps, Km,
is computationally sufficient for seeking Θ that optimizes L over the training set and for inferring outputs from unseen inputs.
Proof. The objective function in Equation 48 computes the error in the system’s performance during training, validation, and
testing phases as well as tracks its generalization metrics on the actual application data during the inference phase. By the
assumption, L can be optimized. This implies that when L is acceptably close to an optimum, the observable output ensemble
from the RNN system approximates the ground truth output ensemble within a commensurately acceptable tolerance bound:
⟨⃗y[n]⟩⌋0≤n≤N−1 ≈⟨⃗v[n]⟩⌋0≤n≤N−1
Segmenting the RNN system’s output sequence by the same procedure as was used in Equation 45 to segment the ground
truth output sequence gives:
⃗ym[n] ⌋0≤n≤N−1 = ⃗wm[n] ⊙⃗y[n] ⌋0≤n≤N−1
j(m) ≤n ≤j(m) + Km −1
where j(m) is given by Equation 42. According to Equation 52, the segment-level output subsequence, ⃗ym[n] ⌋0≤n≤N−1 , in
Equation 51 will have non-zero values for the given value of the segment index, m, where 0 ≤m ≤M −1, only when the
index, n, is in the range j(m) ≤n ≤j(m) + Km −1.
By the assumption that the segment-level ensembles of the ground truth output subsequences are mutually independent, the
objective function in Equation 48 is separable and can be expressed as a set of M independent segment-level components,
{Lm (⟨⃗ym[n]⟩⌋0≤n≤N−1 , ⟨⃗vm[n]⟩⌋0≤n≤N−1 )}, 0 ≤m ≤M −1, combined by a suitable function, C:
L (⟨⃗y[n]⟩⌋0≤n≤N−1 , ⟨⃗v[n]⟩⌋0≤n≤N−1 ) = C ({Lm (⟨⃗ym[n]⟩⌋0≤n≤N−1 , ⟨⃗vm[n]⟩⌋0≤n≤N−1 )} ⌋0≤m≤M−1 )
Then by Equation 50 and Equation 53,
⟨⃗ym[n]⟩⌋0≤n≤N−1 ≈⟨⃗vm[n]⟩⌋0≤n≤N−1
for all values of the segment index, m, where 0 ≤m ≤M −1. In other words, the tracking of the ground truth output by
the observable output of the RNN system at the entire N-sample ensemble level must hold at the Km-samples-long segment
level, too, for all segments.
Since Q(⟨⃗r[n]⟩) is invertible,
⟨⃗rm[n]⟩⌋0≤n≤N−1 = Q−1 (⟨⃗ym[n]⟩⌋0≤n≤N−1 )
and since the warping function, G(z), in Equation 33 is invertible, then for any value of the sample index, n,
⃗sm[n] ⌋0≤n≤N−1 = G−1 (⃗rm[n] ⌋0≤n≤N−1 )
According to Equation 50, Equation 55, and Equation 56, ⟨⃗ym[n]⟩⌋0≤n≤N−1 , ⟨⃗rm[n]⟩⌋0≤n≤N−1 , and ⃗sm[n] ⌋0≤n≤N−1 are
all functions of random variables. Let ⟨⃗vm[n]⟩⌋0≤n≤N−1 and ⟨⃗vl[n]⟩⌋0≤n≤N−1 be the ground truth output subsequence
ensembles, belonging to any two segments, whose indices are m and l, respectively, with m ̸= l. By the assumption,
⟨⃗vm[n]⟩⌋0≤n≤N−1 and ⟨⃗vl[n]⟩⌋0≤n≤N−1 are independent random variables. Because the functions of independent variables are
also independent, it follows that at the segment level the observable output signal subsequence ensembles, ⟨⃗ym[n]⟩⌋0≤n≤N−1
and ⟨⃗yl[n]⟩⌋0≤n≤N−1 , are independent, the readout signal subsequence ensembles, ⟨⃗rm[n]⟩⌋0≤n≤N−1 and ⟨⃗rl[n]⟩⌋0≤n≤N−1 ,
are independent, and the state signal subsequences, ⃗sm[n] ⌋0≤n≤N−1 and ⃗sl[n] ⌋0≤n≤N−1 , are independent.
The mutual independence of the state signal subsequences, ⃗sm[n] ⌋0≤n≤N−1 , for different values of the segment index, m,
places a restriction on the initial conditions of these subsequences. Specifically, the initial condition for the state signal
subsequence of one segment cannot be a function of samples belonging to either the state signal subsequence or the input
signal subsequence of another segment for any value of the index, n.
Performing the element-wise multiplication of the input sequence, ⃗x[n] ⌋0≤n≤N−1 , by the sampling window, ⃗wm[n], extracts
a segment-level input sequence with the index, m:
⃗xm[n] ⌋0≤n≤N−1 = ⃗wm[n] ⊙⃗x[n] ⌋0≤n≤N−1
j(m) ≤n ≤j(m) + Km −1
where j(m) is given by Equation 42. According to Equation 58, the segment-level input subsequence, ⃗xm[n] ⌋0≤n≤N−1 , in
Equation 57 will have non-zero values for the given value of the segment index, m, where 0 ≤m ≤M −1, only when the
index, n, is in the range j(m) ≤n ≤j(m) + Km −1.
Due to recursion, the members of the state signal sequence, ⃗sm[n] ⌋0≤n≤N−1 , in an RNN system can in general depend
on the entire input signal sequence assembly. However, since under the present assumptions the segment-level state signal
subsequences, ⃗sm[n] ⌋0≤n≤N−1 and ⃗sl[n] ⌋0≤n≤N−1 , belonging to different segments, are independent, the dependency of
⃗sm[n] ⌋0≤n≤N−1 on the input signal must be limited to the same segment-level subsequence (i.e., with segment index, m). If
we define F
j(m)≤n≤j(m)+Km−1
as a map that transforms the segment-level input signal subsequence assembly,
⟨⃗xm[n]⟩⌋0≤n≤N−1 , into the segment-level state signal subsequence assembly, ⟨⃗sm[n]⟩
j(m)≤n≤j(m)+Km−1 , then the standard
RNN system definition in Equation 32 at the Km-samples-long segment level can be expressed as:
j(m)≤n≤j(m)+Km−1 = F
j(m)≤n≤j(m)+Km−1
Hence, for any 0 ≤m, l ≤M −1 with m ̸= l, the restriction,
⃗sm[n = j(m) −1] ⊥
j(l) ≤n ≤j(l) + Kl −1
j(l) ≤n ≤j(l) + Kl −1
must be enforced in order to satisfy the independence of the segment-level state signal subsequences. The only way to achieve
this is to set ⃗sm[n = j(m) −1] to a random vector or to ⃗0. The latter choice is adopted here for simplicity.
Thus, substituting Equation 58 and Equation 60 into Equation 32 yields the RNN system equations for an individual segment:
Wr⃗rm[n −1] + Wx⃗xm[n] + ⃗θs,
j(m) ≤n ≤j(m) + Km −1
G(⃗sm[n]),
j(m) ≤n ≤j(m) + Km −1
⃗sm[n = j(m) −1] = ⃗0
0 ≤m ≤M −1
Making the index substitution,
n −→n + j(m)
shifts the segment-level subsequences, ⃗rm[n] ⌋0≤n≤N−1 , ⃗sm[n] ⌋0≤n≤N−1 , and ⃗xm[n] ⌋0≤n≤N−1 , by −j(m) samples:
⃗˜xm[n] ≡⃗xm[n + j(m)] ⌋0≤n≤N−1
⃗x[n + j(m)],
j(m) ≤n + j(m) ≤j(m) + Km −1
⃗x[n + j(m)],
0 ≤n ≤Km −1
⃗˜rm[n] ≡⃗rm[n + j(m)] ⌋0≤n≤N−1
⃗˜sm[n] ≡⃗sm[n + j(m)] ⌋0≤n≤N−1
Wr⃗rm[n + j(m) −1] + Wx⃗xm[n + j(m)] + ⃗θs,
j(m) ≤n + j(m) ≤j(m) + Km −1
Wr⃗˜rm[n −1] + Wx⃗˜xm[n] + ⃗θs,
0 ≤n ≤Km −1
⃗˜sm[n = −1] ≡⃗sm[n + j(m) = j(m) −1] = ⃗0
Simplified, these equations reduce to the form of the standard RNN system, unrolled for Km steps, for any segment with the
index, m, where 0 ≤m ≤M −1:
⃗˜sm[n = −1] = ⃗0
Wr⃗˜rm[n −1] + Wx⃗˜xm[n] + ⃗θs,
0 ≤n ≤Km −1
G(⃗˜sm[n]),
0 ≤n ≤Km −1
⃗x[n + j(m)],
0 ≤n ≤Km −1
It follows that the shifted segment-level state signal subsequences, ⃗˜sm[n] ⌋0≤n≤Km−1 , for different values of the segment
index, m, where 0 ≤m ≤M −1, are mutually independent. In addition, from Equation 71, Equation 70, and Equation 72,
the non-zero values of the resulting sequences, ⃗˜rm[n] ⌋0≤n≤Km−1 , ⃗˜sm[n] ⌋0≤n≤Km−1 , and ⃗˜xm[n] ⌋0≤n≤Km−1 , are confined
to 0 ≤n ≤Km −1 for any value of the segment index, m, where 0 ≤m ≤M −1.
As the sample index, n, traverses the segment-level range, 0 ≤n ≤Km −1, for every segment with the index, m, where
0 ≤m ≤M −1, the input subsequence, ⃗˜xm[n], takes on all the available values of the input sequence, ⃗x[n], segment by
segment. Similarly to the original RNN system in Equation 32, the input signal, ⃗˜xm[n] (the external driving force), is the only
independent variable of the RNN system, unrolled for Km steps, in Equation 70. Together with the mutual independence of
⃗˜sm[n] ⌋0≤n≤Km−1 for different segments, this makes the computations of the RNN system, unrolled for Km steps, generic for
all segments. The only signal that retains the dependence on the segment index, m, is the input. Dropping the segment subscript,
m, from the variables representing the state signal and the readout signal results in the following prototype formulation of the
RNN system, unrolled for Km steps:
⃗˜s[n = −1] = ⃗0
Wr⃗˜r[n −1] + Wx⃗˜xm[n] + ⃗θs,
0 ≤n ≤Km −1
G(⃗˜s[n]),
0 ≤n ≤Km −1
⃗x[n + j(m)],
0 ≤n ≤Km −1
0 ≤m ≤M −1
where j(m) is given by Equation 42.
The same prototype variable-length RNN computation, unrolled for Km steps, can process all segments, one at a time. After
initializing the segment’s state signal using Equation 73 and selecting the input samples for the segment using Equation 76,
Equation 74 and Equation 75 are evaluated for Km steps, 0 ≤n ≤Km −1. This procedure can then be applied to the
next segment using the same computational module, and then to the next segment, and so on, until the inputs comprising all
M segments have been processed. Moreover, the mutual independence of the segments facilitates parallelism, whereby the
computation of ⃗˜sm[n] , ⃗˜rm[n], and ⃗ym[n] for 0 ≤n ≤Km −1 can be carried out for all M segments concurrently.
Remark 1. Proposition 1 and its proof do not formally address advanced RNN architectures, such as Gated Recurrent Unit
(GRU), Attention Networks, and complex models comprised of multiple LSTM networks.
Remark 2. While the segment-level state signal subsequences, ⃗˜sm[n] ⌋0≤n≤Km−1 , are independent, there is no independence
requirement on the input signal subsequences, ⃗˜xm[n], belonging to the different segments. It has been shown that dependencies
in the input signal can be de-correlated by appropriately trained hidden layer weights, Wx, thus maintaining the independence
of ⃗˜sm[n] ⌋0≤n≤Km−1 .
Remark 3. It is important to emphasize that no IIR-to-FIR conversion method is optimal in the absolute sense. Finding an
optimal FIR approximation to an IIR system can only be done with respect to a certain measure of fidelity and performance.
In practice, one must settle for an approximation to the ideal form of the output signal. The success of an approximation
technique depends on the degree to which the resulting FIR system can be adapted to fit the specific data distribution and
achieve acceptable quality metrics for the given application’s requirements.
Unrolling (or unfolding) for a finite number of steps is a standard, straightforward technique for approximating RNNs by
FIR sequences. However, due to the truncation inherent in limiting the number of steps, the resulting unfolded RNN model
introduces artificial discontinuities in the approximated version of the target output sequence. In general, the more steps are
included in the unrolled RNN subsequence, the closer it can get to the desired output samples, but the less efficient the system
becomes, due to the increased number of computations. Nevertheless, if the underlying distribution governing the application
generates the sequence under consideration as a series of independent segments (subsequences), then by Proposition 1, an
unfolded RNN model aligned with each segment can be trained to reproduce outputs from inputs in a way that aims to satisfy
the appropriate criteria of merit faithfully. In this sense, Proposition 1 for RNNs loosely resembles in spirit the Sampling
Theorem in the field of Discrete-Time Signal Processing . The method of unrolling is also applicable to the scenarios where
attention can be restricted to those “present” sections of the output that are influenced to an arbitrarily small extent by the
portions of the “past” or the “future” of the input beyond some arbitrarily large but finite step . As a matter of fact, in certain
situations, the raw data set may be amenable to pre-processing, without losing much of the essential information. Suppose that
after a suitable cleanup, treating the overall sequence as a collection of independent segments becomes a reasonable assumption.
Then by Proposition 1, the adverse effects of truncation can be reduced by adjusting the number of samples comprising the
window of the unrolled RNN system. Moreover, whenever Proposition 1 applies, the segments can be processed by the unrolled
RNN system in any order (because they are assumed to be independent). This flexibility is utilized by the modules that split
the original data set into segments and feed the batches of segmented training samples to the computational core of system.
Conversely, if the assumptions of Proposition 1 are violated, then truncating the unrolling will prevent the model from adequately
fitting the ground truth output. To illustrate this point, suppose that an RNN system, unrolled for a relatively few steps, is
being used to fit the target sequence that exhibits extremely long-range dependencies. The unrolled RNN subsequence will be
trained under the erroneous assumptions, expecting the ground truth to be a series of short independent subsequences. However,
because of its relatively narrow window, this RNN subsequence will not be able to encompass enough samples to capture the
dependencies present in the actual data. Under-sampling the distribution will limit the flow of information from the training
samples to the parameters of the model, leaving it in the constant state of making poor predictions. As a symptom, the model
will repeatedly encounter unexpected variations during training, causing the objective function to oscillate, never converging
to an adequate optimum. During inference, the generated sequence will suffer from severe jitter and distortion when compared
to the expected output.
Remark 4. According to Proposition 1, the RNN unrolling technique is justified by partitioning a single output sequence into
multiple independent subsequences and placing restrictions on the initialization of the state between subsequences. However,
adhering to these conditions may be problematic in terms of modeling sequences in practical applications. Oftentimes, the
output subsequences exhibit some inter-dependence and/or the initial state of one subsequence is influenced by the final state
of another subsequence. In practice, if the choice for the initial conditions of the state of subsequences is consistent with
the process by which the application generates the samples of the input sequence, then a favorable subdivision of the output
sequence into acceptably independent subsequences can be found empirically through experimentation and statistical analysis.
IV. RNN TRAINING DIFFICULTIES
Proposition 1 establishes that Equations 73 – 77 together with Equation 42 specify the truncated unrolled RNN system that
realizes the standard RNN system, given by Equation 32 and Equation 33. We now segue to the analysis of the training
technique for obtaining the weights in the truncated unrolled RNN system, with the focus on Equation 74 and Equation 75.
Once the infinite RNN sequence in Equation 32 is truncated (or unrolled to a finite length), the resulting system, given in
Equation 74, becomes inherently stable. However, RNN systems are problematic in practice, despite their stability. During
training, they suffer from the well-documented issues, known as “vanishing gradients” and “exploding gradients” .
These difficulties become pronounced when the dependencies in the target subsequence span a large number of samples,
requiring the window of the unrolled RNN model to be commensurately wide in order to capture these long-range dependencies.
Truncated unrolled RNN systems, such as Equation 74, are commonly trained using “Back Propagation Through Time”
(BPTT), which is the “Back Propagation” technique adapted for sequences . The essence of Back Propagation
is the repeated application of the chain rule of differentiation. Computationally, the action of unrolling Equation 32 for K
steps amounts to converting its associated directed graph having a delay and a cycle, into a directed acyclic graph (DAG)
corresponding to Equation 74. For this reason, while originally Back Propagation was restricted to feedforward networks only,
subsequently, it has been successfully applied to recurrent networks by taking advantage of the very fact that for every recurrent
network there exists an equivalent feedforward network with identical behavior for a finite number of steps .
As a supervised training algorithm, BPTT utilizes the available ⃗˜xm[n] and ⃗˜r[n] data pairs (or the respective pairs of some
mappings of these quantities) in the training set to compute the parameters of the system, Θ, defined in Equation 49, so as
to optimize an objective function, E, which depends on the readout signal, ⃗˜r[n], at one or more values of the index, n. If
Gradient Descent (or another “gradient type” algorithm) is used to optimize E, then BPTT provides a consistent procedure
for deriving the elements of ∂E
∂Θ through a repeated application of the chain rule12.
By assuming that the conditions of Proposition 1 apply, the objective function, E, takes on the same form for all segments.
Let us now apply BPTT to Equation 74. Suppose that E depends on the readout signal, ⃗˜r[n], at some specific value of the
index, n. Then it is reasonable to wish to measure the total gradient of E with respect to ⃗˜r[n]:
⃗χ[n] ≡⃗∇⃗˜r[n]E =
Since ⃗˜r[n] is explicitly dependent on ⃗˜s[n], it follows that ⃗˜s[n] also influences E, and one should be interested in measuring
the total gradient of E with respect to ⃗˜s[n]:
⃗ψ[n] ≡⃗∇⃗˜s[n]E =
Quite often in practice, the overall objective function is defined as the sum of separate contributions involving the readout
signal, ⃗˜r[n], at each individual value of the index, n:
Because of the presence of the individual penalty terms, E(⃗˜r[n]), in Equation 80 for the overall objective function of the
system, it may be tempting to use the chain rule directly with respect to ⃗˜r[n] in isolation and simply conclude that ⃗χ[n] in
Equation 78 is equal to ∂E(⃗˜r[n])
⌋z=⃗˜s[n], where the ⊙operator denotes the element-wise vector product. However,
this would miss an important additional component of the gradient with respect to the state signal. The subtlety is that for an
RNN, the state signal, ⃗˜s[n], at n = k also influences the state signal, ⃗˜s[n], at n = k + 1 . The dependency of ⃗˜s[n + 1]
on ⃗˜s[n] through ⃗˜r[n] becomes apparent by rewriting Equation 74 at the index, n + 1:
⃗˜s[n + 1] = Wr⃗˜r[n] + Wx⃗˜xm[n + 1] + ⃗θs
⃗˜r[n] = G(⃗˜s[n])
⃗˜r[n + 1] = G(⃗˜s[n + 1])
12The name “Back Propagation Through Time” reflects the origins of recurrent neural networks in continuous-time domain and differential equations.
While not strictly accurate, given the discrete nature of the RNN system under consideration, “Back Propagation Through Time” is easy to remember, carries
historical significance, and should not be the source of confusion.
Hence, accounting for both dependencies, while applying the chain rule, gives the expressions for the total partial derivative
of the objective function with respect to the readout signal and the state signal at the index, n:
⃗χ[n] = ∂E(⃗˜r[n])
+ Wr ⃗ψ[n + 1]
⃗ψ[n] = ⃗χ[n] ⊙dG(⃗z)
∂E(⃗˜r[n])
+ Wr ⃗ψ[n + 1]
Equation 82 and Equation 84 show that the total partial derivatives of the objective function form two sequences, which progress
in the “backward” direction of the index, n. These sequences represent the dual counterparts of the sequence generated by
unrolling Equation 74 in the “forward” direction of the index, n. Therefore, just as Equation 74 requires the initialization of
the segment’s state signal using Equation 73, the sequence formed by the total partial derivative of the objective function with
respect to the state signal (commonly designated as the “the error gradient”) requires that Equation 82 must also be initialized:
⃗ψ[n = Km] = ⃗0
Applying the chain rule to Equation 74 and using Equation 84, gives the expressions for the derivatives of the model’s
parameters:
[n] = ⃗ψ[n]⃗˜rT [n −1]
[n] = ⃗ψ[n]⃗˜xT
[n] = ⃗ψ[n]
Note that for an RNN cell, unrolled for Km steps in order to cover a segment containing Km training samples, the same set
of the model parameters, Θ, is shared by all the steps. This is because Θ is the parameter of the RNN system as a whole.
Consequently, the total derivative of the objective function, E, with respect to the model parameters, Θ, has to include the
contributions from all steps of the unrolled sequence. This is captured in Equation 90, which can now be used as part of
optimization by Gradient Descent. Another key observation is that according to Equation 87, Equation 88, and Equation 89,
all of the quantities essential for updating the parameters of the system, Θ, during training are directly proportional to ⃗ψ[n].
When the RNN system is trained using BPTT, the error gradient signal flows in the reverse direction of the index, n, from
that of the sequence itself. Let
⌋0≤k<n denote all terms of the sequence, each of whose elements, ⃗ψ[k], is the gradient
of E with respect to the state signal, ⃗˜s[k], at the index, k, for all k < n, ending at ⃗ψ[k = 0], the start of the sequence. Then
Equation 84 reveals that ⃗ψ[n], the gradient of E with respect to the state signal, ⃗˜s[n], at some value of the index, n, no matter
how large, can influence the entire ensemble,
⌋0≤k<n . Furthermore, by Proposition 1, ⃗ψ[n] depends on the truncated
⌋n<k≤Km−1 . Thus, of a particular interest is the fraction of ⃗ψ[n] that is retained from back propagating ⃗ψ[l],
where l ≫n. This component of the gradient of the objective function is responsible for adjusting the model’s parameters,
Θ, in a way that uses the information available at one sample to reduce the cost of the system making an error at a distant
sample. If these types of contributions to ⃗ψ[n] ⌋0≤n≤Km−1 are well-behaved numerically, then the model parameters learned
by using the Gradient Descent optimization procedure will able to incorporate the long-range interactions among the samples
in the RNN window effectively during inference.
Expanding the recursion in Equation 84 from the step with the index, n, to the step with the index, l ≤Km −1, where l ≫n,
Wr ⊙dG(⃗z)
From Equation 91, the magnitude of the overall Jacobian matrix, ∂⃗ψ[n]
∂⃗ψ[l] , depends on the product of l −n individual Jacobian
matrices, Wr ⊙dG(⃗z)
d⃗z ⌋z=⃗˜s[k]
13. Even though the truncated unrolled RNN system is guaranteed to be stable by design, since in
the case of long-range interactions the unrolled window size, Km, and the distance between the samples of interest, l −n, are
both large, the stability analysis is helpful in estimating the magnitude of ∂⃗ψ[n]
∂⃗ψ[l] in Equation 91. If all eigenvalues, µi, of Wr
satisfy the requirement for stability, 0 < µi < 1, then ∥Wr∥< 1. Combined with the fact that
< 1 (which follows
from the choice of the warping function advocated in Section II), this yields:
∼∥Wr∥l−n ·
Conversely, if at least one eigenvalue of Wr violates the requirement for stability, the term ∥Wr∥l−n will grow exponentially.
This can lead to two possible outcomes for the RNN system in Equation 74. In one scenario, as the state signal, ⃗˜s[n], grows,
the elements of the readout signal, ⃗˜r[n], eventually saturate at the “rails” (the flat regions) of the warping function. Since in the
saturation regime, dG(⃗z)
= ⃗0, the result is again
≈0. In another, albeit rare, scenario, the state signal, ⃗˜s[n], is initially
biased in the quasi-linear region of the warping function, where dG(⃗z)
̸= ⃗0. If the input, ⃗˜xm[n], then guides the system to stay
in this mode for a large number of steps,
will grow, potentially resulting in an overflow. Consequently, training the
standard RNN system on windows spanning many data samples using Gradient Descent is hampered by either vanishing or
exploding gradients, regardless of whether or not the system is large-signal stable. In either case, as long as Gradient Descent
optimization is used for training the RNN, regulating ⃗ψ[n] will be challenging in practice, leaving no reliable mechanism for
updating the parameters of the system, Θ, in a way that would enable the trained RNN model to infer both ⃗˜r[n] and ⃗˜r[l ≫n]
optimally14. The most effective solution so far is the Long Short-Term Memory (LSTM) cell architecture .
V. FROM RNN TO VANILLA LSTM NETWORK
The Long Short-Term Memory (LSTM) network was invented with the goal of addressing the vanishing gradients problem.
The key insight in the LSTM design was to incorporate nonlinear, data-dependent controls into the RNN cell, which can be
trained to ensure that the gradient of the objective function with respect to the state signal (the quantity directly proportional to
the parameter updates computed during training by Gradient Descent) does not vanish . The LSTM cell can be rationalized
from the canonical RNN cell by reasoning about Equation 30 and introducing changes that make the system robust and versatile.
In the RNN system, the observable readout signal of the cell is the warped version of the cell’s state signal itself. A weighted
copy of this warped state signal is fed back from one step to the next as part of the update signal to the cell’s state. This
tight coupling between the readout signal at one step and the state signal at the next step directly impacts the gradient of the
objective function with respect to the state signal. This impact is compounded during the training phase, culminating in the
vanishing/exploding gradients.
Several modifications to the cell’s design can be undertaken to remedy this situation. As a starting point, it is useful to separate
the right hand side of Equation 30 (the cell’s updated state signal at a step with the index, n) into two parts15:
⃗s[n] = ⃗Fs (⃗s[n −1]) + ⃗Fu (⃗r[n −1], ⃗x[n])
⃗r[n] = Gd(⃗s[n])
⃗Fs (⃗s[n −1]) = Ws⃗s[n −1]
⃗Fu (⃗r[n −1], ⃗x[n]) = Wr⃗r[n −1] + Wx⃗x[n] + ⃗θs
13By convention, the element-wise multiplication by a vector is equivalent to the multiplication by a diagonal matrix, in which the elements of the vector
occupy the main diagonal.
14A detailed treatment of the difficulties encountered in training RNNs is presented in . The problem is defined using Equation 80, which leads to
the formulas for the gradients of the individual objective function at each separate step with respect to the model’s parameters. Then the behavior of these
formulas as a function of the index of the step is analyzed, following the approach in . In contrast, the present analysis follows the method described in
 and . The total gradient of the objective function with respect to the state signal at each step is pre-computed using Equation 84. Then
the behavior of the members of this sequence as a function of the number of steps separating them is analyzed. The results and conclusions of these dual
approaches are, of course, identical.
15In the remainder of this document, the prototype segment notation of Equation 74 is being omitted for simplicity. Unless otherwise specified, it is assumed
that all operations are intended to be on the domain of a segment, where the sample index, n, traverses the steps of the segment, 0 ≤n ≤Km −1, for
every segment with the index, m, in 0 ≤m ≤M −1.
where Gd(⃗z) is the hyperbolic tangent as before16. The first part, ⃗Fs (⃗s[n −1]), carries forward the contribution from the
state signal at the previous step. The second part, ⃗Fu (⃗r[n −1], ⃗x[n]), represents the update information, consisting of the
combination of the readout signal from the previous step and the input signal (the external driving force) at the current step
(plus the bias vector, ⃗θs)17. According to Equation 94, the state signal blends both sources of information in equal proportions
at every step. These proportions can be made adjustable by multiplying the two quantities by the special “gate” signals,
⃗gcs[n] (“control state”) and ⃗gcu[n] (“control update”), respectively:
⃗s[n] = ⃗gcs[n] ⊙⃗Fs (⃗s[n −1]) + ⃗gcu[n] ⊙⃗Fu (⃗r[n −1], ⃗x[n])
⃗0 ≤⃗gcs[n],⃗gcu[n] ≤⃗1
Fig. 4. Expanding the canonical RNN system by adding the “control state” gate, ⃗gcs[n], to control the amount of the state signal, retained from the previous
step and the “control update” gate, ⃗gcu[n], to regulate the amount of the update signal – to be injected into the state signal at the current step.
The elements of gate signals are non-negative fractions. The shorthand notation, ⃗g[n] ∈[⃗0,⃗1] (alternatively, ⃗0 ≤⃗g[n] ≤⃗1),
means that the values of all elements of a vector-valued gate signal, ⃗g[n], at a step with the index, n, lie on a closed segment
between 0 and 1.
The gate signals, ⃗gcs[n] and ⃗gcu[n], in Equation 98 and Equation 99 provide a mechanism for exercising a fine-grained control
of the two types of contributions to the state signal at every step. Specifically, ⃗gcs[n] makes it possible to control the amount
of the state signal, retained from the previous step, and ⃗gcu[n] regulates the amount of the update signal – to be injected into
the state signal at the current step18.
16Throughout this document, the subscript “c” stands for “control”, while the subscript “d” stands for “data”.
17In discrete systems, the concept of time is only of historical significance. The proper terminology would be to use the word “adjacent” when referring to
quantities at the neighboring steps. Here, the terms “previous”, “current”, and “next” are sometimes used only for convenience purposes. The RNN systems
can be readily unrolled in the opposite direction, in which case all indices are negated and the meaning of “previous” and “next” is reversed. As a matter of
fact, improved performance has been attained with bi-directional processing in a variety of applications . Moreover, if the input data
is prepared ahead of time and is made available to the system in its entirety, then the causality restriction can be relaxed altogether. This can be feasible in
applications, where the entire training data set or a collection of independent training data segments is gathered before processing commences. Non-causal
processing (i.e., a technique characterized by taking advantage of the input data “from the future”) can be advantageous in detecting the presence of “context”
among data samples. Utilizing the information at the “future” steps as part of context for making decisions at the “current” step is often beneficial for analyzing
audio, speech, and text.
18The significance of the element-wise control of the “content” signals (here called the “data” signals) exerted by the gates in the LSTM network has been
independently recognized and researched by others .
From the derivation of the standard RNN system in Section II, Ws in Equation 96 is a diagonal matrix with positive fractions,
|aii|, on its main diagonal. Hence, since the elements of ⃗gcs[n] are also fractions, setting:
in ⃗gcs[n] ⊙Ws is acceptable as long as the gate functions are parametrizable and their parameters are learned during training.
Under these conditions, Equation 96 can be simplified to:
⃗Fs (⃗s[n −1]) = ⃗s[n −1]
so that Equation 98 becomes:
⃗s[n] = ⃗gcs[n] ⊙⃗Fs (⃗s[n −1]) + ⃗gcu[n] ⊙⃗Fu (⃗r[n −1], ⃗x[n])
= ⃗gcs[n] ⊙⃗s[n −1] + ⃗gcu[n] ⊙⃗Fu (⃗r[n −1], ⃗x[n])
Hence, the contribution from the state signal at the previous step remains fractional, insuring the stability of the overall system.
Diagrammatically, the insertion of the expanded controls from Equation 102 into the canonical RNN system of Equation 30
transforms Figure 1 into Figure 4.
While the update term, ⃗Fu (⃗r[n −1], ⃗x[n]), as a whole is now controlled by ⃗gcu[n] , the internal composition of ⃗Fu (⃗r[n −1], ⃗x[n])
itself needs to be examined. According to Equation 97, the readout signal from the previous step and the input signal at the
current step constitute the update candidate signal on every step with the index, n, with both of these terms contributing in
equal proportions. The issue with always utilizing Wr⃗r[n−1] in its entirety is that when ⃗gcu[n] ∼1, ⃗s[n−1] and ⃗s[n] become
connected through Wr and the warping function. Based on Equation 91, this link constrains the gradient of the objective
function with respect to the state signal, thus predisposing the system to the vanishing/exploding gradients problem. To throttle
this feedback path, the readout signal, ⃗r[n], will be apportioned by another gate signal, ⃗gcr[n] (“control readout”), as follows:
⃗v[n] = ⃗gcr[n] ⊙⃗r[n]
⃗0 ≤⃗gcr[n] ≤⃗1
The gating control, ⃗gcr[n], determines the fractional amount of the readout signal that becomes the cell’s observable value
signal at the step with the index, n. Thus, using ⃗v[n −1] in place of ⃗r[n −1] in Equation 97 transforms it into:
⃗Fu (⃗v[n −1], ⃗x[n]) = Wr⃗v[n −1] + Wx⃗x[n] + ⃗θs
The RNN cell schematic diagram, expanded to accommodate the control readout gate, introduced in Equation 103, and the
modified recurrence relationship, employed in Equation 105, appears in Figure 5.
Even though the external input does not affect the system’s stability or impact its susceptibility to vanishing/exploding gradients,
pairing the input with its own “control input” gate makes the system more flexible.
Multiplying the external input signal, ⃗x[n], in Equation 97 by a dedicated gate signal, ⃗gcx[n], turns Equation 105 into:
⃗Fu (⃗v[n −1], ⃗x[n]) = Wr⃗v[n −1] + ⃗gcx[n] ⊙Wx⃗x[n] + ⃗θs
According to Equation 103 and Equation 106, utilizing both the control readout gate, ⃗gcr[n], and the control input gate, ⃗gcx[n],
allows for the update term, ⃗Fu (⃗v[n −1], ⃗x[n]), to contain an arbitrary mix of the readout signal and the external input. The
control input gate signal, ⃗gcx[n], will be later incorporated as part of extending the Vanilla LSTM cell. For now, it is assumed
for simplicity that ⃗gcx[n] = ⃗1, so Equation 106 reduces to Equation 105.
The dynamic range of the value signal of the cell, ⃗v[n], is determined by the readout signal, ⃗r[n], which is bounded by the
warping nonlinearity, Gd(z). In order to maintain the same dynamic range while absorbing the contributions from the input
signal, ⃗x[n] (or ⃗gcx[n]⊙⃗x[n] if the control input gate is part of the system architecture), the aggregate signal, ⃗Fu (⃗v[n −1], ⃗x[n]),
is tempered by the saturating warping nonlinearity, Gd(z), so as to produce the update candidate signal, ⃗u[n]:
⃗u[n] = Gd
⃗Fu (⃗v[n −1], ⃗x[n])
Thus, replacing the update term in Equation 102 with ⃗u[n], given by Equation 107, finally yields19:
⃗s[n] = ⃗gcs[n] ⊙⃗s[n −1] + ⃗gcu[n] ⊙⃗u[n]
19Note the notation change: in the rest of the document, the symbol, ⃗u[n], has the meaning of the update candidate signal (not the vector-valued unit step
function).
The “control readout” gate, ⃗gcr[n], determines the fractional amount of the readout signal that becomes the cell’s observable value signal at the
current step.
which is a core constituent of the set of formulas defining the cell of the Vanilla LSTM network. According to Equation 108,
the state signal of the cell at the current step is a weighted combination of the state signal of the cell at the previous step and
the aggregation of historical and novel update information available at the present step. The complete data path of the Vanilla
LSTM cell, culminating from fortifying the canonical RNN system with gating controls and signal containment, is illustrated
in Figure 6.
Example 2. For an idealized illustration of the ability of the LSTM cell to propagate the error gradient unattenuated, set ⃗gcs[n]
to ⃗1 and both, ⃗gcu[n] and ⃗gcr[n], to ⃗0 for all steps in the segment. Then ⃗s[n] = ⃗s[n −1] and ⃗ψ[n] = ⃗ψ[n + 1] for all steps in
the segment. The inventors of the LSTM network named this mode the “Constant Error Carousel” (CEC) to underscore that
the error gradient is recirculated and the state signal of the cell is refreshed on every step20. Essentially, the multiplicative gate
units open and close access to constant error gradient flow through CEC as part of the operation of the LSTM cell21 .
In Section IV, we saw that the error gradient determines the parameter updates for training the standard RNN by Gradient
Descent. It will become apparent in Section VI-I that the same relationship holds for the Vanilla LSTM network as well.
The difference is that because of the gates, the function for the error gradient of the LSTM network accommodates Gradient
Descent better than that of the standard RNN does. As will be shown in Section VI-J, under certain provisions regarding
the model parameters, the unrolled Vanilla LSTM cell operates in the CEC mode. If such a parameter combination emerges
during training, then the parameter update information, embedded in the error gradient signal, will be back-propagated over a
large number of steps of a training subsequence, imparting sensitivity to the long-range dependencies to the model parameters
through the parameter update step of Gradient Descent. If the training process steers the model parameters toward causing
∥⃗gcs[n]∥= 1 (as in Example 2), then the LSTM network circumvents the vanishing gradient problem in this asymptotic case.
20However, the design of the LSTM network does not address explicitly the exploding gradients problem. During training, the derivatives can still become
excessively large, leading to numerical problems. To prevent this, all derivatives of the objective function with respect to the state signal are renormalized to
lie within a predefined range .
21Because of the access control functionality provided by the gates, the LSTM cell is sometimes interpreted as a differentiable version of the digital static
random access memory cell .
Fig. 6. In the Vanilla LSTM network, the state signal of the cell at the current step is a weighted combination of the state signal of the cell at the previous
step and the aggregation of historical and novel update information available at the present step.
Analogously to the standard RNN, the Vanilla LSTM network, trained by Gradient Descent, can also learn the short-range
dependencies among the samples of the subsequences, comprising the training data. Suppose that during training the model
parameters cause ∥⃗gcs[n]∥< 1 (unlike in Example 2). Then, as will be elaborated in Section VI-J, the error gradient signal
will decline, eventually vanishing over a finite number of steps, even if during training ∥⃗gcu[n]∥> 0 and/or ∥⃗gcr[n]∥> 0 so as
to admit (by Equation 108) the contributions from the update candidate signal, ⃗u[n], into the composition of the state signal.
It remains to define the expressions for the gate signals, ⃗gcs[n], ⃗gcr[n], and ⃗gcu[n]. Assuming that the system will be trained
with BPTT, all of its constituent functions, including the functions for the gate signals, must be differentiable. A convenient
function that is continuous, differentiable, monotonically increasing, and maps the domain (−∞, ∞) into the range (0, 1) is
the logistic function:
Gc(z) ≡σ(z) ≡
= 1 + tanh( z
= 1 + Gd( z
which is a shifted, scaled, and re-parameterized replica of the hyperbolic tangent, used as the warping function, Gd(z), for the
data signals in RNN and LSTM systems. When operating on vector arguments, Gc(⃗z) is computed by applying Equation 109
to each element of the vector, ⃗z, separately; the same rule applies to Gd(⃗z).
In order to determine the fractional values of the control signals, ⃗gcs[n], ⃗gcu[n], and ⃗gcr[n], at the step with the index, n, all
the data signals, from as close as possible to the index of the current step, are utilized. Specifically, for both, ⃗gcs[n], which
determines the fraction of the state signal, ⃗s[n −1], from the previous step and ⃗gcu[n], which determines the fraction of the
update candidate signal, ⃗u[n], from the current step, the available data signals are ⃗s[n −1], ⃗v[n −1], and ⃗x[n]. However, note
that for ⃗gcr[n], which determines the fraction of the readout signal, ⃗r[n], from the current step, the available data signals are
⃗s[n], ⃗v[n−1], and ⃗x[n]. This is because by Equation 103, ⃗r[n] is available at the junction of the cell, where ⃗gcr[n] is computed,
and hence, by Equation 95, ⃗s[n] is necessarily available. The input to each gate is presented as a linear combination of all the
data signals available to it:
⃗zcs[n] = Wxcs⃗x[n] + Wscs⃗s[n −1] + Wvcs⃗v[n −1] + ⃗θcs
⃗zcu[n] = Wxcu⃗x[n] + Wscu⃗s[n −1] + Wvcu⃗v[n −1] + ⃗θcu
⃗zcr[n] = Wxcr⃗x[n] + Wscr⃗s[n] + Wvcr⃗v[n −1] + ⃗θcr
Accumulating the available data signals linearly makes the application of the chain rule for BPTT straightforward, while
providing a rich representation of the system’s data as an input to each gate at every step. As the model parameters,
Wxcr, Wxcu, Wxcs, Wscs, Wvcs, ⃗θcs, Wscu, Wvcu, ⃗θcu, Wscr, Wvcr, ⃗θcr
, in Equation 112, Equation 113, and Equation 114
are being trained, the gate functions, given by:
⃗gcs[n] = Gc(⃗zcs[n])
⃗gcu[n] = Gc(⃗zcu[n])
⃗gcr[n] = Gc(⃗zcr[n])
become attuned to the flow of and the variations in the training data through the system at every step. During inference, this
enables the gates to modulate their corresponding data signals adaptively, utilizing all the available information at every step.
In particular, the gates help to detect and mitigate the detrimental ramifications of artificial boundaries, which arise in the input
sequences, due to the implicit truncation, caused by unrolling . The gates make the LSTM system a robust model
that compensates for the imperfections in the external data and is capable of generating high quality output sequences.
This concludes the derivation of the Vanilla LSTM network. The next section presents a formal self-contained summary of the
Vanilla LSTM system, including the equations for training it using BPTT.
VI. THE VANILLA LSTM NETWORK MECHANISM IN DETAIL
A. Overview
Suppose that an LSTM cell is unrolled for K steps. The LSTM cell at the step with the index, n (in the sequence of K steps),
accepts the input signal, ⃗x[n], and computes the externally-accessible (i.e., observable) signal, ⃗v[n]. The internal state signal of
the cell at the step with the index, n, is maintained in ⃗s[n], which is normally not observable by entities external to the cell22.
However, the computations, associated with the cell at the next adjacent step in the increasing order of the index, n (i.e., the
LSTM step at the index, n + 1), are allowed to access ⃗s[n], the state signal of the LSTM cell at the step with the index, n.
The key principle of the LSTM cell centers around organizing its internal operations according to two qualitatively different,
yet cooperating, objectives: data and the control of data. The data components prepare the candidate data signals (ranging
between −1 and 1), while the control components prepare the “throttle” signals (ranging between 0 and 1). Multiplying the
candidate data signal by the control signal apportions the fractional amount of the candidate data that is allowed to propagate
to its intended nodes in the cell. Hence, if the control signal is 0, then 0% of the candidate data amount will propagate.
Conversely, if the control signal is 1, then 100% of the candidate data amount will propagate. Analogously, for intermediate
values of the control signal (in the range between 0 and 1), the corresponding percentage of the candidate data amount will
be made available to the next function in the cell.
As depicted in Figure 7, the Vanilla LSTM cell contains three candidate-data/control stages: update, state, and readout.
22In certain advanced RNN and LSTM configurations, such as Attention Networks, the state signal is externally observable and serves as an important
component of the objective function.
B. Notation
The following notation is used consistently throughout this section to define the Vanilla LSTM cell:
• n – index of a step in the segment (or subsequence); n = 0, . . . , K −1
• K – number of steps in the unrolled segment (or subsequence)
• Gc – monotonic, bipolarly-saturating warping function for control/throttling purposes (acts as a “gate”)
• Gd – monotonic, negative-symmetric, bipolarly-saturating warping function for data bounding purposes
• dx – dimensionality of the input signal to the cell
• ds – dimensionality of the state signal of the cell
• ⃗x ∈Rdx – the input signal to the cell
• ⃗s ∈Rds – the state signal of the cell
• ⃗v ∈Rds – the observable value signal of the cell for external purposes (e.g., for connecting one step to the next adjacent
step of the same cell in the increasing order of the step index, n; as input to another cell in the cascade of cells; for
connecting to the signal transformation filter for data output; etc.)
• ⃗a ∈Rds – an accumulation node of the cell (linearly combines the signals from the preceding step and the present
step as net input to a warping function at the present step; each cell contains several purpose-specific control and data
accumulation nodes)
• ⃗u ∈Rds – the update candidate signal for the state signal of the cell
• ⃗r ∈Rds – the readout candidate signal of the cell
• g ∈Rds – a gate output signal of the cell for control/throttling purposes
• E ∈R – objective (cost) function to be minimized as part of the model training procedure
• ⃗xT⃗v – vector-vector inner product (yields a scalar)
• ⃗x⃗vT – vector-vector outer product (yields a matrix)
• W⃗v – matrix-vector product (yields a vector)
• ⃗x ⊙⃗v – element-wise vector product (yields a vector)
C. Control/Throttling (“Gate”) Nodes
The Vanilla LSTM cell uses three gate types:
• control of the fractional amount of the update candidate signal used to comprise the state signal of the cell at the present
step with the index, n
• control of the fractional amount of the state signal of the cell at the adjacent lower-indexed step, n −1, used to comprise
the state signal of the cell at the present step with the index, n
• control of the fractional amount of the readout candidate signal used to release as the externally-accessible (observable)
signal of the cell at the present step with the index, n
D. Data Set Standardization
Before the operation of the LSTM network (or its parent, RNN) can commence, the external training data set, ⃗x0[n], needs to
be standardized, such that all elements of the input to the network, ⃗x[n], have the mean of 0 and the standard deviation of 1
over the training set:
(⃗x0[n] −⃗µ) (⃗x0[n] −⃗µ)T
(⃗x0[n] −⃗µ)
Applying the transformations in Equation 118, Equation 119, and Equation 120 to the external training samples, ⃗x0[n],
accomplishes this task. In these equations, N is the number of samples in the training set, ⃗µ is the sample mean, and V
is the sample auto-covariance matrix of the training set23.
23The test and validation sets should be standardized with the mean and standard deviation of the training set .
E. Warping (Activation) Functions
As described in Section VI-A, the warping function for control needs to output a value between 0 and 1. The sigmoidal (also
known as “logistic”) nonlinearity is a good choice, because it is bipolarly-saturating between these values and is monotonic,
continuous, and differentiable:
Gc(z) ≡σ(z) ≡
1 + e−z = 1 + tanh( z
= 1 + Gd( z
Related to this function, the hyperbolic tangent is a suitable choice for the warping function for data bounding purposes:
Gd(z) ≡tanh(z) = ez −e−z
ez + e−z = 2σ(2z) −1 = 2Gc(2z) −1
because it is monotonic, negative-symmetric, and bipolarly-saturating at −1 and 1 (i.e., one standard deviation of ⃗x[n] in each
direction). This insures that the data warping function, Gd(z), will support both negative and positive values of the standardized
incoming data signal, ⃗x[n], in Equation 120, and keep it bounded within that range (the “squashing” property).
F. Vanilla LSTM Cell Model Parameters
The Vanilla LSTM cell model uses the following fifteen (15) parameter entities (with their respective dimensions and
designations as indicated below):
1) Parameters of the accumulation node, ⃗acu[n], of the gate that controls the fractional amount of the update candidate signal,
⃗u[n], used to comprise the state signal of the cell at the present step with the index, n:
• Wxcu ∈Rds×dx – the matrix of weights connecting the input signal, ⃗x[n], at the present step with the index, n, to the
“control update” accumulation node, ⃗acu[n], of the cell at the present step with the index, n
• Wscu∈Rds×ds – the matrix of weights connecting the state signal, ⃗s[n −1], at the adjacent lower-indexed step with the
index, n −1, to the “control update” accumulation node, ⃗acu[n], of the cell at the present step with the index, n
• Wvcu∈Rds×ds – the matrix of weights connecting the externally-accessible (observable) value signal, ⃗v[n −1], at the
adjacent lower-indexed step with the index, n −1, to the “control update” accumulation node, ⃗acu[n], of the cell at the
present step with the index, n
• ⃗bcu ∈Rds – the vector of bias elements for the “control update” accumulation node, ⃗acu[n], of the cell at the present step
with the index, n
2) Parameters of the accumulation node, ⃗acs[n], of the gate that controls the fractional amount of the state signal of the cell,
⃗s[n −1], at the adjacent lower-indexed step, n −1, used to comprise the state signal of the cell at the present step with the
• Wxcs ∈Rds×dx – the matrix of weights connecting the input signal, ⃗x[n], at the present step with the index, n, to the
“control state” accumulation node, ⃗acs[n], of the cell at the present step with the index, n
• Wscs∈Rds×ds – the matrix of weights connecting the state signal, ⃗s[n −1], at the adjacent lower-indexed step with the
index, n −1, to the “control state” accumulation node, ⃗acs[n], of the cell at the present step with the index, n
• Wvcs∈Rds×ds – the matrix of weights connecting the externally-accessible (observable) value signal, ⃗v[n −1], at the
adjacent lower-indexed step with the index, n −1, to the “control state” accumulation node, ⃗acs[n], of the cell at the
present step with the index, n
• ⃗bcs ∈Rds – the vector of bias elements for the “control state” accumulation node, ⃗acs[n], of the cell at the present step
with the index, n
3) Parameters of the accumulation node, ⃗acr[n], of the gate that controls the fractional amount of the readout candidate signal,
⃗r[n], used to release as the externally-accessible (observable) value signal of the cell at the present step with the index, n:
• Wxcr ∈Rds×dx – the matrix of weights connecting the input signal, ⃗x[n], at the present step with the index, n, to the
“control readout” accumulation node, ⃗acr[n], of the cell at the present step with the index, n
• Wscr∈Rds×ds – the matrix of weights connecting the state signal, ⃗s[n], at the present step with the index, n, to the
“control readout” accumulation node, ⃗acr[n], of the cell at the present step with the index, n
• Wvcr∈Rds×ds – the matrix of weights connecting the externally-accessible (observable) value signal, ⃗v[n −1], at the
adjacent lower-indexed step with the index, n −1, to the “control readout” accumulation node, ⃗acr[n], of the cell at the
present step with the index, n
• ⃗bcr ∈Rds – the vector of bias elements for the “control readout” accumulation node, ⃗acr[n], of the cell at the present
step with the index, n
4) Parameters of the accumulation node, ⃗adu[n], for the data warping function that produces the update candidate signal,
⃗u[n], of the cell at the present step with the index, n:
• Wxdu ∈Rds×dx – the matrix of weights connecting the input signal, ⃗x[n], at the present step with the index, n, to the
“data update” accumulation node, ⃗adu[n], of the cell at the present step with the index, n
• Wvdu∈Rds×ds – the matrix of weights connecting the externally-accessible (observable) value signal, ⃗v[n −1], at the
adjacent lower-indexed step with the index, n −1, to the “data update” accumulation node, ⃗adu[n], of the cell at the
present step with the index, n
• ⃗bdu ∈Rds – the vector of bias elements for the “data update” accumulation node, ⃗adu[n], of the cell at the present step
with the index, n
5) All model parameters, which must be learned, combined (for notational convenience):
• All parameters of the LSTM network are commonly concatenated and represented as a whole by Θ:
Wxcu, Wscu, Wvcu,⃗bcu, Wxcs, Wscs, Wvcs,⃗bcs, Wxcr, Wscr, Wvcr,⃗bcrWxdu, Wvdu,⃗bdu
• Arranged “thematically” (attributed by the type of an accumulation), Θ can be written as:
G. Summary of the main entities (generalized)
The following glossary lists the main entities of the model in a generalized way (i.e., without the subscripts, indices, etc.).
Note that the special quantities ⃗ψ,⃗χ, ⃗α, ⃗ρ,⃗γ will be defined in Section VI-I.
⃗s,⃗v,⃗a, ⃗u,⃗r,⃗g ∈Rds
⃗ψ, ⃗χ, ⃗α, ⃗ρ,⃗γ ∈Rds
Wx ∈Rds×dx
Ws, Wv ∈Rds×ds
n = 0, . . . , K −1
H. Vanilla LSTM System Equations (“Forward Pass”)
It is important to highlight the general pattern of computations that govern the processes, according to which any RNN cell,
and the LSTM network cell in particular, unrolled for K steps, generates sequences of samples. Namely, the quantities that
characterize the step of the cell at the index, n, of the sequence depend on the quantities that characterize the step of the cell
at the index, n −1, of the sequence24. The following equations fully define the Vanilla LSTM cell:
⃗acu[n] = Wxcu⃗x[n] + Wscu⃗s[n −1] + Wvcu⃗v[n −1] +⃗bcu
⃗acs[n] = Wxcs⃗x[n] + Wscs⃗s[n −1] + Wvcs⃗v[n −1] +⃗bcs
⃗acr[n] = Wxcr⃗x[n] + Wscr⃗s[n] + Wvcr⃗v[n −1] +⃗bcr
⃗adu[n] = Wxdu⃗x[n] + Wvdu⃗v[n −1] +⃗bdu
⃗u[n] = Gd(⃗adu[n])
⃗gcu[n] = Gc(⃗acu[n])
⃗gcs[n] = Gc(⃗acs[n])
⃗gcr[n] = Gc(⃗acr[n])
⃗s[n] = ⃗gcs[n] ⊙⃗s[n −1] + ⃗gcu[n] ⊙⃗u[n]
⃗r[n] = Gd(⃗s[n])
⃗v[n] = ⃗gcr[n] ⊙⃗r[n]
The schematic diagram of the Vanilla LSTM cell, defined by Equations 126 – 136, is presented in Figure 7, and the snapshot
of unrolling it (for only 4 steps as an illustration) appears in Figure 8. In order to make it easier to isolate the specific functions
performed by the components of the Vanilla LSTM cell, its schematic diagram is redrawn in Figure 9, with the major stages
comprising the cell’s architecture marked by dashed rectangles annotated by the names of the respective enclosed stages.
Fig. 7. Vanilla LSTM network cell. The bias parameters, ⃗b, have been omitted from the figure for brevity. They can be assumed to be included without the
loss of generality by appending an additional element, always set to 1, to the input signal vector, ⃗x[n], and increasing the row dimensions of all corresponding
weight matrices by 1.
24If the cell is unrolled in the opposite direction, then n−1 is replaced by n+1, and the direction of evaluating the steps is reversed. For the bi-directional
unrolling, the steps in both the positive and the negative directions of the index, n, need to be evaluated . Here, only the positive direction is considered.
Fig. 8. Sequence of steps generated by unrolling a cell of the LSTM network (displaying 4 steps for illustration).
Fig. 9. Vanilla LSTM network cell from Figure 7, with the stages of the system delineated by dashed rectangles and annotations that depict the function
of each stage. As before, the bias parameters, ⃗b, have been omitted from the figure for brevity. (They can be assumed to be included without the loss of
generality by appending an additional element, always set to 1, to the input signal vector, ⃗x[n], and increasing the row dimensions of all corresponding weight
matrices by 1.)
I. Vanilla LSTM System Derivatives (“Backward Pass”)
This section derives the equations that are necessary for training the Vanilla LSTM network cell, unrolled for K steps, using
Back Propagation Through Time (BPTT). To obtain the update equations for the parameters of the system, two auxiliary
“backward-moving” gradient sequences, indexed by n, are computed first: ⃗χ[n], the total partial derivative of the objective
function, E, with respect to the externally-accessible (observable) value signal, ⃗v[n], and ⃗ψ[n], the total partial derivative of
the objective function, E, with respect to the state signal, ⃗s[n]. The decision to “anchor” the chain rule at the border of the cell
is made judiciously, guided by the principles of modular design. Expressing every intra-cell total partial derivative in terms of
⃗χ[n] (instead of explicitly computing the total partial derivative of the objective function, E, with respect to each variable of
the cell ) reduces the number of intermediate variables. This makes the equations for the backward pass straightforward
and a natural fit for an implementation as a pluggable module .
Due to the backward-moving recursion of ⃗χ[n] and ⃗ψ[n] (the gradient sequences propagate in the direction opposite to that of
the state signal, ⃗s[n], as a function of the step index, n), the values of ⃗χ[n] and ⃗ψ[n] at the index, n, depend on the values
of the same quantities at the index, n + 1, subject to the initial conditions. Once ⃗χ[n] and ⃗ψ[n] are known, they are used to
compute the total partial derivatives of the objective function, E, with respect to the accumulation nodes for each value of the
index, n. These intermediate gradient sequences, named ⃗αcs[n], ⃗αcu[n], ⃗αcr[n], and ⃗αdu[n], allocate the amounts contributed
by the signals associated with the step at the index, n, to the total partial derivatives of the objective function, E, with respect
to the model parameters. By the definition of the total derivative, these contributions have to be summed across all steps,
0 ≤n ≤K −1, to produce the total partial derivatives of the objective function, E, with respect to the model parameters.
During the inference phase of the LSTM system, only ⃗x[n] (the input signal) and ⃗v[n] (the value signal) are externally
accessible (i.e., observable). The cell accepts the input signal at each step and computes the value signal for all steps. All the
other intermediate signals are available only to the internal components and nodes of the cell, with the exception of ⃗s[n] (state
signal) and ⃗v[n] (value signal), which serve both the inter- and the intra-step purposes throughout the unrolled sequence.
The cell’s value signal, ⃗v[n], at the step with the index, n, can be further transformed to produce the output signal, ⃗y[n] (e.g.,
a commonly used form of ⃗y[n] may be obtained by computing a linear transformation of ⃗v[n], followed by a softmax operator,
or a different decision function). Likewise, the input signal, too, may result from the transformation of the original raw data.
For example, one kind of input pre-processing can convert the vocabulary “one-hot” vector into a more compact representation.
Also, for applications where the input data set can be collected for the entire segment at once, input samples that lie within a
small window surrounding the given step can be combined so as to enhance the system’s “attention” to context. A non-causal
input filter, designed for this purpose, will be introduced in Section VII-A as part of extending the Vanilla LSTM cell.
We start by computing the derivatives of the warping functions from their definitions in Equation 121 and Equation 122,
respectively:
= Gc(z)(1 −Gc(z))
= 1 −(Gd(z))2
Next, we anchor the chain rule at the border of the cell by defining ⃗χ[n] as the total partial derivative of the objective function,
E, with respect to the externally-accessible (observable) value signal, ⃗v[n], as follows:
⃗χ[n] ≡⃗∇⃗v[n]E =
As will become imminently evident, having ⃗χ[n] not only makes training equations for the Vanilla LSTM cell amenable for
a modular implementation at the step level, but also greatly simplifies them.
We also define the total partial derivatives of the objective function, E, with respect to three intermediate (i.e., away from the
border) variables and another border variable of the Vanilla LSTM cell:
⃗ρ[n] ≡⃗∇⃗r[n]E =
⃗γ[n] ≡⃗∇⃗g[n]E =
⃗α[n] ≡⃗∇⃗a[n]E =
⃗ψ[n] ≡⃗∇⃗s[n]E =
The border quantity in Equation 143, ⃗ψ[n], is of special significance as it is the total partial derivative of the objective function,
E, with respect to the state signal, ⃗s[n], at the index, n, of the Vanilla LSTM cell. As in the standard RNN, all parameter
updates in the Vanilla LSTM network depend on ⃗ψ[n], making it the most important error gradient sequence of the system.
The backward pass equations are obtained by utilizing these border and intermediate derivatives in the application of the chain
rule to the Vanilla LSTM cell, defined by Equations 126 – 136:
+ ⃗fχ[n + 1]
= ⃗(∇⃗v[n]E) ⊙⃗gcr[n] = ⃗χ[n] ⊙⃗gcr[n]
∂⃗gcr[n] = ⃗(∇⃗v[n]E) ⊙⃗r[n] = ⃗χ[n] ⊙⃗r[n]
⃗αcr[n] = ⃗γcr[n] ⊙∂⃗gcr[n]
∂⃗acr[n] = ⃗γcr[n] ⊙dGc(z)
⌋z=⃗acr[n] = ⃗χ[n] ⊙⃗r[n] ⊙dGc(z)
⌋z=⃗acr[n]
⃗ψ[n] = ⃗ρ[n] ⊙∂⃗r[n]
∂⃗s[n] + ∂⃗acr[n]
∂⃗s[n] ⃗αcr[n] + ⃗fψ[n + 1]
= ⃗ρ[n] ⊙dGd(⃗z)
⌋z=⃗s[n] + Wscr⃗αcr[n] + ⃗fψ[n + 1]
= ⃗χ[n] ⊙⃗gcr[n] ⊙dGd(⃗z)
⌋z=⃗s[n] + Wscr⃗αcr[n] + ⃗fψ[n + 1]
⃗αcs[n] = ⃗ψ[n] ⊙∂⃗s[n]
∂⃗gcs[n] ⊙∂⃗gcs[n]
∂⃗acs[n] = ⃗ψ[n] ⊙⃗s[n −1] ⊙dGc(⃗z)
⌋z=⃗acs[n]
⃗αcu[n] = ⃗ψ[n] ⊙∂⃗s[n]
∂⃗gcu[n] ⊙∂⃗gcu[n]
∂⃗acu[n] = ⃗ψ[n] ⊙⃗u[n] ⊙dGc(⃗z)
⌋z=⃗acu[n]
⃗αdu[n] = ⃗ψ[n] ⊙∂⃗s[n]
∂⃗u[n] ⊙dGd(⃗z)
⌋z=⃗adu[n] = ⃗ψ[n] ⊙⃗gcu[n] ⊙dGd(⃗z)
⌋z=⃗adu[n]
⃗fχ[n + 1] = W T
vcu⃗αcu[n + 1] + W T
vcs⃗αcs[n + 1] + W T
vcr⃗αcr[n + 1] + W T
vdu⃗αdu[n + 1]
⃗fψ[n + 1] = W T
scu⃗αcu[n + 1] + W T
scs⃗αcs[n + 1] + ⃗gcs[n + 1] ⊙⃗ψ[n + 1]
are the portions of the total derivative of the objective function, E, with respect to the cell’s value signal and the cell’s state
signal, respectively, contributed by the quantities evaluated at the step with the index, n + 1.
The total partial derivatives of the objective function, E, with respect to the model parameters at the step with the index, n,
are directly proportional to the “accumulation derivatives”25, given by Equation 147, Equation 151, Equation 152, and
25As noted in Section V, during training, the total derivatives of the objective function, E, with respect to the cell’s accumulation signals (“accumulation
derivatives”) can become excessively large. In order to prevent these kinds of numerical problems, all accumulation derivatives are clipped to lie between −1
and 1, a range that is suitable for the particular choices of the control and data warping functions .
Equation 153. Hence, by referring once again to the definition of the Vanilla LSTM cell in Equations 126 – 136, we obtain:
[n] = ⃗αcu[n]⃗xT [n]
[n] = ⃗αcu[n]⃗sT [n −1]
[n] = ⃗αcu[n]⃗vT [n −1]
[n] = ⃗αcu[n]
[n] = ⃗αcs[n]⃗xT [n]
[n] = ⃗αcs[n]⃗sT [n −1]
[n] = ⃗αcs[n]⃗vT [n −1]
[n] = ⃗αcs[n]
[n] = ⃗αcr[n]⃗xT [n]
[n] = ⃗αcr[n]⃗sT [n]
[n] = ⃗αcr[n]⃗vT [n −1]
[n] = ⃗αcr[n]
[n] = ⃗αdu[n]⃗xT [n]
[n] = ⃗αdu[n]⃗vT [n −1]
[n] = ⃗αdu[n]
Arranged congruently with Equation 124, the total partial derivative of the objective function, E, with respect to the model
parameters, Θ, at the step with the index, n, is:
∂Wxcu [n],
∂Wscu [n],
∂Wvcu [n],
∂⃗bcu [n],
∂Wxcs [n],
∂Wscs [n],
∂Wvcs [n],
∂⃗bcs [n],
∂Wxcr [n],
∂Wscr [n],
∂Wvcr [n],
∂⃗bcr [n],
∂Wxdu [n],
∂Wvdu [n],
When the Vanilla LSTM cell is unrolled for K steps in order to cover one full segment of training samples, the same set of
the model parameters, Θ, is shared by all the steps. This is because Θ is the parameter of the Vanilla LSTM cell as a whole.
Consequently, the total derivative of the objective function, E, with respect to the model parameters, Θ, has to include the
contributions from all steps of the unrolled sequence:
The result from Equation 172 can now be used as part of optimization by Gradient Descent. In practice, Equation 172 is
computed for a batch of segments26, and the sum of the parameter gradients over all segments in the batch is then supplied
to the Gradient Descent algorithm for updating the model parameters27.
26Depending on the application, the batch sizes typically range between 16 and 128 segments.
27Regularization, while outside of the scope of the present article, is an essential aspect of machine learning model training process .
J. Error Gradient Sequences in Vanilla LSTM System
Section V mentions that because of the action of the gates, the LSTM network is more compatible with the Gradient Descent
training procedure than the standard RNN system is. As discussed in Section IV and Section VI-I, for Gradient Descent to
be effective, the elements of ∂E
∂Θ[n] in Equation 171 must be well-behaved numerically. In particular, this implies that the
intermediate gradient sequences, ⃗αcs[n], ⃗αcu[n], ⃗αcr[n], and ⃗αdu[n], and hence the border gradient sequences, ⃗χ[n] and ⃗ψ[n],
must be able to sustain a steady flow of information over long ranges of the step index, n. Expanding Equation 150 produces:
⃗ψ[n] = ⃗χ[n] ⊙⃗gcr[n] ⊙dGd(⃗z)
⌋z=⃗s[n] + Wscr ⃗χ[n] ⊙⃗r[n] ⊙dGc(z)
⌋z=⃗acr[n] + ⃗fψ[n + 1]
+ ⃗fχ[n + 1]
⊙⃗gcr[n] ⊙dGd(⃗z)
+ ⃗fχ[n + 1]
⊙⃗r[n] ⊙dGc(z)
⌋z=⃗acr[n] + ⃗fψ[n + 1]
According to Equation 154 and Equation 155, both ⃗χ[n] and ⃗ψ[n] depend on ⃗ψ[n + 1]. Hence, we can follow the approach in
Section IV to analyze the dependence of ⃗ψ[n] on
⌋n<k≤K−1 in order to gauge the sensitivity of the LSTM system to
factors conducive to gradient decay. Applying the change of indices, n −→k −1, and the chain rule to Equation 174 yields28:
⃗gcr[k −1] ⊙dGd(⃗z)
⌋z=⃗s[k−1]
+ Wscrdiag
⃗r[k −1] ⊙dGc(z)
⌋z=⃗acr[k−1]
⃗u[k] ⊙dGc(⃗z)
⌋z=⃗acu[k]
+ Wvcsdiag
⃗s[k −1] ⊙dGc(⃗z)
⌋z=⃗acs[k]
⃗gcu[k] ⊙dGd(⃗z)
⌋z=⃗adu[k]
⃗u[k] ⊙dGc(⃗z)
⌋z=⃗acu[k]
⃗s[k −1] ⊙dGc(⃗z)
⌋z=⃗acs[k]
⃗u[k] ⊙dGc(⃗z)
⌋z=⃗acu[k]
⃗gcr[k −1] ⊙dGd(⃗z)
⌋z=⃗s[k−1]
+ Wscrdiag
⃗r[k −1] ⊙dGc(z)
⌋z=⃗acr[k−1]
⃗s[k −1] ⊙dGc(⃗z)
⌋z=⃗acs[k]
⃗gcr[k −1] ⊙dGd(⃗z)
⌋z=⃗s[k−1]
+ Wscrdiag
⃗r[k −1] ⊙dGc(z)
⌋z=⃗acr[k−1]
⃗gcu[k] ⊙dGd(⃗z)
⌋z=⃗adu[k]
⃗gcr[k −1] ⊙dGd(⃗z)
⌋z=⃗s[k−1]
+ Wscrdiag
⃗r[k −1] ⊙dGc(z)
⌋z=⃗acr[k−1]
k −1, k; ˜Θ
28The notation, diag
, represents a diagonal matrix, in which the elements of the vector, ⃗z, occupy the main diagonal.
where ˜Θ = {Wscu, Wvcu, Wscs, Wvcs, Wscr, Wvdu}, and Q
k −1, k; ˜Θ
subsumes all the terms in ∂⃗ψ[k−1]
∂⃗ψ[k] , excluding diag
Extrapolating ∂⃗ψ[k−1]
from the step with the index, n, to the step with the index, l ≤K −1, where l ≫n, gives:
Assuming that the issue of “exploding gradients” is handled as a separate undertaking, the present focus is on the effectiveness
of the LSTM network at assuaging the “vanishing gradients” problem. If the value of the total partial derivative of the objective
function, E, with respect to the state signal, ⃗s[l], at the index, l ≤K −1, where l ≫n, is considered to be an impulse of the
error gradient, then Equation 180 computes the fractional amount of this corrective stimulus that did not dissipate across the
large number (l −n) of steps and is preserved in ⃗ψ[n], thereby able to contribute to updating the model parameters.
The propensity of the LSTM system toward diminishing error gradients during training can be assessed by evaluating the
different modes of Equation 179 that can cause
≈0 in Equation 180 when l −n is large. A sufficient condition for
driving the residual
to zero is maintaining
< 1 at each step with the index, k. There are three possibilities
for this outcome:
k −1, k; ˜Θ
and ⃗gcs[k] = ⃗0 for all values of the step index, k. This is the case of the network being perpetually
“at rest” (i.e., in a trivial state), which is not interesting from the practical standpoint.
• ⃗gcs[k] ≈⃗1 and Q
k −1, k; ˜Θ
; in other words, Q
k −1, k; ˜Θ
“cancel each other
out” for some value of the step index, k. However, satisfying this condition would require a very careful orchestration of
all signals, which is highly unlikely to occur in practice, making this pathological case unrealistic.
• The spectral radius of
k −1, k; ˜Θ
in Equation 179 is less than unity for all values of the step
index, k. In this situation, the error gradient will degrade to negligible levels after a sufficiently large number of steps.
Nevertheless, this behavior would not be due to a degenerate mode of the system, but as a consequence of the particular
patterns, occurring in the training data. In other words, some dependencies are naturally short-range.
For all remaining cases, the magnitude of ∂⃗ψ[k−1]
is governed by the triangle inequality:
k −1, k; ˜Θ
The most emblematic regime of the LSTM network arises when
k −1, k; ˜Θ
< 1. Examining the terms in
Equation 178 exposes multiple ways of restricting signals and parameters that would create favorable circumstances for this
to hold. The following list prescribes several plausible alternatives (all conditions in each arrangement must be satisfied)29:
• ∥Wscu∥< 1
2, ∥Wvcu∥< 1
2, ∥Wscs∥< 1
2, ∥Wvcs∥< 1
2, ∥Wvdu∥< 1
• the state signal saturates the readout data warping function, ∥Wscr∥< 1
2, ∥Wscu∥< 1
2, ∥Wscs∥< 1
• the state signal saturates the readout data warping function, the accumulation signal for the control readout gate saturates
its control warping function, ∥Wscu∥< 1
2, ∥Wscs∥< 1
• the control readout gate is turned off, ∥Wscu∥< 1
2, ∥Wscs∥< 1
• the accumulation signals for the control update gate and the control state gate saturate their respective control warping
functions, the update candidate accumulation signal saturates the update candidate data warping function
• the control update gate is turned off, the control state gate is turned off
Since the difference between the step indices, l −n, is large when the network is trained to represent long-range dependencies,
the powers of the Q
k −1, k; ˜Θ
terms become negligible, ultimately leading to:
k −1, k; ˜Θ
in Equation 179 has no attenuating factors (the multiplier of ⃗gcs[n + 1] ⊙⃗ψ[n + 1] in
Equation 155 is the identity matrix). As long as the elements of ⃗gcs[n] are fractions, the error gradient will naturally decay.
However, if the model is trained to saturate ⃗gcs[n] at ⃗1, then the error gradient is recirculated through Constant Error Carousel.
29Note that all data signals in Equation 178 (⃗u, ⃗s, and ⃗r) have the dynamic range of 2, because they are at the output node of the warping function, Gd(⃗z),
which is the hyperbolic tangent. Hence, for the respective term to have the norm of < 1, the associated parameter matrices must have the norm of < 1
VII. EXTENSIONS TO THE VANILLA LSTM NETWORK
Since its invention, many variants and extensions of the original LSTM network model have been researched and utilized
in practice. In this section, we will evolve the Vanilla LSTM architecture, derived in Section V and explained in depth in
Section VI, along three avenues. Based on the analysis in Section II as well as the discussions in Section V and Section VI-I,
we will expand the input from consisting of a single sample to combining multiple samples within a small context window.
In addition, as proposed in Section V, we will introduce a new gate for controlling this richer input signal. Besides these
two novel extensions, we will also include the “recurrent projection layer” in the augmented model, because it proved to be
advantageous in certain sequence modeling applications .
A. External Input Context Windows
We will represent the external input context windows by linear filters that have matrix-valued coefficients and operate on the
sequence of input samples along the dimension of the steps of the sequence produced by unrolling the LSTM cell. In
Equations 126 – 129, the matrix-vector products, Wxcu⃗x[n], Wxcs⃗x[n], Wxcr⃗x[n], and Wxdu⃗x[n], respectively, which involve
a single input sample, ⃗x[n], will be replaced by the convolutions of the context window filters, Wxcu[n], Wxcs[n], Wxcr[n],
and Wxdu[n], respectively, with the input signal, ⃗x[n], thereby involving all input samples within the context window in the
computation of the respective accumulation signal. We choose the context window filters to be non-causal (i.e., with the
non-zero coefficients defined only for n ≤0). This will enable the accumulation signals to utilize the input samples from the
“future” steps of the unrolled LSTM cell without excessively increasing the number of parameters to be learned, since the
input samples from the “past” steps will be already absorbed by the state signal, ⃗s[n], due to recurrence. After making these
substitutions, Equations 126 – 129 become:
⃗acu[n] = Wxcu[n] ∗⃗x[n] + Wscu⃗s[n −1] + Wvcu⃗v[n −1] +⃗bcu
⃗acs[n] = Wxcs[n] ∗⃗x[n] + Wscs⃗s[n −1] + Wvcs⃗v[n −1] +⃗bcs
⃗acr[n] = Wxcr[n] ∗⃗x[n] + Wscr⃗s[n] + Wvcr⃗v[n −1] +⃗bcr
⃗adu[n] = Wxdu[n] ∗⃗x[n] + Wvdu⃗v[n −1] +⃗bdu
To examine the convolutional terms in more detail, let every context window filter, Wx[n] (with the respective subscript), have
L non-zero matrix-valued terms. For example, if L = 4, then Wx , Wx[−1], Wx[−2], and Wx[−3] will be non-zero30.
By the definition of the discrete convolution,
Wx[n] ∗⃗x[n] =
Wx[l]⃗x[n −l] =
Wx[−l]⃗x[n + l]
In the above example, the result on the left hand side of Equation 187 for each step with the index, n, will be influenced by
the window spanning 4 input samples: ⃗x , ⃗x , ⃗x , and ⃗x .
If we redefine Wx[n] to be non-zero for n ≥0, then Equation 187 simplifies to:
Wx[n] ∗⃗x[n] =
Wx[l]⃗x[n + l]
The dependence of the left hand side of Equation 188 on the input samples from the “future” steps of the unrolled LSTM cell
is readily apparent from the expression for the convolution sum on the right hand side of Equation 188.
By taking advantage of the available input samples within a small window surrounding each step of the sequence, the system
can learn to “discern” the context in which the given step occurs. The inspiration for this “look-ahead” extension comes from
the way people sometimes find it beneficial to read forward to the end of the sentence in order to better understand a phrase
occurring in the earlier part of the sentence. It would be interesting to explore the relative trade-offs between the cost of adding
a small number of parameter matrices to Θ so as to accommodate the input context windows with the computational burden of
training a bi-directional LSTM network , and to compare the performance of the two architectures on several data sets31.
30As the members of the expanded LSTM model’s parameter set, Θ, the new matrices and bias vectors are learned during the training phase.
31The non-causal input context windows can be readily employed as part of the bi-directional RNN or LSTM network. The number of additional parameter
matrices to support input convolutions will double compared to the uni-directional case, because the samples covered by the windows are situated on the
positive side along the direction of the sequence.
B. Recurrent Projection Layer
Another modification of the Vanilla LSTM cell redefines the cell’s value signal to be the product of an additional matrix of
weights32 with the LSTM cell’s value signal from Equation 136. To insert the recurrent projection layer into the Vanilla LSTM
cell, we adjust Equation 136 as follows:
⃗q[n] = ⃗gcr[n] ⊙⃗r[n]
⃗v[n] = Wqdr⃗q[n]
where Wqdr implements the recurrent projection layer33, and the intermediate cell quantity, ⃗q[n] (which we will call the cell’s
“qualifier” signal), replaces what used to be the cell’s value signal in the Vanilla LSTM cell. The new value signal of the cell
from Equation 190 will now be used for computing the accumulation signals in Equations 183 – 186.
Let dv denote the dimensionality of the observable value signal of the cell; then ⃗v ∈Rdv and Wqdr∈Rdv×ds. The degree to
which the dimensionality reduction of the cell’s value signal can be tolerated for the given application directly contributes to
speeding up the training phase of the system. By allowing dv < ds, the matrix multipliers of all the terms involving ⃗v[n −1],
which dominate Equations 183 – 186 (or Equations 126 – 129 in the absence of the external input context windows), will
contain correspondingly fewer columns. In contrast, in the Vanilla LSTM cell as covered in Section VI (i.e., without the
recurrent projection layer), dv must equal ds, since ⃗v[n] is on the same data path as ⃗s[n], with no signal transformations along
the data path between them. Hence, the addition of the recurrent projection layer to the Vanilla LSTM cell brings about the
flexibility of trading off the representational capacity of the cell with the computational cost of learning its parameters .
C. Controlling External Input with a New Gate
Section V argues that the two components of the data update accumulation node, ⃗adu[n], in the Vanilla LSTM cell are not
treated the same way from the standpoint of control. While the readout candidate signal is throttled by the control readout
gate, ⃗gcr[n], the external input is always injected at the full 100% contribution of its signal strength. This is not as much of
an issue for the control accumulation nodes (⃗acu[n], ⃗acs[n], and ⃗acr[n]), because they influence the scaling of the data signals,
not the relative mixing of the data signals themselves. However, since the data update accumulation node, ⃗adu[n], is directly
in the path of the cell’s state signal, the ability to regulate both components of ⃗adu[n] can improve the cell’s capacity to adapt
to the nuances and fluctuations in the training data. For instance, the control readout gate, ⃗gcr[n], can diminish the effect of
the cell’s readout signal from the adjacent step in favor of making the external input signal at the given step more prominent
in the make up of the cell’s state signal. Likewise, having the additional flexibility to fine-tune the external input component
of ⃗adu[n] at the same granularity as its readout component (i.e., at the level of the individual step with the index, n) would
provide a means for training the LSTM cell to suppress interference due to noisy or spurious input samples.
As a mechanism for adjusting the contribution of the external input, Equation 106 introduced the control input gate, ⃗gcx[n],
which we will apply to the convolution term in Equation 186. Analogously to the other gates, ⃗gcx[n] is computed by taking the
warping function for control, given by Equation 121, of the accumulation signal for controlling the input, element by element.
From Section VI-F and Equation 186, the data update accumulation node, ⃗adu[n], is followed by the data warping function
that produces the update candidate signal, ⃗u[n], of the cell at the present step with the index, n. The new control input gate,
⃗gcx[n], will throttle Wxdu[n] ∗⃗x[n], the term representing the composite external input signal in Equation 186 for ⃗adu[n].
Letting ⃗ξxdu[n] ≡Wxdu[n] ∗⃗x[n], where ⃗ξxdu[n] denotes the composite external input signal for the data update accumulation
node, ⃗adu[n], this gating operation will be accomplished through the element-wise multiplication, ⃗gcx[n]⊙⃗ξxdu[n], the method
used by all the other gates to control the fractional amount of their designated data signals.
The equations for accommodating the new control input gate, ⃗gcx[n], as part of the LSTM cell design as well as the equation
for the data update accumulation node, ⃗adu[n], modified to take advantage of this new gate, are provided below:
⃗ξxcx[n] = Wxcx[n] ∗⃗x[n]
⃗acx[n] = ⃗ξxcx[n] + Wscx⃗s[n −1] + Wvcx⃗v[n −1] +⃗bcx
⃗gcx[n] = Gc(⃗acx[n])
⃗ξxdu[n] = Wxdu[n] ∗⃗x[n]
⃗adu[n] = ⃗gcx[n] ⊙⃗ξxdu[n] + Wvdu⃗v[n −1] +⃗bdu
32This new matrix of weights, to be learned as part of training, is known as the “recurrent projection layer” .
33In our nomenclature, the matrix of weights, Wqdr, links the cell’s “qualifier” signal, ⃗q[n], with the cell’s value signal, ⃗v[n], along the readout data path
of the cell.
where the additional parameters, needed to characterize the accumulation node, ⃗acx[n], of the new control input gate, ⃗gcx[n],
have the following interpretation:
• Wxcx[l] ∈Rds×dx – the matrices of weights (for 0 ≤l ≤L −1) connecting the input signal, ⃗x[n + l], at the step with
the index, n + l, to the “control input” accumulation node, ⃗acx[n], of the cell at the present step with the index, n
• Wscx∈Rds×ds – the matrix of weights connecting the state signal, ⃗s[n −1], at the adjacent lower-indexed step with the
index, n −1, to the “control input” accumulation node, ⃗acx[n], of the cell at the present step with the index, n
• Wvcx∈Rds×dv – the matrix of weights connecting the externally-accessible (observable) value signal, ⃗v[n −1], at the
adjacent lower-indexed step with the index, n −1, to the “control input” accumulation node, ⃗acx[n], of the cell at the
present step with the index, n
• ⃗bcx ∈Rds – the vector of bias elements for the “control input” accumulation node, ⃗acx[n], of the cell at the present step
with the index, n
• Wxdu[l] ∈Rds×dx – the matrices of weights (for 0 ≤l ≤L −1) connecting the input signal, ⃗x[n + l], at the step with
the index, n + l, to the “data update” accumulation node, ⃗adu[n], of the cell at the present step with the index, n
D. Augmented LSTM System Equations (“Forward Pass”)
We are now ready to assemble the equations for the Augmented LSTM system by enhancing the Vanilla LSTM network with
the new functionality, presented earlier in this section – the recurrent projection layer, the non-causal input context windows,
and the input gate:
⃗ξxcu[n] = Wxcu[n] ∗⃗x[n]
⃗acu[n] = ⃗ξxcu[n] + Wscu⃗s[n −1] + Wvcu⃗v[n −1] +⃗bcu
⃗gcu[n] = Gc(⃗acu[n])
⃗ξxcs[n] = Wxcs[n] ∗⃗x[n]
⃗acs[n] = ⃗ξxcs[n] + Wscs⃗s[n −1] + Wvcs⃗v[n −1] +⃗bcs
⃗gcs[n] = Gc(⃗acs[n])
⃗ξxcr[n] = Wxcr[n] ∗⃗x[n]
⃗acr[n] = ⃗ξxcr[n] + Wscr⃗s[n] + Wvcr⃗v[n −1] +⃗bcr
⃗gcr[n] = Gc(⃗acr[n])
⃗ξxcx[n] = Wxcx[n] ∗⃗x[n]
⃗acx[n] = ⃗ξxcx[n] + Wscx⃗s[n −1] + Wvcx⃗v[n −1] +⃗bcx
⃗gcx[n] = Gc(⃗acx[n])
⃗ξxdu[n] = Wxdu[n] ∗⃗x[n]
⃗adu[n] = ⃗gcx[n] ⊙⃗ξxdu[n] + Wvdu⃗v[n −1] +⃗bdu
⃗u[n] = Gd(⃗adu[n])
⃗s[n] = ⃗gcs[n] ⊙⃗s[n −1] + ⃗gcu[n] ⊙⃗u[n]
⃗r[n] = Gd(⃗s[n])
⃗q[n] = ⃗gcr[n] ⊙⃗r[n]
⃗v[n] = Wqdr⃗q[n]
with the dimensions of the parameters adjusted to take into account the recurrent projection layer:
Wxcu[l] ∈Rds×dx, Wscu ∈Rds×ds, Wvcu ∈Rds×dv, ⃗bcu ∈Rds,
Wxcs[l] ∈Rds×dx, Wscs ∈Rds×ds, Wvcs ∈Rds×dv, ⃗bcs ∈Rds,
Wxcr[l] ∈Rds×dx, Wscr ∈Rds×ds, Wvcr ∈Rds×dv, ⃗bcr ∈Rds,
Wxcx[l] ∈Rds×dx, Wscx ∈Rds×ds, Wvcx ∈Rds×dv, ⃗bcx ∈Rds,
Wxdu[l] ∈Rds×dx, Wvdu ∈Rds×dv, ⃗bdu ∈Rds, and Wqdr ∈Rdv×ds, where 0 ≤l ≤L −1 and dv ≤ds.
The schematic diagram of the Augmented LSTM cell appears in Figure 10.
Combining all the matrix and vector parameters of the Augmented LSTM cell, described by Equations 196 – 214, into:
completes the definition of the inference phase (forward pass) of the Augmented LSTM cell.
(a) Augmented LSTM network cell. The bias parameters, ⃗b, have been omitted from the figure for brevity. They can be assumed to be included without
the loss of generality by appending an additional element, always set to 1, to the input signal vector, ⃗x[n], and increasing the row dimensions of all
corresponding weight matrices by 1. To minimize clutter in the diagram, the context windows are shown separately in Figure 10b below).
(b) The non-causal context windows, implemented as the convolutions (along the dimension
of the sequence index, n) of the external input, ⃗x[n], with linear filters, whose coefficients
are matrix-valued. The operations in this figure compute the quantities of the form
⃗ξx[n] = Wx[n] ∗⃗x[n], corresponding to their respective subscripts.
Fig. 10. Augmented LSTM network cell system schematics.
E. Augmented LSTM System Derivatives: Backward Pass
The equations for training the Augmented LSTM cell, unrolled for K steps, using BPTT, are obtained by adopting the same
method as was used for the Vanilla LSTM cell in Section VI-I. We rely on the same border and intermediate total partial
derivatives, appearing in Equations 139 – 143, with the addition of the total partial derivative of the objective function, E,
with respect to the qualifier signal, ⃗q[n]:
⃗β[n] ≡⃗∇⃗q[n]E =
which is an intermediate total partial derivative that reflects the insertion of the projection layer into the cell’s data path.
Applying the chain rule to the Augmented LSTM cell, defined by Equations 196 – 214, and judiciously utilizing all of these
border and intermediate total partial derivatives, yields the backward pass equations for the Augmented LSTM cell:
+ ⃗fχ[n + 1]
= ⃗(∇⃗q[n]E) ⊙⃗gcr[n] = ⃗β[n] ⊙⃗gcr[n] = W T
qdr ⃗χ[n] ⊙⃗gcr[n]
∂⃗gcr[n] = ⃗(∇⃗q[n]E) ⊙⃗r[n] = ⃗β[n] ⊙⃗r[n] = W T
qdr ⃗χ[n] ⊙⃗r[n]
⃗αcr[n] = ⃗γcr[n] ⊙∂⃗gcr[n]
∂⃗acr[n] = ⃗γcr[n] ⊙dGc(z)
⌋z=⃗acr[n] = W T
qdr ⃗χ[n] ⊙⃗r[n] ⊙dGc(z)
⌋z=⃗acr[n]
⃗ψ[n] = ⃗ρ[n] ⊙∂⃗r[n]
∂⃗s[n] + ∂⃗acr[n]
∂⃗s[n] ⃗αcr[n] + ⃗fψ[n + 1]
= ⃗ρ[n] ⊙dGd(⃗z)
⌋z=⃗s[n] + Wscr⃗αcr[n] + ⃗fψ[n + 1]
qdr ⃗χ[n] ⊙⃗gcr[n] ⊙dGd(⃗z)
⌋z=⃗s[n] + Wscr⃗αcr[n] + ⃗fψ[n + 1]
⃗αcs[n] = ⃗ψ[n] ⊙∂⃗s[n]
∂⃗gcs[n] ⊙∂⃗gcs[n]
∂⃗acs[n] = ⃗ψ[n] ⊙⃗s[n −1] ⊙dGc(⃗z)
⌋z=⃗acs[n]
⃗αcu[n] = ⃗ψ[n] ⊙∂⃗s[n]
∂⃗gcu[n] ⊙∂⃗gcu[n]
∂⃗acu[n] = ⃗ψ[n] ⊙⃗u[n] ⊙dGc(⃗z)
⌋z=⃗acu[n]
⃗αdu[n] = ⃗ψ[n] ⊙∂⃗s[n]
∂⃗u[n] ⊙dGd(⃗z)
⌋z=⃗adu[n] = ⃗ψ[n] ⊙⃗gcu[n] ⊙dGd(⃗z)
⌋z=⃗adu[n]
⃗γcx[n] = ⃗αdu[n] ∂⃗u[n]
∂⃗gcx[n] = ⃗αdu[n] ⊙⃗ξxdu[n]
⃗αcx[n] = ⃗γcx[n] ⊙∂⃗gcx[n]
∂⃗acx[n] = ⃗γcx[n] ⊙dGc(z)
⌋z=⃗acx[n] = ⃗αdu[n] ⊙⃗ξxdu[n] ⊙dGc(z)
⌋z=⃗acx[n]
= ⃗ψ[n] ⊙⃗gcu[n] ⊙⃗ξxdu[n] ⊙dGd(⃗z)
⌋z=⃗adu[n] ⊙dGc(z)
⌋z=⃗acx[n]
⃗fχ[n + 1] = W T
vcu⃗αcu[n + 1] + W T
vcs⃗αcs[n + 1] + W T
vcr⃗αcr[n + 1] + W T
vcx⃗αcx[n + 1] + W T
vdu⃗αdu[n + 1]
⃗fψ[n + 1] = W T
scu⃗αcu[n + 1] + W T
scs⃗αcs[n + 1] + W T
scx⃗αcx[n + 1] + ⃗gcs[n + 1] ⊙⃗ψ[n + 1]
Referring once again to the definition of the Augmented LSTM cell in Equations 196 – 214, we obtain:
∂Wxcu[l][n] = ⃗αcu[n]⃗xT [n + l]
[n] = ⃗αcu[n]⃗sT [n −1]
[n] = ⃗αcu[n]⃗vT [n −1]
[n] = ⃗αcu[n]
∂Wxcs[l][n] = ⃗αcs[n]⃗xT [n + l]
[n] = ⃗αcs[n]⃗sT [n −1]
[n] = ⃗αcs[n]⃗vT [n −1]
[n] = ⃗αcs[n]
∂Wxcr[l][n] = ⃗αcr[n]⃗xT [n + l]
[n] = ⃗αcr[n]⃗sT [n]
[n] = ⃗αcr[n]⃗vT [n −1]
[n] = ⃗αcr[n]
∂Wxcx[l][n] = ⃗αcx[n]⃗xT [n + l]
[n] = ⃗αcx[n]⃗sT [n −1]
[n] = ⃗αcx[n]⃗vT [n −1]
[n] = ⃗αcx[n]
∂Wxdu[l][n] = ⃗αdu[n]⃗xT [n + l]
[n] = ⃗αdu[n]⃗vT [n −1]
[n] = ⃗αdu[n]
[n] = ⃗χ[n]⃗qT [n]
where 0 ≤l ≤L −1 and 0 ≤n ≤K −1. Arranged to parallel the structure of Θ, defined in Equation 215, the total partial
derivative of the objective function, E, with respect to the model parameters, Θ, at the step with the index, n, is:
∂Wxcu[l][n],
∂Wscu [n],
∂Wvcu [n],
∂⃗bcu [n],
∂Wxcs[l][n],
∂Wscs [n],
∂Wvcs [n],
∂⃗bcs [n],
∂Wxcr [l][n],
∂Wscr [n],
∂Wvcr [n],
∂⃗bcr [n],
∂Wxcx[l][n]
∂Wxdu[l][n],
∂Wvdu [n],
Finally, dE
dΘ, the total derivative of the objective function, E, with respect to the model parameters, Θ, for the entire unrolled
sequence is computed by Equation 172. Aggregated over a batch of segments,
dΘ is plugged in to the Gradient Descent
training algorithm for learning the model parameters, Θ.
VIII. CONCLUSIONS AND FUTURE WORK
In this paper, we presented the fundamentals of the RNN and the LSTM network using a principled approach. Starting with the
differential equations encountered in many branches of science and engineering, we showed that the canonical formulation of
the RNN can be obtained by sampling delay differential equations used to model processes in physics, life sciences, and neural
networks. We proceeded to obtain the standard RNN formulation by appropriately choosing the parameters of the canonical
RNN equations and applying stability considerations. We then formally explained RNN unrolling within the framework of
approximating an IIR system by an FIR model and proved the sufficient conditions for its applicability to learning sequences.
Next, we presented the training of the standard RNN using Back Propagation Through Time, segueing to the review of
the vanishing and exploding gradients, the well-known numerical difficulties, associated with training the standard RNN by
Gradient Descent. We subsequently addressed the shortcomings of the standard RNN by morphing the canonical RNN system
into the more robust LSTM network through a series of extensions and embellishments. In addition to the logical construction
of the Vanilla LSTM network from the canonical RNN, we included a self-contained overview of the Vanilla LSTM network,
complete with the specifications of all principal entities as well as clear, descriptive, yet concise, presentations of the forward
pass and, importantly, the backward pass, without skipping any steps. The main contribution up to this point has been our unique
pedagogical approach for analyzing the RNN and Vanilla LSTM systems from the Signal Processing perspective, a formal
derivation of the RNN unrolling procedure, and a thorough treatment using a descriptive and meaningful notation, aimed at
demystifying the underlying concepts. Moreover, as an unexpected benefit of our analysis, we identified two novel extensions to
the Vanilla LSTM network: the convolutional non-causal input context windows and the external input gate. We then augmented
the equations for the LSTM cell with these extensions (along with the recurrent projection layer, previously introduced by
another researcher team). Candidate recommendations for future work include implementing the Augmented LSTM system
within a high-performance computing environment and benchmarking its efficacy in multiple practical scenarios. The use of
the Augmented LSTM could potentially benefit the language representation subsystems used in question answering and in
automating customer support. For these applications, it will be important to evaluate the performance impact, attributed to the
non-causal input context windows, as compared to the different baselines, such the Vanilla LSTM network, the bi-directional
LSTM network, the Transformer, and other state-of-the-art models. Also of particular relevance to this use case will be to
measure the effectiveness of the external input gate in helping to eliminate the non-essential content from the input sequences.
Finally, adopting the Augmented LSTM network to other practical domains and publishing the results is respectfully encouraged.
ACKNOWLEDGMENTS
The author thanks Eugene Mandel for long-time collaboration and engaging discussions, which were instrumental in clarifying
the key concepts, as well as for his encouragement and support. Tremendous gratitude is expressed to Tom Minka for providing
helpful critique and valuable comments and to Mike Singer for reviewing the proposition and correcting errors in the proof.
Big thanks go to Varuna Jayasiri, Eduardo G. Ponferrada, Flavia Sparacino, and Janet Cahn for proofreading the manuscript.