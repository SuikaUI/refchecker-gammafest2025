HAL Id: inria-00491102
 
Submitted on 10 Nov 2010
HAL is a multi-disciplinary open access
archive for the deposit and dissemination of scientific research documents, whether they are published or not.
The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.
L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.
Beyond Soundness: On the Verification of Semantic
Business Process Models
Ingo Weber, Joerg Hoffmann, Jan Mendling
To cite this version:
Ingo Weber, Joerg Hoffmann, Jan Mendling. Beyond Soundness: On the Verification of Semantic Business Process Models. Distributed and Parallel Databases, 2010, 27 (3), pp.271-343. ￿10.1007/s10619-
010-7060-9￿. ￿inria-00491102￿
Distrib Parallel Databases
DOI 10.1007/s10619-010-7060-9
Beyond soundness: on the veriﬁcation of semantic
business process models
Ingo Weber · Jörg Hoffmann · Jan Mendling
© Springer Science+Business Media, LLC 2010
Abstract The veriﬁcation of control-ﬂow soundness is well understood as an important step before deploying business process models. However, the control ﬂow does
not capture what the process activities actually do when they are executed. Semantic annotations offer the opportunity to take this into account. Inspired by semantic
Web service approaches such as OWL-S and WSMO, we consider process models in which the individual activities are annotated with logical preconditions and
effects, speciﬁed relative to an ontology that axiomatizes the underlying business
domain. Veriﬁcation then addresses the overall process behavior, arising from the
interaction between control-ﬂow and behavior of individual activities. To this end,
we combine notions from the workﬂow community with notions from the AI actions and change literature. We introduce a formal execution semantics for annotated
business processes. We point out four veriﬁcation tasks that arise, concerning precondition/effect conﬂicts, reachability, and executability. We examine the borderline
between classes of processes that can, or cannot, be veriﬁed in polynomial time. For
precondition/effect conﬂicts, we show that the borderline is the same as that of the
Communicated by Asuman Dogac.
The major part of this work was conducted while the ﬁrst and second authors worked for SAP
Research, Karlsruhe.
School of Computer Science & Engineering, University of New South Wales, Sydney, NSW 2052,
e-mail: 
J. Hoffmann
INRIA, Centre de Recherche Nancy—Grand Est, 54506 Nancy, France
e-mail: 
J. Mendling ()
Humboldt-Universität zu Berlin, Unter den Linden 6, 10117 Berlin, Germany
e-mail: 
Distrib Parallel Databases
logic underlying the ontology axioms. For reachability and executability, we identify
a class of processes that can be veriﬁed in polynomial time by a ﬁxpoint algorithm
which we design for that purpose. We show that this class of processes is maximal in
the sense that, when generalizing it in any of the most relevant directions, the validation tasks become computationally hard.
Keywords Business process management · Semantic technologies
1 Introduction
The formalism and veriﬁcation techniques we describe in this paper are rather technical, and the background and intended usage of the proposed technology is not trivial
to explain. For these reasons, in what follows we introduce these aspects in some detail. We start with the motivation and background of our work in Sect. 1.1. We give an
overview of the approach and its usage in Sect. 1.2. We summarize our formalization
and contributions in Sect. 1.3.
1.1 Motivation and background
Nowadays, process-aware information systems utilize process models, which are
composed of activities and their associated control ﬂow. This has proven to be an
efﬁcient abstraction for rapid implementation of processes . A challenge is to
assure correctness. As far as control-ﬂow is concerned, veriﬁcation of correctness is
well understood as an important step before deploying executable business process
models, i.e., process models serving as templates for handling individual process
instances. The soundness criterion and its derivatives, e.g. , are typically used to check whether proper completion is possible or even guaranteed. Tools
like Woﬂan provide the functionality to efﬁciently verify soundness based on
Petri nets theory.
A limitation of soundness veriﬁcation is that it covers only the control-ﬂow perspective of the process model—in that sense, soundness is a necessary but insufﬁcient
condition for correctness. Better support for designing correct models is urgently
needed since there are considerable error rates in process models from practice .
To assure that a process model indeed behaves as expected, it is necessary to take
into account what the individual activities in the process—the activities whose order of execution is governed by the process—actually do when they are executed:
What are the prerequisites for the activities to execute successfully? How do they
affect the state of the world in case they are executed? Traditional workﬂow models
do not contain any information about this, apart from the naming of the activities.1
Such activity naming may be sufﬁcient for simple applications in closed domains,
where the behavior of the activities is not overly complex and/or known in detail
to all persons involved. For more complex applications, however, a more powerful
1Indeed, traditional models rather emphasize their black box character to simplify the implementation
Distrib Parallel Databases
means of describing the semantics of activities is in order. This is particularly true if
the individual activities in the process will be executed by different agents (persons or
computers) in a heterogeneous and distributed environment. The ﬁrst question then
is: How should we describe the semantics of activities?
Essentially this same question has been addressed, since several years, in the area
of semantic Web services. Approaches such as OWL-S and the Web Service
Modeling Ontology (WSMO) are in wide-spread use. At a particular level
of abstraction, called “service proﬁle” in OWL-S and “capability level” in WSMO,
Web services are perceived as functionalities with a single entry and exit point. This
corresponds well to the individual activities in a workﬂow. The proﬁle/capability of
a Web service is described in terms of a precondition—a logical formula capturing
the prerequisites of the service—as well as an effect (sometimes also referred to as
a “postcondition”)—a logical formula capturing how the service affects the state of
the world. The formulas are stated relative to the vocabulary of an ontology, which
formalizes the underlying domain, i.e., the “world” in which the service executes.
The use of ontologies facilitates a precise formulation of the domain structure and its
characteristic properties, through ontology axioms. Such formulations are useful for
capturing preconditions/effects, and they may reduce ambiguities in the communication among heterogeneous agents.
Following recent work in the area of Semantic Business Process Management
(SBPM) ,2 we adopt these notions from the semantic Web services area for
explicating the behavior of individual process activities. We assume that activities are
annotated with logical preconditions and effects. The research question we address is
that of veriﬁcation: Does the control ﬂow interact correctly with the behavior of the
individual activities? Precisely, we address the following four veriﬁcation tasks:
• Effect conﬂicts: Are there activities whose effects are in conﬂict, but that may be
executed in parallel?
• Precondition conﬂicts: Are there activities whose effect and precondition are in
conﬂict, but that may be executed in parallel?
• Reachability: Is there an activity that will never be reached by the execution?
• Executability: Is there an activity whose precondition may be false at a time when
the activity is scheduled for execution?
Note that, in this veriﬁcation, we go far beyond what is possible based on activity
names. We are able to conveniently express and check how particular aspects of the
preconditions/effects of some activities affect particular aspects of other activities.
For example, activity A may not be reachable because activity B has an effect invalidating the preconditions of activities C and D, if the workﬂow is such that B must
be executed before C and D, and either C or D must be executed before A. In brief:
based on “local” annotations, we are able to detect “global” conﬂicts.
2For information about the SBPM area, see e.g. the SUPER IP (EU-funded Integrated Project, http://
www.ip-super.org), Semantic Business Process Management Working Group ( 
SBPM workshop .
Distrib Parallel Databases
1.2 Overview of the approach
Our veriﬁcation techniques are aimed at helping with the creation of correct business
process models. Hence they will be used by a human process modeler. This will happen interactively, i.e., on-line while the human modeler is creating or adapting the
process within a BPM modeling environment. The general setting is that the modeler frequently uses the veriﬁcation as a push-button operation for cross-checking the
process and pointing out any bugs, should they exist. To enable such veriﬁcation, the
modeler uses some convenient paradigm for annotating the preconditions/effects of
individual tasks (we get back to this below). Note here that the veriﬁcation can serve
as much for debugging the annotations—these may have a value per se by making
explicit the intended meaning of the process—as it serves for debugging the control-
ﬂow structure. The modeling continues until the process is complete, and proved by
the veriﬁcation to be correct with respect to all four veriﬁcation tasks.
Figure 1 illustrates the interplay between business process models, annotations,
and veriﬁcation. The ﬁgure shows an example of a business process model (top of
the ﬁgure), which has been partly annotated with terms from an ontology (middle of
the ﬁgure). Upon calling our veriﬁcation techniques, a list of problems is returned
(bottom of the ﬁgure). As shown in the picture, the ontology consists of two taxonomies (a, b, c vs. d, e, f, g, h). To indicate that x ⊑y, i.e., that x is a sub-concept
of y, an arrow from x to y is displayed. Further, the ontology states mutual exclusion
between c and g, indicated by a dashed double arrow.
In the shown process model, a precondition conﬂict exists because, although T4
and T5 are parallel, the effect of T4—c—contradicts the precondition of T5—g.
Hence, if T4 happens to be executed prior to T5, then T5’s precondition will not
be satisﬁed at the point where T5 is scheduled for execution, i.e., when T5’s incoming edge carries a token. Similarly, T7 is not executable because T4 is necessarily
executed beforehand, which will invalidate T7’s precondition.3
Why is such a situation—an activity being scheduled for execution at a time when
its precondition is not satisﬁed—problematic? The problem arises (1) if the process is
being executed by a standard (non-semantic) engine, e.g. based on BPEL, or (2) if the
execution engine is aware of the semantic annotations but cannot observe their truth
value at execution time. In both cases, the activity will be enacted regardless of the
unsatisﬁed precondition. This may lead to undeﬁned behavior and errors. Scenario
(1) is, clearly, all we are going to get in industrial applications, in the foreseeable
future. In particular it corresponds to our current use cases at SAP, which we will
detail later on (Sect. 7). Scenario (2) is quite likely if the process coordinates activities
across a heterogeneous system landscape: while it is conceivable that the meaning of
activities is being shared at the modeling level, realizing such communication at IT
level is much more challenging and may not even be wanted.
Using our technology requires computational resources for the veriﬁcation, and
human resources for creating the annotations. Regarding computation, most impor-
3Note that, due to subsumption, there aren’t any other bugs in the process model, with respect to our four
veriﬁcation tasks. Note also that preconditions are not understood as events that trigger activity execution.
Rather, they are evaluated when workﬂow execution has reached the corresponding activity.
Distrib Parallel Databases
Fig. 1 Illustration of the interplay between business process models, annotations, and veriﬁcation. The
modeler (partly) annotates the process (top of picture) with terms from the ontology (middle). Veriﬁcation
is called for debugging, yielding a list of problems (bottom). In the picture, the ontology consists of two
taxonomies (a, b, c vs. d, e, f , g, h) and mutual exclusion between c and g. Note that the annotation is
partial, i.e., the modeler does not have to annotate every task node with precondition and effect
tantly there is a tight constraint on response time—human patience. This partly motivates our quest for tractable classes, cf. the next section. As for modeling effort,
note ﬁrst that there is a huge difference between (a) creating the ontology and (b)
annotating the preconditions/effects in the process. (a) is done once and for all for
an entire domain, while (b) must be done all the time. Fortunately, our experience is
that, once (a) has been accomplished, (b) is comparatively easy. As we demonstrate
in Sect. 7, annotations can be selected in simple drop-down menus; previous work
 has shown that value ranking based on relevance parameters such as process
context can be quite effective. It should also be noted in this context that the process
annotation may be partial, as indicated in Fig. 1. We do not require all activities to
be annotated. Instead, the modeler may annotate preconditions/effects in a piecemeal
fashion as required.
Distrib Parallel Databases
1.3 Summary of formalization and contribution
Our contribution is threefold:
(1) We devise a formal execution semantics for annotated business processes. This
is technically not challenging, but remarkable because it requires to combine notions from the workﬂow community with notions from the AI actions and change
community. We combine control ﬂow, i.e., token passing, with the AI notion of
state changes induced by logical preconditions/effects in the presence of a domain axiomatization. To the best of our knowledge, ours is the ﬁrst work considering this combination.
(2) We investigate the borderline between classes of processes that can, or cannot, be
veriﬁed in polynomial time. This constitutes the main technical body of the paper.
Apart from the theoretical relevance of the investigated borderline, it is important
in our application setting, cf. Sect. 1.2. We determine that the complexity of precondition/effect conﬂict checking is the same as that of the logic underlying the
ontology axioms. We identify a maximal tractable class of processes regarding
reachability and executability checking.
(3) We provide initial evidence of the practicality of our approach. Our techniques
are implemented within three SAP Research prototypes. The prototypes show
how our technology can be accessed via standard user interactions, and how semantic annotations can be obtained at low cost leveraging existing models at
In what follows, we explain our formalization and these contributions in more detail.
First, some words are in order regarding our formalism. Our annotated business
processes combine syntax for (a) control ﬂow and (b) semantic annotations. Regarding (a), we presume that the reader is basically familiar with process modeling languages like BPEL , EPCs , BPMN , UML Activity Diagrams , or
YAWL . Our formalization is oriented at BPEL. We cover several major modeling elements, namely parallel splits/joins, xor splits/joins, and structured loops in
the form of sub-processes that may be repeated. As for (b), we allow: preconditions/effects annotated at individual activities (governing when an activity can be
executed/how it affects the world); conditions annotated at the outgoing edges of
xor splits (governing which edge is taken); and conditions annotated at loops (governing whether a loop is repeated or exited). All these are logical formulas, which
for the sake of simplicity we restrict to be conjunctions of literals. Our ontology
axioms take the form of universally quantiﬁed clauses. These can be used to state
many typical domain properties, such as subsumption ∀x : ¬p(x)∨q(x), disjointness
∀x : ¬p(x)∨¬q(x), or coverage ∀x : ¬p(x)∨q1(x)∨···∨qn(x). The investigation
of richer annotations, e.g. using Description Logic , is an open topic.
We deﬁne an execution semantics for annotated processes, i.e., we deﬁne what the
state space of a process is. Each state consists of two parts: (a) the positions of the
tokens; and (b) the logical state, a truth value assignment to the propositions formed
with the ontology vocabulary. For (a), our formalism relies on a straightforward token
passing semantics. As for (b), this is trivial without ontology axioms: simply modify
the state with the effect literals of the activity that was executed. With axioms, however, logical state transitions are a long-standing topic for a whole research area, see
Distrib Parallel Databases
e.g. . A useful way to think about the ontology axioms is as “physical laws”. As a simple example, the ontology might say that a claim can never be
accepted and rejected at the same time. Say an activity rejects a claim. The effect of
that activity contradicts “one half” of the axiom, necessitating truth of the other half.
Hence, by physical law, the claim is not accepted any longer. With more complex
“laws”, in particular dependencies between more than two properties of the domain,
contradictions between effects and axioms are no longer so easily handled. In a nutshell, the problem is that the contradictions can be solved in several ways, yielding
several possible outcome states. It is not clear which of these should be considered
physically possible. In our work, we adopt the “possible models approach” (PMA)
suggested by Winslett , which is in wide-spread use and, in particular, underlies
most formalisms relating to the execution of semantic Web services, e.g. .
The PMA admits all outcome states that differ from the previous state in a minimal
way. Intuitively, “minimality” here ensures that the world does not change without
a reason. In the above example, physical law will invalidate acceptance of the claim
under consideration; it will not affect, e.g., the status of any other claim.
To brieﬂy position our formalism with respect to the literature, ﬁrst note that traditional veriﬁcation techniques, as considered in the workﬂow community (e.g. )
and the model checking community (e.g. ), do not deal with ontologies.4 Without
ontology axioms, on the other hand, our formalism can be compiled into Petri nets
and other known paradigms. This is obvious for our token-passing semantics and easy
to see for preconditions etc; a related approach has previously appeared. However, our results regarding tractability cannot be derived from the literature via such
compilation. We get back to this below. There is a body of related work addressing
business process models extended beyond control ﬂow, namely . None of them combines control ﬂow token passing with AI actions
and change as we do, and none of them addresses similar veriﬁcation tasks.
Our core technical contribution is the investigation of the borderline between
tractable and intractable veriﬁcation. For effect and precondition conﬂicts, it turns out
that this borderline is the same as that of the logic underlying the ontology axioms.
Whether or not two activities are parallel depends only on the control ﬂow, not on
the semantic annotations. Control-ﬂow parallelism can be determined in polynomial
time. This follows from earlier results in Petri net theory: Kovalyov and Esparza 
devise an algorithm for free-choice Petri nets that determines concurrency in cubic
time. We improve on this result by devising an algorithm that exploits the particular
structure of our control-ﬂows, and runs in quadratic time. Once parallelism has been
determined, checking for precondition/effect conﬂicts reduces to satisﬁability tests.
With our particular formalism for axioms, this means that we inherit the well-known
tractability/intractability results for clausal formulas.
For reachability and executability, matters are more complicated, because those
tasks are more tightly linked to the overall behavior of the process. We show that
neither can be checked in polynomial time (unless P = NP) if we allow either of:
4Many existing veriﬁcation techniques are heavily based on logic, i.e., on the manipulation of formulas
representing certain properties of the system, like the set of states that can be reached within a given
number of steps. However, semantic descriptions formalize the behavior of the system, not its properties.
Distrib Parallel Databases
unrestricted axioms; Horn axioms; xor conditions; or loop conditions. We further
show that, even in the class of what we call basic processes, with binary axioms and
without xor/loop conditions, it is NP-hard to test reachability and it is coNP-hard to
test whether or not a particular individual activity is executable. Our positive result
is that, for basic processes, we can test in polynomial time whether all activities are
executable. The proof is constructive, i.e., we devise a polynomial-time veriﬁcation
algorithm. None of these results have been stated, or follow directly from, results in
the literature. For the case where there are preconditions and effects, but no ontology
axioms, results from Petri net theory can be re-used to identify two tractable classes
for reachability checking. This has been recognized by . One of these classes is a
proper subset of basic processes; the other class is complementary.
Our algorithms are implemented as a back-end prototype that is used in three
front-end tools at SAP Research. One of these addresses a different application (that
we had not originally foreseen), namely a brokerage conﬁguration task in service
marketplaces . The two other applications use the back-end within a process
modeling environment, in an online setting exactly as described above in Sect. 1.2.
One of these front-ends is an SAP Research prototyping platform called Maestro,
the other is a research extension to the commercial SAP NetWeaver platform. Both
applications show how the annotation of preconditions etc. can be done via standard
GUI interactions, e.g., selecting the annotation literals in simple drop-down menus.
The SAP NetWeaver application, moreover, demonstrates very nicely how we can
leverage existing models at SAP. The ontology underlying the tool is taken from a
pre-existing model at SAP, describing the status variables of more than 400 business
objects which are typically affected by process activities at SAP. Apart from the fact
that this ontology comes “for free”, it is based on already established terminology,
with which process modelers are likely to be familiar.
The paper is organized as follows. Section 2 introduces our formalism for semantic
business process models. Section 3 formalizes the four veriﬁcation tasks we consider,
and states a few basic facts about their dependencies. Section 4 presents our results for
the veriﬁcation of effect and precondition conﬂicts. Section 5 contains our negative
results on the computational complexity of reachability and executability checking,
while Sect. 6 contains the positive results, i.e., the polynomial-time veriﬁcation algorithm for basic processes. Section 7 gives details on our prototypes, and discusses the
difﬁculty of creating semantic annotations. Section 8 discusses related work, Sect. 9
concludes the paper. For the sake of readability, the text gives only proof sketches.
Full proofs are available in Appendix.
2 Annotated process graphs
We introduce our formalism for semantic business process models. As stated, the
formalism combines control-ﬂow (adopted from the workﬂow community) with preconditions/effects (adopted from the semantic Web service and AI communities). For
the sake of readability, we ﬁrst consider the former in isolation, then enrich it with
the latter.
Distrib Parallel Databases
2.1 Process graphs
Our formalization of control-ﬂow in process models covers xor splits, xor joins, parallel splits, parallel joins, and structured loops in the form of sub-graphs that may
be repeated. The former four constructs (splits and joins) are a core set of the most
consensual routing elements of various process modeling languages like EPCs , BPMN , UML Activity Diagrams , and YAWL . Indeed, these constructs are among those that are most frequently used in BPMN . As for the latter
construct (structured loops), these are oriented at the widely adopted BPEL language.
BPEL directly enforces such a structure; recent process graph parsing techniques can
be applied to untangle loops and move them into sub-processes .
Our analysis and algorithms apply to any process model that can be expressed in
terms of our constructs. Notationally, we build on , which—after straightforward
extensions for structured loops—offers a concise and easy to read syntax for expressing the particular constructs we are interested in. (In contrast to the more generic
nature of notations like Petri nets, which would complicate the formulation of the
particular distinction lines that are relevant for us.) Formally, the syntax of process
graphs is deﬁned as follows.
Deﬁnition 1 There are two kinds of Process Graphs: atomic process graphs, and
complex process graphs.
1. An atomic process graph is a directed graph P = (N,E), where N is the disjoint union of {n0,n+} (start node, stop node), NT (task nodes), NPS (parallel
splits), NPJ (parallel joins), NXS (xor splits), and NXJ (xor joins). For n ∈N,
in(n)/out(n) denotes the set of incoming/outgoing edges of n. We require that:
P is acyclic; for every split node n, |in(n)| = 1 and |out(n)| > 1; for every
join node n, |in(n)| > 1 and |out(n)| = 1; for every n ∈NT , |in(n)| = 1 and
|out(n)| = 1; |in(n0)| = 0 and |out(n0)| = 1 and vice versa for n+; every node
n ∈N is on a path from the start to the stop node.
2. Say Q1,...,Qm are process graphs. Then a complex process graph is a triple P =
(N,E,λ), where (N,E) is like an atomic process graph except that there is an
additional kind of nodes, NL, called loop nodes, where |in(n)| = 1 and |out(n)| =
1 for every n ∈NL. λ is a bijection from NL into {Q1,...,Qm}.
Q1,...,Qm are sub-graphs of P; a sub-graph of any Qi is (recursively) also a subgraph of P. For any process graph Q, we denote by Sub(Q) the set of graphs containing Q as well as all its sub-graphs. We use superscripts in order to distinguish constructs belonging to particular sub-graphs; e.g., NQ2 is the node set of sub-graph Q2.
Further, we use N to denote the set of all nodes appearing in P itself or in any of its
sub-graphs, and we use E to denote the set of all edges appearing in P itself or in any
of its sub-graphs. For any set of nodes, we use the sub-scripts T , PS, PJ , XS, XJ ,
and L to distinguish the different kinds of nodes, as above.
We require that the direct sub-graph relation is a tree; precisely, the graph (Sub(P),
{(Q,Q′) | ex. n ∈NQ : λQ(n) = Q′}) is a tree with root P. Further, we require that,
for any Q,Q′ ∈Sub(P) with Q ̸= Q′, NQ ∩NQ′ = ∅, i.e., the same node may not
be re-used across several sub-graphs.
Distrib Parallel Databases
Fig. 2 Our running example: a claims handling process adapted from 
If in(n) = {e}, i.e., in(n) is a singleton set, then we overload in(n) to denote its single element, i.e., we identify in(n) with e. Similarly, if out(n) = {e} then we identify
out(n) with e. We denote e0 := out(n0) and e+ := in(n+).
Atomic process graphs are (sub-)graphs without loop nodes, whereas complex
process graphs can contain loop nodes. A loop node is “implemented” by a subgraph, which, again, may be complex or atomic. The λ-function maps from loop
nodes to sub-graphs. We require the compositional sub-graph structure to be a tree.
We will generally refer to the root of the tree as the “top-level process”, and refer to
it with P; sub-processes will generally be referred to with Q. We do not distinguish
between atomic and complex process graphs unless necessary, and we assume by
convention a void function λ for atomic process graphs. If the context is clear, we
omit the superscript indicating the process referred to. Note the difference between
the set of nodes and edges of a single process graph, N,E, and the nodes and edges of
all sub-graphs combined, N,E. Note also that for singleton sets of incoming/outgoing
edges, we overload in/out to denote both the respective set and its element. While this
abuses notation, it makes many of our formal statements a lot more readable, and will
be used frequently.
Example 1 Figure 2 shows our running example, serving to illustrate many of our
deﬁnitions. The example is based on a process model from the IBM Insurance Application Architecture (a large collection of best practice process models from insurance industry); the model was published in . It deﬁnes how a claim is handled
by an insurer. For the purpose of our presentation, we slightly adapted and simpliﬁed
the model.
Distrib Parallel Databases
The process starts when a loss event occurs (step 1 in Fig. 2). The insurance company is notiﬁed of the claim (step 2). Then a sub-process is repeated until either the
claim has been accepted, or its rejection has been approved. In the sub-process, ﬁrst
the claim is recorded and validated. Then the insurer chooses to either accept or reject
the claim.5 In the former case, an according beneﬁt is offered and paid, and the claim
is closed (steps 10–15). In the latter case, the rejection needs to be either approved
(step 9) or disapproved (step 7). If the rejection is disapproved, additional data needs
be provided (step 8). Once the sub-process completes, the claim is archived in the ﬁnal step, number 17 in Fig. 2. Note that step 14 can be executed in parallel to step 15,
due to the parallel split and join nodes.
The semantics of process graphs are, similarly to Petri Nets, deﬁned as a token
game. Like the notation, this deﬁnition follows .
Deﬁnition 2 Let P = (N,E,λ) be a process graph. A token marking t of P is a
function t : E
→N (the natural numbers). The start marking t0 is t0(e) = 1 if e = eP
t0(e) = 0 otherwise. Let Q,Q′ ∈Sub(P). Let t and t′ be token markings. We say that
there is a transition (or token-transition) from t to t′ via n, written t
n→t′, iff one of
the following holds:
1. Tasks, parallel splits and joins (tokens from INs to OUTs).
n ∈NT ∪NPS ∪NPJ , for all ein ∈in(n) we have t(ein) > 0 and
2. Xor splits (token from IN to one OUT).
n ∈NXS, t(in(n)) > 0, and there exists e′ ∈out(n) such that
3. Xor joins (token from one IN to OUT).
n ∈NXJ and there exists e′ ∈in(n) such that t(e′) > 0 and
e = out(n)
5In the original model, this choice is encoded into a task node with non-deterministic outcome, governing
which branch of the xor split to take. From the perspective of veriﬁcation, i.e., as far as the possible
execution traces are concerned, the two models are equivalent. The model as in Fig. 2 is more convenient
for our illustration purposes.
Distrib Parallel Databases
4. Entering a loop (push token downwards).
L with λQ(n) = Q′, t(in(n)) > 0, and
5. Repeating a loop (put token back on start).
+ , t(in(n)) > 0, and
6. Exiting a loop (push token upwards).
+ with Q = λQ′(n′), t(in(n)) > 0, and
e = out(n′)
An execution path, or token-execution path, is a transition sequence t0
t2 ···tk−1
→t. A token marking t is reachable, or token-reachable, if there exists
an execution path ending in t. We say t′ is reachable from t (t →t′) if there exists a
transition sequence such that t
→t2 ···tk−1
The tokens are carried by edges, and the execution status of the process is given
by the position of all tokens, the token marking. t(e) denotes the number of tokens on
an edge e for a given token marking t. A node which passes a token from (one or all
of) its incoming edge to (one or all of) its outgoing edge is said to be executed. Token
passing from edge e to e′ and from token marking t to t′ is denoted as t′(e) = t(e)−1
and t′(e′) = t(e′) + 1.
Task nodes are executed when a token on the incoming edge is consumed and
a token on the outgoing edge is produced. The execution of an xor (parallel) split
node consumes the token on its incoming edge and produces a token on one (all)
of its outgoing edges, whereas an xor (parallel) join node consumes a token on one
(all) of its incoming edges and produces a token on its outgoing edge. A loop node
consumes a token from its incoming edge and produces a token on the start edge of
the sub-graph that is associated with the loop node. The execution of the end node of
a sub-graph consumes a token from its incoming edge e+, and produces a token either
on the start edge e0 of the same process graph (repeating the sub-graph’s execution)
or on the outgoing edge of the loop node (exiting the loop). Note that this is a “dowhile” semantics: the loop is executed at least once.
Soundness, ﬁrst introduced by Van der Aalst in , is an important correctness
criterion for business process models. The soundness property is deﬁned for workﬂow
nets, i.e., a Petri nets with one source and one sink. A workﬂow net is sound iff: (1) for
Distrib Parallel Databases
every token marking reachable from the source, there must exist a ﬁring sequence to
the sink (option to complete); (2) there is no reachable token marking which has a
token both in the sink and in some other edge (proper completion); and (3) there are
no dead transitions, i.e., for every transition there is an execution path that can ﬁre it
 . We adopt this deﬁnition. Van der Aalst shows that soundness of a Workﬂow net
is equivalent to liveness and boundedness of the corresponding short-circuited Petri
net. It follows easily from earlier results that process graphs as per Deﬁnitions 1
and 2 map to free-choice Petri nets, where no output branch of an xor split n ∈NXS
can be disabled by other choices in the process graph.
We will later utilize a property of soundness related to so-called contact situations.
A contact situation is a marking in which a node has tokens on its incoming edges as
well as on its outgoing edges. Such a situation can never occur in a sound process.
Proposition 1 Let P = (N,E,λ) be a sound process graph. Then the following does
not exist: a token-reachable token marking t, a node n ∈N , and edges e ∈in(n),e′ ∈
out(n) such that t(e) > 0 and t(e′) > 0.
Proof Assume a sound process graph P with a node n such that t(e) > 0 and
t(e′) > 0 for e ∈in(n),e′ ∈out(n). Since there is a path from n to the sink n+ and
P is sound, the nodes on the path can propagate the token from e′ to n+. Since P is
free-choice, this ﬁring sequence does not require the token from e. This means that
there can still be a token on edge e after the sink n+ has received a token via the ﬁring
from e′. The latter is a contradiction to condition (2) of the soundness assumption. □
2.2 Semantic annotations
For the semantic annotations, we use standard notions from logic, involving logical
predicates and constants. Predicates provide the formal vocabulary, referring to properties of tuples of constants. Constants correspond to the entities of interest at process
execution time.6 We denote predicates with G,H,I and constants with c,d,e. Facts
are predicates grounded with constants, Literals are possibly negated facts. If l is a
literal, then ¬l denotes l’s opposite (¬p if l = p and p if l = ¬p); if L is a set of
literals then ¬L denotes {¬l | l ∈L}. We identify sets L of literals with their conjunction 
l∈L l. Given a set P of predicates and a set C of constants, P[C] denotes
the set of all literals based on P and C; if arbitrary constants are allowed, we write
A theory T is a closed (no free variables) ﬁrst-order formula. Given a set C of
constants, T [C] denotes T with quantiﬁers interpreted over C. For the purpose of our
formal semantics, T can be arbitrary. For computational purposes, we will consider
the following standard restrictions. A clause is a universally quantiﬁed disjunction of
atoms, e.g., ∀x.¬G(x) ∨¬H(x). There are two classes of clauses that are important
in our analysis, because their propositional variants (without variables) are known to
be tractable: Horn clauses and binary clauses . A clause is Horn if it contains
6Hence our constants correspond to BPEL “data variables” ; note that the term “variables” in our
context is reserved for variables as used in logic, quantifying over constants.
Distrib Parallel Databases
at most one positive literal. A clause is binary if it contains at most two literals.
A theory is Horn (binary) if it is a conjunction of Horn (binary) clauses.
An ontology Ω is a pair (P,T ) where P is a set of predicates (Ω’s formal terminology) and T is a theory over P (constraining the behavior of the application
domain encoded by Ω). For upper-bounding the complexity of reasoning over T ,
we will assume ﬁxed arity: a ﬁxed bound on the arity of the predicates P . This is
a realistic assumption because, according to modeling experience in AI and related
areas, predicate arities are typically small. For example, in Description Logics the
maximum arity is 2.
Deﬁnition 3 An annotated process graph is a tuple P = (N,E,λ,Ω,α) where
(N,E,λ) is a process graph, Ω = (P,T ) is an ontology, and the annotation α =
{pre, eff, rcon, (con,pos)} is deﬁned as follows (where Π denotes the powerset):
– pre is a partial function pre : NT ∪{nP
→Π(P[]) mapping a task node or global
end node to a set of literals (its precondition).
– eff is a partial function eff : NT ∪{nP
→Π(P[]) mapping a task node or global
start node to a set of literals (its effect).
– rcon is a partial function rcon : NL
→Π(P[]) mapping a loop node to a set of
literals (its repetition condition).
– con is a partial function con : {e ∈E|ex. n ∈NXS : e ∈out(n)}
→Π(P[]) mapping
an xor split’s outgoing edge to a set of literals (its condition).
– pos is a partial function pos : {e ∈E|ex. n ∈NXS : e ∈out(n)}
→{1,...,|out(n)|}
mapping an xor split’s outgoing edge to an integer (its position, encoding the evaluation order of the xor split).
We require that:
– There is no n such that pre(n) is deﬁned and T ∧pre(n) is unsatisﬁable.
– There is no n such that eff(n) is deﬁned and T ∧eff(n) is unsatisﬁable.
– There is no n such that rcon(n) is deﬁned and T ∧rcon(n) is unsatisﬁable.
– There is no e such that con(n) is deﬁned and T ∧con(e) is unsatisﬁable.
– con(e) is deﬁned iff pos(e) is deﬁned.
– There do not exist n, e, e′ such that e,e′ ∈out(n), pos(e) and pos(e′) are deﬁned,
and pos(e) = pos(e′).
Any task node, as well as the top-level end node, may have a precondition pre.
Any task node, as well as the top-level start node, may have an effect eff. Loop nodes
may have a repetition condition rcon, and the outgoing edges of an xor split may
have a condition con and an evaluation position pos. Note here the “may have”. All
the annotation functions are partial. This captures the situation where only parts of
the process can be sensibly annotated, or where a developer wants to run veriﬁcation
tests on a model whose annotations have not yet been completed. This is important—
forcing a user to fully annotate a process up front would adversely affect acceptance.7
7One may speculate that annotating an empty set of literals is equivalent to leaving the annotation undeﬁned. Indeed, this is true (with some modiﬁcations regarding the role of pos for xor splits)—except
Distrib Parallel Databases
As stated, the annotation of task nodes—atomic actions that might be implemented
by Web service invocations—in terms of logical preconditions and effects closely follows semantic Web service approaches such as OWL-S and WSMO .
As also stated, all the involved sets of literals (pre(n), eff(n), con(e), rcon(n)) will
be interpreted as conjunctions. (It is easy to extend our formalism to allow arbitrary
formulas for pre(n), eff(n), con(e), rcon(n). Veriﬁcation involving such formulas is
likely to lead to harder decision problems; this remains a topic for future work.)
We now formally deﬁne the semantics of annotated process graphs.
Deﬁnition 4 Let P = (N,E,λ,Ω,α) be an annotated process graph. Let C be the
set of all constants appearing in any of the annotated pre(n), eff(n), rcon(n), con(e).
A state s of P is a pair (ts,is) where t is a token marking and i is a logical interpretation i : P[C]
→{0,1}. A start state s0 is (t0,i0) where t0 is as in Deﬁnition 2,
and i0 |= T [C], and i0 |= eff(nP
0 ) in case α(nP
0 ) is deﬁned. Let Q,Q′ ∈Sub(P). Let
s and s′ be states. We say that there is a transition from s to s′ via n, written s
iff one of the following holds:
1. Parallel splits and joins (straightforward; no change of logical interpretation).
n ∈NPS ∪NPJ , for all ein ∈in(n) we have ts(ein) > 0, is = is′, and ts
according to Deﬁnition 2.
2. Xor joins (straightforward; no change of logical interpretation).
n ∈NXJ , there exists e′ ∈in(n) such that ts(e′) > 0, is = is′, and ts
according to Deﬁnition 2.
3. Xor splits (depends on condition; no change of logical interpretation).
n ∈NXS, ts(in(n)) > 0, is = is′, and
where either e′ ∈out(n) and α(e′) is undeﬁned, or e′ = argmin{pos(e) | e ∈
out(n), α(e) is deﬁned, is |= con(e)}.
4. Entering a loop (condition not tested due to do-while semantics; no change of
logical interpretation).
L so that λQ(n) = Q′, with ts(in(n)) > 0, is = is′, and
for loop conditions. If such a condition is undeﬁned, then we allow the process to non-deterministically
choose whether to exit or repeat (cf. Deﬁnition 4 below). This cannot be encoded into any ﬁxed set of
literals. From a more general perspective, we prefer the notation using partial functions because it is more
Distrib Parallel Databases
5. Repeating a loop (condition must be true; no change of logical interpretation).
+ so that Q = λQ′(n′), ts(in(n)) > 0, where either α(n′) is undeﬁned or
is |= rcon(n′), with is = is′, and
6. Exiting a loop (condition must be false; no change of logical interpretation).
+ so that Q = λQ′(n′), ts(in(n)) > 0, where either α(n′) is undeﬁned or
is ̸|= rcon(n′), with is = is′, and
e = out(n′)
7. Executing a task (affects the logical interpretation, may have ambiguous outcome).
n ∈NT , ts(in(n)) > 0, ts
n→ts′ according to Deﬁnition 2, and either: α(n)
is undeﬁned and is = is′; or is |= pre(n) and is′ ∈PMA-min(is,T [C] ∧eff(n)),
where PMA-min(is,T [C] ∧eff(n)) is the set of all i that satisfy T [C] ∧eff(n)
and that are minimal with respect to the partial order deﬁned by i1 ≤i2: iff {p ∈
P[C] | i1(p) ̸= is(p)} ⊆{p ∈P[C] | i2(p) ̸= is(p)}.
An execution path is a transition sequence s0
→s2 ···sk−1
→s, where s0 is
a start state. A state s is reachable if there exists an execution path ending in s. We
say s′ is reachable from s (s →s′) if there exists a transition sequence such that s
→s2 ···sk−1
→s′. By SP we denote the set of reachable states; if the process
referred to is clear from the context, we will sometimes omit the superscript P.
A state s of the process now consists of the token marking t in combination with
the logical interpretation i. The interpretation assigns truth values to all logical facts
formed from the relevant predicates and constants. To avoid clumsiness of language,
we will usually drop the “logical” in “logical interpretations”. Also, we will often
overload s with is, writing e.g. s |= φ instead of is |= φ.
An execution of the process starts with a token on the outgoing edge of the start
node, and with any interpretation that complies with the start node’s effect (if any)
and the implications of the logical theory. Parallel splits and joins, as well as xor joins,
remain unaffected by the annotation. An xor split, in contrast, non-deterministically
either selects an outgoing edge without annotation, or produces a token on the outgoing edge e with lowest position pos(e) whose condition con(e) is satisﬁed by the
current interpretation, is. Note that this is a hybrid between a deterministic and a nondeterministic semantics, depending on how many output edges are annotated. If all
edges are annotated, then we have a case distinction as handled in, e.g., BPEL, where
the ﬁrst case (smallest position) with satisﬁed condition is executed (Sect. 11.2 in
 ). If no edges are annotated, then the analysis must foresee that a case distinction
may be created later on during the modeling. No assumptions can be made on the
Distrib Parallel Databases
form of that case distinction, so any possibility must be taken into account. Deﬁnition 2 just generalizes these two extremes in the straightforward way.
Entering a loop node also remains the same as in Deﬁnition 2, since each loop
is executed at least once (do-while semantics). If the annotation of the loop node
is undeﬁned, then we can non-deterministically choose whether to repeat or exit the
loop. If the repetition condition rcon is deﬁned, then the loop is repeated iff the current
state’s interpretation satisﬁes rcon.
The execution of any routing node does not affect the logical interpretation. In
contrast, the execution of an annotated task node (which is possible only if the current
state satisﬁes the precondition pre) changes the interpretation according to the effect
eff and the implications of T . The tricky bit lies in the deﬁnition of the possible
outcome states i′. The semantics deﬁnes this to be the set of all i′ that comply with
T and eff(n), and that differ minimally from i. This draws on the AI literature for
a solution to the frame and ramiﬁcation problems. The latter problem refers to the
need to make additional inferences from eff(n), as implied by T . This is reﬂected in
the requirement that i′ complies with both. The frame problem refers to the need to
not change the previous state arbitrarily—e.g., if an activity makes a payment via a
credit card C1, then any other credit card C2 should not be affected. This is reﬂected
in the requirement that i′ differs minimally from i, such that there is no i′′ that makes
do with fewer changes. As explained in the introduction, this semantics follows the
so-called possible models approach (PMA): the set PMA-min(is,T [C] ∧eff(n)) in
the handling of task nodes as per Deﬁnition 4 is exactly as deﬁned in the original
PMA paper by Winslett . The PMA underlies most formalisms relating to the
execution of semantic Web services . Alternative semantics from the AI
literature (see for an excellent overview) could be used in principle; this is a
topic for future research.
We next give two examples. The ﬁrst provides the semantic annotations for our
running example.
Example 2 Consider again Fig. 2. The semantic annotations of the task nodes are
listed in Table 1. The ontology speciﬁes the following axioms:
(1) ∀x : ¬claimAccepted(x) ∨¬claimRejected(x)
(2) ∀x,y : ¬beneﬁtOffered(x,y) ∨¬beneﬁtPosted(x,y)
∀x,y : ¬beneﬁtOffered(x,y) ∨¬beneﬁtPaid(x,y)
∀x,y : ¬beneﬁtPosted(x,y) ∨¬beneﬁtPaid(x,y)
(3) ∀x : claimRejectionDisapproved(x) ⇒¬claimRejected(x)
Axiom (1) means that no claim may be both accepted and rejected at the same time;
in other words, a claim may be in at most one of its possible states. Similarly, axioms
(2) mean that no beneﬁt may be in more than one of its possible states. Axiom (3)
expresses a somewhat more subtle dependency, namely that a claim is no longer
rejected if its rejection has been disapproved.
The following example illustrates the subtleties of the PMA semantics.
Example 3 We ﬁrst illustrate the ramiﬁcation problem. We show how ontology axioms may lead to “side effects”, i.e., to literals that are not mentioned explicitly in the
Distrib Parallel Databases
Table 1 Preconditions and effects of all task nodes in the process from Fig. 2. Node labels abbreviated
Precondition
Postcondition
1. Loss event
lossEvent(e)
2. Notiﬁcation
lossEvent(e)
5. Record claim
claimRecorded(c),
claimValidated(c)
6. Reject claim
claimRejected(c)
7. Disapprove rejection
claimRejected(c)
claimRejectionDisapproved(c)
8. Additional data
claimChanged(c)
9. Approve rejection
claimRejected(c)
claimRejectionApproved(c)
10. Accept claim
claimAccepted(c)
11. Offer beneﬁt
claimAccepted(c)
beneﬁt(b), beneﬁtOffered(b,c)
12. Prepare discharge
beneﬁtOffered(b,c)
dischargePrepared(c)
13. Record payment
beneﬁtOffered(b,c),
beneﬁtPosted(b,c)
dischargePrepared(c)
14. Close claim
claimFinalized(c)
claimClosed(c)
15. Payment
beneﬁtPosted(b,c)
beneﬁtPaid(b,c)
17. Archive claim
claimArchived(c)
effect annotation of a task node n, but that change their value nevertheless when n is
Say we have some process Pexpl using the ontology presented in Example 2 (the
exact form of Pexpl is not relevant in what follows). Say we have a task node n
that is annotated with eff(n) = {claimRejected(c)}, i.e., that rejects a claim. Say we
execute n in a state s where the claim is accepted, i.e., is(claimAccepted(c)) = 1.
Which are the possible outcome states s′, with s
n→s′? By the deﬁnition of
PMA-min(is,T [C] ∧eff(n)) in Deﬁnition 4, any such state s′ must satisfy the
conjunction of effect eff(n) and axioms T . In particular, s′ must satisfy ∀x :
¬claimAccepted(x) ∨¬claimRejected(x), cf. the previous example; we refer to this
axiom with φ in the following. Together with the effect claimRejected(c), φ of
course implies that s′ must satisfy is′(claimAccepted(c)) = 0. That is, the value of
claimAccepted(c) is changed as a side-effect of applying n. Sloppily formulated,
when we apply the effect claimRejected(c) to s, then φ is invalidated and we need to
“repair” it by switching the value of claimAccepted(c).
To illustrate the frame problem, we now show how ontology axioms may lead to
ambiguities in the outcome state, namely to several alternative outcome states depending on how and to what extent the previous state is kept intact. Note ﬁrst that the
clause φ is binary (contains only two literals). This means that, whenever one of the
literals is invalidated, the other literal follows necessarily. That is, there is only one
option to “repair” the clause. For that reason, binary clauses do not lead to ambiguities. This is not so for clauses with more than two literals.
Say we extend Pexpl by an axiom stating that, if two distinct reviewers accept
a claim, then the claim is accepted overall. That is, we have the new predicates
Distrib Parallel Databases
claimAcceptedRevA(.) and claimAcceptedRevB(.), as well as the new axiom:
∀x : claimAcceptedRevA(x) ∧claimAcceptedRevB(x) ⇒claimAccepted(x)
We refer to this axiom with φ′ in what follows. Suppose about our state s from above
that is(claimAcceptedRevA(c)) = 1 and is(claimAcceptedRevB(c)) = 1. Upon executing n, as pointed out above, c is no longer accepted. So φ′ is no longer true and we
must “repair” it. Since, in difference to φ, φ′ is not binary, this spawns a non-trivial
behavior of the minimal change semantics. There are three options to “repair” φ′:
falsify claimAcceptedRevA(c), falsify claimAcceptedRevB(c), or falsify both. The
ﬁrst two options each yield a resulting state s′ ∈PMA-min(is,T [C] ∧eff(n)). The
third option does not yield a resulting state s′ because that option is not a minimal
3 Veriﬁcation tasks
We now formalize our four veriﬁcation tasks, relating to precondition conﬂicts, effect
conﬂicts, reachability, and executability. As a helper notation, we ﬁrst need to deﬁne
when two task nodes are parallel.
Deﬁnition 5 Let P = (N,E,λ,Ω,α) be an annotated process graph. For e1,e2 ∈E,
we say that e1 and e2 are parallel, written e1 ∥e2, if there exists a token-reachable
token marking t such that t(e1) > 0 and t(e2) > 0. For n1,n2 ∈NT , we say that n1
and n2 are parallel, written n1 ∥n2, if in(n1) ∥in(n2).
Deﬁnition 6 Let P = (N,E,λ,Ω,α) be an annotated process graph.
– A node n is reachable iff either n = n0 or there exist a reachable state s and an
edge e ∈in(n) so that ts(e) > 0.
– A node n is executable iff either n ̸∈NT ∪{nP
+} or, for all reachable states s with
ts(in(n)) > 0, we have that s |= pre(n).
P is reachable iff all n ∈N are reachable. P is executable iff all n ∈N are executable.
Let n1,n2 ∈NT , n1 ∥n2. We say that
– n1 has a precondition conﬂict with n2 if T ∧eff(n1) ∧pre(n2) is unsatisﬁable;
– n1 and n2 have an effect conﬂict if T ∧eff(n1) ∧eff(n2) is unsatisﬁable.
Consider ﬁrst precondition and effect conﬂicts. For illustration it is useful to consider the special case where T is empty. A precondition conﬂict, e.g., then means
there exists l ∈eff(n1) ∩¬pre(n2). Generally, precondition and effect conﬂicts indicate that the semantic annotations of different task nodes are in conﬂict: n1 jeopardizes the precondition of n2, or n1 and n2 jeopardize each other’s effects. If n1 and
n2 are ordered with respect to each other, then this kind of conﬂict cannot result in
ambiguities and should not be taken to be a ﬂaw. Hence Deﬁnition 6 postulates that
Distrib Parallel Databases
It is debatable to some extent whether precondition/effect conﬂicts represent ﬂaws,
or whether they are a natural phenomenon of the modeled process. We view them as
ﬂaws, because in a parallel execution it may happen that the conﬂicting nodes are
enacted at the same time.
Consider now the notions of reachable and executable task nodes n. Reachability
is important because, if n is not reachable, then it is superﬂuous; this certainly indicates a problem in the process model.8 As for executability, if n is not executable
then the process may reach a state where n is active—it has a token on its incoming
edge—but its prerequisites for execution are not given. If the process is being executed by a standard (non-semantic) engine (cf. Sect. 1.2), e.g. based on BPEL, then
the implementation of n will be enacted regardless of the unsatisﬁed precondition,
which may lead to undeﬁned behavior and errors. In general, the possibility to activate a task without establishing its precondition indicates that the process model does
not take sufﬁcient care of achieving the relevant conditions in all possible cases.
For illustration, consider our running example, i.e., the process from Fig. 2 and
its annotation as per Table 1. The task node “21. Close claim” has a precondition claimFinalized(c), but there is no activity whose effect provides this assertion.
Thus, this task will not be able to execute when it is activated during runtime. While
this may be due to faulty annotation (e.g., “19. Prepare claim discharge” may have
claimFinalized(c) as an additional effect), it may also be the case that another activity
“Finalize claim” is actually missing.
Reachability and executability are both temporal properties on the behavior of the
process, and of course it may be of interest to allow arbitrary veriﬁcation properties
via a suitable temporal logic (see e.g., ). We leave this open for future work.
The focus on reachability and executability is, in that sense, an investigation of special
cases. Note that these special cases are of practical interest, and perhaps more so than
the fully general case allowing arbitrarily complex quantiﬁcation which may rarely
be used in practice.
Reachability can sometimes be established as a side-effect of executability.
Proposition 2 Let P = (N,E,λ,Ω,α) be a sound annotated process graph where
α is undeﬁned for all edges and loop nodes. If P is executable, then P is reachable.
Proof Let n ∈N \{n0}. By deﬁnition, there exists a sequence ⃗e of edges from n0 to n.
By soundness and executability, and because none of the edges in ⃗e, nor any loop
nodes passed by ⃗e, are annotated with a condition, one can easily use ⃗e to construct
an execution path that reaches n.
The overall methodology we propose for debugging a given process model is to
ﬁrst remove any precondition and effect conﬂicts, and thereafter to ensure the process
is executable. Proposition 2 then implies that the process is correct with respect to all
four veriﬁcation tasks considered herein—provided there are no xor/loop conditions.
8To understand our deﬁnition of reachability, note that all nodes except parallel joins can be token-executed
as soon as one of their incoming edges is active. For parallel joins, soundness implies that, if an incoming
edge is active, then the join can be token-executed eventually.
Distrib Parallel Databases
The latter restriction is of no consequence as far as the identiﬁcation of tractable
classes is concerned, because, as we will see, in the presence of xor/loop conditions
we cannot verify reachability/executability efﬁciently anyway.
4 Checking precondition and effect conﬂicts
We now start the investigation of the computational complexity associated with our
veriﬁcation tasks. Recall that this is important (apart from its theoretical interest) because response times in the targeted application must be instantaneous, cf. Sect. 1.2.
In this section, we are concerned with checking the existence of precondition and
effect conﬂicts. We devise an algorithm consisting of two parts:
(1) We determine which pairs of tasks in the process are parallel.
(2) For each such pair the respective preconditions and effects are tested for conﬂicts.
Step (1) runs in time polynomial in the size of the process. Step (2) consists of two satisﬁability tests of the ontology axioms in conjunction with the preconditions/effects.
Hence the overall complexity is the same as that of testing satisﬁability in the logic
underlying the semantic annotations. We now consider the two steps in detail.
For step (1), one can re-use results from the Petri net literature. Namely, Kovalyov and Esparza show that, for free-choice Petri nets, step (1) can be done in
time cubic in the size of the process. In our own work, we devised an algorithm that
exploits the particular structure of our control-ﬂows, making do with quadratic time.
Since this is not of central relevance for our focus herein—it does not concern the
borderline between tractable and intractable classes—we give only a brief summary.
A full presentation can be looked up in a longer version of this paper .
In Petri nets, the “concurrency relation” is the set of pairs of places that may
contain a token at the same time, i.e., for which there exists a reachable marking
putting a token on both places. Kovalyov and Esparza devise an algorithm that
computes the concurrency relation in time O(|E| ∗(|E| + |N|)2), provided the net is
free-choice. The algorithm is initialized with a set of known pairs of parallel nodes
(transitions and places). It then performs local propagations based on a candidate set
that evolves from this initial set. For example, if a place in the pre-set of a transition
t is parallel to some other node n (i.e., a transition or place), then the post-set of t is
set to be parallel to n.
We devise an algorithm called M-propagation, which computes parallelism for
each subgraph Q ∈Sub(P) in isolation, and re-constructs the overall parallelism from
that. The runtime performance of the algorithm is O(|E|2 +Q∈Sub(P)|NQ|∗|EQ|∗
maxQ), where maxQ is the maximum number of incoming or outgoing edges any
node in Q has. Presuming that the latter number (the branching factor in splits and
joins) is ﬁxed, this means that our algorithm runs in time quadratic in the size of the
process, by contrast to the cubic time taken by ’s algorithm. This improvement
is possible because our control-ﬂows are less general than free-choice Petri nets.9
9We are not aware of any work computing concurrency, for general free-choice nets, with a better runtime
bound than ; neither are the authors of aware of any such work. In personal communication, Javier
Esparza conjectured that a faster algorithm does not exist.
Distrib Parallel Databases
The enabling property is that our loops are structured. We will show that, due to this
structure, the concurrency relation of the overall process can be directly constructed
from the separate concurrency relations computed for each sub-process individually.
Within each sub-process, the process graph is cycle-free, which means that we can
compute concurrency according to a topological order of the sub-process.
Consider a sub-process Q. M-propagation determines pair-wise parallelism for
all edges within Q. The outcome of the algorithm is a function M∗mapping pairs of
edges to Booleans, where M∗(e,e′) = 1 iff e ∥e′. M∗is computed by a propagation
algorithm, in which M∗is maintained in the form of a matrix. Initially, all edges are
set to not be parallel to themselves; everything else is set to be unknown. Each propagation step performs changes corresponding to some node n in the process whose
predecessors have all been processed already. Note here that such a strategy is possible because the graph is acyclic. The propagation step sets matrix entries for the
outgoing edges of n based on the matrix entries of its incoming edges. Task nodes,
loop nodes, and xor splits/joins do not affect parallelism and so the entries are simply copied; the only subtlety is that, for xor joins n, the outgoing edge is parallel to
an edge e ̸∈in(n) iff at least one of its incoming edges is parallel to e. For parallel
splits, the outgoing edges are marked to be pairwise parallel; otherwise the entries
are copied. The outgoing edge of a parallel join n is parallel to an edge e ̸∈in(n) iff
all its incoming edges are parallel to e. We get:
Theorem 1 Let P = (N,E,λ) be a sound process graph, and let Q ∈Sub(P). For
all n1,n2 ∈NQ
we have n1 ∥n2 iff M∗(in(n1),in(n2)) = 1. The time required to
compute M∗is O(|EQ|2 + |NQ| ∗|EQ| ∗maxQ), where maxQ is the maximum
number of incoming or outgoing edges any node in Q has.
The runtime bound here holds because each propagation step takes time at most
|EQ| ∗maxQ; |NQ| steps are performed. The time for initializing the matrix is
O(|EQ|2). To see that it sufﬁces to compute the parallelism for each subgraph in
isolation, observe the following. Say e is the incoming edge of a task node n ∈NQ
Say e′ is the incoming edge of a loop node n′ ∈NQ
L , and say that Q′ is a sub-process
of λQ(n′), or is λQ(n′) itself. If e and e′ are parallel, then any edge e′′ ∈EQ′ is
parallel to e. If e and e′ are not parallel, then no edge e′′ ∈EQ′ can be parallel to e.
Hence the overall parallelism relation can be read off the sub-graph relation and the
parallelism within sub-graphs. Since the sub-graph relation can be stored in a way so
that it can be looked up in constant time, the overall parallelism relation can be constructed from the relations of the individual sub-graphs in time O(|E|2). Hence we
obtain the overall bound O(|E|2 + Q∈Sub(P)|NQ| ∗|EQ| ∗maxQ) as stated above.
Note that parallelism according to Deﬁnition 5 is not affected by the semantic annotations, and hence M-propagation does not need to consider those; we will get back
to this shortly. First, note how we can detect precondition and effect conﬂicts.
Corollary 1 Let P = (N,E,λ,Ω,α) be a sound annotated process graph, and let
M∗be the accumulated M-propagation result for P. Then, for any two task nodes
n1,n2 ∈NT :
Distrib Parallel Databases
• n1 has a precondition conﬂict with n2 iff M∗(in(n1),in(n2)) = 1 and T ∧eff(n1)∧
pre(n2) is unsatisﬁable;
• n1 and n2 have an effect conﬂict iff M∗(in(n1),in(n2)) = 1 and T ∧eff(n1) ∧
eff(n2) is unsatisﬁable.
Using Corollary 1, it is obvious how to perform step (2) in our overall algorithm.
We detect precondition and effect conﬂicts simply by performing a loop over all pairs
of edges e,e′, and executing the described satisﬁability tests for every pair where
M∗(in(n1),in(n2)) = 1.
Since the computation of M∗is polynomial, and the number of edge pairs is
quadratic, the only source of exponential worst-case complexity is the satisﬁability testing. In other words, the borderline between tractable classes and intractable
classes is the same as that of the satisﬁability tests. When restricting, as we do, the
preconditions and effects to be conjunctions of logical atoms, then the borderline is
identical to that of the logic used for formulating the ontology axioms. Note that this
property does not depend on the particular logic we selected in our framework.
The logic we chose here—clausal formulas—has been investigated in depth in
the literature. In our particular setting, quantiﬁcation is over a ﬁnite set of constants,
hence we can compile into propositional logic. That compilation is exponential only
in the nesting depth of the quantiﬁers in the clauses. For binary clauses, the nesting
depth is bounded as soon as predicate arity is bounded, and hence binary formulas
form a tractable class for ﬁxed arity. This is a useful result because it concerns a
non-trivial class of formulas. Binary clauses can be used to specify many common
ontology properties, such as subsumption relations ∀x : G(x) ⇒H(x), attribute image type restrictions ∀x,y : G(x,y) ⇒H(y), and role symmetry ∀x,y : G(x,y) ⇒
G(y,x). With what we have just derived, precondition and effect conﬂicts can be
detected efﬁciently in processes using only such clauses.
A potentially yet much more useful class of formulas is that of Horn clauses. These
allow the speciﬁcation of implications of the form G1 ∧··· ∧Gk ⇒H, as well as
integrity constraints of the form ¬G1 ∨··· ∨¬Gk. Clearly, this language is quite
powerful. To ensure that compilation into propositional logic is polynomial-time, we
need to directly assume a bound on nesting depth. This assumption is more debatable
than ﬁxed predicate arity, but is given in some typical examples such as the Horn rule
deﬁning role transitivity ∀x,y,z : G(x,y) ∧G(y,z) ⇒G(x,z).
One important aspect of precondition and effect conﬂicts, as handled here, is the
underlying deﬁnition of “parallelism”. Deﬁnition 5 deﬁnes this exclusively based on
the control-ﬂow, i.e., two edges are parallel iff there exists a token-reachable token
marking that puts a token on both. An alternative deﬁnition would be to say that
two edges are parallel iff there exists a reachable state that puts a token on both.
We refer in what follows to the former as token parallelism, and to the latter as execution parallelism. The difference between the two is that execution parallelism, in
difference to token parallelism, takes into account the logical states. This can make
a difference in the presence of xor split and loop conditions, and in the presence of
non-executable task nodes: such constructs allow traversal only by a subset of the
token execution paths, and hence there may be less pairs of parallel edges. If a pair
of edges is execution-parallel, then it is token-parallel; but not vice versa.
Distrib Parallel Databases
To some extent, it is a matter of taste which notion of parallelism one uses as
the underlying deﬁnition for precondition and effect conﬂicts. Token parallelism has
two advantages. First, it is more conservative, not relying on the annotation of xor
splits and loops, or on non-executable task nodes, to prevent the co-occurrence of
conﬂicting preconditions/effects. Second, token parallelism leads to easier veriﬁcation problems. Determining whether or not two edges are execution-parallel is hard.
Namely, it is easy to see that the hardness results reported in Sect. 5 for reachability
hold for that problem as well. It remains an open question how to develop veriﬁcation techniques for dealing with precondition/effect conﬂicts based on execution
parallelism.
5 Computational hardness of executability and reachability checking
Precondition and effect conﬂicts are “local” in the sense that they concern only the
respective pair of nodes; whether or not some pair of nodes has a conﬂict does not
inﬂuence whether or not some other pair has. This is not so for reachability and
executability. If a node n is not reachable, then neither is any other node that can be
reached only on paths through n. If a node n is not executable, then it can be traversed
only by a particular subset of the execution paths that reach it, and hence some later
node may become unreachable, or may become executable. In that sense, reachability
and executability are more “global” phenomena. As we shall see now, this leads to
some quite unfavorable properties regarding computational complexity. We consider
four different decision problems:
(1) Is P executable, i.e., are all nodes n ∈N executable?
(2) Is a particular n ∈N executable?
(3) Is P reachable, i.e., are all nodes n ∈N reachable?
(4) Is a particular n ∈N reachable?
The difference between (1) and (2) is that, for (2), we admit the case where some
other node n′ ∈N is not executable. Similar for (3) and (4). Most of the time, this
difference does not have an impact on computational complexity. But in one particular case, (2) is coNP-hard while (1) is in P. That case is the class of what we have
termed “basic processes”:
Deﬁnition 7 Let P = (N,E,λ,Ω,α), Ω = (P,T ), be an annotated process graph.
P is basic if α is undeﬁned for all edges and loop nodes, and T is binary.
In words, basic processes restrict the ontology axioms to mention at most two
literals in each clause, and they restrict the annotations to not deﬁne any conditions
for choosing xor branches or for determining whether or not a loop is repeated. As
per Deﬁnition 4, this means that xor-branches are fully non-deterministic, i.e., the
execution is free to choose which branch to take. Likewise, the execution is free to
choose whether to repeat a loop or exit it. Intuitively, this simpliﬁes the veriﬁcation
problem because the available choices are the same regardless of what the logical
state is. The reason why binary clauses are easier for the veriﬁcation is that, with
Distrib Parallel Databases
axioms consisting only of such clauses, the outcome of an activity—i.e., the logical
state after execution of the activity—can be computed in polynomial time. The latter
is obviously not the case for general clauses, and neither, as we shall see, is it the case
for Horn clauses. We will get back to these issues below. For the moment, recall that
binary clauses are a non-trivial language that can be used to specify many common
ontology properties, cf. Sect. 4.
We prove in the remainder of this section that all the decision problems (1)–(4) are
hard for any sensible generalization of basic processes, and that decision problems
(2)–(4) are hard even for basic processes. We prove in the next section that decision
problem (1) for basic processes is in P. In that sense, basic processes form a maximal
tractable class for this kind of veriﬁcation. Our focus is exclusively on this fact, i.e.,
for the hard cases we prove only hardness and do not consider membership. Establishing the precise complexity classes of the various problems is a topic for future
We now formally state the hardness results, and explain what the sources of complexity are. We ﬁrst consider the decision problems relating to executability, then
those relating to reachability.
Theorem 2 Assume a sound annotated process graph P = (N,E,λ,Ω,α) without
effect conﬂicts, where N \ {n0,n+} ⊆NT ∪NXS ∪NXJ ∪NL, eff(n0) is a complete
assignment, all predicates have arity 0, and either P is atomic or for all n ∈NL we
have Nλ(n) = {nλ(n)
}. The following problem is p
2-hard even if P is known to
be reachable:
– Is P executable, or is n ∈N executable, given that P is basic except that T may
involve arbitrary clauses?
The following problems are coNP-hard even if P is known to be reachable:
– Is P executable, or is n ∈N executable, given that P is basic except that T may
involve arbitrary Horn clauses?
– Is P executable, or is n ∈N executable, given that P is basic except that con(e)
may be deﬁned for some e ∈E?
– Is P executable, or is n ∈N executable, given that P is basic except that con(n)
may be deﬁned for some n ∈NL?
– Is n ∈N executable, given that P is basic?
Proof Sketch: The ﬁrst two results, p
2-hardness when T is unrestricted and coNPhardness when T is Horn, are entirely due to the complexity of computing activity
outcomes, i.e., determining whether or not a particular literal is necessarily true after
a task node has been executed. The control-ﬂows used in the proof constructions are
trivial, with only 3–4 nodes arranged in a sequence. The hardness is proved via the
design of a particular set of axioms, and of the task node preconditions and effects.
Those constructions are adapted from the proofs given by Eiter and Gottlob to
show that “belief update” is p
2-hard (coNP-hard) for unrestricted (Horn) formulas.
In both cases, the axioms take a rather intricate form, assuming as input a Quantiﬁed
Boolean Formula (QBF) formula ψ = ∀X.∃Y.φ[X,Y] for the unrestricted case, and
a QBF formula ψ = ∀X.φ[X] for the Horn case. One task node nt has a single effect
Distrib Parallel Databases
Fig. 3 Schematic illustration of 3SAT reduction for Theorem 2
literal t, and the following task node n has a precondition q. The constructions are
such that ψ is valid iff q is necessarily true after nt. The latter is, of course, the case
iff n is executable.
Intuitively, the source of complexity in both cases is the need to ﬁgure out what
is true in all possible “minimal” changes to the previous state. Any candidate for
an outcome state can be tested for minimality easily, but the number of candidates is
exponential. This complexity combines unfavorably with the complexity of reasoning
about the axioms, and hence we get p
2 (rather than coNP) for unrestricted clauses
and coNP(rather than P) for Horn clauses.
For all the other results, essentially the same construction can be used, reducing the complement of 3SAT to the respective decision problem. Figure 3 shows an
illustration. The construction assumes as input a CNF formula ψ. It starts with a
parallel split/join including one xor split/join for every variable pi in the CNF formula, allowing the execution to set p to be either true or false. In this way, we allow
to generate all possible truth value assignments. Afterwards, we ﬁlter those assignments, removing all but those that comply with all clauses in ψ. The construction
used for doing so is easiest to understand for the case of xor splits annotated with
conditions. For every clause C = {l1,l2,l3} in the formula, we include an xor split
split(C) with four outgoing branches. Three of those are annotated with the condition li, for li ∈{l1,l2,l3}, and lead to the xor split for the next clause. The fourth edge
is annotated with ¬l1 ∧¬l2 ∧¬l3, and leads directly to a ﬁnal xor join just in front of
the end node. The node marked g in Fig. 3 lies at the end of the sequence of xor splits
split(C), and is hence reachable if and only if the CNF is satisﬁable. To obtain our
proof for executability, we now simply introduce a new variable q, obtain a formula
ψ′ by inserting q into every clause, perform our construction for ψ′, and make q a
precondition of the node marked g. Then, g is executable iff q is true in all satisfying
assignments to ψ′, which is the case iff ψ is unsatisﬁable. Note that g is deﬁnitely
reachable because we are free to set q to be true.
If we are not allowed to annotate the outgoing edges of xor splits, then we have to
ﬁnd a replacement for those annotations. If we are allowed to annotate loop nodes,
then we can replace the xor edge conditions with loops. Where before we had an
outgoing edge annotated with li, we now have a loop with condition ¬li, meaning
that the loop will be exited, and hence the path will be traversed, only if li is true.
For xor edges annotated with a conjunction of literals, i.e., with ¬l1 ∧¬l2 ∧¬l3, the
construction is only slightly more complicated.
Finally, consider the case where we may neither annotate xor edges not loop nodes,
but our decision problem is to ﬁgure out whether some particular node n ∈N is
Distrib Parallel Databases
executable. This decision problems allow the presence of other task nodes n′ that are
not executable. We can use such task nodes to ﬁlter truth value assignments, much in
the same way as we did before. Indeed, wherever previously we had an xor outgoing
edge e annotated with condition φ, we replace e with a construction e′ →n →e′′
where pre(n) = φ. In this way, the execution paths that pass through e are the same as
those that pass through e′′. The only difference is that, in the new construction, some
task nodes are deﬁnitely not executable—e.g., the task nodes encoding the conditions
of the ﬁrst clause are not, since any precondition li they have may be invalidated by
setting the respective variable to the opposite value.
All of the constructions are made so that, trivially, all nodes are reachable. In that
sense, the hardness of executability does not depend on the hardness of reachability.
All the constructions comply with the restrictions mentioned in the claim (in particular, the parallel split/join in Fig. 3 can be replaced by a sequence). Except for
the result regarding hardness of executability checking in basic processes, it does not
matter to the constructions whether we ask for executability of a particular node, or of
the whole process. Note that the last three results hold even for empty T , i.e., without
any clauses in the ontology.
Note that the last proof argument, i.e., the one regarding executability of a particular node n ∈N in a basic process (decision problem (2) in the above), does not
work if we ask whether all nodes are executable (decision problem (1) in the above).
In such a setting, we can no longer use task nodes to “ﬁlter” execution paths, like we
did here. Indeed, as indicated, decision problem (1) will turn out to be solvable in
polynomial time, for basic processes.
Our hardness results for reachability are closely related to those for executability.
Theorem 3 Assume a sound annotated process graph P = (N,E,λ,Ω,α) without
effect conﬂicts, where N \ {n0,n+} ⊆NT ∪NXS ∪NXJ ∪NL, eff(n0) is a complete
assignment, all predicates have arity 0, and either P is atomic or for all n ∈NL we
have Nλ(n) = {nλ(n)
}. The following problem is p
– Is P reachable, or is n ∈N reachable, given that P is basic except that T may
involve arbitrary clauses?
The following problems are NP-hard:
– Is P reachable, or is n ∈N reachable, given that P is basic except that T may
involve arbitrary Horn clauses?
– Is P reachable, or is n ∈N reachable, given that P is executable, and basic except
that con(e) may be deﬁned for some e ∈E?
– Is P reachable, or is n ∈N reachable, given that P is executable, and basic except
that con(n) may be deﬁned for some n ∈NL?
– Is P reachable, or is n ∈N reachable, given that P is basic?
Proof Sketch: Like for executability, the ﬁrst two results, p
2-hardness when T is
unrestricted and NP-hardness when T is Horn, are entirely due to the complexity
of computing activity outcomes, i.e., determining whether or not a particular literal is necessarily true after a task node has been executed. The constructions are
Distrib Parallel Databases
essentially the same as in the proof of Theorem 2. We consider a QBF formula
ψ = ∀X.∃Y.φ[X,Y] for the unrestricted case, and a QBF formula ψ = ∀X.φ[X]
for the Horn case. We still have the task node nt, and the following task node n. The
only difference is that, now, n has a precondition ¬q, rather than q. Then, ψ is not
valid iff q is not necessarily true after nt, which is of course the case iff ¬q might
be true after nt. Hence at least one execution path can traverse through n iff ψ is
not valid, and so the node behind n is reachable iff ψ is not valid. Importantly, n is
not executable: irrespectively of the precise form of ψ we can construct a path where
n’s incoming edge is active but ¬q is false. In that sense, this proof of hardness for
deciding reachability relies on the hardness of executability.
If we are allowed to annotate xor outgoing edges with conditions, then we can
use exactly the same proof argument as used for the respective result of Theorem 2,
except that we do not have to introduce the new variable q—as already stated in the
proof of Theorem 2, the node marked g in Fig. 3 is reachable iff the CNF formula ψ
is satisﬁable. If we are allowed to have annotated loop nodes or non-executable task
nodes, then, as before, we can use those to simulate xor conditions. Note here that,
in the constructions using xor/loop conditions, the process is executable, i.e., those
results do not rely on the hardness of executability.
All the constructions comply with the restrictions mentioned in the claim. In none
of the constructions does it matter whether we ask for reachability of a particular
node, or of the whole process. Note that the last three results hold even for empty T ,
i.e., without any clauses in the ontology.
As discussed in the proof sketch, for those results where executability is not explicitly mentioned in Theorem 3, the proof of hardness for deciding reachability is
due to the hardness of deciding executability. This is a necessity, not a coincidence
of our proof arguments. If the process in question is executable, then reachability
follows trivially. Namely, in the respective classes of processes, no conditions are
allowed at xor splits and at loops. With Proposition 2, this means that executability
implies reachability. Hence any reduction of a computationally hard problem to these
decision problems must make use of non-executable task nodes.
Table 2 provides an overview of our complexity results. This is rather dominated
by intractable cases. From a practical perspective, these results mean that, for all
the listed classes of processes, if we wish to build technology able to automatically
verify any process in the class, then (unless P = NP) that technology will have to
have runtime that is worst-case exponential in the size of the process. While that does
not necessarily mean that the technology will be useless, obtaining sufﬁciently quick
response times is certainly a challenge. We get back to this in Sect. 9.
Note that all the hardness results hold even without effect conﬂicts. The same restriction applies also to our positive result, i.e., our polynomial algorithm works correctly only when there are no effect conﬂicts. Hence, in the debugging of a process
model under creation, effect conﬂicts should be found and removed ﬁrst, and thereafter executability should be checked. Our positive result ensures that—to ascertain
or disprove correctness of the overall process—this last step can be performed efﬁciently. We will now discuss that result in detail.
Distrib Parallel Databases
Table 2 Overview of our complexity results. The results for deciding whether n ∈N is reachable are the
same as those for deciding whether P is reachable. All results are valid for (only for, in the case of the
membership result) processes without effect conﬂicts. For all hardness results, we can further impose that
N \ {n0,n+} ⊆NT ∪NXS ∪NXJ ∪NL, that eff(n0) is a complete assignment, that all predicates have
arity 0, and that either P is atomic or for all n ∈NL we have Nλ(n) = {nλ(n)
}. Every hardness result
for executability holds even if P is known to be reachable; the same is true vice versa for the reachability
results, except those marked (*), where executability implies reachability by Proposition 2
Class of P
n ∈N exec?
Basic but T unrestricted
2-hard (*)
Basic but T Horn
NP-hard (*)
Basic but con(e) may be def
Basic but con(n) may be def
NP-hard (*)
6 Polynomial-time executability checking for basic processes
As stated, we now presume that the process under consideration is basic, and that
it does not contain any effect conﬂicts. We design a polynomial-time algorithm determining whether or not the process is executable. Using this veriﬁcation test as a
debugging facility, the process modeler can remove ﬂaws from the process until it is
executable. Then, by Proposition 2, the process is also reachable, and thus has been
established to be correct with respect to all four veriﬁcation tasks considered herein.
Our veriﬁcation algorithm computes, for every edge e in the process, what we
call e’s state intersection: the literals that must hold true whenever e carries a token.
s∈S,ts(e)>0
where a state is written as the set of literals it satisﬁes, i.e., s = {l ∈P[C] | is |= l}.
Note that executability of a task node n is equivalent to pre(n) ⊆SI(in(n)).
The state intersections are computed by a ﬁxpoint algorithm that performs propagation steps over the process structure, maintaining for every edge e a set I(e) of
literals. We call the algorithm I-propagation. Its formal deﬁnition may be a little hard
to read at ﬁrst, but its underlying ideas are straightforward. At any point during the
execution of the algorithm, I(e) is an approximation of SI(e). The approximation is
aimed to be sound, i.e., to guarantee that literals outside of I(e) are not contained in
e’s state intersection.10 At its start, I-propagation assigns a trivially sound approximation: I(e0) is set to eff(n0), i.e., the effect of the start node n0; for all other edges
e, I(e) is set to P[C], i.e, the set of all possible literals. Thereafter, the propagation
commences. Each propagation step corresponds to a simple form of local reasoning about the consequences of (hypothetically) executing a particular process node
n, determining which literals may be invalidated by such execution. This results in
10That guarantee is not actually given in general, but is given under the conditions formally stated below
in Theorem 4. I-propagation is easiest to understand by thinking of it as a sound approximation.
Distrib Parallel Databases
a new approximation I ′(out(n)) of the state intersection of n’s outgoing edge. That
new approximation is, in general, unrelated to the previous one I(out(n)): neither is
guaranteed to contain the other. That is to say, the new approximation may (A) be
tighter than the previous one, i.e., I(out(n)) \ I ′(out(n)) ̸= ∅. But also, due to looping behavior, the new approximation may (B) be less tight than the previous one, i.e.,
I ′(out(n)) \ I(out(n)) ̸= ∅. We will give examples for (A) and (B) below. To obtain
the best of both approximations, we simply intersect them, i.e., we update our approximation of SI(out(n)) to be I(out(n)) ∩I ′(out(n)). Clearly, with this updating
rule, the sets I(e) shrink monotonically over the propagation steps. The propagations
are performed until a ﬁxpoint is reached, i.e., until no more literals can be removed.
A detailed explanation of I-propagation, including a number of examples, will
be given below. Now, we give the formal deﬁnition. For the remainder of the paper,
given a node n we write eff(n) := {l ∈P[C] | T ∧eff(n) |= l} if α(n) is deﬁned; else
we set eff(n) := ∅.
Deﬁnition 8 Let P = (N,E,λ,Ω,α) be an annotated process graph. Say α uses
the constants C. We deﬁne the function I0 : E
→2P[C] as I0(e) = eff(n0) if e =
out(n0), I0(e) = P[C] otherwise. Let I,I ′ : E
→2P[C], n ∈N . We say that I ′ is the
propagation of I at n iff one of the following holds:
1. n ∈NPS ∪NXS and
I(e) ∩I(in(n))
2. n ∈NPJ and
e′∈in(n) I(e′))
e = out(n)
3. n ∈NXJ and
e′∈in(n) I(e′))
e = out(n)
4. n ∈NT and
I(e) ∩(eff(n) ∪(I(in(n)) \ ¬eff(n)))
e = out(n)
I(e) \ ¬eff(n)
L so that λQ(n) = Q′ and
I(e) ∩I(in(n))
Distrib Parallel Databases
Fig. 4 Outcome of I-propagation on a part of the example process from Fig. 2. The literals lossEvent,
claim, claimRecorded, and claimValidated are present in all shown sets, and are omitted
+ so that Q = λQ′(n′) and
I(e) ∩I(in(n))
I(e) ∩I(in(n))
e = out(n′)
If I ′ is the propagation of I at n, then I ′ is valid, written I
n→I ′, iff I ̸= I ′.
An I-propagation path is a sequence I0
→I2 ...Ik−1
→Ik so that, for all
0 ≤j < k, Ij+1 is the valid propagation of Ij at nj+1. If I ∗is the endpoint of an
I-propagation path, and if I ∗is a ﬁxpoint, i.e., for all nodes n the propagation of I ∗
at n is not valid, then I ∗is called an I-propagation result.
Figure 4 shows the outcome of I-propagation on part of our example process. The
literals lossEvent(c), claim(c), claimRecorded(c), and claimValidated(c) are true for
all shown edges, hence they are omitted in the ﬁgure. We now explain the various
propagation steps of Deﬁnition 8 in detail. The cases discussed in the following correspond directly to the cases in Deﬁnition 8.
Splits: If n is a parallel split or an xor split, the propagation simply forwards I from
the incoming edge to every outgoing edge. This is because splits do not change the
state of the world. Note in this context that the outgoing edges of the parallel split
in Fig. 4, i.e., the incoming edges of nodes 14 and 15, have different I sets. This is
due to the effect of node 15: propagation over that node affects the incoming edge
of node 14 as per the second line of Deﬁnition 8 case 4; see also the explanation of
task nodes below.
Parallel joins: Say e′ is n’s outgoing edge. We intersect I(e′) with the union of the
sets I(e) for all of n’s incoming edges e. This is justiﬁed per the assumed absence of
Distrib Parallel Databases
Fig. 5 I-propagation over an xor join on a part of the example process from Fig. 2, showing only the
literals for claims in terms of acceptance, rejection, rejection approval, and rejection disapproval. Left:
directly on the xor join of Fig. 2. Right: a variant where the original xor join has been split up to illustrate
the behavior at xor joins
effect conﬂicts. A parallel join can only ﬁre if there is a token on all of its incoming
edges; for all such cases we know that the literals I(e) of these edges hold. Since
there are no effect conﬂicts, the sets I(e) do not contradict each other. Hence, for a
literal l to be guaranteed to hold after execution of n, it sufﬁces if l is guaranteed to
hold on one of the incoming edges. (In the presence of effect conﬂicts, the outcome
of parallel branches depends on the order of execution.) See the parallel join in Fig. 4
(subsequent to steps 14 and 15) for illustration: the I sets of the 2 incoming edges
are combined, cf. beneﬁtPaid(b,c) and claimClosed(c).
Xor joins: We set I(e′) to the intersection of the sets I(e) for all of n’s incoming
edges. This is adequate because a literal l holds after an xor join only if all paths
leading to the join guarantee that l holds (any one of the paths may be executed).11
Figure 5 shows this behavior in two variants, for the part of the process including
the sub-graph’s end node 16 and the preceding xor join. On the left-hand side, no
literal is in the intersection of the I sets of all three edges, and hence the I set of
the outgoing edge is empty. On the right-hand side, for better illustration a variant
is shown where the single xor join has been split up into two xor joins. In that
variant, ¬claimAccepted(c) holds on both incoming edges of the ﬁrst join node,
and hence holds also on the outgoing edge of that node. Note that this is not the
case for claimRejected(c), because, due to the ontology axioms in our example,
claimRejectionDisapproved(c) implies ¬claimRejected(c).
Task nodes: These are the most complicated propagation steps. By effn we denote
n’s explicit and implicit effects, containing not only eff(n) but also all its implications together with T . Note here that, if T consists of binary clauses and predicate
11Note here that we throw away any information we might have regarding what happened only in some
of the alternative executions (consider Fig. 5). For executability checking, that information is irrelevant.
It is an open topic to explore extended algorithms maintaining more information. Note that the size of
such information is likely to grow exponentially in the number of consecutive xor joins, unless clever
restrictions or approximations are made.
Distrib Parallel Databases
Fig. 6 I-propagation across an
end node, in an illustrative toy
arity is ﬁxed, then effn can be computed in polynomial time. Say n has the incoming edge e and the outgoing edge e′. Three different actions need to be performed.
(1) We write effn into I(e′). (2) We copy every literal l from I(e) to I(e′), unless ¬l
is already present in I(e′). (3) We go through the list of all edges e′′ that are parallel
to e (by M-propagation we know which edges to consider), and remove from I(e′′)
all literals l where ¬l is contained in effn.
(1) and (2) are direct consequences of the semantics of annotated task nodes, cf.
Sect. 2.2. (1) must be done simply because any effect forces a direct change on the
world. (2) must be done since the world is required to change minimally, i.e., if a
property is true before and is not affected, then it is still true. (3) deals with the
case where an edge e′′ parallel to e′ inherited a literal l which is in conﬂict with
effn (l cannot be established by the effect of a task node connected to e′′ since that
would be an effect conﬂict). In this situation, l is not guaranteed to hold whenever
e′′ carries a token: n may be ﬁred, leading to ¬l. This is best understood using an
example. Consider Fig. 4. The task node n we consider is step 15, “Operate outgoing payment”. The preceding parallel split, let’s denote it by n′, has two outgoing
edges. One of those leads to n; the other one, which we denote with e′′, leads to
step 14, “ Close claim”. Say n′ ﬁres, putting a token on both of the edges. In this
situation, we know due to the execution of step 13, “Record beneﬁt payment”, that
beneﬁtPosted(b,c) holds. Due to T , ¬beneﬁtPaid(b,c) is also certain to hold. Accordingly, I-propagation over n′ (as explained above) keeps these literals in I(e′′).
However, say n ﬁres next. Then e′′ still carries a token, but both literals have been
inverted. Hence beneﬁtPosted(b) and ¬beneﬁtPaid(b) may be false when e′′ carries a token. The two literals must thus be removed from I(e′′). (3) does that. The
annotation of e′′ in Fig. 4 shows the outcome.
Loop nodes: For a loop node n with λ(n) = Q, we intersect I(eQ
0 ) with I(in(n)).
This is adequate because an execution of the process will always enter into a loop,
due to the deﬁned do-while-semantics.
End nodes of sub-graphs: At an end node of a sub-graph, the loop can either be repeated or exited. In basic process graphs, this decision is non-deterministic. We thus
intersect both I(out(n′)) and I(eQ
0 ) with I(eQ
+ ), where λ(n′) = Q.
The behavior of this procedure is illustrated with a toy example in Fig. 6: a loop
node (1, n) contains a sub-graph (Q) with only a start (2), task (3, n′), and end
node (4). I(in(n)) comprises two literals G,H, which are copied onto I(eQ
task node (3) has the effect eff(n′) = {¬G,F}, thus replacing G with ¬G on its
outgoing edge, and adding F . This results in the set I = {F,¬G,H} at the outgoing
Distrib Parallel Databases
edge of n′; in what follows we refer to this set as I+. The propagation over the end
node of the loop copies, as described above, I+ to the start edge eQ
0 of the loop—
more precisely, I+ is intersected with I(eQ
0 ), yielding a changed I(eQ
0 ) (denoted
as I ′ in Fig. 6). Notably, bot (A) and (B) from the discussion above Deﬁnition 8
can be observed, i.e., neither I+ nor I(eQ
0 ) are a priori tighter approximations of
0 ). As for (A), I+ serves to remove further invalid literals from I(eQ
0 ): G was
beforehand presumed to be a member of the state intersection, which it is not. As
for (B), I+ contains the additional literals ¬G,F which I(eQ
0 ) already concluded
to not be contained in SI(eQ
It is important to note here that step (2) for task nodes can be done in such a
simple way only because T is restricted to disjunctions of at most 2 literals. The
minimal change semantics as per Deﬁnition 4 can get quite intricate in the presence of more complex T —cf. the proofs of Theorems 2 and 3. For illustration,
reconsider Example 3. We execute a task node with effect claimRejected(c) in a
state s where both claimAcceptedRevA(c) and claimAcceptedRevB(c) hold. Suppose that the two facts necessarily hold prior to n, i.e., claimAcceptedRevA(c),
claimAcceptedRevB(c) ∈I(in(n)). As discussed in Example 3, execution of n invalidates either claimAcceptedRevA(c) or claimAcceptedRevB(c). In particular, after
n, neither of the two facts is guaranteed to hold—although their opposites are not
implied by T ∧eff(n)! Step (2) does not recognize this, and wrongly includes both
facts into I(out(n)). Situations like this (and other more complicated situations) cannot appear when T consists of binary clauses only; hence for basic process graphs
(1) and (2) sufﬁce.
We now analyze the properties of I-propagation formally. We ﬁrst observe that Ipropagation yields a unique result, terminates in polynomial time, and is correct provided the process is executable. The reader may be alerted at this point since, as stated
above, we wish to use I-propagation for testing whether the process is executable.
We will show below that this is indeed possible. The analysis of I-propagation is
more natural, and easier to understand, when ﬁrst considering the more restricted
case where executability holds a priori.
Theorem 4 Let P = (N,E,λ,Ω,α) be an executable basic sound annotated
process graph without effect conﬂicts. Say we run I-propagation on P. There exists exactly one I-propagation result I ∗. For all e ∈E, SI(e) = I ∗(e). With ﬁxed
arity, the time required to compute I ∗is polynomial in the size of P.
Proof Sketch: The main result is correctness. First, we prove that, provided P is
executable and basic, it does not affect the state intersections to remove T and replace
each eff(n) with eff(n). The behavior for a single state and task node is the same in
both cases because, intuitively, eff(n) captures all forced consequences of T , and with
binary clauses every consequence of T is forced. The claim for the overall process
follows because the process structure is not changed, and logical states do not affect
the possible token executions when there are no xor/loop conditions and when all
task nodes are executable. We can hence, without loss of generality, assume that T is
empty (we get back to this below the proof).
Distrib Parallel Databases
Our core argument focuses on the literals that are “deleted” during I-propagation,
i.e., the literals l and edges e for which there exists an I-propagation step so that,
after that step, l ̸∈I(e). We show soundness and completeness of the literal deletion:
for soundness, if l is removed at e then there exists a reachable state s with ts(e) > 0
and s ̸|= l; vice versa for completeness.
Completeness is shown as follows. Given any execution path s0
→s1 ··· sk−1
sk, we construct a sequence I1,...,Ik by performing I-propagation of Ij at nj if
that is possible, i.e., if it results in any changes, and setting Ij+1 := Ij otherwise.
Obviously, a sub-sequence of I1,...,Ik corresponds to an I-propagation path. We
show by induction over j that, for all e where tsj (e) > 0, we have sj |= Ij(e); in
particular, if sj ̸|= l then l ̸∈Ij(e). The proof distinguishes the different kinds of
nodes nj. For example, say nj is a task node, and tsj+1(e) > 0. Then either e =
out(nj), or e ∥out(nj). In the former case, we have the induction hypothesis for
in(nj) because we must have tsj (in(nj)) > 0; in the latter case we have that property
for e itself. In both cases, it is easy to see that sj+1 |= Ij+1(e) because the propagation
step over nj deletes all literals that become false when executing nj.
Soundness is more tricky to prove. We assume an I-propagation path I0
→Ik. We prove by induction over j that, for every e and l where l ̸∈Ij(e),
there exists an execution path ending in a state s so that ts(e) > 0 and s ̸|= l. Again,
we distinguish the different kinds of nodes nj. The most tricky kind are parallel
joins. By the deﬁnition of I-propagation over parallel join nodes, we either have (a)
l ̸∈Ij(e) or (b) e = out(nj) and for every ei ∈in(nj) : l ̸∈Ij(ei). In case (a), the
induction hypothesis shows the existence of an execution path as desired, so there is
nothing to prove. For case (b), we need to construct a reachable state s′ where s′ ̸|= l
and ts′(ei) > 0 for all ei ∈in(nj); in s′, we can execute nj and are done. However,
the induction hypothesis gives us such a state only for every individual ei ∈in(nj).
For each ei ∈in(nj), we have a state si with tsi(ei) > 0 and si ̸|= l. We prove in a
separate lemma that, for every set of edges ei that are pairwise parallel and where
such states si exist, we can construct a state s′ as desired. The proof is by induction
over the process structure. The lemma makes use of the absence of effect conﬂicts:
if l ∈eff(n),l ∈eff(n′) but l ̸∈SI(out(n)),l ̸∈SI(out(n′)) due to effect conﬂicts,
then we may never be able to falsify l at both e and e′ together (an example for this
is given below this proof sketch).
The soundness arguments for the other kinds of nodes nj are similar but have a
more direct connection between induction hypothesis and claim. For xor split/end
nodes, to construct the desired execution paths we exploit the fact that, in a basic
process, an execution path may choose any outgoing edge/may choose to repeat or
exit the loop; similar for executability and task nodes.
Uniqueness follows directly from correctness. As for computation time, the main
observation consists in an upper bound for the number of propagation steps performed
by I-propagation until a ﬁxpoint I ∗is reached. Denote with ∥I∥the total number
of literals annotated by I, in sum over all edges in the process. Since I-propagation
steps always intersect their outcome with the previous outcome, and since every valid
step must make at least one change, it is obvious from Deﬁnition 8 that whenever
n→I ′ we must have ∥I∥> ∥I ′∥. If ∥I ′∥= 0, then certainly a ﬁxpoint is
reached. Obviously ∥I0∥≤|E| ∗|P[C]|, so this is the desired upper bound. With
Distrib Parallel Databases
ﬁxed arity, |P[C]| is O(|P| ∗|C|), where C is the set of constants mentioned by
α. Overall, we can derive that the runtime of I-propagation is O(|P[C]|3 + |N| ∗
|P[C]| ∗maxeff +(|P[C]| ∗maxE +|E| ∗|P[C]|) ∗|E| ∗|P[C]|), where maxeff is the
maximum number of effect literals any task node has, and maxE is the maximum
number of incoming or outgoing edges any node has.
Note that the runtime is low-order polynomial. If we assume that |P| is ﬁxed, then
the runtime is roughly cubic in the size of the process graph.
It may seem odd that we can assume an empty T without loss of generality. It is
important to note here that this holds only for the purpose of executability checking.
When removing T (and accordingly extending effects), the space of reachable states
does not stay the same, because T imposes restrictions on how particular pairs of
literals can be combined. However, that does not affect the state intersections.
To illustrate why we need to disallow effect conﬂicts, consider the following example. We have a parallel split node nsplit, a parallel join node njoin, and four task
nodes n1¬p, n2¬p, n1p, n2p where each ni¬p has the effect ¬p and each nip has
the effect p. The edges are (nsplit,n1¬p), (nsplit,n2¬p), (n1¬p,n1p), (n2¬p,n2p),
e1 := (n1p,njoin), e2 := (n2p,njoin). That is, we have two parallel branches, on each
of which p is ﬁrst made false and then made true. Consider the edges going into the
join node, e1 and e2. Even though e1 is the outgoing edge of a task node with effect p, we have p ̸∈SI(e1) because n2¬p may be executed while e1 still carries a
token—note here the effect conﬂict between n1p and n2¬p. The same is true of e2,
i.e., p ̸∈SI(e2). So for each ei there exists a reachable state where ei is active and p
is false. However, there does not exist a reachable state where both ei are active and p
is false! If both ei are active then either n1p or n2p was executed last, so p is necessarily true. In consequence, p ∈SI(out(njoin)); since p ̸∈SI(e) for any e ∈in(njoin),
this means that, in the presence of effect conﬂicts, the state intersection of the outgoing edge of a parallel split is no longer a function of the state intersections of the
incoming edges. It is currently an open issue whether this problem can be overcome
by maintaining supplementary information during I-propagation, in addition to the
sets I(e); see also the outlook in Sect. 9.
Theorem 4 presumes that the process is executable. For checking whether that is
the case, of course we cannot make that assumption. The key observation here is
that, if the process is not executable, and even if xor/loop conditions are deﬁned, the
outcome of I-propagation is conservative.
Lemma 1 Let P = (N,E,λ,Ω,α) be an annotated process graph without effect
conﬂicts, which is basic except that α may be deﬁned for edges and loop nodes. Say
we run I-propagation on P, and I ∗is an I-propagation result. Then, for all e ∈E,
SI(e) ⊇I ∗(e).
Proof Sketch: This is surprisingly easy to show by considering the modiﬁed process
P0 = (N,E,λ,Ω,α0) which is like P except that all preconditions and all xor/loop
conditions have been removed. Obviously, Theorem 4 applies to P0 and so in particular we get completeness of literal deletion, i.e., SIP0(e) ⊇I ∗
0 (e) for all e ∈E,
where SIP0(e) is the state intersection for P0, and I ∗
0 is an I-propagation result for
Distrib Parallel Databases
P0. The claim then follows because the execution paths of P are a subset of those
of P0; hence the state intersections in P are supersets of the respective ones in P0;
hence SI(e) ⊇SIP0(e) ⊇I ∗
Putting Theorem 4 and Lemma 1 together, we immediately get our two main results regarding executability checking.
Theorem 5 Let P = (N,E,λ,Ω,α) be a basic annotated process graph without
effect conﬂicts. Say we run I-propagation on P, and I ∗is an I-propagation result.
Then P is executable iff for all n ∈NT ∪{nP
+} : pre(n) ⊆I ∗(in(n)).
Proof Sketch: First, clearly P is executable iff, for every n ∈NT ∪{nP
+} : pre(n) ⊆
SI(in(n)). If P is executable, then Theorem 4 applies, meaning that I ∗(in(n)) =
SI(in(n)) and hence pre(n) ⊆I ∗(in(n)). If P is not executable, then Lemma 1
applies, meaning that I ∗(in(n)) ⊆SI(in(n)). So if l ∈pre(n) \ SI(in(n)), then
l ∈pre(n) \ I ∗(in(n)) and hence pre(n) ̸⊆I ∗(in(n)).
Theorem 6 Let P = (N,E,λ,Ω,α) be an annotated process graph without effect
conﬂicts, which is basic except that α may be deﬁned for edges and loop nodes.
Say we run I-propagation on P, and I ∗is an I-propagation result. Then, for all
n ∈NT ∪{nP
+}, if pre(n) ⊆I ∗(in(n)) then n is executable.
Proof Sketch: Say that n is not executable. Then l ∈pre(n) \ SI(in(n)), for some l.
With Lemma 1 we have I ∗(in(n)) ⊆SI(in(n)). Hence l ∈pre(n) \ I ∗(in(n)), and
pre(n) ̸⊆I ∗(in(n)) in contradiction.
Theorem 5 means that, for basic processes, we can use I-propagation for executability checking, as desired. We simply run I-propagation up to its ﬁxpoint and
check whether all precondition literals remained at the respective edges. Theorem 6
constitutes a weaker kind of veriﬁcation, providing a sufﬁcient but not necessary test
for correctness. Note, however, that this test is applicable to individual task nodes,
not only to the overall process. If, for any individual task node n, pre(n) ⊆I ∗(in(n)),
then n is executable. This result holds (provided T is binary) even in the presence of
xor conditions, loop conditions, and (other) non-executable task nodes. Hence, even
under such circumstances, we can use Theorem 6 to ascertain the correctness of some
nodes, and to point out potential bugs regarding others.
7 Prototypical implementation
The presented work is implemented as a back-end prototype that is used in three
front-end applications at SAP Research. The back-end component implements the
algorithms devised herein, on a generic level as presented. The front-end components
are integrated prototypes with graphical user interfaces tailored for speciﬁc scenarios.
The back-end prototype is implemented in Java. The implementation is comparatively simple: the main algorithms, i.e., M-propagation and I-propagation, each consist only of a few hundred lines of code. Even without any code optimizations, the
Distrib Parallel Databases
backend component performs quite well. For example, a non-trivial process with 40
nodes and 46 edges was processed in 0.2 seconds on a Pentium M CPU running at
1.6 GHz, with negligible memory consumption. Considering in addition to this that
the worst-case behavior is low order polynomial in the number of nodes and edges,
performance is unlikely to be problematic in typical real-world settings.
Two of the front-end prototypes use our veriﬁcation methods within a process
modeling environment, in an online setting where the modeler frequently checks for
bugs, as described in Sect. 1.2. Note that it is of paramount importance that the annotation function α as per Deﬁnition 3 is allowed to be partial: otherwise, we would
force the modeler to completely annotate every task in the process up-front, rather
than adding the annotations as needed and useful.
Presuming that the process in question is basic as per Deﬁnition 7, based on our
techniques the modeler debugs a process as follows: (1) ﬁnd and remove any precondition/effect conﬂicts; and (2) thereafter remove any bugs leading to non-executable
task nodes. Once (1) and (2) are completed, reachability follows by Proposition 2.
Hence, at that point, the resulting process is correct with respect to all four veriﬁcation tasks identiﬁed herein.
In what follows, we give a brief outline of the three front-end prototypes, in turn.
We conclude the section with a discussion of the practical difﬁculty of writing ontologies.
7.1 Maestro
Maestro is a process modeling tool, developed at SAP Research, for the BPMN notation. Maestro is mainly used for early prototyping. The tool has been extended to
allow for semantic annotation, as proposed in . It has been integrated with service discovery and service composition facilities, as well as the veriﬁcation
functionality described herein. The tool was presented in the form of a demonstration
at DASFAA 2009 . A screenshot of the tool is shown in Fig. 7. In the screenshot,
a semantic annotation can be seen for the “Customer Quote” document, shown as a
BPMN data object above the “Submit quote to customer” task. The object and task
are associated via an edge showing the semantic annotation: “< approved (Customer
Quote)” indicates that “approved” is a precondition; “> sent (Customer Quote)” indicates that “sent” is an effect. Both annotations refer to the status of the Customer
Quote object, prior respectively after execution of the task. In the situation shown,
I-propagation has just been performed, and the task “Submit quote to customer” is
highlighted in red to indicate that it is not executable. The reason for that—the precondition whose truth is not guaranteed—is shown in the text window at the bottom
of the screenshot.
7.2 SAP NetWeaver BPM process composer
SAP NetWeaver BPM Process Composer is the modeling part of SAP’s future product for Business Process Management:
Distrib Parallel Databases
Fig. 7 Screenshot of Maestro for BPMN. Semantic annotations are associated with edges between BPMN
data objects and tasks. The task “Submit quote to customer” is highlighted in red to indicate that it is not
executable
“SAP NetWeaver BPM delivers a suite of state-of-the-art, standards-based tools that
enable customers to quickly and efﬁciently model processes and execute them
without time-consuming, error-prone coding. It leverages the service-enabled
functionality of SAP Business Suite applications, and of third-party software, to
create and modify processes. This ultimately leads to signiﬁcant increases in speed,
ﬂexibility, quality and time to value.”
We implemented a research extension to the tool suite, comprising semantic annotation of tasks, service composition methods , as well as our veriﬁcation methods.
The extensions may undergo a pilot customer evaluation project in the next years.
Due to the complexity of such a commercialization process, and due to re-structuring
activities within SAP, a more deﬁnite statement cannot be made at the time of writing.
Screenshots are shown in Fig. 8. The bottom part of the ﬁgure shows how a nonexecutable task is highlighted, in a fashion similar (if differently visualized) to Maestro above. A more remarkable feature of the prototype is the ease of creating semantic annotations. As shown in the top part of Fig. 8, from the point of view of the user
this amounts to selecting values in drop-down menus. The user double-clicks a task
to open the window shown in the bottom right of the screenshot. She can then select the “Initial conditions” (the preconditions) and “Goals” (the effects) for the task.
Both is done via selecting business objects from a drop-down menu (left hand side
in each of “Initial conditions” respectively “Goals”), and afterwards selecting their
desired status value from another drop-down menu (right hand side, shown open for
Distrib Parallel Databases
Fig. 8 Screenshots of the SAP NetWeaver BPM Process Composer, with our extensions. Semantic annotation (top) is done via simple drop-down menus. Executability checking (bottom) is a push-button
operation highlighting erroneous tasks
“Initial conditions”). This interface, of course, assumes that the business objects and
their possible states have been modeled beforehand. Such modeling is, fortunately
for our approach, a well-established activity at SAP anyway; we will get back to this
below in Sect. 7.4. What’s important to note for now is that, once such a model has
been established, doing the actual annotations is a matter of a few commonly used
mouse movements.
Distrib Parallel Databases
The question remains how easy the concept of semantic annotations, and their suitable content, will be to grasp, for SAP customers. The prospects appear to be good.
The annotations are made in terms of business object states. That is the language of
business users—standard terms from business administration, logistics, etc.—not the
language of developers. It can be expected that SAP customers will be familiar with
the language, and ﬁnd it easy to deal with. That said, an actual customer evaluation
has not yet been performed, and remains an open topic.
7.3 Automatic service conﬁguration for service brokers
This application differs considerably from the BPM scenarios above, for which the
presented work was originally performed. However, the application uses the same
back-end component. The application addresses service marketplaces, which are
nowadays steadily gaining momentum. In a service marketplace, services from a variety of service providers can be registered, published, advertised, discovered, and
brokered. Marketplace brokers manage the “front-desk” of service marketplaces, brokering the trade between service providers and consumers. In separate work , we
provide technology aimed at lowering the entrance barrier for service providers, i.e.,
reducing their effort for registering services with a broker. Such registration requires
utilization of the broker’s service delivery management components. For doing so,
a suitably combined process must be composed. Our technology helps with this activity, based on simple semantic annotations not unlike the ones used in the aforementioned prototypes. The technology can automatically ﬁlter the available options,
and it can automatically suggest process fragments. The back-end provided herein,
speciﬁcally I-propagation, is required by both these features for determining the possible execution states of the involved processes.
7.4 How to obtain the ontologies?
The creation of ontologies is a time-consuming and error-prone task. Clearly, this
may seriously impede the practical usefulness and uptake of our technology—a problem we share with many approaches in the Semantic Web area. The cost of modeling
is the prize to pay, and at this stage it cannot be predicted how serious the problem is,
or under which circumstances. That said, our speciﬁc approach has two aspects that
make the problem seem manageable at least in some applications:
1. Ontologies are a possibility, not a requirement. Our methodology allows the speciﬁcation of ontologies; it does not enforce them. Recall that ontologies (P,T )
consist of two parts: their terminology (the predicates P ) and their axiomatization
(the theory T ). Clearly, the main difﬁculty is to obtain T ; P will often be easy
to come by based on pre-existing terminology (cf. point 2 below). For our algorithms to work, only P is required. More importantly, the problem we address
remains substantial, even without axiomatizations, both in theory and practice.
All our hardness results regarding xor/loop conditions, as well as reachability and
individual-task executability checking, hold with empty T . Similarly, axiomatizations are no source of complications for I-propagation. That algorithm is tailored
Distrib Parallel Databases
for the use with binary clauses, which may be compiled away prior to even starting the algorithm (cf. the proof of Theorem 4). From a practical perspective, it
is quite conceivable that one may make do without complicated axiomatizations.
For example, such axiomatizations are not present in our extension to the SAP
NetWeaver BPM Process Composer. Even when reducing the annotation to simple keywords—predicates without any arguments—the veriﬁcation may still yield
useful insights into the process structure, so long as the same keywords are used
across different tasks in the process.
2. We can leverage existing models at SAP. As hinted above in Sect. 7.2, our approach combines naturally and effortlessly with existing models and methodologies at SAP, particularly those underlying SAP NetWeaver. In the relevant applications, data is warehoused in the form of the content of business objects. Individual
transactions change these contents, and thereby the information contained in the
warehouse. Each task in a business process corresponds—depending on the level
of abstraction of the process—to a single transaction or to a combination thereof.
In any case, the behavior of the task can be naturally expressed in terms of how it
affects the relevant business objects. Now, annotating the latter in full is not feasible; a single object may contain thousands of attributes. However, motivated by
precisely that complexity, SAP has developed models at an intermediate level of
abstraction, where the content of each object is represented in terms of a number
of high-level status variables. While these models were originally designed for
very different purposes, we can use these very same models as the input for our
technology. Indeed, this is exactly what underlies the implementation shown in
Fig. 8. In other words, leveraging existing models at SAP, we obtain the ontology
for free! Plus, the ontology is exhaustive (>400 business objects and their status
variables), and the potential customers are already familiar with its terminology.
Interestingly, the SAP model even gives an example of how ontologies—and
speciﬁcally the clausal theories we consider herein—can be put to productive use.
There are several kinds of dependencies between status variables that are not represented in the current model. Current work at SAP Research addresses this shortcoming. The dependencies can be conveniently expressed in terms of the clausal theories
we consider herein. Formalizing all the dependencies of course involves intensive
cooperation with the relevant development groups at SAP. This is currently ongoing.
8 Related work
We give an overview of related work, and we discuss in detail the most relevant
technical connections to our work. Such a connection mainly exists to the area of
Petri nets, which has been used as the basis for control-ﬂow veriﬁcation, and where
tractable classes have been identiﬁed. Since our focus is on checking the properties
of a model, the ﬁeld of model checking is, of course, related as well. Finally, there
is a growing body of work extending process models and their veriﬁcation beyond
control-ﬂow. We review these three areas in turn, after brieﬂy discussing our own
related work.
Distrib Parallel Databases
8.1 Own related work
Some predecessors of the presented work have discussed, from a general perspective,
the use of semantic technology in BPM . Our tools have been showcased as
demonstrations, partially related to this work .
Earlier versions of the presented work have been published at the Semantic BPM
Workshop 2008 , and at ECOWS 2008 . The present paper goes far beyond
these works not only in terms of detail of write-up, but also in terms of technical
results. Most importantly, the previous versions restricted the processes to be plain
DAGs, i.e., to not contain any loops. The addition of loops required a signiﬁcant extension to nearly all technical devices of the paper, most particularly to I-propagation
whose correctness is much easier to understand and prove when not dealing with
There are some works that build on I-propagation, for the purpose of compliance
checking. One line of work uses the outcome of I-propagation to approximate the truth status of clausal compliance constraints, i.e., clauses constraining the
desired process states (not to be confused with the clauses herein, which form part of
the execution semantics of the process). Another line of work modiﬁes I-propagation
(without loops) to propagate reparation chains over deontic logic primitives .
None of these works has I-propagation, as devised herein, as its original contribution.
8.2 Petri nets
Petri net theory has come up with a wealth of complexity results for various classes of
Petri nets, including in particular tractability results for a number of restricted classes.
We already discussed in Sect. 4 how one of these results can be exploited to determine parallel task nodes in our framework, which is half of the job of ﬁnding all
precondition/effect conﬂicts. Task node parallelism does not depend on the annotation, hence this is an application of Petri net theory to non-annotated process graphs.
We can also obtain an application to annotated process graphs, via compiling such
graphs into Petri nets. However, the results obtainable in this way are substantially
weaker than what we proved herein.
How can annotated process graphs be compiled into Petri nets? First, in the presence of ontology axioms, clearly such a compilation is not possible, at least not in a
straightforward/natural way. Petri nets do not cater for a “minimal change semantics”
of transitions between states. Note that this is quite fundamental, as is reﬂected e.g.
by the complexity of determining the truth of a literal in the outcome state, which
is coNP-hard for Horn axioms and p
2-hard in general, cf. the proof of Theorem 2.
Encoding this into a Petri net would require to encode each task node into some form
of worst-case exponential search.
If there are no ontology axioms (or, as far as executability checking is concerned, if
the axioms are binary, cf. the proof of Theorem 4), then a straightforward compilation
exists. Encode each task as a transition, and encode edges as places. Joins and splits
can then be encoded using the rules deﬁned in . Loops, i.e., transitions into and
out of sub-graphs, are encoded in the straightforward fashion. Next, enumerate all
Distrib Parallel Databases
facts that can be built from the predicates and constants. Create an additional place
for each fact, as well as one for its negation. Add an arc for each precondition/effect
literal to the respective place; similarly, encode xor/loop conditions.
Apart from the process structure, we also need to express our veriﬁcation tasks in
terms of Petri net queries. Reachability in the annotated process model is equivalent
to the question whether the control ﬂow pre-place of a task may ever carry a token.
Executability in the annotated process model is equivalent to the question whether,
whenever the control ﬂow pre-place of a task carries a token, the precondition preplaces carry a token as well. To ask whether a particular task node n is executable,
we need to ask for every precondition p of n whether a state is reachable where the
control ﬂow pre-place of n carries a token, but p does not. To ask whether the overall
process is executable, we need to ask these questions for every task node.
To test reachability in our annotated process graph, we hence need to be able to
test, in a Petri net, whether a given place can be active. This is a fairly common query
for Petri nets. To test executability, we need to be able to test whether a given place
p can be active while another place p′ is not. This is a rather unusual query. It is
related to what has been termed “implicit places” (see e.g. ). An implicit
(or “redundant”) place is a place p′ that always carries a token if any other place
p does, where p and p′ occur together in the input of any transition. Note that this
notion refers to all transitions and places p, while what we are interested in is the
connection (if any) between p′ and one particular place p. It is an open question
whether techniques for detecting implicit places can be adapted to perform this kind
of test. We remark that the only known polynomial-time technique to detect implicit
places is the detection of “structural implicit places” , which are a special case
of implicit places; i.e., this technique corresponds to a sufﬁcient but not necessary
criterion for executability and is hence not a veriﬁcation method in our sense.
What we can derive are two tractable classes for checking reachability. A closely
related topic was previously investigated by , who are concerned amongst other
things with a Petri net based formalization of compositions of semantic Web services,
and with veriﬁcation of reachability. Narayanan and McIlraith use a formalism
that does not encompass any ontology axioms, but that is otherwise closely related to
ours. They use a Petri net encoding similar to what we sketched above. They state two
tractability results, based on restricting the process in a way so that the compiled Petri
net becomes free-choice , respectively conﬂict-free . These results, in the
form stated in , are slightly ﬂawed—the stated restrictions do not sufﬁce to make
the Petri net free-choice/conﬂict-free. However, the results can easily be repaired, by
imposing more restrictions. We have:
(1) If every literal l appears in at most one task node precondition, xor condition, or
loop condition, then the compiled Petri net is free-choice.
(2) If the process has no loops and no xor splits, and for every fact p we have that
either p is not made false by any task node, or is contained in the precondition of
at most one task node, then the compiled Petri net is conﬂict-free.
Both for free-choice and conﬂict-free Petri nets, it can be decided in polynomial time
whether there exists a reachable marking activating a given place. Hence, (1) and
(2) identify tractable classes for checking reachability in annotated process graphs.
Distrib Parallel Databases
These tractability results are not implied by our results—we propose to establish
reachability as a side-effect of establishing executability, in a class of processes where
reachability checking is NP-hard. Note that class (2) is a subset of the tractable class
we identify,12 and a very restricted one at that. Hence this class is considerably more
impractical than ours. Class (1), on the other hand, could be useful since it allows
xor/loop conditions, albeit in a restricted form. The tractability of reachability in class
(1) clearly is complementary to the results proved herein.
8.3 Model checking
Model checking is concerned with checking the properties of some formal model
of a piece of software or hardware under consideration; see as an entry point
into the vast amount of literature. There are two key differences to our work. First,
model checking has not been concerned with ontologies, i.e., with ontology axioms
that form part of the model to be checked. Like for Petri nets, this is a fundamental
difference to our approach, and a natural encoding into traditional model checking
formalisms is not possible. Hence we can only consider the restricted case where the
axioms are empty (or, as far as executability checking is concerned, where all axioms
are binary clauses).
The second major difference to model checking is that model checking has traditionally not been concerned with the identiﬁcation of tractable fragments, which is
the core contribution of our work. Model checking is usually concerned with very
general formalisms, which are far from tractable. The focus then is on theoretical
analysis of algorithms addressing such formalisms, and on the development of search
techniques for enhancing empirical performance, such as symbolic representations
(e.g. ), constraint propagation (e.g. ), search space reduction (e.g.
 ), and clever implementation techniques (e.g. ). In our view, the main importance of model checking for our work lies in the potential of applying (adaptations
of) these search techniques to the intractable cases identiﬁed by Theorems 2 and 3.
We have already performed an initial experiment in this direction; we will get back
to this in the outlook, Sect. 9.
8.4 Beyond control-ﬂow
Veriﬁcation of process models has been studied for quite a while, mostly from a
control ﬂow perspective. In this context, different notions of soundness have been
proposed; for an overview see . There is a growing body of contributions beyond
pure control-ﬂow veriﬁcation. Those relate to semantic checks and data ﬂow analysis.
The approach of checks a notion of semantic correctness that builds on
annotations to tasks as being mutually exclusive or dependent. In the ﬁrst case they
cannot co-occur in a trace, in the second case they must appear in a certain order.
For semantic correctness the process must comply with the annotations. This approach provides somewhat similar features as linear temporal logic . This kind
12There are no ontology axioms; with no loops and no xor splits, clearly there cannot be any xor/loop
conditions; the restriction on facts implies that there can’t be any effect conﬂicts.
Distrib Parallel Databases
of annotations can be simulated using a subset of our framework (using only preconditions/effects, with an empty ontology). In that sense, can be viewed as a
special case of our framework.
In the area of access control the approach of extends process models with predicates, constants, and variables. The meaning of these constructs relates to constraints
on role assignments, while in our model they directly affect the executability of tasks.
The work of describes methods to check compliance of a process against rules
for role assignment. This is related to our approach in that an ontology could (to some
extent) be deﬁned to model such rules; but not vice versa since we build on general
logic while covers some practical special cases. The paper by addresses
amongst others life cycle compliance. This can be partly reformulated in terms of
preconditions, effects, and ontological axioms. Our running example illustrates some
constraints related to the life cycle of business objects, i.e., when certain actions can
only be performed if the business object is in the required state.
In , the preconditions and effects of service compositions are calculated on the
basis of atomic services of which the compositions consist. Similar to our approach,
the preconditions and effects of the atomic services are formulas, and the processes
are assumed to be sound, have a single start and end node, respectively, and the routing constructs are and/xor join/split. However, Meyer does not deal with loops
and neither with ontological axiomatizations. There is no formal discussion of the
algorithms or their properties. In particular, there is no proof of correctness and no
consideration of complexity. The algorithm is based on computing the reachability
graph of the composition’s workﬂow, which is exponential in size of the workﬂow.
This is in contrast to our investigation of polynomial time algorithms.
In , based on annotations of task nodes with logical effects, the authors use a
propagation algorithm somewhat reminiscent of our I-propagation. There are, however, a number of important differences between the two approaches. Koliadis and
Ghose allow CNF effects which are considerably more expressive than our
purely conjunctive effects. On the other hand, their propagation algorithm is exponential in the size of the process (the size of the propagated constructs multiplies
at every XOR join). Further, Koliadis and Ghose circumvent the consideration
of loops, by assuming that entire sub-processes are annotated with effects. That is,
sub-processes are handled as if they were atomic task nodes. This makes the analysis
simpler, but, obviously, seriously impedes the ability to model sub-processes at a ﬁne
granular level. Koliadis and Ghose do not consider preconditions, and they do
not consider ontology axioms constraining the domain behavior. Finally, do not
provide a formal semantics for their effect annotations, and consequently, in difference to us, do not prove any formal correctness properties for their algorithms.
Another related line of work is data ﬂow analysis, where dependencies are examined between the points where data is generated, and where it is consumed; some
ideas related to this are implemented in the ADEPT system . Data ﬂow analysis
builds on compiler theory where data ﬂows are typically examined for sequential programs mostly; it does neither consider theories T nor logical conﬂicts, and
hence explores a direction complementary to ours. To some extent, our concepts can
be applied in this area by expressing data dependencies as preconditions, effects, and
ontological axioms.
Distrib Parallel Databases
ADEPT also provides a major contribution on the problem of process schema
evolution . In the latter area, also techniques from AI planning have already been
combined with workﬂow concepts . These combinations, however, have
a very different purpose—and hence take a very different form—than the combination of workﬂows with AI that we develop herein. Whereas we aim at veriﬁcation
and hence deﬁne a formal state-based execution semantics, the previous approaches
aimed at automatically creating new/adapted processes based on plan-like representations of the dependencies between process steps. Apart from that, a distinguishing
feature of our approach is the handling of axiomatizations. Recall (cf. the discussion
below Deﬁnition 4) that this impacts the formalization quite substantially, necessitating to deal with actions and change in the presence of state axioms. Finally, none
of these previous works investigated the borderline between tractable and intractable
9 Conclusion and discussion of open questions
Reducing the time span for design and deployment of process models is a very relevant problem . Towards this end, we devise a veriﬁcation method exploiting semantic annotations. Our formalism is unique in the way it combines notions
from the workﬂow community and from the AI literature, providing an execution semantics that integrates control-ﬂow with logical preconditions and effects relative to
an ontology. Based on the formalism, one can detect execution problems in process
graphs with sound control ﬂow, hence enabling veriﬁcation beyond soundness.
We have investigated the tractability borderline of such veriﬁcation, which is important because response time is a critical factor in practice. For precondition/effect
conﬂicts, we have shown that the borderline is the same as that of reasoning in
the logic underlying the ontology axioms. We have determined the class of basic
processes, where, presuming effect conﬂicts have already been removed, executability of the overall process can be checked in polynomial time. The latter is not the case
for any of the most relevant extensions of basic processes, so the class is maximal in
that sense. Our algorithms are implemented within two BPM modeling environment
prototypes, which show that user-friendly interfaces can be designed, and that ontologies can (sometimes) be obtained cheaply, by leveraging existing models.
One line of current research regards the enhancement of the SAP model underlying
our SAP NetWeaver application, making explicit the dependencies between status
variables. The most important open issue, in our view, is that of customer evaluation.
As we stated in Sect. 7, such evaluation of our SAP prototypes is on the agenda, but at
the time of writing it is not foreseeable when the evaluation will actually take place.
Apart from that, several technical points are left open by our current results.
One question is whether executability of basic processes can be veriﬁed efﬁciently
also in the presence of effect conﬂicts. If so, then the debugging facility provided
becomes more ﬂexible, allowing to check executability without prior removal of effect conﬂicts, and allowing to tolerate effect conﬂicts (to not view them as bugs) in
case such behavior is intended. Further, such a solution would enable us to deal with
precondition/effect conﬂicts based on execution parallelism (cf. Sect. 4) rather than
Distrib Parallel Databases
token-parallelism. This is because, for executable basic processes, the two notions of
parallelism are equivalent. Hence the modeler could establish executability ﬁrst, and
thereafter use the algorithms from Sect. 4 to tackle precondition/effect conﬂicts based
on execution parallelism.
An important open line of research regards the intractable cases we identiﬁed.
Computational hardness is certainly a challenge for veriﬁcation in an online setting,
but not necessarily a deal-breaker. If the process models are not too large, and if the
veriﬁcation makes use of advanced search techniques (like symbolic representations,
constraint propagation, search space reduction, or process decomposition), then the
response times may be tolerable. We have made some initial experiments encoding
processes with empty ontology (no axioms) for the explicit-state model checker SPIN
 . The results are not encouraging, taking excessive runtime and/or memory even
in fairly small processes. However, certainly that is not the end of the story. The
performance of SPIN can possibly be improved by using different encodings, or some
algorithmic extensions to SPIN (e.g. ). Also, one option we deem particularly
promising is the use of SAT solvers (e.g. ) for the veriﬁcation, in the style of
the bounded model checking approach . In some cases, a single SAT call sufﬁces
for testing whether a particular node is executable. For example, we have already
shown that this the case for basic processes without loops.
Another topic is to enhance the debugging information returned by the veriﬁcation. The techniques presented herein provide only minimal information, namely the
process nodes that are directly involved in a failure. It would be more desirable to
return some approximation of what may cause the failure, and perhaps to make suggestions for bug ﬁxes. We have made some initial steps in that direction, based on
the local information obtained by I-propagation, i.e., the information pertaining to
particular edges in the process. Using this information, unsatisﬁed preconditions can
be traced back to activities that contribute to validating/invalidating them .
Last but not least, a long term research topic remains to investigate richer semantic
annotations. In particular, an investigation of Description Logic , variants of which
are widely used in the semantic Web community (e.g. ), would be
desirable.
Acknowledgements
We would like to thank the anonymous reviewers for their excellent feedback and
insights. Further, we want to acknowledge the contributions of Ulrich Benz during the early beginnings of
this work. Part of this work has been supported by the EU Integrated Project SUPER and the Australian
SmartServices CRC.
Appendix: Proofs
A.1 Control-ﬂow properties
If two edges are parallel, then, in particular situations, we can “choose” which one to
activate last:
Lemma 2 Let P = (N,E,λ) be a sound process graph. Let e ̸= e′ ∈E so that e ∥e′,
and e ∈out(n) where n ̸∈NPS. Let t′ be a token-reachable token marking where
Distrib Parallel Databases
t′(e) > 0 and t′(e′) > 0. Then there exists a token-reachable token marking t so that
Proof Since e ∥e′, we know that t′ as claimed exists. Say t′ is reached on the execution path ⃗p = ⟨t0
→tk⟩where t0 is the start marking and tk = t′. By
prerequisite we have tk(e) > 0. Deﬁne i to be the highest index of a marking that
activates e, i.e., ni−1 = n and consequently ti(e) > 0, such that e remains activated
until tk. That is, we have: (*) for all i ≤j ≤k : tj(e) > 0.
Now, consider the token markings ti−1 and ti, as well as the nodes ni−1 = n and ni.
We know that n is executable in ti−1, and that ni is executable in ti. We prove that
we can re-order n and ni in ⃗p, and still obtain a valid execution path. Once this
is proved, we are done: iterating the argument, we can move n upwards in ⃗p and,
ultimately, execute it last.
Consider the re-ordered sequence ⟨t0
i+1⟩. It sufﬁces to
show that:
1. ni is token-executable in ti−1,
2. ni−1 = n is token-executable in t′
i+1 = ti+1.
As for 1., we know that ni is token-executable in ti, which differs from ti−1 only in
that n is executed beforehand. Observe that executing n puts a token only on e. This
is obvious for non-split nodes, which have only a single outgoing edge. For xor splits
it is clear because otherwise we would not have ti(e) > 0, in contradiction to (*). This
covers all cases because by prerequisite n is not a parallel split. Now, ni cannot have e
as an incoming edge: tokens from incoming edges are always removed by deﬁnition,
except for xor joins. But incoming edges of xor joins cannot be parallel: the process
is assumed to be sound so that would be a contradiction to Proposition 1. Thus, if ni
had e as an incoming edge, then we would not have ti+1(e) > 0, in contradiction to
(*). Hence ni must be executable in ti−1 already, as desired.
As for 2., we know that n is token-executable in ti−1. This differs from t′
in that ni is not executed beforehand. Now, token-executability of n (of any node)
depends of course only on the activation of n’s incoming edges, and execution of
ni (of any node) removes tokens only from its incoming edges. Hence, if n is not
executable in t′
i, then we can derive that in(n) ∩in(ni) ̸= ∅, which is of course not
possible since every edge has exactly one target node.
As for 3., we have already seen that ni does not consume any tokens set by n.
Likewise, it is obvious that n does not consume any tokens set by ni, or else n could
not be executed prior to ni in ⃗p. Hence the effects of the nodes on the token structure
are mutually independent, from which the claimed property follows. This concludes
the argument.
In the next lemma, and at some points further below, we will make use of ﬂow
orderings. Given a process graph, a ﬂow ordering is a bijective function # : E
{0,...,|E| −1}, numbering the edges such that (i) every incoming edge of a node
has a lower number than any of the node’s outgoing edges, and (ii) all outgoing edges
of a split node are consecutively enumerated. Flow orderings obviously exist, since
Distrib Parallel Databases
(N,E) is acyclic. For example, a ﬂow ordering results from a breadth-ﬁrst traversal
of the process graph. We assume in the rest of the paper that, for every process graph
under consideration, a ﬂow ordering # is ﬁxed. This is just a simple device to be
able to more conveniently state certain proof arguments. We use the following helper
notations. #−1 is the inverse function of #, i.e., #−1(i) = e iff #(e) = i. If E is a set
of edges, then #Emax := max{#(e) | e ∈E} is the maximum number of any edge in
E, and analogously for #Emin. For example, given a node n, #in(n)max = max{#(e) |
e ∈in(n)} is the maximum number of any incoming edge.
Lemma 3 Let P = (N,E,λ) be a sound process graph, and let Q ∈Sub(P). Let
e ̸= e′ ∈EQ so that e ∥e′, e ∈out(n) where n ∈NQ
PS, and #Q(e′) < #out(n)min. Let
t′ be a token-reachable token marking where t′(e) > 0 and t′(e′) > 0. Then there exist
token-reachable token markings t,t′′ so that t
n→t′′ where t′′(e) > 0 and t′′(e′) > 0.
Proof Since e ∥e′, we know that t′ as claimed exists. Say t′ is reached on the execution path ⃗p = ⟨t0
→tk⟩as in the proof to Lemma 2. Since, obviously,
parts of the path outside the sub-process Q in question do not matter, and ⃗p ends
within Q, in the following we will ignore the part of ⃗p outside Q, i.e., we act as if
the path was completely contained within Q.
Virtually all arguments in the proof to Lemma 2 remain intact, with a single exception, namely the proof that ni is token-executable in ti−1. Precisely, the only part
of the proof of Lemma 2 that makes use of the prerequisite n ̸∈NPS, is the argument
given here to show that execution of n does not put a token on any edge e′′ ∈in(ni).
We need to ﬁnd a different argument for this.
Such an argument can be based on the new prerequisite of our claim here, namely
that #Q(e′) < #out(n)min. What we prove is that: (*) a suitable ⃗p′ can be constructed
so that, for all nodes nj in ⃗p′, #in(nj)max < #out(n)min. This immediately proves the
claim: if e′′ ∈out(n) ∩in(ni), then, by construction of #, it follows that #Q(e′′) ≥
#out(n)min in contradiction to (*).
Say nj ̸= n is the node in ⃗p with maximal #in(nj)max. If #in(nj)max < #out(n)min,
there is nothing to prove. Else, construct ⃗p′ by removing nj, i.e., set ⃗p′ := ⟨t0
First, observe that ⃗p′ is still a valid execution path, i.e., for j + 2 ≤l ≤k −1, we
have that nl is executable in t′
l. If that were not the case, then obviously there would
exist an l so that in(nl) ∩out(nj) ̸= ∅, i.e., nj produces a token needed by nl. However, by construction of #, #in(nj)max < #out(nj)min. So, if e′′ ∈in(nl) ∩out(nj),
then #in(nl)max ≥#Q(e′) > #in(nj)max which is a contradiction since #in(nj)max is
assumed to be maximal.
Second, observe that t′
k(e) > 0 and t′
k(e′) > 0. Obviously, the only chance for
that not to happen is if e, respectively e′, is contained in out(nj). So t′
is obvious since nj ̸= n. As for t′
k(e′) > 0, assume that e′ ∈out(nj). Then, by
construction of #, we have #Q(e′) > #in(nj)max. Further, by assumption we have
#in(nj)max ≥#out(n)min. Finally, by prerequisite we have #out(n)min > #Q(e′). We
can conclude that #Q(e′) > #Q(e′) which is of course a contradiction.
Distrib Parallel Databases
Iterating the argument, we can remove from ⃗p all nodes where #in(nj)max ≥
#out(n)min, and still obtain an execution path at whose end both e and e′ are active.
This proves (*) and hence concludes the argument.
A.2 Binary theories can be compiled away
We sometimes need to distinguish the state spaces of different processes. We then
indicate the process as a superscript: SIQ(e) denotes the state intersection relative
to Q, i.e., the set of literals that are always true when e is activated in an execution
path of Q.
Lemma 4 Let Q = (N,E,λ,Ω,α), Ω = (P,T ), be an executable basic annotated process graph. Denote by C the set of all constants appearing in any of
the annotated pre(n),eff(n). Let Q′ = (N,E,λ,Ω′,α′) be the modiﬁcation of Q
where Ω′ = (P,1) and α′ ≡α except that, for all n ∈NT , eff′(n) := {l ∈P[C] |
T [C] ∧eff(n) |= l} if eff(n) is deﬁned, and eff′(n) := {l ∈P[C] | T [C] |= l} otherwise. Then, for every e ∈E, we have: SIQ(e) = SIQ′(e).
Proof In what follows, we denote a state by the set of literals it makes true. We ﬁrst
prove the following: given a reachable state s with a token on in(n) for a task node
n, in Q exactly one state s′ can be reached by executing n in s, namely the state
s′ := (s \ ¬eff′(n)) ∪eff′(n).
Recall that, by deﬁnition, the states s′ reachable by executing n in s are all those
where s′ ∈PMA-min(s,T [C]∧eff(n)), which is deﬁned to be the set of all states that
satisfy T [C] ∧eff(n) and that differ in a set-inclusion minimal set of values from s.
First, for any s′ ∈PMA-min(s,T [C] ∧eff(n)) it is clear by deﬁnition that
eff′(n) ⊆s′. The deﬁnition of s′ as given above changes only those values. It suf-
ﬁces to show that s′ |= T [C]: then, we have s′ |= T [C] ∧eff(n), and clearly the set
of changed values is a proper subset of any other state with the same property. Assume to the contrary of the claim that (l ∨l′) ∈T [C] and s′ ̸|= l ∨l′, i.e., ¬l ∈s′ and
¬l′ ∈s′; note here that T is binary and hence every clause has at most two literals.
If ¬l ∈eff′(n), then l′ ∈eff′(n)—because, given the clause l ∨l′, l′ is a logical consequence of ¬l. With eff′(n) ⊆s′ we obtain a contradiction, proving that ¬l cannot
be contained in eff′(n). Similarly, we can disprove ¬l′ ∈eff′(n). Hence, by construction of s′, {¬l,¬l′} ⊆s. But then, s ̸|= T [C] which is a contradiction because s is
reachable.
With the above, we know that, for any reachable state s and any task node n,
the (single) transition induced in Q is exactly the same as the transition induced in
Q′. Hence, obviously since the graph structure is not changed in any other way, any
possible difference in the sets SI(e) would have to be due to different start states. So
let us consider the start states in Q and Q′.
The start states in Q are all those with s0 |= T [C], and s0 |= T [C] ∧eff(n0) in
case α(n0) is deﬁned. In Q′, by construction the start states are all those where s0 |=
1 ∧eff′(n0), with eff′(n0) = {l ∈P[C] | T [C] |= l} in case α(n0) is undeﬁned, and
eff′(n0) = {l ∈P[C] | T [C] ∧eff(n0) |= l} in case α(n0) is deﬁned.
Distrib Parallel Databases
Obviously, this means that the set of start states of Q′ is a superset of the set of start
states of Q—any start state of Q is a start state of Q′, but not vice versa. However,
likewise obviously, the set of literals true in all start states is the same in both cases,
i.e., we have SIQ(e0) = SIQ′(e0).
Let e be any edge in the graph. Consider, for the moment, only the workﬂow
structure of the graphs, i.e., the token executions. Since Q′ does not change the graph
structure, the set of token execution paths leading from (a state with a token on) e0
to (a state with a token on) e is the same in both Q and Q′. Let’s call this set of
paths ⃗P . By prerequisite, every task node is executable, there are no conditions at the
outgoing edges of xor splits, and there are no conditions at loop nodes. Thus we know
that every path ⃗p ∈⃗P can be executed from every possible start state s0, in both Q
and Q′. The change that ⃗p makes to s0 is the accumulated effect of the task nodes
executed on ⃗P . From the above, we know that this is the same in both Q and Q′. We
can write the resulting state s as s = (s0 \¬eff( ⃗p))∪eff( ⃗p), where eff( ⃗p) denotes the
accumulated effect of ⃗p—what exactly that latter effect is does not play a role in our
argument below. The important point is that eff( ⃗p) is a function, i.e., is well-deﬁned.
Consider now the sets SIQ(e) and SIQ′(e). With the above, we know that
((s0 \ ¬eff( ⃗p)) ∪eff( ⃗p)),
where s0 ranges over the start states of Q and ⃗p ranges over ⃗P . Now, ﬁrst, we can
separate the “positive effects”—which occur irrespectively of the start state—out and
(s0 \ ¬eff( ⃗p))
Further, we can re-write
s0, ⃗p(s0 \ ¬eff( ⃗p)) to
s0, ⃗p(s0 ∩L( ⃗p)) where L( ⃗p) is the
complement of ¬eff( ⃗p). We can re-write
s0, ⃗p(s0 ∩L( ⃗p)) to (
⃗p L( ⃗p)).
Hence, overall, we have derived that
In the same way, we can derive
0 ranges over the start states of Q′. We need to prove that SIQ(e) = SIQ′(e).
Replacing both sides of the equation with the expressions we have just derived, the
terms concerning ⃗p occur on both sides and can be removed. Thus we ﬁnd that our desired equality is equivalent to
0, which we have already proved above.
This concludes the argument.
Distrib Parallel Databases
A.3 Correctness of I-propagation
We deﬁne aggregate-eff(Q), the aggregated effect literals of a sub-graph Q, as follows:
aggregate-eff(Q) :=
aggregate-eff(λQ(n)).
Lemma 5 Let Q = (N,E,λ,Ω,α) be an executable basic sound annotated process
graph without effect conﬂicts, and let t ≥0. Let E0 ⊆E be a set of edges so that
there exists a state s ∈S where, for all e ∈E0, ts(e) > 0. Let l be a literal so that, for
each e ∈E0, there exists a state s′ ∈S where s′ ̸|= l and ts′(e) > 0. Then, there exists
a state s0 ∈S where s0 ̸|= l and, for all e ∈E0, ts0(e) > 0.
Proof Let l be an arbitrary literal, and let t ≥0 be arbitrary. We prove that the claim
holds for all possible E0, by induction over the process structure, as reﬂected in the
enumeration function #. As the induction base case, we prove that the claim holds for
every set E0 where #E0
max ≤0. As the inductive step, we prove that, for every node n,
if the claim holds for every E0 where #E0
max ≤#out(n)min −1, then the claim holds
for every E0 where #E0
max ≤#out(n)max.
Base case. Since e0 is not parallel to any other edge (no edge can carry a token
at the same time as e0 does), the only set E0 containing e0 is the singleton {e0}, for
which the claim holds trivially.
Inductive case. Let n ∈N. As stated, the induction hypothesis is that the claim
holds for every E0 where #E0
max ≤#out(n)min −1. We prove that, under this hypothesis, the claim holds for every E0 where #E0
max ≤#out(n)max.
To avoid clumsiness of language, we will use the following conventions. Whenever we write “E0”, we mean a set of edges with #E0
max ≤#out(n)min −1 for which
the prerequisite of the claim holds: there exists a state s ∈S where, for all e ∈E0,
ts(e) > 0; and, for each single e ∈E0, there exists a state s′ ∈S where s′ ̸|= l
and ts′(e) > 0. Similarly, whenever we write “E0′”, we mean a set of edges with
max ≤#out(n)max for which the prerequisite of the claim holds. Further, since the
induction hypothesis covers all other cases, we assume that E0′ ∩out(n) ̸= ∅. Finally, since the case of E0′ ⊆out(n) is trivial for all kinds of nodes n, we assume that
E0′ ̸⊆out(n). We distinguish the different kinds of nodes n:
1. n ∈NT . We distinguish three cases:
(a) l ∈eff(n). This case is trivial because no E0′ exists. Assume the opposite was
the case. Then there exists a state s′ ∈S where ts′(out(n)) > 0 and s′ ̸|= l.
Since, directly after executing n, l is true, this means that a task node parallel
to n has made l false. Hence we have an effect conﬂict, in contradiction to the
prerequisite.
(b) ¬l ∈eff(n). Let E0′ be an arbitrary set of edges, with out(n) ∈E0′ and so that
there exists a state s ∈S where ts(e) > 0 for every e ∈E0′. In order to reach
s, n must be executed. Since n is not a parallel split, we can apply Lemma 2
to any pair of out(n) and out(n) ̸= e ∈E0′. Hence there exists an execution
path to s on which n comes last. By prerequisite, n is executable, and so we
Distrib Parallel Databases
can execute it at this point. Obviously, and s0 ̸|= l. Hence the claim holds for
E0′, and we are done.
(c) {l,¬l} ∩eff(n) = ∅. For this case, we prove that there is a mapping from sets
E0 to sets E0′. Precisely, we prove that we can construct each set E0′ as E0′ =
E0 \ {in(n)} ∪{out(n)} where E0 is a set satisfying the prerequisite of the
claim. Once this is proved, the claim follows easily: by induction hypothesis,
we know that there exists a state s0 ∈S where s0 ̸|= l and ts0(e) > 0 for all
e ∈E0; in that state, we can execute n; the resulting state obviously satisﬁes
the requirements of the claim.
It remains to prove the desired mapping. Let E0′ be a set of edges with
E0′ ∩out(n) ̸= ∅so that: there exists a state s ∈S where, for all e ∈E0′,
ts(e) > 0; and, for each single e ∈E0′, there exists a state s′ ∈S where s′ ̸|= l
and ts′(e) > 0. We need to prove that E0 := E0′ \ {out(n)} ∪{in(n)} has the
same properties. The existence of the desired state s ∈S follows by application of Lemma 2 to E0′ and s: we get a path to s on which n is applied
last; the predecessor state activates all edges in E0 and hence serves as the
desired state s for E0. Regarding the existence of the state s′ ∈S with s′ ̸|= l
and ts′(out(n)) > 0, there are two possible reasons for that. First, there exists
a state s′′ ∈S with s′′ ̸|= l and ts′(in(n)) > 0; in that case there is nothing to
prove. Second, there exists a task node n′ parallel to n that falsiﬁes l in its
effect. But then, n′ can be executed directly before n, and hence we are back
in the ﬁrst case, i.e., we can construct a state s′′ ∈S as appropriate.
2. n ∈NL. We distinguish three cases similar as for task nodes; the respective proofs
are similar as well:
(a) On every path through λ(n), the last change to l makes l true; in particular,
l ∈aggregate-eff(λ(n)). This case is trivial because no E0′ exists. Assume the
opposite was the case. Then there exists a state s′ ∈S where ts′(out(n)) > 0
and s′ ̸|= l. Since, directly after executing λ(n), l is true, this means that a
task node parallel to n has made l false. Hence we have an effect conﬂict, in
contradiction to the prerequisite.
(b) There exists a path ⃗p through λ(n) where the last change makes l false; in
particular, ¬l ∈aggregate-eff(λ(n)). Let E0′ be an arbitrary set of edges, with
out(n) ∈E0′ and so that there exists a state s ∈S where ts(e) > 0 for every
e ∈E0′. In order to reach s, n must be executed. Since n is not a parallel split,
we can apply Lemma 2 to any pair of out(n) and out(n) ̸= e ∈E0′. Hence
there exists an execution path to s on which n comes last. By prerequisite, λ(n)
is executable, and so we can execute ⃗p at this point. Obviously, the resulting
state s0 has s0 ̸|= l. Hence the claim holds for E0′, and we are done.
(c) {l,¬l} ∩aggregate-eff(λ(n)) = ∅. This case is proved exactly as for task
nodes. The only difference is that, rather than executing just n without affecting the value of l, we execute some path through λ(n) without affecting
the value of l. This does not affect the proof arguments.
3. n ∈NXS. There is a mapping from sets E0′ to sets E0. Namely, we can construct
each E0′ respectively as E0′ = E0 \ {in(n)} ∪{e′}, where e′ ∈out(n). This, like
above, follows from Lemma 2 regarding parallelism, i.e., the existence of the state
s in the prerequisite of the claim. Regarding the existence of the states s′ in the
Distrib Parallel Databases
prerequisite of the claim, the argument is the same as before: a state s′ which
falsiﬁes l and activates one of the outgoing edges can always be constructed from
a state which falsiﬁes l and activates the incoming edge.
By induction hypothesis we know that there exists a reachable state s0 ∈S
where s0 ̸|= l and, for all e ∈E0, ts0(e) > 0. In that state, we can execute n. Because, by prerequisite, the process graph is basic, in particular no conditions are
annotated at the outgoing edges of any xor split. Hence, regardless of how s0 interpretes the logical propositions, we can choose to execute n in a way so that a
token is put on e′. The resulting state obviously satisﬁes the requirements of the
4. n ∈NXJ . Like for xor splits, we have a mapping from sets E0′ to sets E0: every
set E0′ can be constructed from a set E0 as E0′ = E0 \ {e} ∪{out(n)}, where
e ∈in(n). The proof for that is as before, and the claim follows as before.
5. n ∈NPJ . This case is also handled analogously: every set E0′ can be constructed
from a set E0 as E0′ = E0 \ in(n) ∪{out(n)}. That correspondence is proved as
before, and the claim follows as before.
6. n ∈NPS. In this case, every set E0′ can be constructed from a set E0 as E0′ =
E0 \ {in(n)} ∪E′, where E′ ⊆out(n); we argue this mapping below. With this
mapping, the proof proceeds as before. By induction hypothesis we know that
there exists a reachable state s0 ∈S where s0 ̸|= l and, for all e ∈E0, ts0(e) > 0.
In that state, we can execute n and put a token on every edge in E′. The resulting
state obviously satisﬁes the requirements of the claim.
It remains to prove that every set E0′ can be constructed from a set E0 as
E0′ = E0 \ {in(n)} ∪E′, where E′ ⊆out(n). Let E0′ be any set of edges with
E0′ ∩out(n) ̸= ∅and #E0′
max ≤#out(n)max so that: there exists a state s ∈S where,
for all e ∈E0′, ts(e) > 0; and, for each single e ∈E0′, there exists a state s′ ∈S
where s′ ̸|= l and ts′(e) > 0. We prove that E0 := E0′ \out(n)∪in(n) has the same
properties. The existence of the state s ∈S follows by application of Lemma 3 to
Q, E0′, and s: we get a path on which n is applied last and whose end state activates all edges in E0′; the predecessor state activates all edges in E0. Regarding
the existence of the state s′ ∈S with s′ ̸|= l which activates the edges in E′, there
are two possible reasons for that. First, there exists a state s′′ ∈S with s′′ ̸|= l and
ts′(in(n)) > 0; in that case there is nothing to prove. Second, there exists a task
node n′ parallel to n that falsiﬁes l in its effect. But then, n′ can be executed directly before n, and hence we are back in the ﬁrst case, i.e., we can construct a
state s′′ as appropriate. This concludes the argument.
Lemma 6 Let P = (N,E,λ,Ω,α) be an executable basic annotated process graph.
Say we run I-propagation on P, and I ∗is an I-propagation result. Then, for all
e ∈E, SI(e) ⊇I ∗(e).
Proof Since P is executable and basic, we can apply Lemma 4. That is, we can
compile the binary ontology into extended action effects without affecting the sets
SI(e). Hence in what follows we can assume without loss of generality that the
ontology is empty.
Let e ∈E and let l ∈P[C], where C are the constants used by α. Assume that there
exists an execution path s0
→s2 ···sk−1
→sk = s so that ts(e) > 0 and is ̸|= l.
Distrib Parallel Databases
We show that, then, there exists an I-propagation path I0
I ′ so that l ̸∈I(e).
Note ﬁrst that, given a function I : E
→2P[C] and a node n, there exists at most
one I ′ so that I ′ is the propagation of I at n, i.e., I ′ is completely determined; I ′
exists iff propagating I at n results in any changes.
Consider now the sequence of nodes n1,...,nk. We construct a sequence
I0,I1,...,Ik as follows. For all 0 ≤j < k, if propagating Ij at nj results in changes,
then set Ij+1 to the outcome of that propagation; else, set Ij+1 := Ij. Obviously,
we get an I-propagation path I0
l = I by removing from
I0,I1,...,Ik those steps where no changes occur. We then have Ik = I, and hence it
sufﬁces to prove that l ̸∈Ik(e).
In what follows, we denote tj := tsj and ij := isj . We prove by induction that, for
all 0 ≤j ≤k: for all e where tj(e) > 0, we have ij |= Ij(e).
Base case, j = 0. The only e′ with tj(e′) > 0 is the start edge e0. Since I0(e0) =
eff(n0), the claim follows.
Inductive case, j →j + 1. We distinguish the different kinds of executions of the
node n := nj+1:
1. n ∈NPS ∪NXS. Consider the edges e′ where tj+1(e′) > 0. We either have (a)
tj(e′) > 0, or (b) e′ ∈out(n). In case (a), the claim follows immediately from the
induction hypothesis because ij+1 = ij and Ij+1(e′) = Ij(e′). As for case (b),
since n can be executed in sj, we have that tj(in(n)) > 0, and hence by induction
assumption we know that ij |= Ij(in(n)). The claim then follows because ij+1 =
ij and, for all e′ ∈out(n), Ij+1(e′) ⊆Ij(in(n)).
2. n ∈NT . Consider the edges e′ where tj+1(e′) > 0. We either have (a) tj(e′) > 0,
or (b) e′ = out(n). In case (a), the claim follows immediately from the induction
hypothesis because ij+1 = eff(n) ∪(ij \ ¬eff(n)), writing an interpretation as the
set of literals it satisﬁes; and Ij+1(e′) = Ij(e′) \ ¬eff(n) because, with tj(e′) > 0
and tj(in(n)) > 0, we have e′ ∥in(n). As for case (b), since tj(in(n)) > 0 by induction assumption we know that ij |= Ij(in(n)). The claim then follows because
ij+1 = eff(n) ∪(ij \ ¬eff(n)) and Ij+1(out(n)) ⊆eff(n) ∪(Ij(in(n)) \ ¬eff(n)).
3. n ∈NPJ . Consider the edges e′ where tj+1(e′) > 0. We either have (a) e′ ̸= out(n)
and tj(e′) > 0, or (b) e′ = out(n). In case (a), Ij+1(e′) = Ij(e′) and hence the
claim follows from the induction hypothesis and ij+1 = ij. As for case (b), since n
can be executed in sj, we have that tj(e′) > 0 for all e′ ∈in(n). Hence by induction
assumption we know that ij |= Ij(e′) for all e′ ∈in(n). The claim then follows
because ij+1 = ij and Ij+1(out(n)) ⊆
e′∈in(n) Ij(e′).
4. n ∈NXJ . Consider the edges e′ where tj+1(e′) > 0. We either have (a) e′ ̸= out(n)
and tj(e′) > 0, or (b) e′ = out(n). In case (a), Ij+1(e′) = Ij(e′) and hence the
claim follows from the induction hypothesis and ij+1 = ij. As for case (b), since
n can be executed in sj, we have that tj(e′) > 0 for at least one e′ ∈in(n). By
induction assumption we know that ij |= Ij(e′) for that e′. The claim then follows
because ij+1 = ij and Ij+1(out(n)) ⊆
e′∈in(n) Ij(e′).
L with λQ(n) = Q′. Consider the edges e′ where tj+1(e′) > 0. We either
have (a) tj(e′) > 0, or (b) e′ = eQ′
0 . In case (a), the claim follows immediately
Distrib Parallel Databases
from the induction hypothesis because ij+1 = ij and Ij+1(e′) = Ij(e′). As for
case (b), since n can be executed in sj, we have that tj(in(n)) > 0, and hence
by induction assumption we know that ij |= Ij(in(n)). The claim then follows
because ij+1 = ij and Ij+1(eQ′
0 ) ⊆Ij(in(n)).
+ and tj+1(eQ
0 ) > tj(eQ
0 ). Consider the edges e′ where tj+1(e′) > 0. We
either have (a) tj(e′) > 0, or (b) e′ = eQ
0 . In case (a), the claim follows immediately from the induction hypothesis because ij+1 = ij and Ij+1(e′) = Ij(e′). As
for case (b), since n can be executed in sj, we have that tj(in(n)) > 0, and hence
by induction assumption we know that ij |= Ij(in(n)). The claim then follows
because ij+1 = ij and Ij+1(eQ
0 ) ⊆Ij(in(n)).
+ with Q = λQ′(n′) and tj+1(out(n′)) > tj(out(n′)). Consider the edges e′
where tj+1(e′) > 0. We either have (a) tj(e′) > 0, or (b) e′ = out(n′). In case (a),
the claim follows immediately from the induction hypothesis because ij+1 = ij
and Ij+1(e′) = Ij(e′). As for case (b), since n can be executed in sj, we have that
tj(in(n)) > 0, and hence by induction assumption we know that ij |= Ij(in(n)).
The claim then follows because ij+1 = ij and Ij+1(out(n′)) ⊆Ij(in(n)).
Lemma 7 Let P = (N,E,λ,Ω,α) be an executable basic sound annotated process
graph without effect conﬂicts. Say we run I-propagation on P, and I ∗is an Ipropagation result. Then, for all e ∈E, SI(e) ⊆I ∗(e).
Proof Since P is executable and basic, we can apply Lemma 4. That is, we can
compile the binary ontology into extended action effects without affecting the sets
SI(e). Hence in what follows we can assume without loss of generality that the
ontology is empty.
Assume an I-propagation path I0
→I2 ···Ik−1
→Ik. We prove the following. For every 0 ≤j ≤k and for every edge e ∈E and literal l ∈P[C] where
l ̸∈Ij(e), there exists an execution path ending in a state s so that ts(e) > 0 and
s ̸|= l. The proof is by induction over j.
Base case, j = 0. By deﬁnition, I0(e) = P[C] except for e = e0, where I0(e0) =
eff(n0). Hence the only pairs e,l with l ̸∈I0(e) are those where e = e0 and l ̸∈eff(n0).
Obviously, every start state s0 has ts0(e0) > 0. If l ̸∈eff(n0) then by deﬁnition at least
one start state s0 exists where s0 ̸|= l. This shows the claim.
Inductive case, j →j + 1. By induction hypothesis, we know that, for every edge
e ∈E and literal l ∈P[C] where l ̸∈Ij(e), there exists an execution path ending in
a state s so that ts(e) > 0 and s ̸|= l. We distinguish the different kinds of nodes
n := nj+1:
1. n ∈NPS ∪NXS. Say that e ∈E and l ∈P[C] where l ̸∈Ij+1(e). By the deﬁnition
of I-propagation over split nodes, we either have (a) l ̸∈Ij(e) or (b) e ∈out(n)
and l ̸∈Ij(in(n)). In case (a), the induction hypothesis shows the existence of an
execution path as desired, so there is nothing to prove. As for case (b), by induction
hypothesis there exists an execution path ending in a state s so that ts(in(n)) > 0
and s ̸|= l. We can execute n in s. Since there are no conditions at the outgoing
edges of xor splits, if n is an xor split then we can choose to put a token on e; if
n is a parallel split then tokens are put on all outgoing edges, in particular on e.
Distrib Parallel Databases
Hence we can construct an execution path ending in a state s′ where ts′(e) > 0 and
s′ ̸|= l. This concludes the argument.
2. n ∈NT . Say that e ∈E and l ∈P[C] where l ̸∈Ij+1(e). By the deﬁnition of Ipropagation over task nodes, we have one of the following cases: (a) l ̸∈Ij(e);
or (b) e ∥out(n) and l ∈¬eff(n); or (c) e = out(n) and l ∈¬eff(n); or (d) e =
out(n) and l ̸∈Ij(in(n)). In case (a), the induction hypothesis proves the claim. In
case (b), we construct some execution path that activates both e and out(n), and
which executes n last. A token execution path of P doing so exists by Lemma 2;
any token execution of P corresponds directly to an execution path because by
prerequisite there are no conditions at the outgoing edges of xor splits, there are
no conditions at loop nodes, and all task nodes are executable. In case (c), we
simply construct some execution path that executes n last; at least one such path
exists because by prerequisite P is sound, all task nodes are executable, there are
no conditions at the outgoing edges of xor splits, and there are no conditions at
loop nodes. In case (d), ﬁnally, by induction hypothesis there exists an execution
path ending in a state s so that ts(in(n)) > 0 and s ̸|= l. Since n is executable by
prerequisite, we can execute n in s, getting to a state s′ where ts′(e) > 0 and s′ ̸|= l.
This concludes the argument.
3. n ∈NPJ . Say that e ∈E and l ∈P[C] where l ̸∈Ij+1(e). By the deﬁnition of Ipropagation over parallel join nodes, we either have (a) l ̸∈Ij(e) or (b) e = out(n)
and for every ei ∈in(n) : l ̸∈Ij(ei). In case (a), the induction hypothesis shows the
existence of an execution path as desired, so there is nothing to prove. As for case
(b), by induction hypothesis for every ei ∈in(n) there exists an execution path
ending in a state si so that tsi(ei) > 0 and si ̸|= l. We can thus apply Lemma 5, and
obtain an execution path to a state s with s ̸|= l and ts(ei) > 0 for all ei ∈in(n). We
can execute n in s, getting to a state s′ where ts′(e) > 0 and s′ ̸|= l. This concludes
the argument.
4. n ∈NXJ . Say that e ∈E and l ∈P[C] where l ̸∈Ij+1(e). By the deﬁnition of Ipropagation over xor join nodes, we either have (a) l ̸∈Ij(e) or (b) e = out(n) and
for at least one e′ ∈in(n) : l ̸∈Ij(e′). In case (a), the induction hypothesis shows
the existence of an execution path as desired, so there is nothing to prove. As for
case (b), by induction hypothesis there exists an execution path ending in a state
s so that ts(e′) > 0 and s ̸|= l. We can execute n in s, getting to a state s′ where
ts′(e) > 0 and s′ ̸|= l. This concludes the argument.
L with λQ(n) = Q′. Say that e ∈E and l ∈P[C] where l ̸∈Ij+1(e). By
the deﬁnition of I-propagation over loop nodes, we either have (a) l ̸∈Ij(e) or
(b) e = eQ′
and l ̸∈Ij(in(n)). In case (a), the induction hypothesis shows the
existence of an execution path as desired, so there is nothing to prove. As for case
(b), by induction hypothesis there exists an execution path ending in a state s so
that ts(in(n)) > 0 and s ̸|= l. We can execute n in s, getting to a state s′ where
ts′(e) > 0 and s′ ̸|= l. This concludes the argument.
+ with Q = λQ′(n′). Say that e ∈E and l ∈P[C] where l ̸∈Ij+1(e). By the
deﬁnition of I-propagation over end nodes, we have one of the following cases:
(a) l ̸∈Ij(e); or (b) e = eQ
0 and l ̸∈Ij(in(n)); or (c) e = out(n′) and l ̸∈Ij(in(n)).
In case (a), the induction hypothesis shows the existence of an execution path
as desired, so there is nothing to prove. As for cases (b) and (c), by induction
Distrib Parallel Databases
hypothesis there exists an execution path ending in a state s so that ts(in(n)) > 0
and s ̸|= l. Since n is executable by prerequisite, we can execute n in s. Since by
prerequisite there are no conditions at loop nodes, we can choose to repeat the loop
or exit the loop, i.e., we can put a token on eQ
0 or out(n′) as desired for case (b)
respectively for case (c). We hence, in both cases, get to a state s′ where ts′(e) > 0
and s′ ̸|= l. This concludes the argument.
Theorem 4. Let P = (N,E,λ,Ω,α) be an executable basic sound annotated
process graph without effect conﬂicts. Say we run I-propagation on P. There exists exactly one I-propagation result I ∗. For all e ∈E, SI(e) = I ∗(e). With ﬁxed
arity, the time required to compute I ∗is polynomial in the size of P.
Proof First, it is a direct consequence of Lemmas 6 and 7 that, for all e ∈E, SI(e) =
I ∗(e), for any I-propagation result I ∗. From this it follows directly that there exists
exactly one such I ∗.
For time complexity, there are three issues to consider: (1) the time taken for compiling binary clauses away, (2) the time taken within any single propagation step, and
(3) the maximal number of propagation steps performed. (1) consists of computing,
for every task node n, the set eff(n) of literals that are implied by eff(n) ∧T . This
can be done as follows. We view T as a directed graph whose nodes are literals and
whose edges correspond to the clauses. The number of nodes of the graph is the number of literals |P[C]|, where C is the set of constants mentioned by α. We compute
the transitive closure of that graph, in time O(|P[C]|3). Then, for every effect eff(n)
and for every literal l, we ask whether there is an edge (¬l,l) in the transitive closure,
or whether for any literal l′ ∈eff(n) there is an edge (l′,l) in the transitive closure.
This is done in time O(|N|∗|P[C]|∗maxeff), where maxeff is the maximum number
of effect literals any task node has.
As for (2), loop nodes and end nodes take time O(|P[C]|) since sets can be
intersected in linear time using, e.g., a bitvector representation. Parallel and xor
joins/splits, accordingly, take time O(|P[C]| ∗maxE), where maxE is the maximum number of incoming or outgoing edges any node has. Task nodes take time
O(|E| ∗|P[C]|).
As for (3), deﬁne, for any function I : E
→2P[C], ||I|| := 
e∈E |I(e)|. That is,
||I|| counts the total number of literals annotated by I, in sum over all edges in the
process. I-propagation admits a propagation step from I to I ′ only if I ̸= I ′. Since
we always have, for all e ∈E, that I(e) ⊇I ′(e), this means that ||I ′|| ≤||I|| −1. If
||I ′|| = 0, then certainly a ﬁxpoint is reached. Now, obviously ||I0|| ≤|E| ∗|P[C]|.
Hence |E| ∗|P[C]| is an upper bound on the number of propagation steps performed.
Overall, we get that the runtime is in O(|P[C]|3+|N|∗|P[C]|∗maxeff +(|P[C]|∗
maxE +|E| ∗|P[C]|) ∗|E| ∗|P[C]|). With ﬁxed arity, |P[C]| is O(|P| ∗|C|), which
concludes the argument.
A.4 I-propagation can be used for executability checking
Lemma 1. Let P = (N,E,λ,Ω,α) be an annotated process graph without effect
conﬂicts, which is basic except that α may be deﬁned for edges and loop nodes. Say
Distrib Parallel Databases
we run I-propagation on P, and I ∗is an I-propagation result. Then, for all e ∈E,
SI(e) ⊇I ∗(e).
Proof The only differences of this claim compared to Lemma 6 is that we do not
require P to be executable, and that conditions may be annotated at xor splits and
Let P0 = (N,E,λ,Ω,α0) be like P except that pre0(n) has been set to ∅for all
n ∈NT , and that α0 is undeﬁned on all xor edges and loop nodes. Obviously, P0 is
executable and basic. Hence we can apply Lemma 6, and get that SIP0(e) ⊇I ∗
0 is an I-propagation result for P0. Since P0 differs from P only in terms of
the task node preconditions and the xor/loop conditions, which are not considered by
I-propagation, we have I ∗
0 = I ∗where I ∗is an I-propagation result for P, and hence
SIP0(e) ⊇I ∗(e). In what follows, we show that SIP0(e) ⊆SIP(e). Obviously, this
proves the claim.
Consider the execution paths through P and P0. Let us denote the set of these
paths with ⃗P and ⃗P0, respectively. P0 does not alter the structure of P in any way
other than removing preconditions and xor/loop conditions. So the only difference is
that some paths are disallowed in P—but are allowed in P0—due to preconditions
or conditions that are not satisﬁed along the path. Hence we have ⃗P ⊆⃗P0. Consider
now a particular edge e ∈E, and consider the sets of states
(A) {s | s ∈SP,ts(e) > 0}
(B) {s | s ∈SP0,ts(e) > 0}
With what we just said about paths, we have that (B) is a superset of (A). Now, by
deﬁnition, SIP(e) is the set of literals satisﬁed by all states in (A), and SIP0(e)
is the set of literals satisﬁed by all states in (B). Since (B) is a superset of (A), this
means that SIP0(e) ⊆SIP(e), which is what we needed to show. This concludes
the argument.
Theorem 5. Let P = (N,E,λ,Ω,α) be a basic annotated process graph without
effect conﬂicts. Say we run I-propagation on P, and I ∗is an I-propagation result.
Then P is executable iff for all n ∈NT ∪{nP
+} : pre(n) ⊆I ∗(in(n)).
Proof Recall that a task node n ∈NT is executable iff, for all reachable states s so
that ts(in(n)) > 0, we have s |= pre(n). In other words, whenever a path of transitions
reaches n with a token, n’s precondition is satisﬁed. P is executable if all its nodes
are executable. Obviously, a node n is executable iff pre(n) ⊆SI(in(n)).
First, consider the direction from left to right. P is executable, so we can apply
Lemma 7 and get that I ∗(e) ⊇SI(e) for all e ∈E. Let n ∈NT ∪{nP
+} be arbitrary.
We have SI(in(n)) ⊆I ∗(in(n)). Since n is executable, we have pre(n) ⊆SI(in(n)).
Hence pre(n) ⊆I ∗(in(n)) as desired.
Now, consider the direction from right to left. We can apply Lemma 1, and get that
I ∗(e) ⊆SI(e) for all e ∈E. Assume to the contrary of the claim that n ∈NT ∪{nP
so that pre(n) ⊆I ∗(in(n)), but n is not executable, i.e., ex. l ∈pre(n) \ SI(in(n)).
We have that l ∈pre(n) and hence l ∈I ∗(in(n)). With the above, this implies that
l ∈SI(e), in contradiction. Hence all n ∈NT ∪{nP
+} are executable, which concludes
the proof.
Distrib Parallel Databases
Theorem 6. Let P = (N,E,λ,Ω,α) be an annotated process graph without effect
conﬂicts, which is basic except that α may be deﬁned for edges and loop nodes.
Say we run I-propagation on P, and I ∗is an I-propagation result. Then, for all
n ∈NT ∪{nP
+}, if pre(n) ⊆I ∗(in(n)) then n is executable.
Proof Recall that a task node n ∈NT is executable iff, for all reachable states s so
that ts(in(n)) > 0, we have s |= pre(n). In other words, whenever a path of transitions
reaches n with a token, n’s precondition is satisﬁed.
We can apply Lemma 1, and get that I ∗(e) ⊆SI(e) for all e ∈E. Assume to
the contrary of the claim that n ∈NT ∪{nP
+} so that pre(n) ⊆I ∗(in(n)), but n is
not executable, i.e., ex. l ∈pre(n) \ SI(in(n)). We have that l ∈pre(n) and hence
l ∈I ∗(in(n)). With the above, this implies that l ∈SI(e), in contradiction. Hence n
is executable, which concludes the proof.
A.5 Complexity results
Lemma 8 Assume a sound atomic annotated process graph P = (N,E,λ,Ω,α)
without effect conﬂicts, where N \ {n0,n+} ⊆NT , eff(n0) is a complete assignment,
all predicates have arity 0, and P is basic except that T is not binary. Even if P is
known to be reachable, deciding whether P is executable, or whether some n ∈N is
executable, is p
2-hard for general T , and coNP-hard if T is Horn. Deciding whether
P is reachable, or whether some n ∈N is reachable, is p
2-hard for general T , and
NP-hard if T is Horn.
Proof Let us ﬁrst consider the general case, with no restrictions on T . The proofs are
by reduction of validity of a QBF formula ∀X.∃Y.φ[X,Y], where φ is in CNF. The
process graphs P in our construction are very similar for reachability and executability; we ﬁrst consider the common parts, then explain the details below.
We have a node nt ∈N which is connected to the start node n0 via an edge
(n0,nt) ∈E. We set pre(nt) = ∅. The main trick of the proof lies in the deﬁnitions
of Ω, eff(n0), and eff(nt). Those are adapted from the constructions used in the
proof of Lemma 6.2 from . The predicates P of Ω are all 0-ary, i.e., they have
no arguments and are hence logical propositions. Precisely, we have the predicates
X = {x1,...,xm} and Y = {y1,...,yn} from the formula ∀X.∃Y.φ[X,Y], as well as
new predicates {z1,...,zm,q,t}. We deﬁne eff(n0) to contain all xi, all yi, all zi, q,
and ¬t. So all facts except t are made true by the start state s0; note that the start state
is complete. We deﬁne eff(nt) to be {t}. The complex part of the construction lies in
the theory T of Ω. We deﬁne
(¬t ∨xi ∨zi)
(¬t ∨¬xi ∨¬zi)
(¬t ∨¬q ∨C)
(¬t ∨¬yi ∨q)
Distrib Parallel Databases
where φ is viewed as a set of clauses C. More readably, the theory is equivalent to:
Note that eff(nt) is consistent with the theory: any interpretation that sets r and all yi
to 0 satisﬁes T ∧eff(nt). Hence nt complies with Deﬁnition 3.
We now prove that (*) ∀X.∃Y.φ[X,Y] is valid iff q is true in any state s that results
from executing nt. From this, the desired hardness results will be easy to obtain. We
denote with S the set of states s that may be reached by executing nt.
The theory conjuncts xi ≡¬zi make sure that each s ∈S makes exactly one of
xi,zi true. In particular, the different assignments to X are incomparable with respect to set inclusion. Hence, we have that for every assignment aX of truth values
to X, there exists a state s ∈S that complies with aX: aX is satisﬁable together with
T ∧eff(nt), and any other assignment a′
X is more distant from s0 in at least one proposition (e.g., if a′
X(xi) = 1 and aX(xi) = 0 then aX is closer to s0 than a′
X regarding
the interpretation of zi).
We ﬁrst prove that, if q is true in any state s that results from executing nt, then
∀X.∃Y.φ[X,Y] is valid. Let aX be a truth value assignment to X. With the above, we
have a state s ∈S that complies with aX. By assumption, s makes q true. Therefore,
due to the theory conjunct q ⇒φ, we have is |= φ. Obviously, the values assigned to
Y by is satisfy φ for aX.
For the other direction, say ∀X.∃Y.φ[X,Y] is valid. Assume that, to the contrary
of the claim, there exists a s ∈S so that is ̸|= q. But then, due to the theory conjunct
i=1 yi) ⇒q, we have that s sets all yi to false. Now, because ∀X.∃Y.φ[X,Y] is
valid, there exists a truth value assignment aY to Y that complies with the setting of
all xi and zi in s. Obtain s′ by modifying s to comply with aY , and setting q to 1.
We have that is′ |= T ∧eff(nt). But then, s′ is closer to s0 than s, and hence s ̸∈S in
contradiction. This concludes the argument for (*).
To prove p
2-hardness of deciding executability, we now simply connect nt via an
edge (nt,n+) to the stop node, and set pre(n+) = {q}. By (*), n+ is executable iff
∀X.∃Y.φ[X,Y] is valid; since the other nodes have no preconditions and are trivially
executable, and since all nodes are trivially reachable, the claim follows.
To prove p
2-hardness of deciding reachability, an only slightly more complex
construction is required. We introduce another node n¬q ∈N, and connect (nt,n¬q)
as well as (n¬q,n+). We set pre(n¬q) = {¬q}, and eff(n¬q) = pre(n+) = ∅. Then,
by (*), n+ is reachable iff ∀X.∃Y.φ[X,Y] is not valid; the other nodes are trivially
reachable; this concludes the argument.
Let’s consider now the case where T is restricted to be Horn. The graphs (N,E)
that we use for reachability/executability remain exactly the same. What changes is
the semantic annotation. The latter is obtained by the following adaptation of the
proof of Lemma 7.1 from . The proof works by a reduction of satisﬁability of
a CNF formula φ[X]. We use the 0-ary predicates X = {x1,...,xm}, and new 0-ary
predicates Y = {y1,...,yn,z1,...,zn,q,t}. As before, pre(nt) = ∅and eff(nt) =
{t}. We deﬁne eff(n0) to contain all xi, all yi, all ¬zi, ¬q, and ¬t; note that this is a
Distrib Parallel Databases
complete assignment. The theory is:
((¬t ∨¬xi ∨¬yi) ∧(¬t ∨¬xi ∨zi) ∧(¬t ∨¬yi ∨zi))
(¬t ∨C[−Y/ + X])
where φ is viewed as a set of clauses C, and C[−Y/ + X] for a clause C denotes
the modiﬁcation of C where every occurrence of a positive literal xi is replaced with
¬yi. More readably, the theory is equivalent to:
((¬xi ∨¬yi) ∧(xi ⇒zi) ∧(yi ⇒zi))
C[−Y/ + X]
Obviously, this theory is in Horn format: every clause contains at most one positive
literal. Note that eff(nt) is consistent with the theory: e.g., the interpretation that sets
all propositions except t to 0 satisﬁes T ∧eff(nt). Hence nt complies with Deﬁnition 3.
The key in this transformation is that φ is made Horn by replacing positive occurrences of xi with ¬yi. If the truth value of yi is different from the value of xi, for
each i, then C[−Y/ + X] is satisﬁed by this assignment iff C is satisﬁed. The role
of zi is to indicate whether xi and yi are indeed different. The role of q is to indicate
whether the latter is the case for all i.
We now prove that (**) φ[X] is unsatisﬁable iff ¬q is true in any state s that results from executing nt. From this, the desired hardness results will be easy to obtain.
We denote with S the set of states s that may be reached by executing nt.
We ﬁrst prove that, if there exists s ∈S so that is |= ¬q, then φ is satisﬁable. Let
L0 be the set of literals on whose interpretation s agrees with s0. We can conclude
that T ∧eff(nt) ∧
l∈L0 l ∧¬q is unsatisﬁable, since otherwise we can construct a
state s′ that has s′ |= L0 ∧¬q and that is hence closer to s0 than s. The only part
of T ∧eff(nt) that forces implication of q is (n
i=1 zi) ⇒q. Thus we infer that
T ∧eff(nt)∧
l∈L0 l |= n
i=1 zi. The only part of T ∧eff(nt) that forces implication
of zi is if either xi or yi are true. Hence, for all i, either xi or yi are implied by
T ∧eff(nt) ∧
l∈L0 l. Hence, in particular s satisﬁes, for all i, either is |= xi or
is |= yi. Hence the value of xi and yi is different for all i, and hence, with the above,
the assignment that s makes to X satisﬁes φ.
For the other direction, assume that φ is satisﬁable, by the truth value assignment
aX. We construct a state s so that s |= q and s ∈S. First, we set that for all xi, is |= xi
Distrib Parallel Databases
Fig. 9 Schematic illustration of 3SAT reduction for Lemma 9, reachability checking
iff aX(xi) = 1. Then, we set that for all yi, is |= yi iff aX(xi) = 0. We set that for all
zi, is |= zi. Finally, we set is |= q and is |= t. It is easily veriﬁed that is |= T ∧eff(nt):
φ is satisﬁed because the values of xi and yi are different, for each i. Further, s is
maximally close to s0. This can be seen as follows. First, we cannot change any of
the values of a zi or of q, because those are implied by the distinct values of each xi
and yi. Second, we cannot set any xi or yi to true in isolation, because that would be
in conﬂict with the respective other value. So any change we make to the setting of
xi and yi would involve switching one xi or yi to false, and hence being further away
from s0 in that proposition. This concludes the argument for (**).
To prove p
2-hardness of deciding executability, as before connect nt via an edge
(nt,n+) to the stop node. We set pre(n+) = {¬q}. By (**), n+ is executable iff φ[X]
is unsatisﬁable; since the other nodes have no preconditions and are trivially executable, and since all nodes are trivially reachable, the claim follows.
To prove p
2-hardness of deciding reachability, we introduce another node nq ∈
N, and connect (nt,nq) as well as (nq,n+). We set pre(nq) = {q}, and eff(nq) =
pre(n+) = ∅. Then, by (*), n+ is reachable iff φ[X] is satisﬁable; the other nodes are
trivially reachable; this concludes the argument.
Lemma 9 Assume a sound atomic annotated process graph P = (N,E,λ,Ω,α)
without effect conﬂicts, where N \{n0,n+} ⊆NT ∪NXS ∪NXJ , eff(n0) is a complete
assignment, all predicates have arity 0, and P is basic except that con(e) may be
deﬁned for some e ∈E. Even if P is known to be reachable, deciding whether P is
executable, or whether some n ∈N is executable, is coNP-hard. Even if P is known to
be executable, deciding whether P is reachable, or whether some n ∈N is reachable.
Proof The proof for reachability checking is by the following reduction from 3SAT.
Assume a CNF φ with n propositions p1,...,pn, and k clauses c1,...,ck where
ci = li1 ∨li2 ∨li3. We obtain an atomic basic annotated process graph with some
annotated edges, (N,E,λ,Ω,α), as follows. The ontology contains only 0-ary predicates, namely P := {p1, notp1,..., pn, notpn}; we identify literal ¬pi with proposition notpi. The construction is illustrated in Fig. 9.
The set of nodes N and their annotation (of which we show only the non-empty ones)
1. start node n0; eff(n0) = ∅
2. parallel split node nps
3. xor-split nodes nxs1 ···nxsn
Distrib Parallel Databases
4. for 1 ≤i ≤n: task nodes npi and nnotpi; eff(npi) = {pi}, eff(npi) = {notpi}
5. xor-join nodes nxj1 ···nxjn
6. parallel join node npj
7. for 1 ≤i ≤k: xor-split node nxs′
8. for 1 ≤i ≤k −1: xor-join node nxj′
9. task node ng
10. xor-join node nxj′
11. stop node n+
The set of edges E and their annotation is given below. Again, empty annotation is
not shown; also, the position of the annotated edges does not matter and is hence not
1. (n0,nps)
2. for 1 ≤i ≤n: (nps,nxsi)
3. for 1 ≤i ≤n: (nxsi,npi) and (nxsi,nnotpi)
4. for 1 ≤i ≤n: (npi,nxji) and (nnotpi,nxji)
5. for 1 ≤i ≤n: (nxji,npj)
6. (npj,nxs1)
7. for 1 ≤i ≤k: (nxs′
i,nxj′); con((nxs′
i,nxj′)) = {¬li1,¬li2,¬li3}
8. for 1 ≤i ≤k −1: for 1 ≤j ≤3: (nxs′
i); con((nxs′
i)) = {lij}
9. for 1 ≤i ≤k −1: (nxj′
10. for 1 ≤j ≤3: (nxs′
k,ng); con((nxs′
k,ng)) = {lkj}
11. (ng,nxj′)
12. (nxj′,n+)
Since all preconditions are empty, it is obvious that P is executable. By construction,
P is reachable iff ng is reachable. The latter is the case iff φ is satisﬁable. The annotation of the start node can be set to be eff(n0) = {¬p1, ¬notp1,..., ¬pn, ¬notpn},
and hence to be complete. The parallel split/join can be replaced by a simple sequencing of all the xors setting proposition values.
For executability checking, we can use a similar reduction. Given a CNF φ, let p
be a new proposition; obtain φ′ by inserting p into every clause of φ. Then construct,
for φ′, the process graph as above, with the only difference being that ng has the
annotation pre(ng) = {p}. With this construction, we have that (1) ng is reachable
(trivially, by making p true and choosing the p-branch for every clause); (2) with
that, clearly all nodes are reachable; and (3) ng is executable iff every satisfying
assignment to φ′ makes p true. The latter is, obviously, the case iff φ is unsatisﬁable.
Since ng is the only node with a precondition, all other nodes are trivially executable
and hence the claim follows.
Lemma 10 Assume a sound annotated process graph P = (N,E,λ,Ω,α) without
effect conﬂicts, where N \ {n0,n+} ⊆NT ∪NXS ∪NXJ , for all n ∈NL we have
Nλ(n) = {nλ(n)
}, eff(n0) is a complete assignment, all predicates have arity 0,
and P is basic except that con(n) may be deﬁned for some n ∈NL. Even if P is
known to be reachable, deciding whether P is executable, or whether some n ∈N is
executable, is coNP-hard. Even if P is known to be executable, deciding whether P
is reachable, or whether some n ∈N is reachable.
Distrib Parallel Databases
Proof This can be proved via a 3SAT reduction very similar to that used for proving
Lemma 9. We simply replace each edge condition with a loop node n where λ(n)
points to an empty sub-process—consisting only of start and end node. The idea is
to only allow exiting the loop if the edge condition holds true. The only tricky bit
here lies in the interpretation of edge conditions and repetition conditions. An edge
condition con(e) means that the edge can be taken when con(e) is true. A repetition
condition con(n) means that the loop is repeated if con(n) is true. Our construction
necessitates us to say the opposite, i.e., we want to state a condition under which
the loop may be exited. The solution is, of course, to use ¬con(e) as the repetition
condition. If con(e) contains several literals, then ¬con(e) is a disjunction, which is
not supported by repetition conditions. However, we can obtain the desired effect by
creating, in this case, one loop node for every literal in con(e).
In detail, the reduction works as follows. We assume a CNF φ with n propositions
p1,...,pn, and k clauses c1,...,ck where ci = li1 ∨li2 ∨li3. The construction follows the same scheme as depicted in Fig. 9, and the reader is advised to consider this
ﬁgure when reading the following. The set of nodes N and their annotation (of which
we show only the non-empty ones) is:
1. start node n0; eff(n0) = ∅
2. parallel split node nps
3. xor-split nodes nxs1 ···nxsn
4. for 1 ≤i ≤n: task nodes npi and nnotpi; eff(npi) = {pi}, eff(npi) = {notpi}
5. xor-join nodes nxj1 ···nxjn
6. parallel join node npj
7. for 1 ≤i ≤k: xor-split node nxs′
8. for 1 ≤i ≤k: loop node nli with con(nli) = {¬li1,¬li2,¬li3}; for 1 ≤j ≤3:
loop node nlj
i with con(nlj
i ) = {lij}
9. for 1 ≤i ≤k −1: xor-join node nxj′
10. task node ng
11. xor-join node nxj′
12. stop node n+
As stated, λ points to an empty sub-process for every loop node. The set of edges E
1. (n0,nps)
2. for 1 ≤i ≤n: (nps,nxsi)
3. for 1 ≤i ≤n: (nxsi,npi) and (nxsi,nnotpi)
4. for 1 ≤i ≤n: (npi,nxji) and (nnotpi,nxji)
5. for 1 ≤i ≤n: (nxji,npj)
6. (npj,nxs1)
7. for 1 ≤i ≤k −1: (nxs′
i,nli) and (nli,nxj′
8. for 1 ≤i ≤k: (nxj′
9. for 1 ≤i ≤k −1: (nxj′
k,nlk) and (nlk,ng)
11. (ng,nxj′)
12. (nxj′,n+)
Distrib Parallel Databases
Since all preconditions are empty, it is obvious that P is executable. By construction, P is reachable iff ng is reachable. The repetition conditions at nodes nli ensure
that one can exit the loop iff clause i is satisﬁed. The repetition conditions at the
sequenced nodes nl1
i ensure that one can traverse the entire sequence iff
clause i is violated. Hence ng is reachable iff φ is satisﬁable. The annotation of the
start node can be set to be eff(n0) = {¬p1, ¬notp1,..., ¬pn, ¬notpn}, and hence
to be complete. The parallel split/join can be replaced by a simple sequencing of all
the xors setting proposition values.
For executability checking, we can use a similar reduction. Given a CNF φ, let p
be a new proposition; obtain φ′ by inserting p into every clause of φ. Then construct,
for φ′, the process graph as above, with the only difference being that ng has the
annotation pre(ng) = {p}. With this construction, we have that (1) ng is reachable
(trivially, by making p true and choosing the p-branch for every clause); (2) with
that, clearly all nodes are reachable; and (3) ng is executable iff every satisfying
assignment to φ′ makes p true. The latter is, obviously, the case iff φ is unsatisﬁable.
Since ng is the only node with a precondition, all other nodes are trivially executable
and hence the claim follows.
Lemma 11 Assume a basic sound atomic annotated process graph P = (N,E,λ,
Ω, α) without effect conﬂicts, where N \ {n0,n+} ⊆NT ∪NXS ∪NXJ , eff(n0) is
a complete assignment, and all predicates have arity 0. Even if P is known to be
reachable, deciding whether n ∈N is executable is coNP-hard. Deciding whether P
is reachable, or whether n ∈N is reachable, is NP-hard.
Proof This can be proved via a 3SAT reduction very similar to that used for proving Lemma 9. The difference to that lemma is that P is basic, so we cannot make
use of edge conditions or of repetition conditions. The main property underlying the
situations considered is that non-executable task nodes are allowed. We can simply
use those just like edge conditions, to ﬁlter the set of execution paths that may traverse a certain branch of the process. Note here that, for executability, we consider
only the decision problem asking whether a particular node (rather than the entire
process) is executable. For reachability, it is noteable that we can not restrict consideration to executable processes—if the process is executable then it is also reachable,
cf. Proposition 2.
In detail, the reduction works as follows. We assume a CNF φ with n propositions
p1,...,pn, and k clauses c1,...,ck where ci = li1 ∨li2 ∨li3. The construction follows the same scheme as depicted in Fig. 9, and the reader is advised to consider this
ﬁgure when reading the following.
The set of nodes N and their annotation (of which we show only the non-empty
1. start node n0; eff(n0) = ∅
2. parallel split node nps
3. xor-split nodes nxs1 ···nxsn
4. for 1 ≤i ≤n: task nodes npi and nnotpi; eff(npi) = {pi}, eff(npi) = {notpi}
5. xor-join nodes nxj1 ···nxjn
6. parallel join node npj
Distrib Parallel Databases
7. for 1 ≤i ≤k: xor-split node nxs′
8. for 1 ≤i ≤k: for 1 ≤j ≤3: task node nxstij; pre(nxstij) = {lij}
9. for 1 ≤i ≤k: task node nxst′
i; pre(nxst′
i) = {¬li1,¬li2,¬li3}
10. for 1 ≤i ≤k −1: xor-join node nxj′
11. task node ng
12. xor-join node nxj′
13. stop node n+
The set of edges E and their annotation is:
1. (n0,nps)
2. for 1 ≤i ≤n: (nps,nxsi)
3. for 1 ≤i ≤n: (nxsi,npi) and (nxsi,nnotpi)
4. for 1 ≤i ≤n: (npi,nxji) and (nnotpi,nxji)
5. for 1 ≤i ≤n: (nxji,npj)
6. (npj,nxs1)
7. for 1 ≤i ≤k: (nxs′
i) and (nxst′
8. for 1 ≤i ≤k −1: for 1 ≤j ≤3: (nxs′
i,nxstij) and (nxstij,nxj′
9. for 1 ≤i ≤k −1: (nxj′
10. for 1 ≤j ≤3: (nxs′
k,nxstkj) and (nxstkj,ng)
11. (ng,nxj′)
12. (nxj′,n+)
Obviously, P is reachable iff ng is reachable iff φ is satisﬁable. The annotation of the
start node can be set to be eff(n0) = {¬p1, ¬notp1,..., ¬pn, ¬notpn}, and hence
to be complete. The parallel split/join can be replaced by a simple sequencing of all
the xors setting proposition values.
For executability checking, we use a similar reduction. Given a CNF φ, let p be
a new proposition; obtain φ′ by inserting p into every clause of φ. Then construct,
for φ′, the process graph as above, with the only difference being that ng has the
annotation pre(ng) = {p}. With this construction, ng is executable iff every satisfying
assignment to φ′ makes p true. The latter is, obviously, the case iff φ is unsatisﬁable.
Since all nodes are reachable (ng can be reached by setting p to be true), this proves
the claim.
Theorem 2. Assume a sound annotated process graph P = (N,E,λ,Ω,α) without
effect conﬂicts, where N \ {n0,n+} ⊆NT ∪NXS ∪NXJ ∪NL, eff(n0) is a complete
assignment, all predicates have arity 0, and either P is atomic or for all n ∈NL we
have Nλ(n) = {nλ(n)
}. The following problem is p
2-hard even if P is known to
be reachable:
– Is P executable, or is n ∈N executable, given that P is basic except that T may
involve arbitrary clauses?
The following problems are coNP-hard even if P is known to be reachable:
– Is P executable, or is n ∈N executable, given that P is basic except that T may
involve arbitrary Horn clauses?
– Is P executable, or is n ∈N executable, given that P is basic except that con(e)
may be deﬁned for some e ∈E?
Distrib Parallel Databases
– Is P executable, or is n ∈N executable, given that P is basic except that con(n)
may be deﬁned for some n ∈NL?
– Is n ∈N executable, given that P is basic?
Proof Follows directly from Lemmas 8, 9, 10, and 11.
Theorem 3. Assume a sound annotated process graph P = (N,E,λ,Ω,α) without
effect conﬂicts, where N \ {n0,n+} ⊆NT ∪NXS ∪NXJ ∪NL, eff(n0) is a complete
assignment, all predicates have arity 0, and either P is atomic or for all n ∈NL we
have Nλ(n) = {nλ(n)
}. The following problem is p
– Is P reachable, or is n ∈N reachable, given that P is basic except that T may
involve arbitrary clauses?
The following problems are NP-hard:
– Is P reachable, or is n ∈N reachable, given that P is basic except that T may
involve arbitrary Horn clauses?
– Is P reachable, or is n ∈N reachable, given that P is executable, and basic except
that con(e) may be deﬁned for some e ∈E?
– Is P reachable, or is n ∈N reachable, given that P is executable, and basic except
that con(n) may be deﬁned for some n ∈NL?
– Is P reachable, or is n ∈N reachable, given that P is basic?
Proof Follows directly from Lemmas 8, 9, 10, and 11.