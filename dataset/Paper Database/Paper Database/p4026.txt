IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-9, NO. 1, JANUARY 1983
 M. M. Zloof, "Query-By-Example: A database language," IBM
Syst. J., vol. 16, no. 4, pp. 324-343.
Barry E. Jacobs was born in Brooklyn, NY, in
He received the B.S. degree in mathematics from
Brooklyn College of the City
University of New York and the M.S. and Ph.D.
degrees in mathematics from the Courant Institute of Mathematical Sciences (N.Y.U.) under
the direction of Prof. M. D. Davis.
He is currently an Assistant Professor of Computer Science at the University of Maryland,
College Park.
He has published in the area of
mathematical logic, in particular, in generalized
recursion theory and abstract computational complexity theory. More
recently, this "born again" databaser has written over 20 papers generalizing and extending database research from the relational to the
heterogeneous case (relational, hierarchical, network) using database
logic as a framework.
Cynthia A. Walczak received the B.S. degree in
mathematics from the University of Wisconsin,
Stevens Point, in 1976 and the M.S. degree in
computer science from the University of Maryland, College Park, in 1979.
She is presently a Ph.D. student at the University of Maryland and works at the National
Institute of Dental Research in Bethesda, MD.
Her research interests include database design
and pattern recognition.
Optimization Algorithms for Distributed Queries
PETER M. G. APERS, ALAN R. HEVNER, AND S. BING YAO
Abstract-The efficiency of processing strategies for queries in a distributed database
is critical for system performance.
Methods are
studied to minimize the response time and the total time for distributed
A new algorithm (Algorithm GENERAL) is presented to
derive processing strategies for arbitrarily complex queries.
versions of the algorithm are given: one for minimizing response time
and two for minimizing total time. The algorithm is shown to provide
optimal solutions under certain conditions.
Index Tenns-Computer network,
distributed
systems, distributed processing strategy, heuristic algorithms, query
processing, relational data model, system modeling.
1. INTRODUCTION
IN a distributed database, we have the ability to decentralize
data that are most heavily used by end users at geographically dispersed locations and, at the same time, to combine data
from different sources by means of queries. The decentralization of data will result in better response times and, if multiple
copies are used, in a more reliable system.
The retrieval of data from different sites in a network is
known as distributed query processing.
The difference between query processing in a centralized database and a distributed database is the potential for decomposing a query
Manuscript received October 1, 1980; revised January 4, 1982 and
April 1, 1982.
P.M.G. Apers is with the Informatica Wiskundig Seminarium, Vrije
Universiteit, de Boelelaan 1081, HV Amsterdam, The Netherlands.
A. R. Hevner and S. B. Yao are with the College of Business and
Management, University of Maryland, College Park, MD 20742.
into subqueries which can be processed in parallel, and their
intermediate results can be sent in parallel to the required
computers.
Finding an efficient way of processing a query is
important.
If a query is processed inefficiently, it not orxly
takes a long time before the end user gets his answer, but it
might also decrease the performance of the whole system
because of network congestion. We will investigate two optimization objectives: the minimization of response time and of
total time. Which of these two objectives is better for a specific system depends upon the system's characteristics.
Distributed query processing has received a great deal of
attention , .
The initial research in this area was
done by Wong .
He proposed an optimization method
based on a greedy heuristic that produces efficient, but not
necessarily optimal query processing strategies. An enhanced
version of this method is implemented in the SDD-1 system
Epstein et aL. developed an algorithm based on the
query optimization technique of decomposition .
algorithm is implemented in the distributed INGRES database system.
Performance studies of this algorithm are reported in . A dynamic optimization algorithm for the
POLYPHEME system has been proposed by Toan [171.
research on dynamic optimization algorithms has
been done by Baldissera et aL and Takizawa .
Work by Chu and Hurley defined the solution space of
feasible processing strategies for distributed queries.
presented an optimal, although inherently exponential, optimization algorithm.
The use of the semi-join operation has led
to the development of full-reduction methods of processing a
0098-5589/83/0100-0057$01.00 i) 1983 IEEE
IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-9, NO. 1, JANUARY 1983
distributed query [61, 
 , .
These methods are
applicable for a special class of queries known as tree queries.
and Schreiber
use an integer programming
technique to minimize cost in distributed query processing.
Kershberg et al. apply query optimization to a database
allocated on a star network and study the system performance.
For a special class of simple queries, Hevner and Yao developed algorithms PARALLEL and SERIAL that find
strategies with, respectively, minimurn response time and total
In , they extended these algorithms to Algorithm
distributed queries.
showed that this algorithm had some serious drawbacks.
complexity for worst case queries does not have a polynomial
Also, the analysis of the quality of the derived processing strategies is difficult.
Both Hevner and Apers
 recognized these problems and developed improved algorithms.
Here we present this improved algorithm, Algorithm
It is more clearly understood and more usable
distributed query optimization algorithm than Algorithm G.
This paper is organized as follows.
In Section II, we will
briefly repeat the query processing model described in .
Three versions of Algorithm GENERAL, for response time and
total time, are presented and analyzed in Section III.
II. DEFINITIONS AND DISTRIBUTED SYSTEM MODEL
A distributed database system is characterized by the distribution of the system components of hardware., control, and
For this research, a distributed system is a collection of
independent
interconnected
point-to-point
communication lines.
Each computer, known as a node in
the network, has a processing capability, a data storage capability, and is capable of operating autonomously in the system.
Each node contains a version of a distributed DBMS.
The database is viewed logically in the relational data model
The database is allocated across system nodes in units
of relations (without loss of generality, relation fragments
may be considered as relations for distribution). The relation
distribution allows a general manner of redundancy. The only
allocation constraint is that all data must be either locally or
globally accessible from any system node.
The distribution
of data on the network is invisible to the user.
We assume that we know the following information about
the relations.
For each relation R1, i = 1, 2,-., m,
ni: number of tuples,
ai: number of attributes,
si: size (e.g., in bytes).
For each attribute d11, j = 1, 2,'
*, ai of relation Ri,
pij: selectivity,
b11: size (e.g., in bytes) of the data item in attribute di;.
The selectivity Pij of attribute '4i is defined as the number of
different values occurring in the attribute divided by the
number of all possible values ofthe attribute. Thus, O<piJ
To process a query in a relational database, we only need
the operations restriction, projection, and join .
In a distributed database, we may need to compute joins on relations
which are located at different sites.
Instead of computing
these joins immediately, we will first reduce the sizes of the
relations wherever possible by restrictions and projections.
A relation, which is one of the operands of a join, can -be
made smaller by deleting the tuples that cannot play a role
in the join. An operation called a semi-join deletes these
tuples of the relation.
If relation Ri has a semi-join with attribute dkl on attribute di, then the parameters of relation
Ri are changed in the following way:
Si vSi * Pkl,
Pij +Pij * Pkl,
bijv bij P*pkl.
The selectivity and size of only the joining attribute are
reduced because of an assumption of attribute independence
within each relation in our model.
To compute a semi-join, the unique values of the joining
attribute of one relation are sent to the other relation.
cheaper to compute this semi-join than the complete join.
In the result node, the-complete join will be computed after
the reduced relations have arrived by concatenating matching
tuples on the joining attributes.
The data transmissions
used for reducing a relation and the transmission of the reduced relation to the query computer form a schedule for this
An example of a schedule for relation Ri can be
seen below.
I_____________
I- -------
-----------d22
Attribute d2l
is sent to attribute d3I.
A semi-join is performed on relation R3 . The reduced d3l attribute is sent to
relation R1 in parallel with attribute d22.
Further relational
operations reduce the size of relationRR1. Finally, the reduced
relation R I is sent to the result node.
It is also possible to construct a schedule for an attribute
instead of a relation. A schedule for an attribute is constructed
to send the attribute to a relation upon which a semi-join
will be computed-for example, attribute d31
in the above
We assume that the transmission cost of the data is the same
between any two computers and is a linear function of the
size of the data.
This function will be denoted by C(X) v-
Co + C1X where X is the amount of data transmitted.
response time of a schedule is the time elapsed between the
start of the first transmission and the time at which the relation (attribute) arrives at the required computer.
The minimnum response time of a relation (attribute) is the minimum
response time among all possible schedules for this relation
(attribute).
The total time of a schedule is the sum of the
costs of all transmissions required in the schedule.
The incoming selectivity of a schedule for a relation (or
attribute) is the product of selectivities of all the attributes in
the schedule (more than one occurrence of an attribute in a
schedule can contribute only one instance of its selectivity)
APERS et al.. OPTIMIZATION ALGORITHMS FOR DISTRIBUTED QUERIES
excluding the attributes of the relation (or in the case of an
attribute, the attribute itself).
A distribution strategy for a query consists of the schedules
for all relations which do not reside in the result node and are
used in the query. With the assumption that data transmission
costs are significantly greater than local processing costs in the
system, the cost of processing a query is determined by the
transmission costs in its distribution strategy.
Another implicit assumption that we make throughout this paper is that
the query processing strategy is run on a dedicated system in
order to achieve minimum execution times. Dynamic system
factors such as communication line contention and subsequent
queueing delays are not considered in our static query optimization algorithms.
In a distributed database, it is, in general, better to do local
processing first because it reduces the amount of data to be
transmitted. With local processing, we mean the computation
of restrictions, projections, and semi-joins between relations
that reside in the same node.
After the initial processing,
each node that has query data will be considered to contain
only one "integrated" relation.
The relations at each node
remain distinct (i.e., no Cartesian product relation is formed).
However, by
reformatting
becomes a variable, the distribution aspects of the query are
emphasized . Without loss of generality, this assumption
provides a distribution abstraction to the problem and simplifies the understanding of our following algorithms.
Initial local processing results in the following parameters:
m: number of relations in the remaining query,
ai: number of attributes in relation Ri,
Pis: number of intemodal joining attributes in relation R,.
In and , Hevner and Yao introduced and investigated algorithms, PARALLEL and SERIAL, which, respectively, compute minimum response and total time schedules
for simple queries.
Queries are called simple if, after initial
local processing, the relations contain only one attribute: the
joining attribute. Thus, a= gi = 1 for i =
Algorithm PARALLEL
1) Order relations Ri such that s, < s22
2) Consider each relation Ri in ascending order of size.
3) For each relation R1(j <i), construct a schedule to Ri
that consists of the parallel transmission of the relation R, and
all schedules of relations Rk(k <j).
Select the schedule with
minimum response time.
Algorithm SERIAL
1) Order relations R1 such that s, < S2
2) If no relations are at the result node, then select strategy:
* **Rn -+ result node.
Or else if Rr is a relation at the result node, then there are two
strategies:
Select the one with minimum total time.
The complexity of algorithm PARALLEL is 0(m2) and that
of algorithm SERIAL is O(m log2 m) where m is the number
of required relations in the query .
III. ALGORITHM GENERAL
A general query
is characterized by a i> ,i
1i 2,.*.*, m.
This means that a relation can contain more
than one joining attribute.
Let a represent the number of
joining attributes in a query.
Therefore, such a relation can
be reduced in size by semi-joins on different joining attributes.
To illustrate our query optimization methods, we will use a
database consisting of the following relations:
PARTS(P#, PNAME)
ON-ORDER(S#,P#, QTY)
S-P-J(S#, P#, J#).
The query represented by Fig.
1 is: "List the P#, PNAME,
and total quantity for all parts that are currently on order
from suppliers who supply that part to jobs 10 or 20."
In this query, there are two joining attributes, P# and S#.
Assume that each relation is located at a different node and
that the result is required at a fourth node. After performing
the restriction on the S-P-J relation, the required attributes in
each relation are projected. The resulting size and selectivity
parameters are given in Table I.
Let C(X) =20+ X.
The response time and total time costs of the different
query processing strategies for this query will be compared
for the response time and total time versions of algorithm
A simple way of processing a query is to perform initial
local processing, followed directly by the transmissions of all
remaining data to the result node, where centralized query
processing builds the result.
This will be called the Initial
Feasible Solution (IFS).
R1: ON-ORDER
1------------------I
Response time = 3020.
Total time = 6060.
We now present an outline of Algorithm GENERAL. Minimization of response time and total time is done by three
different versions of the algorithm, which are discussed in the
next three sections.
Algorithm GENERAL
1) Do -all initial local processing.
2) Generate candidate relation schedules.
Isolate each of
the a joining attributes, and consider each to define a simple
query with an undefined result node.
a) To minimize response time, apply Algorithm PARAL-
LEL to each simple query.
Save all candidate schedules for
integration in step 3.
IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-9, NO. 1, JANUARY 1983
10) OR (J# = 20))
(P# ,PNAME, SUM(QTY))
Fig. 1. Example query 1.
R1: ON-ORDER
R 2: S-P-J
b) To minimize total time, apply Algorithm SERIAL to
each simple query.
This results in one schedule per simple
From these schedules, the candidate schedules for
each joining attribute are extracted. Consider joining attribute
Its candidate schedule is identical to the schedule produced by Algorithm SERIAL, applied to the simple query in
occurs, up to the transmission of di,.
All transmissions after that are deleted from the schedule.
3) Integrate the candidate schedules.
For each relation R1,
the candidate schedules are integrated to form a processing
integration
is done by procedure
RESPONSE for response time minimization and by procedure TOTAL
or procedure COLLECTIVE
for total time
minimization.
redundancies.
schedules for relations which have been transmitted in the
schedule of another relation.
Algorithm GENERAL derives a query processing strategy for
either response time or total time minimization by using the
procedures RESPONSE, TOTAL, and COLLECTIVE.
A. Response Time Version
To minimize the response time of a relation Rk, we have to
test whether transmitting an attribute di, to Rk is cost beneficial.
Therefore, we have to know how long it takes to get
to the site where Rk is located.
Algorithm PARALLEL
derives minimum response time schedules for joining attributes.
In fact, there is no procedural difference between computing
the minimum response time schedules for joining attributes
whether they are sent to a result node or the node where Rk
is located.
Therefore, in step 2 of Algorithm GENERAL,
Algorithm PARALLEL is applied to each joining attribute
individually to compute a minimum response time schedule
All these candidate schedules are saved for integration by procedure RESPONSE.
Procedure RESPONSE
1) Candidate schedule ordering.
For each relation R1,
order the candidate schedules on joining attribute dif,j= 1, 2,
a in ascending order of arrival time.
Let ART, denote
the arrival time of candidate schedule CSCH,.
(For the di1
joining attributes not in Ri, disregard the corresponding candidate schedules.)
2) Schedule integration. For each candidate schedule CSCH,
in ascending order, construct an integrated schedule for R1
that consists of the parallel transmission of CSCH, and all
CSCHk with k < 1.
Select the integrated schedule with minimum response time.
Applying Algorithm GENERAL (response time) to the previous example, after the initial processing, two simple queries
are formed, one having di, = P# as a common joining attribute
and the other having di2 = S#. Running Algorithm PARAL-
LEL on the P# query, the resulting candidate schedules are
---------1
I---------------di,l
I----------------:
i---------1
Applying Algorithm PARALLEL
to the S# query, the
candidate schedules are
d22: I--------F--------------
The construction of the schedule for R1 will be given in
1 of Procedure RESPONSE, the schedules of
attributes that can be applied to relation R, are ordered on
their arrival time in the node where R1 is located.
This gives
the following result:
Arrival Time
In step 2, for each of these attributes dk, an integrated
schedule for RI
is constructed, consisting of the parallel
transmission of all attributes having an arrival time less than or
equal to ARTk. The following three integrated schedules are
APERS et al.: OPTIMIZATION ALGORITHMS FOR DISTRIBUTED QUERIES
constructed:
1--I-----------1--I------------1-
Response time = C(100) + C(0.2 * 450) + C(0.9 * 1000)
= 120+ 110+920
I-.-.-I-.-- i---
Response time = C(400) + C(0.9 * 0.4 * 1000)
= 420 + 380
.-------------------------.I------------I
I.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
I___________________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Response time = C(400) + C(0.4 * 0.4 * 900)
+ C(0.9 * 0.4 * 0.9 * 1000)
=420+ 164 +344
From these three schedules for RI and the Initial Feasible
Solution for RI, the schedule with the minimum response
time is chosen.
This is the second schedule and its response
time is 800.
The schedules for R2 and R3 are constructed in a similar
The Algorithm GENERAL (response time) query processing strategy for the example query is
A comparison to the response time of the IFS shows a considerable cost reduction.
Procedure RESPONSE is given the minimum response time
schedules of all joining attributes.
In step 2 of Algorithm
GENERAL, Algorithm PARALLEL is applied to a different
simple queries.
Therefore the minimum response time schedules for one common joining attribute are given in order of
response time. This means that putting the candidate schedules
in order of arrival time will take at most O(Um log2 cX), which
is the merging complexity.
In step 2 of Algorithm GENERAL, Algorithm PARALLEL
is applied a times and its complexity is 0(m2). However, the
cost of applying procedure RESPONSE for every relation Ri
is O(Um2 log2 a).
Therefore, the complexity of Algorithm
GENERAL (response time) is O(um2 log2 a).
Now we will investigate the quality of the derived schedules.
The schedules produced by algorithm PARALLEL for the
joining attributes have a minimum response time. From this
fact, we now can prove that each relation schedule has a minimum response time and, consequently, that the total query
processing strategy has a minimum response time.
within our proofs, we require the model assumption of attribute independence within each relation.
Initial studies
indicate that the effect of this assumption on the performance
of the resulting query processing strategies may not be significant .
Theorem 1: Procedure
response time integrated schedule for Ri.
Proof: The
RESPONSE are all minimum response time schedules because
of the optimality of Algorithm PARALLEL . Procedure
RESPONSE puts these candidate schedules in ascending order
of arrival time, and it only considers integrated schedules for
relation Ri that consist of the parallel transmission of joining
attributes with arrival time less than or equal to the arrival
time of a certain CSCHk.
We will show that no other integrated schedule needs to be considered.
Assume that we are given a minimum response time schedule
This schedule contains the transmissions of some
joining attribute which arrives last (i.e., has the greatest value
in the schedule).
The corresponding integrated
schedule (based on ARTk as the largest ART value) considered
R 1: ON-ORDER
.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
I-----------I---------__I
I-----------------------I
Response time = 920.
Total time = 2910.
IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-9, NO. 1, JANUARY 1983
by procedure RESPONSE contains at least as many transmissions of joining attributes as the previous schedule and,
therefore, its selectivity is at least as small. Hence, its response
time must be less than or equal to that of the minimum response time schedule.
Theorem 2: Algorithm GENERAL (response time) derives
a minimum response time processing strategy for any distributed query.
Proof: The response time of a processing strategy is the
maximum- response time of the relation schedules in the
1 showed that these relation schedules
have minimum response time. Hence, the theorem follows.
Total Time Version
The motivation for using the minimization of the total time
as the objective of Algorithm General comes from the use of
the algorithm in a multiprocessing environment.
Minimizing
response time leads to an increased number of parallel data
transmissions
in the query processing
In multiprocessing systems, under moderate
to heavy loads, these
extra transmissions may lead to significant queueing delays
and synchronization
delays, delays which may cause poor
query response time. By minimizing the total time in a query
processing strategy, fewer transmissions will be included and
improved actual response times may result in certain system
environments.
The candidate schedules produced in step 2 of Algorithm
GENERAL (total time) look very much like the schedules
produced by Algorithm SERIAL.
Algorithm SERIAL produces minimum total time schedules for simple queries. In its
optimality proof , it is shown that parallel transmissions
of common joining attributes can be avoided.
Therefore, we
will do the same in Algorithm GENERAL (total time). Only
parallel transmissions of different joining attributes are allowed.
This means that in constructing a schedule for relation
Ri, we will consider only one candidate schedule per joining
attribute of Ri.
This candidate schedule will be the one that
minimizes the total time of transmitting Ri if only that one
joining attribute is considered.
In , it was shown that it is not sufficient to just look at
the candidate schedules produced in step 2 of Algorithm
For every candidate schedule to relation R1
containing a transmission of a joining attribute from the same
relation Ri, we
to add another candidate schedule,
namely, one without the transmission of this joining attribute.
This is necessary since the size of relation Ri cannot be reduced by the selectivity of its own attribute.
Thus, this data
transmission in the incoming schedule may not be cost beneficial.
Among this extended set of candidate schedules, we
select the schedule which minimizes the total time of transmitting Ri if only one joining attribute is considered.
selected schedule for relation Ri considering joining attribute
di will be called BEST1j.
We define SLTi, to be the accumulated attribute selectivity
of the BESTii candidate schedule into Ri.
Note that j may
take on values from
1 to a only if the common joining at-
Procedure TOTAL
1) Adding candidate schedules. For each relation Ri and
each candidate schedule CSCHI, do the following.
If this schedule contains
a transmission of a joining attribute of Ri, say di, then add another candidate schedule
which is the same as CSCH, except that the transmission of
di is deleted.
2) Select the best candidate schedule. For each relation
Ri and for each joining attribute di(j = 1, 2,
a), select
the candidate schedule which minimizes total time for transmitting Ri if only the joining attributes are considered which
can be joined with di,.
3) Candidate
ordering. For
order the candidate schedules BESTij on joining attributes
di, j= 1, 2,-, a,
so that ART1l +C(s
ARTig + C(si * SLTig).
(For the joining attributes not in Ri,
disregard BESTi1.)
ART1j denotes the arrival time of the
BESTij schedule.
4) Schedule integration. For each BEST1j in ascending order
of j, construct an integrated schedule to Ri that consists of
the parallel transmission of candidate schedule BESTi1 and all
schedules BESTik where k <j.
Select the integrated schedule
that results in the minimum total time value
ARTik + c(s1 * H SLTik
Applying Algorithm GENERAL (total time) to the example,
two simple queries
are formed on the following joining attributes, di, = P# and di2 = S# in the example
step 2 of Algorithm GENERAL (total time), the following
serial candidate schedules are forned.
I-.-.-.---------1
d12:.1-----d12
1---------I-I-1---------
Again, the construction of the schedule
discussed in detail. We will treat the two attributes of R 1 in
Attribute d1
1 of Procedure TOTAL, the following two schedules are added to the above schedules for P#. The first one is
obtained by deleting the transmission of d,1 from the schedule for d21, and the second one by deleting di, from the
tributes di appear in Ri.
schedule for d3l
APERS et al.: OPTIMIZATION ALGORITHMS FOR DISTRIBUTED QUERIES
<.---------local processing
Fig. 2. Example query 2.
-------------
Thus, there are five schedules that only contain transmis-
sions of theP#attribute.
Four of them will be tested. The
transmission of d 1I to R1 is meaningless as a schedule.
d21: I-------
Total time = C(400) + C(0.4 * 400) + C(0.4 * 1000)
= 420 + 180 + 420
Total time = C(400) + C(0.4 * 400) + C(0.4 * 0.4 * 900) + C(0.4 * 0.9 * 1000)
= 420 + 180 + 164 + 380
d :I------
-i--I------
Total time = C(400) + C(0.4 * 1000)
= 420 + 420
Total time = C(400) + C(0.4 * 900) + C(0.4 * 0.9 * 1000)
= 420 + 380 + 380
Because the schedule of d2l1 has the smallest total time, it
to the above schedules for attribute S#.
is chosen as the BEST,1 schedule.
Attribute d12
Each of the schedules for S# is applied to RI.
Again, trans-
In step 2 of Procedure TOTAL, only one schedule is added
mitting dl2 toRI is not considered.
IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-9, NO. 1, JANUARY 1983
.--1-.-.-.-.-----
Total time = C(100) + C(0.2 * 450) + C(0.9 * 1000)
= 120+ 110+920
d 2: I--------------------I-I--- -
Total time = C(450) + C(0.9 * 1000)
= 470 + 920
Because the schedule of d22 has the smallest total time, it is
chosen as the BEST12 schedule.
In steps 3 and 4 of the Procedure TOTAL, the above obtained BEST1j schedules are ordered on their total time, and
the following two integrated schedules are constructed:
.------------------.-----I---------------------d2 1
I----------I
-------------------~ ~~~~~~~~I
The first of these two has the smallest total time; it is chosen
as the solution of Algorithm GENERAL for R 1.
The schedules for R2 and R3 are constructed in a similar
way. The Algorithm GENERAL (total time) query processing
strategy for the example query is
R 1: ON-ORDER
schedules.
Hence, the cost of step 2 is O(am2).
This means
that for an arbitrary general distributed query, Algorithm
GENERAL (total time) has a processing complexity no worse
than O(Um2).
The quality of the resulting query processing strategies is
much harder to analyze than those for minimizing response
The BESTij schedules were shown to be the best possible schedules for minimizing the total transmission time of
relation Ri if only one common joining attribute is considered
[1I. However, the optimality is lost during the integration of
the different BESTij schedules.
In , it was shown that
finding the minimum total time schedule is equivalent to a
problem which is proved to be NP-hard.
C Handling Redundant Data Transmissions
A major reason why the query processing strategy derived
by Algorithm GENERAL (total time) is not optimal is that
procedure TOTAL does not consider the existence of redundant
data transmissions in separate relation schedules.
(Note that such redundant transmissions between relation
schedules do not effect the minimum response time strategies
of Section
is because Algorithm GENERAL
(response time) minimizes the response time of each relation
schedule separately.)
This example
illustrates
of redundant data
transmissions.
A database contains three relations: R1, R2,
and R3. The query represented by Fig. 2 is entered in a distributed database system wherein each relation is located at
a separate node and the result of the query is required at a
different node.
The sizes and selectivities for each di, after local processing,
are given in Table II. Assume the cost function for the system
----------- ----------di1
--------------------------I
Response time = 1100.
The total time of this strategy is considerably smaller than
the total time ofthe IFS. Also, the response time of its strategy
for the example query is not much larger than the response
time of the strategy produced by the response time version of
Algorithm GENERAL, although it only tries to minimize total
Algorithm GENERAL (total time) has a slightly better worst
case complexity than the
response time version, O(am2).
assume that
a general query requires data from m
relations, and all m relations are joined on a joining attributes.
In step 2, algorithm SERIAL is applied to each simple query.
The complexity of this is O(aM log2 m) because the joining
attributes have to be ordered by size.
The complexity of the procedure TOTAL is O(aM2).
step 1, no more than O(am) candidate schedules are added.
This means that for every relation, the procedure has to
among O(am)
Total time = 2480.
to be C(X) = 25 + X.
applying Algorithm GENERAL
(total time) to this
query (the
derivation
in the Appendix),
the resulting processing strategy is
.-----I----------d12
.----------------I-----------I----------------.
Total time = 1600.
The first redundant transmission one can clearly recognize
is the transmission of the attribute d21
towards R 1.
transmission will physically take place only once, so its cost
(125) should be accounted for only once as well. We might
APERS et al.: OPTIMIZATION ALGORITHMS FOR DISTRIBUTED QUERIES
visualize this removal as follows:
:----------------I
__________-------d12
l---------------- I----------------l----------------l
Total time = 1475.
Apart from this type of direct transmission redundancy, it
is possible to discern a somewhat more complicated type.
might happen that the transmission of di1 towards the node of
Rk is part of some schedule, while it does not occur in the
schedule of Rk itself.
Because the values of this attribute
are available for a semi-join with Rk, it seems fair enough
to assume that this semi-join will actually take place, and that
the cost for the final transmission of Rk will subsequentially
In such a case, it is clear that Rk cannot be transmitted before all attributes have arrived, which means that the
schedule must be synchronized.
This could lead to an increased response time.
In our example, we can also detect
such a case.
In the R2 schedule, d12 is sent to d32.
So d12 is available
for R3, although it is not part of the R3 schedule.
transmission of R3 will only cost C =
85 instead of 265. Again we try to illustrate this:
I-----------:
Total time = 1295.
(Note that R3 can be sent at time t = 325, instead of at time
As these aspects are not considered during the selection of
the final schedules, a few beneficial strategies will not be
found by Algorithm GENERAL (total time).
This. is mainly
due to the characteristic that a best schedule is separately
chosen for each relation, without regarding the "collective"
It means that for some Rk, a schedule might be just
too expensive and thus rejected, while it had many transmissions in common with selected schedules of other relations, and thus would have been a very good choice for the
strategy as a whole.
In order to
test the above statements, we developed an
altemative
of Algorithm GENERAL
called Algorithm GENERAL (collective), completely based on
redundant transmissions.
It is simpler in that it constructs
only one basic strategy for the entire query, after which a
few variations are
tried out.
The schedules of the basic
strategy include as many semi-joins as possible for each relation.
This tends towards a large number of redundant transmissions.
The investments for such an extended integrated
schedule are shared, as it were, by all Rk. The strategy is then
perturbed by subsequentially trying to drop schedule components (i.e., linear parts of an integrated schedule) for some
relation Rk, and finally to drop such a component, which
actually stands for the semi-joins on one particular attribute,
from the entire strategy.
Algorithm GENERAL (collective)
step 2b) in
Algorithm GENERAL.
The candidate schedule integration is
performned in step 3 by the following procedure.
Procedure COLLECTIVE
1) Select candidate schedule. For each relation Ri and for
each joining attribute di1(j = 1, 2, *
, a), select the minimum
cost candidate schedule that contains the transmission of all
components of attribute j with selectivities <1.
2) Build processing strategy. For each relation Ri, define
the schedule to be the parallel transmission of all di candidate
schedules to R .
3) Test variations of strategy. Using a removal heuristic,
derive new strategies by removing the most costly data transmissions.
Compare the total time cost of the new and old
strategies.
Maintain the less costly strategy. Continue testing
until no cost benefit can be obtained.
Consider the state of the relations RI, R2, and R3 in Table
III after local processing for the query in Fig. 3. The transmission cost function is C(X) = 10 + X.
The schedule components for the three attributes are
l----------- I--------d32
-----I---------.
I-------I-----I
leading to the basic strategy (integrating as much as possible)
I..-----I.-----------------------.
I---------------|
..I____--------------
Total Time = 1408.
IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-9, NO. 1, JANUARY 1983
.---------local processing
Fig. 3. Example query 3.
d12~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(Here ** stands for transmissions, which are already accounted
During the variation trials, it turns out that it is beneficial
to drop the component of attribute 2 from the schedule for
This saves 154 time units, while the cost for the transmission of R3 will increase: C(0.4 * 1250) = 510.
this means a gain of 54.
In the second variation round, it is
found that it is better to leave out the component of attribute
2 at all relations.
Thus, the final solution of the "COLLECTIVE" algorithm
for this example is
-----------l-___I
I--------------
Total time = 1194.
Algorithm GENERAL (collective) has the same worst case
complexity as Algorithm GENERAL (total time) since the
complexity of procedure COLLECTIVE is O(Um2). In step 1,
for every relation (m possibilities) and for every joining attrnbute (a possibilities), the desired candidate schedule must be
selected from m possible schedules. The optimization of step
3 is a greedy heuristic procedure with linear order.
For a significant number of queries, the collective version
of Algorithm GENERAL will produce a smaller total time
strategy than will the total time version. Such improvement is
due to the recognition and inclusion of redundant data transmissions among separate relation schedules in the overall query
processing strategy.
IV. CONCLUSIONS
We claim Algorithm GENERAL to be an efficient algorithm
of polynomial complexity that derives close to optimal query
processing strategies on distributed systems.
The algorithm
was designed as a straightforward extension of the processing
tactics found optimal for simple queries in Algorithm PAR-
ALLEL and Algorithm SERIAL.
There are two primary versions of Algorithm GENERAL.
To minimize response time of a processing strategy, parallel
data transmissions are emphasized by the use of Algorithm
PARALLEL and Procedure RESPONSE.
Algorithm GEN-
ERAL (response time) can be proved to derive minimum response time strategies under the assumption of attribute independence within query relations. To minimize the total time
of a processing strategy, serial time transmissions are emphasized by the use of Algorithm SERIAL and Procedure TOTAL
in Algorithm GENERAL (total time).
Recognizing the existence of identical data transmissions in
different relation schedules may lead to a further reduction in
the total time of a query processing strategy. We develop a
third version of Algorithm GENERAL (collective) that uses
Algorithm SERIAL and Procedure COLLECTIVE to produce
strategies with increased data transmission redundancy among
schedules.
In many cases, the total time of these strategies is
less than the total time of strategies produced by Algorithm
GENERAL (total time).
Algorithm GENERAL can be applied to any general distributed query environment.
It is relatively simple to program
and has the added flexibility that all versions can be implemented together.
Then, depending upon run-time factors,
such as system load or query complexity, the optimization
objective can be changed by a simple switch in the program.
The derivation of the query processing strategy using Algorithm GENERAL (total time) on the database state found in
Table II proceeds as follows.
Two simple queries are formed on the joining attributes di,
In step 2 of Algorithm GENERAL (total time), the
following serial candidate schedules are formed.
For attribute di,:
1--------------I--------d21:
APERS et al.: OPTIMIZATION ALGORITHMS FOR DISTRIBUTED Ql
For attribute di2:
I.-------------d22:
..----------------------------.---------d32:
I1-------------I.-------------
Entering Procedure TOTAL, the BESTil and BESTi2 schedules
are determined as follows:
the linear schedules (i.e., the first in the BESTij ordering) are
the cheapest solutions. Thus, our strategy will be
Total Time = 1600
2I.-I.I_-_-_----I
-----------d21
I-- -_-_-_--
The first schedule becomes our BEST11.
For BEST12, we have to choose among
The first schedule thus will be our BEST12.
In the same way, we find
.-----------I- --------I-
I--------.---I .
By now we can determine the solution for each Ri.
For example, for R1, there are two possibilities, which are
------------and
We conclude that the first schedule is superior.
For the other relations, it also (coincidentally) turns out that
Total Time:
IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-9, NO. 1, JANUARY 1983