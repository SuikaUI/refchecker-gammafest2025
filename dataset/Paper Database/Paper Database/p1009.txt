Structural-RNN: Deep Learning on Spatio-Temporal Graphs
Ashesh Jain1,2, Amir R. Zamir2, Silvio Savarese2, and Ashutosh Saxena3
Cornell University1, Stanford University2, Brain Of Things Inc.3
 , {zamir,ssilvio,asaxena}@cs.stanford.edu
Deep Recurrent Neural Network architectures, though
remarkably capable at modeling sequences, lack an intuitive high-level spatio-temporal structure.
That is while
many problems in computer vision inherently have an underlying high-level structure and can beneÔ¨Åt from it. Spatiotemporal graphs are a popular tool for imposing such highlevel intuitions in the formulation of real world problems.
In this paper, we propose an approach for combining the
power of high-level spatio-temporal graphs and sequence
learning success of Recurrent Neural Networks (RNNs). We
develop a scalable method for casting an arbitrary spatiotemporal graph as a rich RNN mixture that is feedforward,
fully differentiable, and jointly trainable.
The proposed
method is generic and principled as it can be used for transforming any spatio-temporal graph through employing a
certain set of well deÔ¨Åned steps. The evaluations of the proposed approach on a diverse set of problems, ranging from
modeling human motion to object interactions, shows improvement over the state-of-the-art with a large margin. We
expect this method to empower new approaches to problem
formulation through high-level spatio-temporal graphs and
Recurrent Neural Networks.
Links: mWeb
1. Introduction
The world we live in is inherently structured. It is comprised of components that interact with each other in space
and time, leading to a spatio-temporal composition. Utilizing such structures in problem formulation allows domainexperts to inject their high-level knowledge in learning
frameworks.
This has been the incentive for many efforts in computer vision and machine learning, such as
Logic Networks , Graphical Models , and Structured SVMs . Structures that span over both space and
time (spatio-temporal) are of particular interest to computer
vision and robotics communities. Primarily, interactions between humans and environment in real world are inherently
Corresponding
Structural-RNN
Spatio-temporal
graph representation
(e.g. Activity)
Activity Affordance
Activity Affordance
Activity Affordance
Figure 1: From st-graph to S-RNN for an example problem. (Bottom) Shows an example activity (human microwaving food). Modeling
such problems requires both spatial and temporal reasoning. (Middle) Stgraph capturing spatial and temporal interactions between the human and
the objects. (Top) Schematic representation of our structural-RNN architecture automatically derived from st-graph. It captures the structure and
interactions of st-graph in a rich yet scalable manner.
spatio-temporal in nature. For example, during a cooking
activity, humans interact with multiple objects both in space
and through time. Similarly, parts of human body (arms,
legs, etc.) have individual functions but work with each
other in concert to generate physically sensible motions.
Hence, bringing high-level spatio-temporal structures and
rich sequence modeling capabilities together is of particular
importance for many applications.
The notable success of RNNs has proven their capability
on many end-to-end learning tasks . However, they lack a high-level and intuitive spatio-temporal
structure though they have been shown to be successful
at modeling long sequences . Therefore, augmenting a high-level structure with learning capability of
RNNs leads to a powerful tool that has the best of both
Spatio-temporal graphs (st-graphs) are a popular general tool for representing
such high-level spatio-temporal structures. The nodes of the
graph typically represent the problem components, and the
edges capture their spatio-temporal interactions. To achieve
 
the above goal, we develop a generic tool for transforming
an arbitrary st-graph into a feedforward mixture of RNNs,
named structural-RNN (S-RNN). Figure 1 schematically illustrates this process, where a sample spatio-temporal problem is shown at the bottom, the corresponding st-graph representation is shown in the middle, and our RNN mixture
counterpart of the st-graph is shown at the top.
In high-level steps, given an arbitrary st-graph, we Ô¨Årst
roll it out in time and decompose it into a set of contributing factor components. The factors identify the independent components that collectively determine one decision
and are derived from both edges and nodes of the st-graph.
We then semantically group the factor components and represent each group using one RNN, which results in the desired RNN mixture. The main challenges of this transformation problem are: 1) making the RNN mixture as rich as
possible to enable learning complex functions, yet 2) keeping the RNN mixture scalable with respect to size of the
input st-graph. In order to make the resulting RNN mixture rich, we liberally represent each spatio-temporal factor
(including node factors, temporal edge factors, and spatiotemporal edge factors) using one RNN. On the other hand,
to keep the overall mixture scalable but not lose the essential learning capacity, we utilize ‚Äúfactor sharing‚Äù (aka clique
templates ) and allow the factors with similar semantic functions to share an RNN. This results in a rich and
scalable feedforward mixture of RNNs that is equivalent to
the provided st-graph in terms of input, output, and spatiotemporal relationships. The mixture is also fully differentiable, and therefore, can be trained jointly as one entity.
The proposed method is principled and generic as the
transformation is based on a set of well deÔ¨Åned steps and
it is applicable to any problem that can be formulated as
st-graphs (as deÔ¨Åned in Section 3). Several previous works
have attempted solving speciÔ¨Åc problems using a collection
of RNNs , but they are almost unanimously task-speciÔ¨Åc. They also do not utilize mechanisms
similar to factorization or factor sharing in devising their
architecture to ensure richness and scalability.
S-RNN is also modular, as it is enjoying an underlying
high-level structure. This enables easy high-level manipulations which are basically not possible in unstructured
(plain-vanilla) RNNs (e.g., we will experimentally show
forming a feasible hybrid human motion by mixing parts
of different motion styles - Sec 4.2 ). We evaluate the proposed approach on a diverse set of spatio-temporal problems (human pose modeling and forecasting, human-object
interaction, and driver decision making), and show significant improvements over the state of the art on each problem. We also study complexity and convergence properties of S-RNN and provide further experimental insights by
visualizing its memory cells that reveals some cells interestingly represent certain semantic operations. The code
of the entire framework that accepts a st-graph as the input and yields the output RNN mixture is available at the
 
The contribution of this paper are: 1) a generic method
for casting an arbitrary st-graph as a rich, scalable, and
jointly trainable RNN mixture, 2) in defence of structured
approaches, we show S-RNN signiÔ¨Åcantly outperforms its
unstructured (plain-vanilla) RNN counterparts, 3) in defence of RNNs, we show on several diverse spatio-temporal
problems that modeling structure with S-RNN outperforms
the non-deep learning based structured counterparts.
2. Related Work
We give a categorized overview of the related literature.
In general, three main characteristics differentiate our work
from existing techniques: being generic and not restricted to
a speciÔ¨Åc problem, providing a principled method for transforming a st-graph into a scalable rich feedforward RNN
mixture, and being jointly trainable.
Spatio-temporal problems. Problems that require spatial and temporal reasoning are very common in robotics
and computer vision.
Examples include human activity
recognition and segmentation from videos , context-rich human-object interactions , modeling human motion 
Spatio-temporal reasoning also Ô¨Ånds application in
assistive robots, driver understanding, and object recognition . In fact most of our daily activities
are spatio-temporal in nature. With growing interests in rich
interactions and robotics, this form of reasoning will become even more important. We evaluate our generic method
on three context-rich spatio-temporal problems: (i) Human
motion modeling ; (ii) Human-object interaction understanding ; and (iii) Driver maneuver anticipation .
Mixtures of deep architectures. Several previous works
build multiple networks and wire them together in order
to capture some complex structure (or interactions) in the
problem with promising results on applications such as activity detection, scene labeling, image captioning, and object detection . However, such architectures are mostly hand designed for speciÔ¨Åc problems,
though they demonstrate the beneÔ¨Åt in using a modular deep
architecture. Recursive Neural Networks are, on the
other hand, generic feedforward architectures, but for problems with recursive structure such as parsing of natural sentences and scenes . Our work is a remedy for problems expressed as spatio-temporal graphs. For a new spatiotemporal problem in hand, all a practitioner needs to do is
to express their intuition about the problem as an st-graph.
Deep learning with graphical models. Many works have
addressed deep networks with graphical models for structured prediction tasks. Bengio et al. combined CNNs
with HMM for hand writing recognition.
Tompson et
al. jointly train CNN and MRF for human pose estimation. Chen et al. use a similar approach for image
classiÔ¨Åcation with general MRF. Recently several works
(a) Spatio-temporal graph representing an activity
(b) Unrolled through time
(c) Factor graph parameterization
G = (V, EùëÜ, Eùëá)
Spatio-temporal edge
Temporal edge
Node factor
Spatio-temporal
Edge factor
Edge factor
Figure 2: An example spatio-temporal graph (st-graph) of a human activity. (a) st-graph capturing human-object interaction. (b) Unrolling the st-graph
through edges ET . The nodes and edges are labelled with the feature vectors associated with them. (c) Our factor graph parameterization of the st-graph.
Each node and edge in the st-graph has a corresponding factor.
have addressed end-to-end image segmentation with fully
connected CRF . Several works follow a
two-stage approach and decouple the deep network from
CRF. They have been applied to multiple problems including image segmentation, pose estimation, document processing etc. All of these works advocate and
well demonstrate the beneÔ¨Åt in exploiting the structure in
the problem together with rich deep architectures. However, they largely do not address spatio-temporal problems
and the proposed architectures are task-speciÔ¨Åc.
Conditional Random Fields (CRF) model dependencies
between the outputs by learning a joint distribution over
them. They have been applied to many applications including st-graphs which are commonly modeled
as spatio-temporal CRF . In our approach,
we adopt st-graphs as a general graph representation and
embody it using an RNN mixture architecture. Unlike CRF,
our approach is not probabilistic and is not meant to model
the joint distribution over the outputs. S-RNN instead learns
the dependencies between the outputs via structural sharing
of RNNs between the outputs.
3. Structural-RNN architectures
In this section we describe our approach for building
structural-RNN (S-RNN) architectures.
We start with a
st-graph, decompose it into a set of factor components, then
represent each factor using a RNN. The RNNs are interconnected in a way that the resulting architecture captures the
structure and interactions of the st-graph.
3.1. Representation of spatio-temporal graphs
Many applications that require spatial and temporal reasoning are modeled using st-graphs . We
represent a st-graph with G = (V, ES, ET ), whose structure (V, ES) unrolls over time through edges ET . Figure 2a
shows an example st-graph capturing human-object interactions during an activity. The nodes v ‚ààV and edges
e ‚ààES ‚à™ET of the st-graph repeats over time. In particular, Figure 2b shows the same st-graph unrolled through
time. In the unrolled st-graph, the nodes at a given time
step t are connected with undirected spatio-temporal edge
e = (u, v) ‚ààES, and the nodes at adjacent time steps (say
the node u at time t and the node v at time t + 1) are connected with undirected temporal edge iff (u, v) ‚ààET .1
Given a st-graph and the feature vectors associated with
the nodes xt
v and edges xt
e, as shown in Figure 2b, the goal
is to predict the node labels (or real value vectors) yt
each time step t. For instance, in human-object interaction,
the node features can represent the human and object poses,
and edge features can their relative orientation; the node labels represent the human activity and object affordance. Label yt
v is affected by both its node and its interactions with
other nodes (edges), leading to an overall complex system.
Such interactions are commonly parameterized with a factor graph that conveys how a (complicated) function over
the st-graph factorizes into simpler functions . We derive our S-RNN architecture from the factor graph representation of the st-graph. Our factor graph representation has
a factor function Œ®v(yv, xv) for each node and a pairwise
factor Œ®e(ye(1), ye(2), xe) for each edge. Figure 2c shows
the factor graph corresponding to the st-graph in 2a. 2
Sharing factors between nodes. Each factor in the stgraph has parameters that needs to be learned. Instead of
learning a distinct factor for each node, semantically similar
nodes can optionally share factors. For example, all ‚Äúobject
nodes‚Äù {u,w} in the st-graph can share the same node factor and parameters. This modeling choice allows enforcing
parameter sharing between similar nodes. It further gives
the Ô¨Çexibility to handle st-graphs with more nodes without
increasing the number of parameters. For this purpose, we
partition the nodes as CV = {V1, .., VP } where Vp is a set of
semantically similar nodes, and they all use the same node
factor Œ®Vp. In Figure 3a we re-draw the st-graph and assign
same color to the nodes sharing node factors.
Partitioning nodes on their semantic meanings leads to a
natural semantic partition of the edges, CE = {E1, .., EM},
where Em is a set of edges whose nodes form a semantic pair.
Therefore, all edges in the set Em share the
same edge factor Œ®Em.
For example all ‚Äúhuman-object
1For simplicity, the example st-graph in Figure 2a considers temporal
edges of the form (v, v) ‚ààET .
2Note that we adopted factor graph as a tool for capturing interactions
and not modeling the overall function. Factor graphs are commonly used
in probabilistic graphical models for factorizing joint probability distributions. We consider them for general st-graphs and do not establish relations
to its probabilistic and function decomposition properties.
xùë¢,ùë£+ xùë£,ùë§
(b) Corresponding S-RNN
(c) Forward-pass for human node ùë£
(d) Forward-pass for object node ùë§
(a) Spatio-temporal graph with colors
indicating sharing of factors
Object (O)
Figure 3: An example of st-graph to S-RNN. (a) The st-graph from Figure 2 is redrawn with colors to indicate sharing of nodes and edge factors. Nodes
and edges with same color share factors. Overall there are six distinct factors: 2 node factors and 4 edge factors. (b) S-RNN architecture has one RNN for
each factor. EdgeRNNs and nodeRNNs are connected to form a bipartite graph. Parameter sharing between the human and object nodes happen through
edgeRNN RE1. (c) The forward-pass for human node v involve RNNs RE1, RE3 and RV1. In Figure 4 we show the detailed layout of this forward-pass.
Input features into RE1 is sum of human-object edge features xu,v + xv,w. (d) The forward-pass for object node w involve RNNs RE1, RE2, RE4 and
RV2. In this forward-pass, the edgeRNN RE1 only processes the edge feature xv,w. (Best viewed in color)
edges‚Äù {(v, u), (v, w)} are modeled with the same edge factor. Sharing factors based on semantic meaning makes the
overall parametrization compact. In fact, sharing parameters is necessary to address applications where the number of nodes depends on the context.
For example, in
human-object interaction the number of object nodes vary
with the environment. Therefore, without sharing parameters between the object nodes, the model cannot generalize to new environments with more objects. For modeling Ô¨Çexibility, the edge factors are not shared across the
edges in ES and ET . Hence, in Figure 3a, object-object
(w, w) ‚ààET temporal edge is colored differently from
object-object (u, w) ‚ààES spatio-temporal edge.
In order to predict the label of node v ‚ààVp, we consider
its node factor Œ®Vp, and the edge factors connected to v in
the factor graph. We deÔ¨Åne a node factor and an edge factor
as neighbors if they jointly affect the label of some node in
the st-graph. More formally, the node factor Œ®Vp and edge
factor Œ®Em are neighbors, if there exist a node v ‚ààVp such
that it connects to both Œ®Vp and Œ®Em in the factor graph.
We will use this deÔ¨Ånition in building S-RNN architecture
such that it captures the interactions in the st-graph.
3.2. Structural-RNN from spatio-temporal graphs
We derive our S-RNN architecture from the factor graph
representation of the st-graph. The factors in the st-graph
operate in a temporal manner, where at each time step the
factors observe (node & edge) features and perform some
computation on those features. In S-RNN, we represent
each factor with an RNN. We refer the RNNs obtained from
the node factors as nodeRNNs and the RNNs obtained from
the edge factors as edgeRNNs. The interactions represented
by the st-graph are captured through connections between
the nodeRNNs and the edgeRNNs.
We denote the RNNs corresponding to the node factor
Œ®Vp and the edge factor Œ®Em as RVp and REm respectively. In order to obtain a feedforward network, we connect the edgeRNNs and nodeRNNs to form a bipartite graph
GR = ({REm}, {RVp}, ER). In particular, the edgeRNN
REm is connected to the nodeRNN RVp iff the factors Œ®Em
and Œ®Vp are neighbors in the st-graph, i.e. they jointly af-
Algorithm 1 From spatio-temporal graph to S-RNN
Input G = (V, ES, ET ), CV = {V1, ..., VP }
Output S-RNN graph GR = ({REm}, {RVp}, ER)
1: Semantically partition edges CE = {E1, ..., EM}
2: Find factor components {Œ®Vp, Œ®Em} of G
3: Represent each Œ®Vp with a nodeRNN RVp
4: Represent each Œ®Em with an edgeRNN REm
5: Connect {REm} and {RVp} to form a bipartite graph.
(REm, RVp) ‚ààER iff ‚àÉv ‚ààVp, u ‚ààV s.t. (u, v) ‚ààEm
Return GR = ({REm}, {RVp}, ER)
fect the label of some node in the st-graph. To summarize,
in Algorithm 1 we show the steps for constructing S-RNN
architecture. Figure 3b shows the S-RNN for the human
activity represented in Figure 3a. The nodeRNNs combine
the outputs of the edgeRNNs they are connected to (i.e. its
neighbors in the factor graph), and predict the node labels.
The predictions of nodeRNNs (eg. RV1 and RV2) interact
through the edgeRNNs (eg. RE1). Each edgeRNN handles
a speciÔ¨Åc semantic interaction between the nodes connected
in the st-grap and models how the interactions evolve over
time. In the next section, we explain the inputs, outputs, and
the training procedure of S-RNN.
3.3. Training structural-RNN architecture
In order to train the S-RNN architecture, for each node
of the st-graph the features associated with the node are fed
into the architecture. In the forward-pass for node v ‚ààVp,
the input into edgeRNN REm is the temporal sequence of
edge features xt
e on the edge e ‚ààEm, where edge e is incident to node v in the st-graph. The nodeRNN RVp at each
time step concatenates the node feature xt
v and the outputs
of edgeRNNs it is connected to, and predicts the node label.
At the time of training, the errors in prediction are backpropagated through the nodeRNN and edgeRNNs involved
during the forward-pass. That way, S-RNN non-linearly
combines the node and edge features associated with the
nodes in order to predict the node labels.
Figure 3c shows the forward-pass through S-RNN for
the human node. Figure 4 shows a detailed architecture lay-
Concatenate
H-O edgeRNN
H-H edgeRNN
Human activity label
Figure 4: Forward-pass for human node v. Shows the architecture
layout corresponding to the Figure 3c on unrolled st-graph. (View in color)
out of the same forward-pass. The forward-pass involves
the edgeRNNs RE1 (human-object edge) and RE3 (humanhuman edge). Since the human node v interacts with two
object nodes {u,w}, we pass the summation of the two edge
features as input to RE1. The summation of features, as
opposed to concatenation, is important to handle variable
number of object nodes with a Ô¨Åxed architecture. Since the
object count varies with environment, it is challenging to
represent variable context with a Ô¨Åxed length feature vector.
Empirically, adding features works better than mean pooling. We conjecture that addition retains the object count
and the structure of the st-graph, while mean pooling averages out the number of edges. The nodeRNN RV1 concatenates the (human) node features with the outputs from
edgeRNNs, and predicts the activity at each time step.
Parameter sharing and structured feature space. An
important aspect of S-RNN is sharing of parameters across
the node labels.
Parameter sharing between node labels
happen when an RNN is common in their forward-pass. For
example in Figure 3c and 3d, the edgeRNN RE1 is common in the forward-pass for the human node and the object
nodes. Furthermore, the parameters of RE1 gets updated
through back-propagated gradients from both the object and
human nodeRNNs. In this way, RE1 affects both the human
and object node labels.
Since the human node is connected to multiple object
nodes, the input into edgeRNN RE1 is always a linear combination of human-object edge features. This imposes an
structure on the features processed by RE1. More formally,
the input into RE1 is the inner product sT F, where F is the
feature matrix storing the edge features xe s.t. e ‚ààE1. Vector s captures the structured feature space. Its entries are in
{0,1} depending on the node being forward-passed. In the
example above F = [xv,u xv,w]T . For the human node v,
s = [1 1]T , while for the object node u, s = [1 0]T .
4. Experiment
We present results on three diverse spatio-temporal problems to ensure generic applicability of S-RNN, shown in
(a) Human motion modeling
(b) Activity detection and anticipation
(c) Maneuver anticipation
Figure 5: Diverse spatio-temporal tasks. We apply S-RNN to the following three diverse spatio-temporal problems. (View in color)
Figure 5. The applications include: (i) modeling human
motion from motion capture data ; (ii) human activity detection and anticipation ; and (iii) maneuver
anticipation from real-world driving data .
4.1. Human motion modeling and forecasting
Human body is a good example of separate but well
related components. Its motion involves complex spatiotemporal interactions between the components (arms, legs,
spine), resulting in sensible motion styles like walking, eating etc. In this experiment, we represent the complex motion of humans over st-graphs and learn to model them with
S-RNN. We show that our structured approach outperforms
the state-of-the-art unstructured deep architecture on
motion forecasting from motion capture (mocap) data. Several approaches based on Gaussian processes , Restricted Boltzmann Machines (RBMs) , and
RNNs have been proposed to model human motion.
Recently, Fragkiadaki et al. proposed an encoder-
RNN-decoder (ERD) which gets state-of-the-art forecasting
results on H3.6m mocap data set .
S-RNN architecture for human motion. Our S-RNN architecture follows the st-graph shown in Figure 5a. According to the st-graph, the spine interacts with all the body
parts, and the arms and legs interact with each other. The
st-graph is automatically transformed to S-RNN following
Section 3.2. The resulting S-RNN have three nodeRNNs,
one for each type of body part (spine, arm, and leg), four
edgeRNNs for modeling the spatio-temporal interactions
between them, and three edgeRNNs for their temporal connections. For edgeRNNs and nodeRNNs we use FC(256)-
FC(256)-LSTM(512) and LSTM(512)-FC(256)-FC(100)-
FC(¬∑) architectures, respectively, with skip input and output
connections . The outputs of nodeRNNs are skeleton
joints of different body parts, which are concatenated to reconstruct the complete skeleton. In order to model human
motion, we train S-RNN to predict the mocap frame at time
t + 1 given the frame at time t. Similar to , we gradually add noise to the mocap frames during training. This
simulates curriculum learning and helps in keeping the
forecasted motion close to the manifold of human motion.
As node features we use the raw joint values expressed as
exponential map , and edge features are concatenation
Ground Truth
w/o edgeRNN
Seed Motion
Short-term forecast
Long-term forecast
Figure 6: Forecasting eating activity on test subject. On aperiodic
activities, ERD and LSTM-3LR struggle to model human motion. S-RNN,
on the other hand, mimics the ground truth in the short-term and generates
human like motion in the long term. Without (w/o) edgeRNNs the motion
freezes to some mean standing position. See the video .
of the node features. We train all RNNs jointly to minimize
the Euclidean loss between the predicted mocap frame and
the ground truth. See supplementary material on the project
web page for training details.
Evaluation setup.
We compare S-RNN with the stateof-the-art ERD architecture on H3.6m mocap data
set . We also compare with a 3 layer LSTM architecture
(LSTM-3LR) which use as a baseline.3 For motion
forecasting we follow the experimental setup of . We
downsample H3.6m by two and train on 6 subjects and test
on subject S5. To forecast, we Ô¨Årst feed the architectures
with (50) seed mocap frames, and then forecast the future
(100) frames. Following , we consider walking, eating,
and smoking activities. In addition to these three, we also
consider discussion activity.
Forecasting is specially challenging on activities with
complex aperiodic human motion. In H3.6m data set, signiÔ¨Åcant parts of eating, smoking, and discussion activities
are aperiodic, while walking activity is mostly periodic. Our
evaluation demonstrates the beneÔ¨Åts of having an underlying structure in three important ways: (i) We present visualizations and quantitative results on complex aperiodic
activities ( evaluates only on periodic walking motion);
(ii) We forecast human motion for almost twice longer than
state-of-the-art . This is very challenging for aperiodic
activities; and Ô¨Ånally (iii) We show S-RNN interestingly
3We reproduce ERD and LSTM-3LR architectures following . The
authors implementation were not available at the time of submission.
Table 1: Motion forecasting angle error. {80, 160, 320, 560, 1000}
msecs after the seed motion. The results are averaged over 8 seed motion
sequences for each activity on the test subject.
Short-term forecast
Long-term forecast
Walking activity
Eating activity
Smoking activity
Discussion activity
learns semantic concepts, and demonstrate its modularity
by generating hybrid human motion. Unstructured deep architectures like does not offer such modularity.
Qualitative results on motion forecasting. Figure 6 shows
forecasting 1000ms of human motion on ‚Äúeating‚Äù activity
‚Äì the subject drinks while walking.
S-RNN stays close
to the ground-truth in the short-term and generates human
like motion in the long-term. On removing edgeRNNs, the
parts of human body become independent and stops interacting through parameters. Hence without edgeRNNs the
skeleton freezes to some mean position. LSTM-3LR suffers with a drifting problem. On many test examples it drifts
to the mean position of walking human ( made similar
observations about LSTM-3LR). The motion generated by
ERD stays human-like in the short-term but it drifts
away to non-human like motion in the long-term. This was
a common outcome of ERD on complex aperiodic activities, unlike S-RNN. Furthermore, ERD produced human
motion was non-smooth on many test examples. See the
video on the project web page for more examples .
Quantitative evaluation. We follow the evaluation metric
of Fragkiadaki et al. and present the 3D angle error
between the forecasted mocap frame and the ground truth
in Table 1. Qualitatively, ERD models human motion better than LSTM-3LR. However, in the short-term, it does
not mimic the ground-truth as well as LSTM-3LR. Fragkiadaki et al. also note this trade-off between ERD and
LSTM-3LR. On the other hand, S-RNN outperforms both
LSTM-3LR and ERD on short-term motion forecasting on
all activities. S-RNN therefore mimics the ground truth in
the short-term and generates human like motion in the long
term. In this way it well handles both short and long term
forecasting. Due to stochasticity in human motion, longterm forecasts (> 500ms) can signiÔ¨Åcantly differ from the
ground truth but still depict human-like motion. For this
reason, the long-term forecast numbers in Table 1 are not a
fair representative of algorithms modeling capabilities. We
also observe that discussion is one of the most challenging
(A) Cell #496 fires in response to ‚Äúmoving the leg forward‚Äù
Left leg cell activations
Eating with
with left arm
(B) Cell #419 fires in response to
‚Äúmoving arm close to the face‚Äù
puff of smoke
with right arm
Figure 7: S-RNN memory cell visualization. (Left) A cell of the leg
nodeRNN Ô¨Åres (red) when ‚Äúputting the leg forward‚Äù. (Right) A cell of the
arm nodeRNN Ô¨Åres for ‚Äúmoving the hand close to the face‚Äù. We visualize
the same cell for eating and smoking activities. (See the video )
aperiodic activity for all algorithms.
User study. We asked users to rate the motions on a Likert
scale of 1 to 3. S-RNN performed best according to the user
study. See supplementary material for the results.
To summarize, unstructured approaches like LSTM-3LR
and ERD struggles to model long-term human motion on
complex activities. S-RNN‚Äôs good performance is attributed
to its structural modeling of human motion through the underlying st-graph.
S-RNN models each body part separately with nodeRNNs and captures interactions between
them with edgeRNNs in order to produce coherent motions.
4.2. Going deeper into structural-RNN
We now present several insights into S-RNN architecture
and demonstrate the modularity of the architecture which
enables it to generate hybrid human motions.
Visualization of memory cells. We investigated if S-
RNN memory cells represent meaningful semantic submotions. Semantic cells were earlier studied on other problems , we are the Ô¨Årst to present it on a vision task
and human motion. In Figure 7 (left) we show a cell in
the leg nodeRNN learns the semantic motion of moving the
leg forward. The cell Ô¨Åres positive (red color) on the forward movement of the leg and negative (blue color) on its
backward movement. As the subject walks, the cell alternatively Ô¨Åres for the right and the left leg. Longer activations in the right leg corresponds to the longer steps taken
by the subject with the right leg. Similarly, a cell in the
arm nodeRNN learns the concept of moving hand close to
the face, as shown in Figure 7 (right). The same cell Ô¨Åres
whenever the subject moves the hand closer to the face during eating or smoking. The cell remains active as long as
the hand stays close to the face. See the video .
Generating hybrid human motion. We now demonstrate the Ô¨Çexibility of our modular architecture by generating novel yet meaningful motions which are not in the
data set. Such modularity is of interest and has been explored to generate diverse motion styles . As a result
of having an underlying high-level structure, our approach
allows us to exchange RNNs between the S-RNN architectures trained on different motion styles. We leverage this to
create a novel S-RNN architecture which generates a hybrid
Iterations
Figure 8: (Left) Generating hybrid motions (See the video ). We
demonstrate Ô¨Çexibility of S-RNN by generating a hybrid motion of a ‚Äúhuman jumping forward on one leg‚Äù. (Right) Train and test error. S-RNN
generalizes better than ERD with a smaller test error.
motion of a human jumping forward on one leg, as shown
in Figure 8 (Left). For this experiment we modeled the left
and right leg with different nodeRNNs. We trained two independent S-RNN models ‚Äì a slower human and a faster
human (by down sampling data) ‚Äì and swapped the left leg
nodeRNN of the trained models. The resulting faster human, with a slower left leg, jumps forward on the left leg to
keep up with its twice faster right leg.4 Unstructured architectures like ERD does not offer this kind of Ô¨Çexibility.
Figure 8 (Right) examines the test and train error with iterations. Both S-RNN and ERD converge to similar training
error, however S-RNN generalizes better with a smaller test
error for next step prediction. Discussion in supplementary.
4.3. Human activity detection and anticipation
In this section we present S-RNN for modeling human
activities. We consider the CAD-120 data set where
the activities involve rich human-object interactions. Each
activity consist of a sequence of sub-activities (e.g. moving, drinking etc.) and objects affordance (e.g., reachable,
drinkable etc.), which evolves as the activity progresses.
Detecting and anticipating the sub-activities and affordance
enables personal robots to assist humans.
However, the
problem is challenging as it involves complex interactions
‚Äì humans interact with multiple objects during an activity,
and objects also interact with each other (e.g. pouring water from ‚Äúglass‚Äù into a ‚Äúcontainer‚Äù), which makes it a particularly good Ô¨Åt for evaluating our method. Koppula et
al. represents such rich spatio-temporal interactions
with the st-graph shown in Figure 5b, and models it with
a spatio-temporal CRF. In this experiment, we show that
modeling the same st-graph with S-RNN yields superior results. We use the node and edges features from .
Figure 3b shows our S-RNN architecture to model the
Since the number of objects varies with environment, factor sharing between the object nodes and the
human-object edges becomes crucial. In S-RNN, RV2 and
RE1 handles all the object nodes and the human-object
edges respectively. This allows our Ô¨Åxed S-RNN architecture to handle varying size st-graphs. For edgeRNNs we
use a single layer LSTM of size 128, and for nodeRNNs we
use LSTM(256)-softmax(¬∑). At each time step, the human
nodeRNN outputs the sub-activity label (10 classes), and
the object nodeRNN outputs the affordance (12 classes).
4Imagine your motion forward if someone holds your right leg and
Table 2: Maneuver Anticipation on 1100 miles of real-world driving data. S-RNN is derived from the st-graph shown in Figure 5c. Jain et al. use
the same st-graph but models it in a probabilistic frame with AIO-HMM. The table shows average precision, recall and time-to-maneuver. Time-to-maneuver
is the interval between the time of algorithm‚Äôs prediction and the start of the maneuver. Algorithms are compared on the features from .
Lane change
All maneuvers
Time-tomaneuver (s)
maneuver (s)
maneuver (s)
AIO-HMM 
S-RNN w/o edgeRNN
Table 3: Results on CAD-120 . S-RNN architecture derived from the
st-graph in Figure 5b outperforms Koppula et al. which models the
same st-graph in a probabilistic framework. S-RNN in multi-task setting
(joint detection and anticipation) further improves the performance.
Detection F1-score
Anticipation F1-score
activity (%)
Affordance (%)
activity (%)
Affordance (%)
Koppula et al. 
S-RNN w/o edgeRNN
S-RNN (multi-task)
Having observed the st-graph upto time t, the goal is to
detect the sub-activity and affordance labels at the current
time t, and also anticipate their future labels of the time step
t+1. For detection we train S-RNN on the labels of the current time step. For anticipation we train the architecture to
predict the labels of the next time step, given the observations upto the current time. We also train a multi-task version of S-RNN, where we add two softmax layers to each
nodeRNN and jointly train for anticipation and detection.
Table 3 shows the detection and anticipation F1-scores
averaged over all the classes.
S-RNN signiÔ¨Åcantly improves over Koppula et al. on both anticipation and
detection . On anticipating object affordance S-RNN
F1-score is 44% more than , and 7% more on detection. S-RNN does not have any Markov assumptions like
spatio-temporal CRF, and therefore, it better models the
long-time dependencies needed for anticipation. The table also shows the importance of edgeRNNs in handling
spatio-temporal components. EdgeRNN transfers the information from the human to objects, which helps is predicting
the object labels. Therefore, S-RNN without the edgeRNNs
poorly models the objects. This signiÔ¨Åes the importance of
edgeRNNs and also validates our design. Finally, training
S-RNN in a multi-task manner works best in majority of
the cases. In Figure 9 we show the visualization of an eating activity. We show one representative frame from each
sub-activity and our corresponding predictions.
S-RNN complexity. In terms of complexity, we discuss
two aspects as a function of the underlying st-graph: (i) the
number of RNNs in the mixture; and (ii) the complexity of
forward-pass. The number of RNNs depends on the number of semantically similar nodes in the st-graph. The overall S-RNN architecture is compact because the edgeRNNs
are shared between the nodeRNNs, and the number of semantic categories are usually few in context-rich applications. Furthermore, because of factor sharing the number of
RNNs does not increase if more semantically similar nodes
are added to the st-graph.
The forward-pass complexity
stationary reachable
drinkable moveable
Ground-truth
placeable stationary
Anticipation
Affordance
Ground-truth
Anticipation
Figure 9: Qualitative result on eating activity on CAD-120. Shows
multi-task S-RNN detection and anticipation results. For the sub-activity
at time t, the labels are anticipated at time t‚àí1. (Zoom in to see the image)
depends on the number of RNNs. Since the forward-pass
through all edgeRNNs and nodeRNNs can happen in parallel, in practice, the complexity only depends on the cascade
of two neural networks (edgeRNN followed by nodeRNN).
4.4. Driver maneuver anticipation
We Ô¨Ånally present S-RNN for another application which
involves anticipating maneuvers several seconds before they
happen. Jain et al. represent this problem with the stgraph shown in Figure 5c. They model the st-graph as a
probabilistic Bayesian network (AIO-HMM ). The stgraph represents the interactions between the observations
outside the vehicle (eg. the road features), the driver‚Äôs maneuvers, and the observations inside the vehicle (eg. the
driver‚Äôs facial features). We model the same st-graph with
S-RNN architecture using the node and edge features from
Jain et al. . Table 2 shows the performance of different algorithms on this task. S-RNN performs better than the
state-of-the-art AIO-HMM in every setting. See supplementary material for the discussion and details .
5. Conclusion
We proposed a generic and principled approach for
combining high-level spatio-temporal graphs with sequence
modeling success of RNNs. We make use of factor graph,
and factor sharing in order to obtain an RNN mixture that
is scalable and applicable to any problem expressed over
st-graphs.
Our RNN mixture captures the rich interactions in the underlying st-graph. We demonstrated significant improvements with S-RNN on three diverse spatiotemporal problems including: (i) human motion modeling;
(ii) human-object interaction; and (iii) driver maneuver anticipation. By visualizing the memory cells we showed that
S-RNN learns certain semantic sub-motions, and demonstrated its modularity by generating novel human motion.5
5We acknowledge NRI #1426452, ONR-N00014-14-1-0156, MURI-
WF911NF-15-1-0479 and Panasonic Center grant #122282.