Temporal Fusion Transformers
for Interpretable Multi-horizon Time Series Forecasting
Bryan Lima,1,∗, Sercan ¨O. Arıkb, Nicolas Loeﬀb, Tomas Pﬁsterb
aUniversity of Oxford, UK
bGoogle Cloud AI, USA
Multi-horizon forecasting often contains a complex mix of inputs – including
static (i.e. time-invariant) covariates, known future inputs, and other exogenous
time series that are only observed in the past – without any prior information
on how they interact with the target. Several deep learning methods have been
proposed, but they are typically ‘black-box’ models which do not shed light on
how they use the full range of inputs present in practical scenarios. In this paper, we introduce the Temporal Fusion Transformer (TFT) – a novel attentionbased architecture which combines high-performance multi-horizon forecasting
with interpretable insights into temporal dynamics.
To learn temporal relationships at diﬀerent scales, TFT uses recurrent layers for local processing and
interpretable self-attention layers for long-term dependencies. TFT utilizes specialized components to select relevant features and a series of gating layers to
suppress unnecessary components, enabling high performance in a wide range of
scenarios. On a variety of real-world datasets, we demonstrate signiﬁcant performance improvements over existing benchmarks, and showcase three practical
interpretability use cases of TFT.
Deep learning, Interpretability, Time series, Multi-horizon
forecasting, Attention mechanisms, Explainable AI.
1. Introduction
Multi-horizon forecasting, i.e. the prediction of variables-of-interest at multiple future time steps, is a crucial problem within time series machine learning.
In contrast to one-step-ahead predictions, multi-horizon forecasts provide users
with access to estimates across the entire path, allowing them to optimize their
actions at multiple steps in future (e.g. retailers optimizing the inventory for
∗Corresponding authors
Email addresses: (Bryan Lim), (Sercan ¨O.
Arık), (Nicolas Loeﬀ), (Tomas Pﬁster)
1Completed as part of internship with Google Cloud AI Research.
 
September 29, 2020
 
the entire upcoming season, or clinicians optimizing a treatment plan for a patient). Multi-horizon forecasting has many impactful real-world applications in
retail , healthcare and economics ) – performance improvements
to existing methods in such applications are highly valuable.
Figure 1: Illustration of multi-horizon forecasting with static covariates, past-observed and
apriori-known future time-dependent inputs.
Practical multi-horizon forecasting applications commonly have access to
a variety of data sources, as shown in Fig.
1, including known information
about the future (e.g. upcoming holiday dates), other exogenous time series
(e.g. historical customer foot traﬃc), and static metadata (e.g. location of the
store) – without any prior knowledge on how they interact. This heterogeneity
of data sources together with little information about their interactions makes
multi-horizon time series forecasting particularly challenging.
Deep neural networks (DNNs) have increasingly been used in multi-horizon
forecasting, demonstrating strong performance improvements over traditional
time series models . While many architectures have focused on variants
of recurrent neural network (RNN) architectures , recent improvements
have also used attention-based methods to enhance the selection of relevant time
steps in the past – including Transformer-based models . However, these
often fail to consider the diﬀerent types of inputs commonly present in multihorizon forecasting, and either assume that all exogenous inputs are known
into the future – a common problem with autoregressive models – or
neglect important static covariates – which are simply concatenated with
other time-dependent features at each step. Many recent improvements in time
series models have resulted from the alignment of architectures with unique data
characteristics . We argue and demonstrate that similar performance
gains can also be reaped by designing networks with suitable inductive biases
for multi-horizon forecasting.
In addition to not considering the heterogeneity of common multi-horizon
forecasting inputs, most current architectures are ‘black-box’ models where fore-
casts are controlled by complex nonlinear interactions between many parameters. This makes it diﬃcult to explain how models arrive at their predictions,
and in turn makes it challenging for users to trust a model’s outputs and model
builders to debug it. Unfortunately, commonly-used explainability methods for
DNNs are not well-suited for applying to time series.
In their conventional
form, post-hoc methods (e.g. LIME and SHAP ) do not consider the
time ordering of input features. For example, for LIME, surrogate models are
independently constructed for each data-point, and for SHAP, features are considered independently for neighboring time steps. Such post-hoc approaches
would lead to poor explanation quality as dependencies between time steps are
typically signiﬁcant in time series. On the other hand, some attention-based
architectures are proposed with inherent interpretability for sequential data,
primarily language or speech – such as the Transformer architecture . The
fundamental caveat to apply them is that multi-horizon forecasting includes
many diﬀerent types of input features, as opposed to language or speech. In
their conventional form, these architectures can provide insights into relevant
time steps for multi-horizon forecasting, but they cannot distinguish the importance of diﬀerent features at a given timestep. Overall, in addition to the need
for new methods to tackle the heterogeneity of data in multi-horizon forecasting
for high performance, new methods are also needed to render these forecasts
interpretable, given the needs of the use cases.
In this paper we propose the Temporal Fusion Transformer (TFT) – an
attention-based DNN architecture for multi-horizon forecasting that achieves
high performance while enabling new forms of interpretability. To obtain significant performance improvements over state-of-the-art benchmarks, we introduce
multiple novel ideas to align the architecture with the full range of potential inputs and temporal relationships common to multi-horizon forecasting – specifically incorporating (1) static covariate encoders which encode context vectors
for use in other parts of the network, (2) gating mechanisms throughout and
sample-dependent variable selection to minimize the contributions of irrelevant
inputs, (3) a sequence-to-sequence layer to locally process known and observed
inputs, and (4) a temporal self-attention decoder to learn any long-term dependencies present within the dataset. The use of these specialized components
also facilitates interpretability; in particular, we show that TFT enables three
valuable interpretability use cases: helping users identify (i) globally-important
variables for the prediction problem, (ii) persistent temporal patterns, and (iii)
signiﬁcant events.
On a variety of real-world datasets, we demonstrate how
TFT can be practically applied, as well as the insights and beneﬁts it provides.
2. Related Work
DNNs for Multi-horizon Forecasting: Similarly to traditional multihorizon forecasting methods , recent deep learning methods can be categorized into iterated approaches using autoregressive models or direct
methods based on sequence-to-sequence models .
Iterated approaches utilize one-step-ahead prediction models, with multistep predictions obtained by recursively feeding predictions into future inputs.
Approaches with Long Short-term Memory (LSTM) networks have been
considered, such as Deep AR which uses stacked LSTM layers to generate parameters of one-step-ahead Gaussian predictive distributions. Deep State-Space
Models (DSSM) adopt a similar approach, utilizing LSTMs to generate parameters of a predeﬁned linear state-space model with predictive distributions
produced via Kalman ﬁltering – with extensions for multivariate time series data
in . More recently, Transformer-based architectures have been explored in
 , which proposes the use of convolutional layers for local processing and a
sparse attention mechanism to increase the size of the receptive ﬁeld during
forecasting. Despite their simplicity, iterative methods rely on the assumption
that the values of all variables excluding the target are known at forecast time
– such that only the target needs to be recursively fed into future inputs. However, in many practical scenarios, numerous useful time-varying inputs exist,
with many unknown in advance. Their straightforward use is hence limited for
iterative approaches. TFT, on the other hand, explicitly accounts for the diversity of inputs – naturally handling static covariates and (past-observed and
future-known) time-varying inputs.
In contrast, direct methods are trained to explicitly generate forecasts for
multiple predeﬁned horizons at each time step. Their architectures typically rely
on sequence-to-sequence models, e.g. LSTM encoders to summarize past inputs,
and a variety of methods to generate future predictions.
The Multi-horizon
Quantile Recurrent Forecaster (MQRNN) uses LSTM or convolutional encoders to generate context vectors which are fed into multi-layer perceptrons
(MLPs) for each horizon. In a multi-modal attention mechanism is used
with LSTM encoders to construct context vectors for a bi-directional LSTM
decoder. Despite performing better than LSTM-based iterative methods, interpretability remains challenging for such standard direct methods. In contrast,
we show that by interpreting attention patterns, TFT can provide insightful
explanations about temporal dynamics, and do so while maintaining state-ofthe-art performance on a variety of datasets.
Time Series Interpretability with Attention: Attention mechanisms
are used in translation , image classiﬁcation or tabular learning 
to identify salient portions of input for each instance using the magnitude of
attention weights. Recently, they have been adapted for time series with interpretability motivations , using LSTM-based and transformer-based
 architectures. However, this was done without considering the importance
of static covariates (as the above methods blend variables at each input). TFT
alleviates this by using separate encoder-decoder attention for static features
at each time step on top of the self-attention to determine the contribution
time-varying inputs.
Instance-wise Variable Importance with DNNs:
Instance (i.e. sample)wise variable importance can be obtained with post-hoc explanation methods
 and inherently intepretable models . Post-hoc explanation
methods, e.g.
LIME , SHAP and RL-LIM , are applied on pre-
trained black-box models and often based on distilling into a surrogate interpretable model, or decomposing into feature attributions.
They are not designed to take into account the time ordering of inputs, limiting their use for
complex time series data. Inherently-interpretable modeling approaches build
components for feature selection directly into the architecture. For time series
forecasting speciﬁcally, they are based on explicitly quantifying time-dependent
variable contributions. For example, Interpretable Multi-Variable LSTMs 
partitions the hidden state such that each variable contributes uniquely to its
own memory segment, and weights memory segments to determine variable
contributions. Methods combining temporal importance and variable selection
have also been considered in , which computes a single contribution coeﬃcient based on attention weights from each. However, in addition to the shortcoming of modelling only one-step-ahead forecasts, existing methods also focus
on instance-speciﬁc (i.e. sample-speciﬁc) interpretations of attention weights
– without providing insights into global temporal dynamics. In contrast, the
use cases in Sec. 7 demonstrate that TFT is able to analyze global temporal
relationships and allows users to interpret global behaviors of the model on the
whole dataset – speciﬁcally in the identiﬁcation of any persistent patterns (e.g.
seasonality or lag eﬀects) and regimes present.
3. Multi-horizon Forecasting
Let there be I unique entities in a given time series dataset – such as diﬀerent
stores in retail or patients in healthcare.
Each entity i is associated with a
set of static covariates si ∈Rms, as well as inputs χi,t ∈Rmχ and scalar
targets yi,t ∈R at each time-step t ∈[0, Ti]. Time-dependent input features are
subdivided into two categories χi,t =
T – observed inputs zi,t ∈R(mz)
which can only be measured at each step and are unknown beforehand, and
known inputs xi,t ∈Rmx which can be predetermined (e.g. the day-of-week at
In many scenarios, the provision for prediction intervals can be useful for
optimizing decisions and risk management by yielding an indication of likely
best and worst-case values that the target can take. As such, we adopt quantile
regression to our multi-horizon forecasting setting (e.g. outputting the 10th,
50th and 90th percentiles at each time step). Each quantile forecast takes the
ˆyi(q, t, τ) = fq (τ, yi,t−k:t, zi,t−k:t, xi,t−k:t+τ, si) ,
where ˆyi,t+τ(q, t, τ) is the predicted qth sample quantile of the τ-step-ahead
forecast at time t, and fq(.) is a prediction model. In line with other direct
methods, we simultaneously output forecasts for τmax time steps – i.e.
{1, . . . , τmax}. We incorporate all past information within a ﬁnite look-back
window k, using target and known inputs only up till and including the forecast
start time t (i.e. yi,t−k:t = {yi,t−k, . . . , yi,t}) and known inputs across the entire
range (i.e. xi,t−k:t+τ =
xi,t−k, . . . , xi,t, . . . , xi,t+τ
4. Model Architecture
Figure 2: TFT architecture. TFT inputs static metadata, time-varying past inputs and timevarying a priori known future inputs.
Variable Selection is used for judicious selection of
the most salient features based on the input. Gated Residual Network blocks enable eﬃcient
information ﬂow with skip connections and gating layers. Time-dependent processing is based
on LSTMs for local processing, and multi-head attention for integrating information from any
time step.
We design TFT to use canonical components to eﬃciently build feature
representations for each input type (i.e. static, known, observed inputs) for high
forecasting performance on a wide range of problems. The major constituents
of TFT are:
1. Gating mechanisms to skip over any unused components of the architecture, providing adaptive depth and network complexity to accommodate a
wide range of datasets and scenarios.
2. Variable selection networks to select relevant input variables at each time
3. Static covariate encoders to integrate static features into the network,
through encoding of context vectors to condition temporal dynamics.
4. Temporal processing to learn both long- and short-term temporal relationships from both observed and known time-varying inputs. A sequenceto-sequence layer is employed for local processing, whereas long-term dependencies are captured using a novel interpretable multi-head attention block.
2For notation simplicity, we omit the subscript i unless explicitly required.
5. Prediction intervals via quantile forecasts to determine the range of likely
target values at each prediction horizon.
Fig. 2 shows the high level architecture of Temporal Fusion Transformer
(TFT), with individual components described in detail in the subsequent sections.
4.1. Gating Mechanisms
The precise relationship between exogenous inputs and targets is often unknown in advance, making it diﬃcult to anticipate which variables are relevant.
Moreover, it is diﬃcult to determine the extent of required non-linear processing, and there may be instances where simpler models can be beneﬁcial – e.g.
when datasets are small or noisy. With the motivation of giving the model the
ﬂexibility to apply non-linear processing only where needed, we propose Gated
Residual Network (GRN) as shown in in Fig. 2 as a building block of TFT. The
GRN takes in a primary input a and an optional context vector c and yields:
GRNω (a, c) = LayerNorm (a + GLUω(η1)) ,
η1 = W1,ω η2 + b1,ω,
η2 = ELU (W2,ω a + W3,ω c + b2,ω) ,
where ELU is the Exponential Linear Unit activation function , η1 ∈Rdmodel, η2 ∈
Rdmodel are intermediate layers, LayerNorm is standard layer normalization of
 , and ω is an index to denote weight sharing. When W2,ω a + W3,ω c +
b2,ω >> 0, the ELU activation would act as an identity function and when
W2,ω a + W3,ω c + b2,ω << 0, the ELU activation would generate a constant
output, resulting in linear layer behavior.
We use component gating layers
based on Gated Linear Units (GLUs) to provide the ﬂexibility to suppress
any parts of the architecture that are not required for a given dataset. Letting
γ ∈Rdmodel be the input, the GLU then takes the form:
GLUω(γ) = σ(W4,ω γ + b4,ω) ⊙(W5,ω γ + b5,ω),
where σ(.) is the sigmoid activation function, W(.) ∈Rdmodel×dmodel, b(.) ∈
Rdmodel are the weights and biases, ⊙is the element-wise Hadamard product,
and dmodel is the hidden state size (common across TFT). GLU allows TFT
to control the extent to which the GRN contributes to the original input a –
potentially skipping over the layer entirely if necessary as the GLU outputs could
be all close to 0 in order to surpress the nonlinear contribution. For instances
without a context vector, the GRN simply treats the contex input as zero – i.e.
c = 0 in Eq. (4). During training, dropout is applied before the gating layer
and layer normalization – i.e. to η1 in Eq. (3).
4.2. Variable Selection Networks
While multiple variables may be available, their relevance and speciﬁc contribution to the output are typically unknown.
TFT is designed to provide
instance-wise variable selection through the use of variable selection networks
applied to both static covariates and time-dependent covariates. Beyond providing insights into which variables are most signiﬁcant for the prediction problem,
variable selection also allows TFT to remove any unnecessary noisy inputs which
could negatively impact performance. Most real-world time series datasets contain features with less predictive content, thus variable selection can greatly
help model performance via utilization of learning capacity only on the most
salient ones.
We use entity embeddings for categorical variables as feature representations, and linear transformations for continuous variables – transforming each
input variable into a (dmodel)-dimensional vector which matches the dimensions
in subsequent layers for skip connections. All static, past and future inputs
make use of separate variable selection networks (as denoted by diﬀerent colors
in Fig. 2). Without loss of generality, we present the variable selection network
for past inputs – noting that those for other inputs take the same form.
∈Rdmodel denote the transformed input of the j-th variable at time
t, with Ξt =
, . . . , ξ(mχ)T
being the ﬂattened vector of all past inputs
at time t. Variable selection weights are generated by feeding both Ξt and an
external context vector cs through a GRN, followed by a Softmax layer:
vχt = Softmax
 GRNvχ(Ξt, cs)
where vχt ∈Rmχ is a vector of variable selection weights, and cs is obtained
from a static covariate encoder (see Sec. 4.3). For static variables, we note
that the context vector cs is omitted – given that it already has access to static
information.
At each time step, an additional layer of non-linear processing is employed
by feeding each ξ(j)
through its own GRN:
= GRN˜ξ(j)
where ˜ξ(j)
is the processed feature vector for variable j. We note that each variable has its own GRNξ(j), with weights shared across all time steps t. Processed
features are then weighted by their variable selection weights and combined:
where v(j)
χt is the j-th element of vector vχt.
4.3. Static Covariate Encoders
In contrast with other time series forecasting architectures, the TFT is carefully designed to integrate information from static metadata, using separate
GRN encoders to produce four diﬀerent context vectors, cs, ce, cc, and ch.
These contect vectors are wired into various locations in the temporal fusion
decoder (Sec. 4.5) where static variables play an important role in processing.
Speciﬁcally, this includes contexts for (1) temporal variable selection (cs), (2)
local processing of temporal features (cc, ch), and (3) enriching of temporal features with static information (ce). As an example, taking ζ to be the output
of the static variable selection network, contexts for temporal variable selection
would be encoded according to cs = GRNcs(ζ).
4.4. Interpretable Multi-Head Attention
The TFT employs a self-attention mechanism to learn long-term relationships across diﬀerent time steps, which we modify from multi-head attention in
transformer-based architectures to enhance explainability. In general,
attention mechanisms scale values V ∈RN×dV based on relationships between
keys K ∈RN×dattn and queries Q ∈RN×dattn as below:
Attention(Q, K, V ) = A(Q, K)V ,
where A() is a normalization function. A common choice is scaled dot-product
attention :
A(Q, K) = Softmax(QKT /
To improve the learning capacity of the standard attention mechanism,
multi-head attention is proposed in , employing diﬀerent heads for diﬀerent representation subspaces:
MultiHead(Q, K, V ) = [H1, . . . , HmH] WH,
Hh = Attention(Q W (h)
Q , K W (h)
K , V W (h)
where W (h)
∈Rdmodel×dattn, W (h)
∈Rdmodel×dattn, W (h)
∈Rdmodel×dV are
head-speciﬁc weights for keys, queries and values, and WH ∈R(mH·dV )×dmodel
linearly combines outputs concatenated from all heads Hh.
Given that diﬀerent values are used in each head, attention weights alone
would not be indicative of a particular feature’s importance. As such, we modify
multi-head attention to share values in each head, and employ additive aggregation of all heads:
InterpretableMultiHead(Q, K, V ) = ˜
H = ˜A(Q, K) V WV ,
Q , K W (h)
h=1 Attention(Q W (h)
Q , K W (h)
K , V WV ),
where WV ∈Rdmodel×dV are value weights shared across all heads, and WH ∈
Rdattn×dmodel is used for ﬁnal linear mapping. From Eq. (15), we see that each
head can learn diﬀerent temporal patterns, while attending to a common set of
input features – which can be interpreted as a simple ensemble over attention
weights into combined matrix ˜A(Q, K) in Eq. (14). Compared to A(Q, K) in
Eq. (10), ˜A(Q, K) yields an increased representation capacity in an eﬃcient
4.5. Temporal Fusion Decoder
The temporal fusion decoder uses the series of layers described below to
learn temporal relationships present in the dataset:
4.5.1. Locality Enhancement with Sequence-to-Sequence Layer
In time series data, points of signiﬁcance are often identiﬁed in relation
to their surrounding values – such as anomalies, change-points or cyclical patterns. Leveraging local context, through the construction of features that utilize
pattern information on top of point-wise values, can thus lead to performance
improvements in attention-based architectures. For instance, adopts a single convolutional layer for locality enhancement – extracting local patterns using the same ﬁlter across all time.
However, this might not be suitable for
cases when observed inputs exist, due to the diﬀering number of past and future inputs.
As such, we propose the application of a sequence-to-sequence
model to naturally handle these diﬀerences – feeding ˜ξt−k:t into the encoder
and ˜ξt+1:t+τmax into the decoder. This then generates a set of uniform temporal
features which serve as inputs into the temporal fusion decoder itself – denoted
by φ(t, n) ∈{φ(t, −k), . . . , φ(t, τmax)} with n being a position index. For comparability with commonly-used sequence-to-sequence baselines, we consider the
use of an LSTM encoder-decoder – although other models can potentially be
adopted as well. This also serves as a replacement for standard positional encoding, providing an appropriate inductive bias for the time ordering of the
inputs. Moreover, to allow static metadata to inﬂuence local processing, we use
the cc, ch context vectors from the static covariate encoders to initialize the cell
state and hidden state respectively for the ﬁrst LSTM in the layer. We also
employ a gated skip connection over this layer:
˜φ(t, n) = LayerNorm
˜ξt+n + GLU ˜φ(φ(t, n))
where n ∈[−k, τmax] is a position index.
4.5.2. Static Enrichment Layer
As static covariates often have a signiﬁcant inﬂuence on the temporal dynamics (e.g. genetic information on disease risk), we introduce a static enrichment
layer that enhances temporal features with static metadata. For a given position
index n, static enrichment takes the form:
θ(t, n) = GRNθ
˜φ(t, n), ce
where the weights of GRNφ are shared across the entire layer, and ce is a context
vector from a static covariate encoder.
4.5.3. Temporal Self-Attention Layer
Following static enrichment, we next apply self-attention. All static-enriched
temporal features are ﬁrst grouped into a single matrix – i.e. Θ(t) = [θ(t, −k), . . . ,
θ(t, τ)]T – and interpretable multi-head attention (see Sec. 4.4) is applied at
each forecast time (with N = τmax + k + 1):
B(t) = InterpretableMultiHead(Θ(t), Θ(t), Θ(t)),
to yield B(t) = [β(t, −k), . . . , β(t, τmax)]. dV = dattn = dmodel/mH are chosen, where mH is the number of heads. Decoder masking is applied to
the multi-head attention layer to ensure that each temporal dimension can only
attend to features preceding it. Besides preserving causal information ﬂow via
masking, the self-attention layer allows TFT to pick up long-range dependencies that may be challenging for RNN-based architectures to learn. Following
the self-attention layer, an additional gating layer is also applied to facilitate
δ(t, n) = LayerNorm(θ(t, n) + GLUδ(β(t, n))).
4.5.4. Position-wise Feed-forward Layer
We apply an additional non-linear processing to the outputs of the selfattention layer. Similar to the static enrichment layer, this makes use of GRNs:
ψ(t, n) = GRNψ (δ(t, n)) ,
where the weights of GRNψ are shared across the entire layer. As per Fig. 2, we
also apply a gated residual connection which skips over the entire transformer
block, providing a direct path to the sequence-to-sequence layer – yielding a
simpler model if additional complexity is not required, as shown below:
˜ψ(t, n) = LayerNorm
˜φ(t, n) + GLU ˜
ψ(ψ(t, n))
4.6. Quantile Outputs
In line with previous work , TFT also generates prediction intervals on
top of point forecasts. This is achieved by the simultaneous prediction of various
percentiles (e.g. 10th, 50th and 90th) at each time step. Quantile forecasts are
generated using linear transformation of the output from the temporal fusion
ˆy(q, t, τ) = Wq ˜ψ(t, τ) + bq,
where Wq ∈R1×d, bq ∈R are linear coeﬃcients for the speciﬁed quantile q.
We note that forecasts are only generated for horizons in the future – i.e. τ ∈
{1, . . . , τmax}.
5. Loss Functions
TFT is trained by jointly minimizing the quantile loss , summed across
all quantile outputs:
L(Ω, W ) =
QL (yt, ˆy(q, t −τ, τ), q)
QL(y, ˆy, q) = q(y −ˆy)+ + (1 −q)(ˆy −y)+,
where Ωis the domain of training data containing M samples, W represents the
weights of TFT, Q is the set of output quantiles (we use Q = {0.1, 0.5, 0.9} in
our experiments, and (.)+ = max(0, .). For out-of-sample testing, we evaluate
the normalized quantile losses across the entire forecasting horizon – focusing
on P50 and P90 risk for consistency with previous work :
τ=1 QL (yt, ˆy(q, t −τ, τ), q)
where ˜Ωis the domain of test samples. Full details on hyperparameter optimization and training can be found in Appendix A.
6. Performance Evaluation
6.1. Datasets
We choose datasets to reﬂect commonly observed characteristics across a
wide range of challenging multi-horizon forecasting problems. To establish a
baseline and position with respect to prior academic work, we ﬁrst evaluate
performance on the Electricity and Traﬃc datasets used in – which
focus on simpler univariate time series containing known inputs only alongside
the target. Next, the Retail dataset helps us benchmark the model using the
full range of complex inputs observed in multi-horizon prediction applications
(see Sec. 3) – including rich static metadata and observed time-varying inputs.
Finally, to evaluate robustness to over-ﬁtting on smaller noisy datasets, we
consider the ﬁnancial application of volatility forecasting – using a dataset much
smaller than others. Broad descriptions of each dataset can be found below:
• Electricity: The UCI Electricity Load Diagrams Dataset, containing the
electricity consumption of 370 customers – aggregated on an hourly level as
In accordance with , we use the past week (i.e.
168 hours) to
forecast over the next 24 hours.
• Traﬃc: The UCI PEM-SF Traﬃc Dataset describes the occupancy rate (with
yt ∈ ) of 440 SF Bay Area freeways – as in . It is also aggregated on
an hourly level as per the electricity dataset, with the same look back window
and forecast horizon.
• Retail: Favorita Grocery Sales Dataset from the Kaggle competition ,
that combines metadata for diﬀerent products and the stores, along with
other exogenous time-varying inputs sampled at the daily level. We forecast
log product sales 30 days into the future, using 90 days of past information.
• Volatility (or Vol.): The OMI realized library contains daily realized
volatility values of 31 stock indices computed from intraday data, along with
their daily returns. For our experiments, we consider forecasts over the next
week (i.e. 5 business days) using information over the past year (i.e. 252
business days).
6.2. Training Procedure
For each dataset, we partition all time series into 3 parts – a training set
for learning, a validation set for hyperparameter tuning, and a hold-out test
set for performance evaluation. Hyperparameter optimization is conducted via
random search, using 240 iterations for Volatility, and 60 iterations for others.
Full search ranges for all hyperparameters are below, with datasets and optimal
model parameters listed in Table 1.
• State size – 10, 20, 40, 80, 160, 240, 320
• Dropout rate – 0.1, 0.2, 0.3, 0.4, 0.5, 0.7, 0.9
• Minibatch size – 64, 128, 256
• Learning rate – 0.0001, 0.001, 0.01
• Max. gradient norm – 0.01, 1.0, 100.0
• Num. heads – 1, 4
To preserve explainability, we adopt only a single interpretable multi-head
attention layer. For ConvTrans , we use the same ﬁxed stack size (3 layers)
and number of heads (8 heads) as in . We keep the same attention model,
and treat kernel sizes for the convolutional processing layer as a hyperparameter
(∈{1, 3, 6, 9}) – as optimal kernel sizes are observed to be dataset dependent
 . An open-source implementation of the TFT on these datasets can be found
on GitHub3 for full reproducibility.
6.3. Computational Cost
Across all datasets, each TFT model was also trained on a single GPU, and
can be deployed without the need for extensive computing resources. For instance, using a NVIDIA Tesla V100 GPU, our optimal TFT model (for Electricity dataset) takes just slightly over 6 hours to train (each epoch being roughly
52 mins). The batched inference on the entire validation dataset (consisting
50,000 samples) takes 8 minutes.
TFT training and inference times can be
further reduced with hardware-speciﬁc optimizations.
Table 1: Information on dataset and optimal TFT conﬁguration.
Electricity
Dataset Details
Target Type
Number of Entities
Number of Samples
Network Parameters
Dropout Rate
State Size
Number of Heads
Training Parameters
Minibatch Size
Learning Rate
Max Gradient Norm
6.4. Benchmarks
We extensively compare TFT to a wide range of models for multi-horizon
forecasting, based on the categories described in Sec. 2. Hyperparameter optimization is conducted using random search over a pre-deﬁned search space,
using the same number of iterations across all benchmarks for a give dataset.
Additional details are included in Appendix A.
Direct methods: As TFT falls within this class of multi-horizon models,
we primarily focus comparisons on deep learning models which directly generate
prediction at future horizons, including: 1) simple sequence-to-sequence models
with global contexts (Seq2Seq), and 2) the Multi-horizon Quantile Recurrent
Forecaster (MQRNN) .
Iterative methods: To position with respect to the rich body of work on
iterative models, we evaluate TFT using the same setup as for the Electricity
and Traﬃc datasets. This extends the results from for 1) DeepAR , 2)
DSSM , and 3) the Transformer-based architecture of with local convolutional processing – which refer to as ConvTrans. For more complex datasets,
we focus on the ConvTrans model given its strong outperformance over other
iterative models in prior work, and DeepAR due to its popularity among practitioners. As models in this category require knowledge of all inputs in the future
to generate predictions, we accommodate this for complex datasets by imputing
unknown inputs with their last available value.
For simpler univariate datasets, we note that the results for ARIMA, ETS,
TRMF, DeepAR, DSSM and ConvTrans have been reproduced from in
3URL: 
Table 2: P50 and P90 quantile losses on a range of real-world datasets. Percentages in brackets
reﬂect the increase in quantile loss versus TFT (lower q-Risk better), with TFT outperforming
competing methods across all experiments, improving on the next best alternative method
(underlined) between 3% and 26%.
Electricity
0.154 (+180%)
0.102 (+85%)
0.084 (+53%)
0.075 (+36%)
0.083 (+51%)
0.223 (+135%)
0.236 (+148%)
0.186 (+96%)
0.161 (+69%)
0.167 (+76%)
Electricity
0.059 (+7%)
0.067 (+22%)
0.077 (+40%)
0.122 (+28%)
0.105 (+11%)
0.117 (+23%)
(a) P50 losses on simpler univariate datasets.
Electricity
0.102 (+278%)
0.077 (+185%)
0.040 (+48%)
0.056 (+107%)
0.137 (+94%)
0.148 (+110%)
0.099 (+40%)
0.113 (+60%)
Electricity
0.034 (+26%)
0.036 (+33%)
0.036 (+33%)
0.081 (+15%)
0.075 (+6%)
0.082 (+16%)
(b) P90 losses on simpler univariate datasets.
0.050 (+28%)
0.047 (+20%)
0.042 (+7%)
0.042 (+7%)
0.574 (+62%)
0.429 (+21%)
0.411 (+16%)
0.379 (+7%)
(c) P50 losses on datasets with rich static or observed inputs.
0.024 (+21%)
0.024 (+22%)
0.021 (+8%)
0.021 (+9%)
0.230 (+56%)
0.192 (+30%)
0.157 (+7%)
0.152 (+3%)
(d) P90 losses on datasets with rich static or observed inputs.
Table 2 for consistency.
6.5. Results and Discussion
Table 2 shows that TFT signiﬁcantly outperforms all benchmarks over the
variety of datasets described in Sec.
For median forecasts, TFT yields
7% lower P50 and 9% lower P90 losses on average compared to the next best
model – demonstrating the beneﬁts of explicitly aligning the architecture with
the general multi-horizon forecasting problem.
Comparing direct and iterative models, we observe the importance of accounting for the observed inputs – noting the poorer results of ConvTrans on
complex datasets where observed input imputation is required (i.e. Volatility
and Retail). Furthermore, the beneﬁts of quantile regression are also observed
when targets are not captured well by Gaussian distributions with direct models
outperforming in those scenarios. This can be seen, for example, from the Traf-
ﬁc dataset where target distribution is signiﬁcantly skewed – with more than
90% of occupancy rates falling between 0 and 0.1, and the remainder distributed
evenly until 1.0.
6.6. Ablation Analysis
To quantify the beneﬁts of each of our proposed architectural contribution,
we perform an extensive ablation analysis – removing each component from the
network as below, and quantifying the percentage increase in loss versus the
original architecture:
• Gating layers: We ablate by replacing each GLU layer (Eq. (5)) with a
simple linear layer followed by ELU.
• Static covariate encoders: We ablate by setting all context vectors to zero
– i.e. cs=ce=cc=ch=0 – and concatenating all transformed static inputs to
all time-dependent past and future inputs.
• Instance-wise variable selection networks: We ablate by replacing the
softmax outputs of Eq. 6 with trainable coeﬃcients, and removing the networks generating the variable selection weights.
We retain, however, the
variable-wise GRNs (see Eq. (7)), maintaining a similar amount of non-linear
processing.
• Self-attention layers: We ablate by replacing the attention matrix of the
interpretable multi-head attention layer (Eq. 14) with a matrix of trainable
parameters WA – i.e.
˜A(Q, K) = WA, where WA ∈RN×N. This prevents
TFT from attending to diﬀerent input features at diﬀerent times, helping
evaluation of the importance of instance-wise attention weights.
• Sequence-to-sequence layers for local processing: We ablate by replacing the sequence-to-sequence layer of Sec. 4.5.1 with standard positional
encoding used in .
Ablated networks are trained across for each dataset using the hyperparameters of Table 1. Fig. 3 shows that the eﬀects on both P50 and P90 losses
are similar across all datasets, with all components contributing to performance
improvements on the whole.
In general, the components responsible for capturing temporal relationships,
local processing and self-attention layers, have the largest impact on performance, with P90 loss increases of > 6% on average and > 20% on select datasets
when ablated. The diversity across time series datasets can also be seen from the
diﬀerences in the ablation impact of the respective temporal components. Concretely, while local processing is critical in Traﬃc, Retail and Volatility, lower
post-ablation P50 losses indicate that it can be detrimental in Electricity – with
the self-attention layer playing a more vital role. A possible explanation is that
persistent daily seasonality appears to dominate other temporal relationships in
the Electricity dataset. For this dataset, Table B.4 of Appendix B also shows
that the hour-of-day has the largest variable importance score across all temporal inputs, exceeding even the target (i.e. Power Usage) itself. In contrast to
other dataset where past target observations are more signiﬁcant (e.g. Traﬃc),
direct attention to previous days seem to help learning daily seasonal patterns
in Electricity – with local processing between adjacent time steps being less
necessary. We can account for this by treating the sequence-to-sequence architecture in the temporal fusion decoder as a hyperparameter to tune, including
an option for simple positional encoding without any local processing.
Static covariate encoders and instance-wise variable selection have the next
largest impact – increasing P90 losses by more than 2.6% and 4.1% on average.
The biggest beneﬁts of these are observed for electricity dataset, where some of
the input features get very low importance.
Finally, gating layer ablation also shows increases in P90 losses, with a 1.9%
increase on average. This is the most signiﬁcant on the volatility (with a 4.1%
P90 loss increase), underlying the beneﬁt of component gating for smaller and
noisier datasets.
7. Interpretability Use Cases
Having established the performance beneﬁts of our model, we next demonstrate how our model design allows for analysis of its individual components
to interpret the general relationships it has learned. We demonstrate three interpretability use cases: (1) examining the importance of each input variable
in prediction, (2) visualizing persistent temporal patterns, and (3) identifying
any regimes or events that lead to signiﬁcant changes in temporal dynamics. In
contrast to other examples of attention-based interpretability which
zoom in on interesting but instance-speciﬁc examples, our methods focus on
ways to aggregate the patterns across the entire dataset – extracting generalizable insights about temporal dynamics.
7.1. Analyzing Variable Importance
We ﬁrst quantify variable importance by analyzing the variable selection
weights described in Sec. 4.2. Concretely, we aggregate selection weights (i.e.
χt in Eq. (8)) for each variable across our entire test set, recording the 10th,
50th and 90th percentiles of each sampling distribution. As the Retail dataset
Table 3: Variable importance for the Retail dataset. The 10th, 50th and 90th percentiles of
the variable selection weights are shown, with values larger than 0.1 highlighted in purple.
For static covariates, the largest weights are attributed to variables which uniquely identify
diﬀerent entities (i.e. item number and store number). For past inputs, past values of the
target (i.e. log sales) are critical as expected, as forecasts are extrapolations of past observations. For future inputs, promotion periods and national holidays have the greatest inﬂuence
on sales forecasts, in line with periods of increased customer spending.
Perishable
(a) Static Covariates
Transactions
On-promotion
Day of Week
Day of Month
National Hol
Regional Hol
(b) Past Inputs
On-promotion
Day of Week
Day of Month
National Hol
Regional Hol
(c) Future Inputs
(a) Changes in P50 losses across ablation tests
(b) Changes in P90 losses across ablation tests
Figure 3: Results of ablation analysis. Both a) and b) show the impact of ablation on the
P50 and P90 losses respectively. Results per dataset shown on the left, and the range across
datasets shown on the right.
While the precise importance of each is dataset-speciﬁc, all
components contribute signiﬁcantly on the whole – with the maximum percentage increase
over all datasets ranging from 3.6% to 23.4% for P50 losses, and similarly from 4.1% to 28.4%
for P90 losses.
contains the full set of available input types (i.e. static metadata, known inputs,
observed inputs and the target), we present the results for its variable importance analysis in Table 3. We also note similar ﬁndings in other datasets, which
are documented in Appendix B.1 for completeness. On the whole, the results
show that the TFT extracts only a subset of key inputs that intuitively play a
signiﬁcant role in predictions. The analysis of persistent temporal patterns is
often key to understanding the time-dependent relationships present in a given
dataset. For instance, lag models are frequently adopted to study length of time
required for an intervention to take eﬀect – such as the impact of a government’s increase in public expenditure on the resultant growth in Gross National
Product . Seasonality models are also commonly used in econometrics to
identify periodic patterns in a target-of-interest and measure the length of
each cycle. From a practical standpoint, model builders can use these insights to
further improve the forecasting model – for instance by increasing the receptive
ﬁeld to incorporate more history if attention peaks are observed at the start of
the lookback window, or by engineering features to directly incorporate seasonal
eﬀects. As such, using the attention weights present in the self-attention layer of
the temporal fusion decoder, we present a method to identify similar persistent
patterns – by measuring the contributions of features at ﬁxed lags in the past
on forecasts at various horizons. Combining Eq. (14) and (19), we see that the
self-attention layer contains a matrix of attention weights at each forecast time
t – i.e. ˜A(φ(t), φ(t)). Multi-head attention outputs at each forecast horizon τ
(i.e. β(t, τ)) can then be described as an attention-weighted sum of lower level
features at each position n:
n=−k α(t, n, τ) ˜θ(t, n),
where α(t, n, τ) is the (τ, n)-th element of ˜A(φ(t), φ(t)), and ˜θ(t, n) is a row
of ˜Θ(t) = Θ(t)WV . Due to decoder masking, we also note that α(t, i, j) = 0,
∀i > j. For each forecast horizon τ, the importance of a previous time point
n < τ can hence be determined by analyzing distributions of α(t, n, τ) across
all time steps and entities.
7.2. Visualizing Persistent Temporal Patterns
Attention weight patterns can be used to shed light on the most important
past time steps that the TFT model bases its decisions on. In contrast to other
traditional and machine learning time series methods, which rely on modelbased speciﬁcations for seasonality and lag analysis, the TFT can learn such
patterns from raw training data.
Fig. 4 shows the attention weight patterns across all our test datasets –
with the upper graph plotting the mean along with the 10th, 50th and 90th
percentiles of the attention weights for one-step-ahead forecasts (i.e. α(t, 1, τ))
over the test set, and the bottom graph plotting the average attention weights
for various horizons (i.e. τ ∈{5, 10, 15, 20}). We observe that the three datasets
exhibit a seasonal pattern, with clear attention spikes at daily intervals observed
for Electricity and Traﬃc, and a slightly weaker weekly patterns for Retail.
For Retail, we also observe the decaying trend pattern, with the last few days
dominating the importance.
No strong persistent patterns were observed for the Volatility – attention
weights equally distributed across all positions on average. This resembles a
moving average ﬁlter at the feature level, and – given the high degree of randomness associated with the volatility process – could be useful in extracting
the trend over the entire period by smoothing out high-frequency noise.
TFT learns these persistent temporal patterns from the raw training data
without any human hard-coding. Such capability is expected to be very useful
in building trust with human experts via sanity-checking. Model developers can
also use these towards model improvements, e.g. via speciﬁc feature engineering
or data collection.
7.3. Identifying Regimes & Signiﬁcant Events
Identifying sudden changes in temporal patterns can also be very useful,
as temporary shifts can occur due to the presence of signiﬁcant regimes or
events. For instance, regime-switching behavior has been widely documented in
ﬁnancial markets , with returns characteristics – such as volatility – being
observed to change abruptly between regimes. As such, identifying such regime
changes provides strong insights into the underlying problem which is useful for
identiﬁcation of the signiﬁcant events.
(a) Electricity
(c) Retail
(d) Volatility
Figure 4: Persistent temporal patterns across datasets. Clear seasonality observed for the
Electricity, Traﬃc and Retail datasets, but no strong persistent patterns seen in Volatility
dataset. Upper plot – percentiles of attention weights for one-step-ahead forecast. Lower plot
– average attention weights for forecast at various horizons.
Regime identiﬁcation for S&P 500 realized volatility.
Signiﬁcant deviations in
attention patterns can be observed around periods of high volatility – corresponding to the
peaks observed in dist(t). We use a threshold of dist(t) > 0.3 to denote signiﬁcant regimes, as
highlighted in purple. Focusing on periods around the 2008 ﬁnancial crisis, the top right plot
visualizes α(t, n, 1) midway through the signiﬁcant regime, compared to the normal regime on
the top left.
Firstly, for a given entity, we deﬁne the average attention pattern per forecast
horizon as:
¯α(n, τ) =
t=1 α(t, j, τ)/T,
and then construct ¯α(τ) = [¯α(−k, τ), . . . , ¯α(τmax, τ)]T . To compare similarities
between attention weight vectors, we use the distance metric proposed by :
1 −ρ(p, q),
where ρ(p, q) = P
√pjqj is the Bhattacharya coeﬃcient measuring the
overlap between discrete distributions – with pj, qj being elements of probability
vectors p, q respectively. For each entity, signiﬁcant shifts in temporal dynamics
are then measured using the distance between attention vectors at each point
with the average pattern, aggregated for all horizons as below:
  ¯α(τ), α(t, τ)
where α(t, τ) = [α(t, −k, τ), . . . , α(t, τmax, τ)]T .
Using the volatility dataset, we attempt to analyse regimes by applying our
distance metric to the attention patterns for the S&P 500 index over our training period . Plotting dist(t) against the target (i.e. log realized
volatility) in the bottom chart of Fig. 5, signiﬁcant deviations in attention patterns can be observed around periods of high volatility – corresponding to the peaks observed in dist(t). From the plots, we can
see that TFT appears to alter its behaviour between regimes – placing equal attention across past inputs when volatility is low, while attending more to sharp
trend changes during high volatility periods – suggesting diﬀerences in temporal
dynamics learned in each of these cases.
8. Conclusions
We introduce TFT, a novel attention-based deep learning model for interpretable high-performance multi-horizon forecasting.
To handle static covariates, a priori known inputs, and observed inputs eﬀectively across wide
range of multi-horizon forecasting datasets, TFT uses specialized components.
Speciﬁcally, these include: (1) sequence-to-sequence and attention based temporal processing components that capture time-varying relationships at diﬀerent
timescales, (2) static covariate encoders that allow the network to condition
temporal forecasts on static metadata, (3) gating components that enable skipping over unnecessary parts of the network, (4) variable selection to pick relevant input features at each time step, and (5) quantile predictions to obtain
output intervals across all prediction horizons. On a wide range of real-world
tasks – on both simple datasets that contain only known inputs and complex
datasets which encompass the full range of possible inputs – we show that TFT
achieves state-of-the-art forecasting performance. Lastly, we investigate the general relationships learned by TFT through a series of interpretability use cases
– proposing novel methods to use TFT to (i) analyze important variables for a
given prediction problem, (ii) visualize persistent temporal relationships learned
(e.g. seasonality), and (iii) identify signiﬁcant regimes changes.
9. Acknowledgements
The authors gratefully acknowledge discussions with Yaguang Li, Maggie
Wang, Jeﬀrey Gu, Minho Jin and Andrew Moore that contributed to the development of this paper.