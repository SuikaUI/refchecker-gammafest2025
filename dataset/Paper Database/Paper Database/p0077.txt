Online Learning for Ofﬂoading and
Autoscaling in Energy Harvesting Mobile Edge
Jie Xu, Member, IEEE, Lixing Chen, Student Member, IEEE,
Shaolei Ren, Member, IEEE
Mobile edge computing (a.k.a. fog computing) has recently emerged to enable in-situ processing
of delay-sensitive applications at the edge of mobile networks. Providing grid power supply in support
of mobile edge computing, however, is costly and even infeasible (in certain rugged or under-developed
areas), thus mandating on-site renewable energy as a major or even sole power supply in increasingly
many scenarios. Nonetheless, the high intermittency and unpredictability of renewable energy make
it very challenging to deliver a high quality of service to users in energy harvesting mobile edge
computing systems. In this paper, we address the challenge of incorporating renewables into mobile
edge computing and propose an efﬁcient reinforcement learning-based resource management algorithm,
which learns on-the-ﬂy the optimal policy of dynamic workload ofﬂoading (to the centralized cloud)
and edge server provisioning to minimize the long-term system cost (including both service delay and
operational cost). Our online learning algorithm uses a decomposition of the (ofﬂine) value iteration
and (online) reinforcement learning, thus achieving a signiﬁcant improvement of learning rate and runtime performance when compared to standard reinforcement learning algorithms such as Q-learning.
We prove the convergence of the proposed algorithm and analytically show that the learned policy has
a simple monotone structure amenable to practical implementation. Our simulation results validate the
efﬁcacy of our algorithm, which signiﬁcantly improves the edge computing performance compared to
ﬁxed or myopic optimization schemes and conventional reinforcement learning algorithms.
J. Xu and L. Chen are with the Department of Electrical and Computer Engineering, University of Miami. Email:
 , .
S. Ren is with the Department of Electrical and Computer Engineering, University of California, Riverside. Email:
 
Index Terms
Mobile edge computing, energy harvesting, online learning.
I. INTRODUCTION
In the era of mobile computing and Internet of Things, a tremendous amount of data is
generated from massively distributed sources, requiring timely processing to extract its maximum
value. Further, many emerging applications, such as mobile gaming and augmented reality, are
delay sensitive and have resulted in an increasingly high computing demand that frequently
exceeds what mobile devices can deliver. Although cloud computing enables convenient access
to a centralized pool of conﬁgurable computing resources, moving all the distributed data and
computing-intensive applications to clouds (which are often physically located in remote megascale data centers) is simply out of the question, as it would not only pose an extremely
heavy burden on today’s already-congested backbone networks but also result in (sometimes
intolerable) large transmission latencies that degrade the quality of service – .
As a remedy to the above limitations, mobile edge computing (MEC) – (a.k.a., fog
computing ) has recently emerged to enable in-situ processing of (some) workloads locally
at the network edge without moving them to the cloud. In MEC, network edge devices, such
as base stations, access points and routers, are endowed with cloud-like computing and storage
capabilities to serve users’ requests as a substitute of clouds, while signiﬁcantly reducing the
transmission latency as they are placed in close proximity to end users and data sources. In this
paper, we consider base station as the default edge device and refer to the combination of an
edge device and the associated edge servers as an edge system.
Effective operation of MEC is contingent upon efﬁcient power provisioning for the edge
system. However, providing reliable and stable grid power supply in remote areas and hazardous locations can be extremely costly and even infeasible since construction and operation of
transmission lines are often prohibitive, and grid-tied servers can violate environmental quality
regulations in rural areas that are ecologically sensitive . For instance, in many developing
countries, the majority of base stations have to be powered by continuously operating diesel
generators because the electric grid is too unreliable . In view of the signiﬁcant carbon
footprint of grid power as well as soaring electricity prices, off-grid renewable energy harvested
from ambient vibrations, heat, wind and/or solar radiation is embraced as a major or even
Fig. 1. Architecture of a renewable-powered edge computing system. The photo shows a solar- and wind-powered base station
deployed by Alcatel Lucent in Turkey. (Source: 
sole power supply for edge systems in the ﬁeld, thanks to the recent advancements of energy
harvesting techniques , .
Despite the clear advantages, the high intermittency and unpredictability of renewable energy
creates tremendous new challenges for fully reaping the beneﬁts of MEC. Although batteries are
often installed as an energy buffer, the computing capacity of an edge system is still signiﬁcantly
limited at any moment in time. As a result, although processing computation tasks at the edge
reduces the transmission latency, a considerable processing time may occur when little power
supply is available. This gives rise to an important trade-off between transmission delay and
processing delay, which is jointly determined by the edge system’s ofﬂoading policy (i.e. how
much workload is ofﬂoaded to the cloud) and autoscaling policy (i.e. how many servers are
dynamically provisioned or activated). The problem is further complicated due to the temporal
correlation — provisioning more servers and processing more workloads at the edge system
in the current time means that fewer servers can be provisioned and fewer workloads can be
processed locally in the future due to the limited and time-varying renewable energy supply.
Figure 1 illustrates the considered system architecture.
In this paper, we address the challenge of incorporating renewable energy into MEC and
propose an efﬁcient reinforcement learning-based resource management algorithm, which learns
on-the-ﬂy the optimal policy of dynamic workload ofﬂoading (to the centralized cloud) and
edge server provisioning to minimize the long-term system cost (including both service delay
and operational cost). Our main contributions are summarized as follows:
• We formulate the joint ofﬂoading and edge server provisioning problem as a Markov
decision process (MDP) by taking into account various unique aspects of the considered
energy harvesting MEC system. The ofﬂoading and edge server provisioning decisions are
jointly made according to the information of computation workload, core network congestion
state, available battery power and anticipated renewable power arrival. By formulating the
MDP, the edge system resource management is carried out in a foresighted way by taking
future system dynamics into account, thereby optimizing the long-term system performance.
• We develop a novel post-decision state (PDS) based learning algorithm that learns the
optimal joint ofﬂoading and autoscaling policy on-the-ﬂy. It is well-known that MDP suffers
from the so-called “curse of dimensionality” problem when the state space is large .
The proposed PDS-based learning algorithm exploits the special structure of state transitions of the considered energy harvesting MEC system to conquer this challenge, thereby
signiﬁcantly improving both the learning convergence speed and the run-time performance
compared with conventional online reinforcement learning algorithms such as Q-learning
 . The key to achieving this performance improvement is a decomposition of the (ofﬂine)
value iteration and (online) reinforcement learning that allows many components of the
algorithm to be learned in a batch manner.
• We prove the convergence of the proposed PDS-based learning algorithm and analytically
characterize the structure of the resulting optimal policy. The optimal policy is proven to
have a simple monotone structure: the power demand for the optimal joint ofﬂoading and
autoscaling policy is non-decreasing in the amount of available battery power. This result
enables easy implementation of the proposed algorithm in practical MEC applications.
• Extensive simulations are carried out to verify our analytical results and evaluate the
performance of the proposed algorithm. The results conﬁrm that our method can signiﬁcantly
improve the performance of the energy harvesting MEC system.
The rest of this paper is organized as follows. Section II discusses related works. Section III
describes the system model. Section IV formulates the MDP problem. Section V develops the
PDS-based learning algorithm. Section VI proves the convergence of the proposed algorithm
and characterizes the structure of the optimal policy. Section VII evaluates the proposed method
via systematic simulations. Section VIII concludes the paper.
II. RELATED WORK
Mobile edge computing (MEC) has received an increasing amount of attention in recent years.
The concept of MEC was proposed in 2014 as a new platform that provides IT and cloudcomputing capabilities within the radio access network in close proximity to mobile subscribers
 . Initially, MEC refers to the use of BSs for ofﬂoading computation tasks from mobile
devices. Recently, the deﬁnition of edge devices gets broader, encompassing any devices that
have computing resources along the path between data sources and cloud data centers . Fog
computing is a related concept that refers to the same computing paradigm. The areas of Fog
computing and MEC are overlapping and the terminologies are frequently used interchangeably.
There exist signiﬁcant disparities between MEC and mobile cloud computing (MCC). Compared
with MCC, MEC has the advantages of achieving lower latency, saving energy, supporting
context-aware computing, and enhancing privacy and security for mobile applications . A
central theme of many prior studies is ofﬂoading policy on the user side, i.e., what/when/how to
ofﬂoad a user’s workload from its device to the edge system or cloud (see and references
therein). Depending on the type of tasks, ofﬂoading can be either binary or partial. Our work
focuses on edge-side ofﬂoading and autoscaling, and hence is complementary to these studies
on user-side ofﬂoading.
MEC servers are small-scale data centers and consume substantially less energy than the
conventional cloud mega-scale data center . However, as MEC servers become more widely
deployed, the system-wide energy consumption becomes a big concern. Therefore, innovative
techniques for achieving green MEC is in much need. Off-grid renewable energy, such as solar
radiation and wind energy, has recently emerged as a viable and promising power source for
various IT systems thanks to the recent advancement of energy harvesting techniques , .
Compared with traditional grid energy which is normally generated by coal-ﬁred power plants,
employing renewable energy signiﬁcantly reduces the amount of carbon emission. Moreover, the
use of renewable energy sources eliminates the need of human intervention, which is difﬁcult if
not impossible for certain types of application scenarios where the devices are hard and dangerous
to reach. However, designing green MEC powered by renewable energy is much more challenging
compared to green communication systems – or green data center networks ,
 , since the radio and computation resources have to be jointly managed, whereas prior
research typically only considers one of the two decisions. For example, autoscaling (a.k.a.,
right-sizing) in data centers dynamically controls the number of active servers, but the
control knob of ofﬂoading to the cloud is not available in the context of data centers. For energy
harvesting mobile devices, a dynamic computation ofﬂoading policy was proposed in using
Lyapunov optimization techniques based on both information of the wireless channel and
energy. The focus of the present paper is on energy harvesting MEC systems and our solution
is based on reinforcement learning.
Another study relevant to our work is , which also studies workload allocation/ofﬂoading
in a cloud-fog computing system. However, unlike our energy harvesting edge system, this
paper considers a grid-powered system and focuses on a one-shot static optimization without
addressing the temporal correlation among the ofﬂoading decisions across time (due to intermittent renewable energy and limited battery capacity). The present paper develops a foresighted
resource management algorithm for energy harvesting MEC, which can operate optimally in timevarying and unknown environments by formulating a Markov decision process problem. To cope
with unknown time-varying system dynamics, our learning algorithm employs a decomposition
of (ofﬂine) value iteration and (online) reinforcement learning based on factoring the system
dynamics into an a priori known and an a priori unknown component. A key advantage of
our proposed algorithm is that it exploits the partial information of the edge computing system
and the structure of the resource management problem, and thus it converges much faster than
conventional reinforcement learning algorithms such as Q-learning .
To the best knowledge of the authors, the conference version of this paper was the
ﬁrst to study resource management for energy harvesting MEC servers (see related discussions
in a recent comprehensive survey paper ). The present paper extents our ﬁndings in .
Speciﬁcally, in addition to developing an efﬁcient learning algorithm for the optimal ofﬂoading
and autoscaling policy, we analytically characterize the structure of the learned optimal resource
management policy and carry out extensive simulations to evaluate its performance.
III. SYSTEM MODEL
As a major deployment method of mobile edge computing , we consider an edge system
consisting of a base station and a set of edge servers, which are physically co-located and share
the same power supply in the cell site.
MAIN NOTATIONS AND THEIR MEANINGS
total workload arrival rate
amount of locally processed workload
number of active servers
wireless access and transmission delay cost
local processing delay cost
ofﬂoading delay cost
total delay cost
backup power supply cost
edge system operation power consumption
edge system computing power consumption
total energy consumption
harvested green energy
environment state
battery level
backhaul network congestion state
system state
post-decision system state
normal value function
post-decision value function
A. Workload model
We consider a discrete-time model by dividing the operating period into time slots of equal
length indexed by t = 0, 1, ..., each of which has a duration that matches the timescale at which
the edge device can adjust its computing capacity (i.e. number of active servers). We use x ∈L
to represent a location coordinate in the service area L. Let λ(x, t) represent the workload arrival
rate in location x, and θ(x, t) be the wireless transmission rate between the base station and
location x. Thus λ(t) = P
x∈L λ(x, t) ∈[0, λmax] is the total workload arrival rate at the edge
system, where λmax is the maximum possible arrival rate. The system decides the amount of
workload µ(t) ≤λ(t) that will be processed locally. The remaining workload ν(t) ≜λ(t)−µ(t)
will be ofﬂoaded to the cloud for processing. The edge system also decides at the beginning
of the time slot the number of active servers, denoted by m(t) ∈[0, M] ≜M. These servers
are used to process the local workload µ(t). Since changing the number of servers during job
execution are difﬁcult and in many cases impossible, we only allow determining the number of
servers at the beginning of each time slot but not within the slot.
B. Delay cost model
The average utilization of the base station is ρ(t) = P
x λ(x, t)/θ(x, t), which results in a total
wireless access and transmission delay of cwi(t) = P
x λ(x, t)/[θ(x, t)(1−ρ(t))] by following the
literature and modeling the base station as a queueing system . Next we model the workload
processing delay incurred at the edge servers.
For the local processed workload, the delay cost clo(t) is mainly processing delay due to the
limited computing capacity at the local edge servers. The transmission delay from the edge device
to the local servers is negligible due to physical co-location. To quantify the delay performance
of services, such as average delay and tail delay (e.g. 95th-percentile latency), without restricting
our model to any particular performance metric, we use the general notion of clo(m(t), µ(t))
to represent the delay performance of interest during time slot t. As a concrete example, we
can model the service process at a server instance as an M/G/1 queue and use the average
response time (multiplied by the arrival rate) to represent the delay cost, which can be expressed
as clo(m(t), µ(t)) =
m(t)·κ−µ(t), where κ is the service rate of each server.
For the ofﬂoaded workload, the delay cost coff(t) is mainly transmission delay due to network
round trip time (RTT), which varies depending on the network congestion state. For modeling
simplicity, the service delay at the cloud side is also absorbed into the network congestion state.
Thus, we model the network congestion state, denoted by h(t), as an exogenous parameter and
express it in terms of the RTT (plus cloud service delay) for simplicity. The delay cost is thus
coff(h(t), λ(t), µ(t)) = (λ(t) −µ(t))h(t). The total delay cost is therefore
cdelay(h(t), λ(t), m(t), µ(t))
=clo(m(t), µ(t)) + coff(h(t), λ(t), µ(t)) + cwi(λ(t))
C. Power model
We interchangeably use power and energy, since energy consumption during each time slot
is the product of (average) power and the duration of each time slot that is held constant in our
model. The total power demand of the edge system in a time slot consists of two parts: ﬁrst,
basic operation and transmission power demand by edge devices (base station in our study); and
second, computing power demand by edge servers. The ﬁrst part is independent of the ofﬂoading
or the autoscaling policy, which is modeled as dop(λ(t)) = dsta + ddyn(λ(t)) where dsta is the
static power consumption and ddyn(λ(t)) is the dynamic power consumption depending on the
amount of total workload. The computing power demand depends on the number of active servers
as well as the locally processed workload. We use a generic function dcom(m(t), µ(t)), which is
increasing in m(t) and µ(t), to denote the computing power demand. The total power demand
in time slot t is therefore
d(λ(t), m(t), µ(t)) = dop(λ(t)) + dcom(m(t), µ(t))
To model the uncertainty of the green power supply, we assume that the green power budget,
denoted by g(t), is realized after the ofﬂoading and autoscaling decisions are made. Therefore,
the decisions cannot utilize the exact information of g(t). However, we assume that there is an
environment state e(t) which the system can observe and it encodes valuable information of how
much green energy budget is anticipated in the current time slot. For instance, daytime in a good
weather usually implies high solar power budget. Speciﬁcally, we model g(t) as an i.i.d. random
variable given e(t), which obeys a conditional probability distribution Pg(g(t)|e(t)). Note that
the environment state e(t) itself may not be i.i.d.
D. Battery model
Batteries are used to balance the power supply and demand. In a solar+wind system, photovoltaic modules and wind turbines can combine their output to power the edge system and
charge the batteries . When their combined efforts are insufﬁcient, batteries take over to ensure
steady operation of the edge system. We denote the battery state at the beginning of time slot t
by b(t) ∈[0, B] ≜B (in units of power) where B is the battery capacity. For system protection
reasons, the battery unit has to be disconnected from the load once its terminal voltage is below
a certain threshold for charging. We map b(t) = 0 to this threshold voltage to ensure basic
operation of the system.
Since green power budget is unpredictable and hence unknown at the beginning of time slot
t, the edge system uses a conservative policy which satisﬁes dcom(m(t), µ(t)) ≤max{b(t) −
dop(λ(t)), 0} to avoid activating backup power supply by making ofﬂoading and autoscaling
decisions.
 
 

   
 

Fig. 2. Battery state dynamics. Case 1: current battery cannot support basic operation and thus, backup power supply is invoked.
Case 2: current battery can support basic operation.
• When dop(λ(t)) ≥b(t), dcom(λ(t), m(t), µ(t)) must be zero, which means that the edge
system ofﬂoads all workload to the cloud if the existing battery level cannot even support
the basic operation and transmission in the current slot. Moreover, the backup power supply
(e.g. diesel generator) will be used to maintain basic operation for the slot. The cost due
to activating the backup power supply is cbak(t) = φ · dop(λ(t)) where φ > 0 is a large
constant representing the large cost due to using the backup power supply. The next time
slot battery state then evolves to b(t + 1) = b(t) + g(t).
• When dop(λ(t)) ≤b(t), the edge system may process part of the workload µ(t) ≤λ(t)
at the local servers, but the power demand must satisfy dcom(λ(t), m(t), µ(t)) ≤b(t) −
dop(λ(t)). Depending on the realized green power g(t) and the computing power demand
dcom(λ(t), m(t), µ(t)), the battery is recharged or discharged accordingly:
– If g(t) ≥d(λ(t), m(t), µ(t)), then the surplus g(t) −d(λ(t), m(t), µ(t)) is stored in the
battery until reaching its capacity B:
b(t + 1) = max{b(t) + g(t) −d(λ(t), m(t), µ(t)), B}
– If g(t) < d(λ(t), m(t), µ(t)), then the battery has to be discharged to cover the energy
deﬁcit d(λ(t), m(t), µ(t)) −g(t).
b(t + 1) = b(t) + g(t) −d(λ(t), m(t), µ(t))
For simplicity, we will assume that there is no power loss either in recharging or
discharging the batteries, noting that this can be easily generalized. We also assume
that the batteries are not leaky. We model the battery depreciation cost in a time slot,
denoted by cbattery(t), using the amount of discharged power in this time slot since the
lifetime discharging is often limited. Speciﬁcally,
cbattery(t) = ω · max{d(λ(t), m(t), µ(t)) −g(t), 0}
where ω > 0 is the normalized unit depreciation cost.
IV. PROBLEM FORMULATION
In this section, we formulate the dynamic ofﬂoading and autoscaling problem as an online
learning problem, in order to minimize the system cost. The system state is described by a tuple
s(t) ≜(λ(t), e(t), h(t), b(t)), which is observable at the beginning of each time slot. Among
the four state elements, the workload arrival rate λ(t), the environment state e(t), the backbone
network state h(t) are exogenous states which are independent of the ofﬂoading and autoscaling
actions while the battery state b(t) evolves according the to ofﬂoading and autoscaling actions
as well as the renewable power realization. To make the stochastic control problem tractable,
they are assumed to have ﬁnite value spaces and λ(t), e(t), h(t) evolve as ﬁnite-state Markov
chains. Speciﬁcally, let Pλ(λ(t + 1)|λ(t)), Pe(e(t + 1)|e(t)) and Ph(h(t + 1)|h(t)) denote the
transition matrices for λ(t), e(t) and h(t), respectively. Similar assumptions have been made in
existing literature, e.g. , . Importantly, all these probability distributions are unknown a
priori to the edge system.
The stochastic control problem now can be cast into an MDP, which consists of four elements:
the state space S, the action space A, the state transition probabilities Ps(s(t+1)|s(t), a(t)), ∀s, s′ ∈
S, a ∈A, and the cost function c(s, a), ∀s, a. We have already deﬁned the state space. Next we
introduce the other elements as follows.
Actions. Although the actual actions taken by the edge system are ν(t) (ofﬂoading) and m(t)
(autoscaling) in each time slot t, we will consider an intermediate action in the MDP formulation,
which is the computing power demand in each time slot t, denoted by a(t) ∈A where A is a
ﬁnite value space [0, 1, ...., B]. We will see in a moment how to determine the optimal ofﬂoading
and autoscaling actions based on this. As mentioned before, to maintain basic operation in the
worst case, we require that a(t) ≤max{b(t) −dop(λ(t)), 0}. Thus, this condition determines the
feasible action set in each time slot.
State transitions. Given the current state s(t), the computing power demand a(t) and the
realized green power budget g(t), the buffer state in the next time slot is
b(t + 1) = [b(t) + g(t)]B
0 , if dop(λ(t)) > b(t)
b(t + 1) = [b(t) −dop(λ(t)) −a(t) + g(t)]B
0 , otherwise
where [·]B
0 denotes max{min{·, B}, 0}. The system then evolves into the next time slot t + 1
with the new state s(t + 1). The transition probability from s(t) to s(t + 1), given a(t), can be
expressed as follows
P(s(t + 1)|s(t), a(t))
=Pλ(λ(t + 1)|λ(t))Pe(e(t + 1)|e(t))Ph(h(t + 1)|h(t))
Pg(g(t)|e(t))1{ζ(t)}
where 1{·} is the indicator function and ζ(t) denotes the event deﬁned by (5). Notice that the
state transition only depends on a(t) but not the ofﬂoading or the autoscaling action. This is
why we can focus on the computing power demand action a(t) for the foresighted optimization
Cost function. The total system cost is the sum of the delay cost, the battery depreciation
cost and the backup power supply cost. If dop(λ(t)) > b(t), then the cost is simply
˜c(t) = cdelay(h(t), λ(t), 0, 0) + cbak(λ(t))
since we must have m(t) = 0 and µ(t) = 0. Otherwise, the realized cost given the realized green
power budget g(t) is
˜c(t) = cdelay(h(t), λ(t), m(t), µ(t)) + ω · [a(t) −g(t)]∞
Since the state transition does not depend on µ(t) or m(t), they can be optimized given s(t)
and a(t) by solving the following myopic optimization problem
cdelay(h, λ, m, µ) s.t. d(m, µ) = a
Let m∗(s, a) and µ∗(s, a) denote the optimal solution and c∗
delay(s, a) the optimal value given s
and a. Therefore, the minimum cost in time slot t given s and a is
˜c(t) = c∗
delay(s(t), a(t)) + ω · [a(t) −g(t)]∞
The expected cost is thus
c(s(t), a(t)) = c∗
delay(s(t), a(t)) + Eg(t)|e(t)ω · [a(t) −g(t)]∞
Policy. The edge system’s computing power demand policy (which implies the joint ofﬂoading
and autoscaling policy) in the MDP is a mapping π : Λ × E × H × B →A. We focus
on optimizing the policy to minimize the edge system’s expected long-term cost, which is
deﬁned as the expectation of the discounted sum of the edge device’s one-slot cost: Cπ(s(0)) =
δtc(s(t), a(t))|s(0)
where δ < 1 is a constant discount factor, which models the fact
that a higher weight is put on the current cost than the future cost. The expectation is taken over
the distribution of the green power budget, the workload arrival, the environment state and the
network congestion state. It is known that in MDP, this problem is equivalent to the following
optimization
π Cπ(s), ∀s ∈S
Let C∗(s) be the optimal discounted sum cost starting with state s. It is well-known that π∗and
C∗(s) can be obtained by recursively solving the following set of Bellman equations
C∗(s) = min
c(s, a) + δ
P(s′|s, a)C∗(s′)
In the next section, we solve this problem using the idea of dynamic programming and online
V. POST-DECISION STATE BASED ONLINE LEARNING
If all the probability distributions were known a priori, then the optimal policy could be
solved using traditional algorithms for solving Bellman equations, e.g. the value iteration and
the policy iteration , in an ofﬂine manner. In the considered problem, all these probability
distributions are unknown a priori and hence, these algorithms are not feasible. In this section,
we propose an online reinforcement learning algorithm to derive the optimal policy π∗on-the-ﬂy.
Our solution is based on the idea of post-decision state (PDS), which exploits the partially known
information about the system dynamics and allows the edge system to integrate this information
into its learning process to speed up learning. Compared with conventional online reinforcement
learning algorithms, e.g. Q-learning, the proposed PDS based learning algorithm signiﬁcantly
improves its convergence speed and run-time performance.
In this rest of this section, we ﬁrst deﬁne PDS, and then describe the proposed algorithm.
Finally, we prove the convergence of the proposed algorithm.
 
             
                     
Fig. 3. Illustration of Post-Decision State
A. Post-Decision State
We ﬁrst introduce the notion of PDS, which is the most critical idea of our proposed algorithm.
In our problem, PDS is the intermediate system state after the edge system takes the computing
power demand action a(t) but before the green power budget g(t) is realized. Figure 3 illustrates
the relationship between a normal state s(t) and its PDS ˜s(t). Speciﬁcally, the PDS in time slot
t, denoted by ˜s(t) ≜(˜λ(t), ˜e(t), ˜h(t),˜b(t)), is deﬁned as
˜λ(t) = λ(t),
˜e(t) = e(t),
˜h(t) = h(t)
b(t), if dop(λ(t)) > b(t)
max{b(t) −dop(λ(t)) −a(t), 0}, otherwise
As we can see, the post-decision workload state ˜λ(t), post-decision environment state ˜e(t)
and post-decision network congestion state ˜h(t) remain the same because the computing power
demand action a(t) does not have a direct impact on these elements of the system state. The only
element of the system state that may change is the battery state b(t). However, it is important
to notice that the post-decision battery state ˜b(t) is only a virtual state but not the real battery
state. Given the deﬁnition of PDS, we further deﬁne the post-decision value function V ∗(˜s) as
P(s′|˜s)C∗(s′), ∀s
where the transition P(s′|˜s) between PDS and the next system state is now independent of the
˜P(s|˜s) =Pλ(λ|˜λ)Pe(e|˜e)Ph(h|˜h)
Pg(g|˜e)1{b = min{˜b + g, B}}
For the ease of exposition, we refer to s as the “normal” state and C∗(s) as the “normal” value
(cost) function, in order to differentiate with their post-decision counterparts.
By comparing (11) and (14), it is obvious that there is a deterministic mapping from the
normal value function C∗(s) to the post-state value function V ∗(˜s) as follows by
C∗(s) = min
a∈A(c(s, a) + δV ∗(˜s))
The above equation shows that the normal value function C∗(s) in each time slot is obtained from
the corresponding post-decision value function V ∗(˜s) in the same time slot, where ˜s = (λ, e, h, b)
if dop(λ)) > b and ˜s = (λ, e, h, max{b −dop(λ) −a, 0}) if dop(λ) ≤b, by performing the
minimization over the action a.
The advantages of using the PDS and post-decision value function are summarized as follows.
(1) In the normal state based Bellman’s equation set (11), the expectation over the possible
workload arrival λ, the environment state e, network congestion state h, and green power budget
g has to be performed before the minimization over the possible energy demand actions a.
Therefore, performing the minimization requires the knowledge of these dynamics. In contrast,
in the PDS based Bellman equations (14), the expectation operation is separated from the
minimization operation. If we can learn and approximate the post-decision value function V ∗(˜s),
then the minimization can be solved without any prior knowledge of the system dynamics.
(2) Given the energy demand action a, the PDS decomposes the system dynamics into an a
priori unknown component, i.e. λ, e, h and g whose evolution is independent of a, and an a priori
known component, i.e. the battery state evolution is partially determined by a. Importantly, λ, e,
h and g are also independent of the battery state b. This fact enables us to develop a batch update
scheme on the post-decision value functions, which can signiﬁcantly improve the convergence
speed of the proposed PDS based reinforcement learning.
B. The algorithm
The algorithm maintains and updates a set of variables in each time slot. These variables are
• The one slot cost estimate ˆct(s, a), ∀(s, a) ∈S × A.
• The post-decision value function estimate ˆV t(˜s), ∀˜s ∈S.
• The normal value function estimates ˆCt(s), ∀s ∈S.
The superscript t is used to denote the estimates at the beginning of the time slot t. If these
estimates are accurate, i.e. ˆct(s, a) = c(s, a), ˆV t(˜s) = V ∗(˜s) and ˆCt(s) = C∗(s), then the optimal
power demand policy is readily obtained by solving (16). Our goal is to learn these variables
over time using the realizations of the system states and costs. The algorithm works as follows:
(In each time slot t)
Step 1: Determine the empirically optimal computing power demand by solving
a(t) = min
a (ˆct(s(t), a) + δ ˆV t(˜s(t)))
using the current estimates ˆct(s(t), a) and ˆV t(˜s(t)), where for each a, ˜s(t) represents the corresponding PDS. Given this power demand, the corresponding optimal ofﬂoading and autoscaling
actions are determined as µ(t) = µ∗(s(t), a(t)) and m(t) = m∗(s(t), a(t)) based on the solution
After the green power g(t) is harvested and hence the current slot cost ˜c(t) is realized according
to (9), the battery state evolves to b(t + 1) according to (5).
Steps 2 through 4 update the estimates.
Step 2: Batch update ˆct(s, a) for any action a and any state s = (λ, e, h, b) such that e is
the same as the current slot environment state e(t) using the realized green power budget g(t)
according to
ˆct+1(s, a) = (1 −ρt)ˆct(s, a) + ρtc(s, a, g(t))
where ρt is the learning rate factor that satisﬁes P∞
t=0 ρt = ∞and
(ρt)2 < ∞. For all other
action-state pair, ˆct+1(s, a) = ˆct(s, a). We can do this batch update because the green power
budget g(t) depends only on the environment state e(t) but not on other states or actions.
Step 3: Batch update the normal value function estimate for any state s = (λ, e, h, b) such
that e = e(t) according to
ˆCt+1(s) = min
a∈A(ˆct+1(s, a) + δ ˆV t(˜s))
The normal value function estimates for the remaining states are unchanged. The reason why
we can do this batch update is the same as that in Step 2.
Step 4: Batch update the post-decision value function estimate for any ˜s ∈˜S such that
˜λ = ˜λ(t), ˜e = ˜e(t) and ˜h = ˜h(t) according to
ˆV t+1(˜s) = (1 −αt) ˆV t(˜s) + αt ˆCt+1(s)
where s = (λ, e, h, b) satisﬁes λ = λ(t+1), e = e(t+1), h = h(t+1) and b = min{˜b+g(t), B}.
In this way, we update not only the currently visited PDS ˜s(t) but all PDS with common ˜λ(t),
˜e(t) and ˜h(t). This is because the temporal transition of λ, e, h is independent of of the battery
state b and the green power budget realization follows the same distribution since the environment
state e is the same for these states.
Algorithm 1 Online Learning for Joint Ofﬂoading and Autoscaling
1: Initialize: ˆc0(s, a) = 0, ∀(s, a), ˆV 0(˜s) = 0, ∀˜s, ˆC0(s) = 0, ∀s.
2: for every time slot t do
Observe current state s(t)
Determine power demand a(t) by solving (17)
Determine ofﬂoading and autoscaling actions µ(t) and m(t) by solving (8)
Compute the post-decision state ˜st according to (12) and (13)
(The green power budget g(t) is realized.)
Batch update ˆct(s, a) according to (18)
Batch update ˆCt(s) according to (19)
Batch update ˆV t(˜(s)) according to (20)
11: end for
VI. ALGORITHM ANALYSIS
A. Convergence of the PDS learning algorithm
We ﬁrst prove the convergence of our algorithm.
Theorem 1. The PDS based online learning algorithm converges to the optimal post-decision
value function V ∗(˜s), ∀˜s when the sequence of learning rates ρt satisﬁes P∞
t=0 ρt = ∞and
(ρt)2 < ∞.
Proof. The proof follows . For each PDS ˜s, we deﬁne a function on its value function as
F˜s(V ) = min
a∈A(c(s, a) + δV (˜s))
where s and a are such that, λ = ˜λ, e = ˜e, h = ˜h and b = ˜b −a. Thus, for any value of V (˜s),
F˜s(V ) maps to a real number. Based on this, we deﬁne F : R|S| →R|S| be a mapping which
collects F˜s for all ˜s ∈S. It is proven in that the convergence of our proposed algorithm is
equivalent to the convergence of the associated ordinary differential equation (O.D.E.):
˙V = F(V ) −V
Since the map F : R|S| →R|S| is a maximum norm δ-contraction, the asymptotic stability of
the unique equilibrium point of the above O.D.E. is guaranteed . This unique equilibrium
point corresponds to the optimal post-decision value function V ∗(˜s), ∀˜s ∈S.
Because C∗(s), ∀s is a deterministic function of V ∗(˜s), ∀˜s, it is straightforward that the PDS
based online learning algorithm also converges to C∗(s), ∀s. Therefore, we prove that the edge
system is able to learn the optimal power demand policy and hence the optimal ofﬂoading and
autoscaling policies using the proposed algorithm.
B. Structure of the Optimal Policy
Next, we characterize the structure of the optimal policy. First, we show that the one-slot cost
function is convex in the power demand action.
Lemma 1. Assume that both clo(m, µ) and dcom(m, µ) are jointly convex in (m, µ) for any given
s, then the one-slot cost function c(s, a) is convex in a for any given s.
Proof. Recall that c(s, a) = c∗
delay(s, a) + Eg|eω · max{a −g, 0}. Since a −g is linear in a, and
the maximum of convex functions is still convex, it is obvious that max{a −g, 0} is convex in
a. Since the expectation is just a weighted sum of convex functions, Eg|eω · max{a −g, 0} is
also convex in a. Now, if we can prove c∗
delay(s, a) is convex in a, then the lemma is proved.
Recall that c∗
delay(s, a) is the solution to
cdelay(h, λ, m, µ) s.t. d(m, µ) = a
for the given s. Since cdelay(h, λ, m, µ) = clo(m, µ)+coff(µ(t))+cwi, clo(m, µ) is jointly convex
in (m, µ) and coff(µ(t)) is linear in µ, cdelay(h, λ, m, µ) is also jointly convex in (m, µ). Similarly,
since d(m, µ) = dop + dcom(m, µ) and dcom(m, µ) is jointly convex in (m, µ), d(m, µ) is also
jointly convex in (m, µ).
Consider two power demand actions a1, a2, let (m∗
1) and (m∗
2) be the corresponding
optimal joint ofﬂoading and autoscaling actions. Clearly, we should have the constraint be binding
for the optimal solution, i.e. d(m∗
1 and d(m∗
2. Now, we have, ∀λ ∈(0, 1),
delay(a1) + (1 −λ)λc∗
=λcdelay(m∗
1) + (1 −λ)λcdelay(m∗
≥cdelay(λ(m∗
1) + (1 −λ)(m∗
2)) ≜cdelay(mλ, µλ)
where we deﬁne (mλ, µλ) ≜λ(m∗
1)+(1−λ)(m∗
2). Let ˜a = d(mλ, µλ) be the corresponding
required power demand. Further, we let (m∗, µ∗) be the optimal ofﬂoading and autoscaling action
for this ˜a. Clearly, cdelay(mλ, µλ) ≥cdelay(m∗, µ∗). Due to the convexity of d(m, µ), we have
˜a = d(mλ, µλ) = d(λ(m∗
1) + (1 −λ)(m∗
1) + (1 −λ)d(m∗
=λa1 + (1 −λ)a2 ≜aλ
Therefore, cdelay(m∗, µ∗) ≥cdelay(m∗
λ), where (m∗
λ) are the optimal ofﬂoading and autoscaling actions for aλ. Therefore, we have
delay(a1) + (1 −λ)λc∗
≥cdelay(m∗
delay(λa1 + (1 −λ)a2)
This completes the proof of this lemma.
Lemma 2 characterizes the shape of the optimal value function and post-state value function.
Lemma 2. Assume that c(s, a) is convex in a for any given s, then both V ∗(s) and C∗(s) are
non-increasing and convex in b for any given λ, e, h.
Proof. We ﬁrst prove C∗(s) is non-increasing. The optimal value functions satisfy
C∗(s) = min
c(s, a) + δ
P(s′|s, a)C∗(s′)
Consider two states s and s′ that differs only in b and b′, and assume b < b′. Let a∗be the
optimal action for s. Now consider an action a′ = b′ −b + a∗> a∗for state s′. It is obvious
that the second term on the right-hand side is identical in both cases since the transitions of
λ, e, h are independent of the battery state, and because b′ −a′ = b −a∗, the battery state
transition is also the same. Because c(s, a) is non-increasing in a, we have c(s′, a′) ≤c(s, a∗).
Therefore, by choosing a′ for s′, we have C(s′, a′) ≤C∗(s). Realizing C∗(s′) ≤C(s′, a′) due
to the minimization operation, we have C∗(s′) ≤C∗(s), thus proving C∗(s) is non-increasing.
Next, we prove that C∗(s) is convex by induction. The optimal value functions C∗(s), ∀s can
be solved by the value iteration algorithm
Cn+1(s) = min
c(s, a) + δ
P(s′|s, a)Cn(s′)
where the subscript n and n + 1 represent the n-th iteration and (n + 1)-th iteration. It is well
known that valuation iteration converges to the optimal solution, i.e. as n →∞, Cn(s) →
C∗(s), ∀s, starting from any initial value function C0(s), ∀s. We initialize C0(s) to be convex
in b for any given λ, e, h. It is easy to see that V ∗(s) is also non-increasing since it is simply a
weighted average of a bunch of value functions.
Suppose Cn(s), ∀s are convex in b for any given λ, e, h. Consider two battery states b < b′
and let the corresponding optimal action be a∗and a′∗. Then we have
Cn+1(b) = c(a∗) + δVn(b −a∗)
Cn+1(b′) = c(a′∗) + δVn(b′ −a′∗)
In the above equations, we omitted the state elements λ, e, h. Since we have assumed that
Cn(b), ∀s are convex in b. In addition, ˆb = min{b + g, B} is a concave function in b. Thus, by
applying the results of composition (i.e. if f is concave and g is convex and non-increasing,
then h(x) = g(f(x)) is convex.), we have Cn(min{b + g, B}), ∀s also convex. Therefore Vn(b)
is also convex in b since it is a weighted sum of convex functions.
Now, combining (29) and (30) and using the convexity of Vn(b) we have
λCn+1(b) + (1 −λ)Cn+1(b′)
=λc(a∗) + (1 −λ)c(a′∗)
+ δ[λVn(b −a∗) + (1 −λ)Vn(b′ −a′∗)]
≥c(aλ) + δVn(bλ −aλ) ≥Cn+1(bλ)
where bλ = λb + (1 −λ)b′ and aλ = λa∗+ (1 −λ)a′∗. This proves that Cn+1(b) is also convex
Now, we are ready to prove the structural result of the optimal power demand policy.
Theorem 2. Assume that both clo(m, µ) and dcom(m, µ) are jointly convex in (m, µ) for any given
s, then the optimal power demand policy is monotonically non-decreasing in b for any given
λ, e, h. That is, ∀s, s′ such that λ = λ′, e = e′, h = h′ and b ≤b′, then we have π∗(s) ≤π(s′).
Proof. We aim to prove that C(b, a) is subadditive in the battery state b and the power demand
action a for any given λ, e, h. This is to prove that ∀b ≤b′ and a ≤a′, we have
C(b, a′) −C(b, a) ≥C(b′, a′) −C(b′, a)
If the above is true, then we can apply (Section 4.7) to show that π(s) is non-decreasing
Equation (32) is equivalent to
V ∗(b −a′) −V ∗(b −a) ≥V ∗(b′ −a′) −V ∗(b′ −a)
Let b −a = ˆb, b′ −a = ˆb′ and ∆= a′ −a. Then the above becomes
V ∗(ˆb −∆) −V ∗(ˆb) ≥V ∗(ˆb′ −∆) −V ∗(ˆb′)
which is true due to the fact that V ∗(b) is non-increasing and convex when clo(m, µ) and
dcom(m, µ) are jointly convex in (m, µ) for any given s (by Lemma 1 and Lemma 2). This
completes the proof.
VII. SIMULATION
A. Simulation Setup
We consider each time slot as 15 minutes. The workload arrival space is set as Λ ={10
units/sec, 20 units/sec, ..., 100 units/sec}. The network congestion space is H ={20 ms/unit,
30 ms/unit, ..., 60 ms/unit}. The environment state space is E ={Low, Medium, High}. For
each environment state, the green power will be realized according to a normal distrinution
with different means: g(t|e = Low) ∼N (200W, 102), g(t|e = Medium) ∼N (400W, 102),
g(t|e = High) ∼N (600W, 102). The battery capacity is set as B =2 kWh. The base station
static power consumption is dsta = 300W. The maximum number of activated edge server is
M = 15. The power consumption of each edge server is 150W. The maximum service rate of
each edge server is 20 units/sec. Other important parameters are set as follows: the normalized
unit depreciation cost ω = 0.01, the cost coefﬁcient of backup power supply φ = 0.15.
Time Average Cost
PDS learning (proposed)
Q-learning
Myopic optimization
Fixed 0.4 kW
Fixed 1.0 kW
Fig. 4. Run-time performance comparison
The proposed PDS-based learning algorithm is compared with three benchmark schemes:
• Q-learning : Q-learning is a famous model-free reinforcement learning technique for
solving MDP problems. It has been proven that for any ﬁnite MDP problem, Q-learning
eventually ﬁnds an optimal policy.
• Myopic optimization: this scheme ignores the temporal correlation between the system
states and the decisions, and minimizes the cost function given the state in the current time
slot by utilizing all available battery energy.
• Fixed power: this scheme uses a ﬁxed computation power (whenever possible) for edge
computing in each time slot.
B. Run-time Performance Comparison
Figure 4 compares the run-time performance of our scheme with the three benchmark schemes
for 10000 time slots. As can be seen, the proposed PDS-based learning algorithm incurs a
signiﬁcantly lower cost than all benchmark schemes.
• Myopic optimization incurs a large time-average cost since it ignores the temporal correlation of decision making and frequently is forced to activate the backup power in the
subsequent time slots.
• The ﬁxed power scheme has tremendously different performance depending on the ﬁxed
value used, which implies that it is sensitive to system parameters. In Figure 4, two ﬁxed
values (1.0kW and 0.4kW) are shown for illustrative purposes, where 1.0kW is the best ﬁxed
value found by our extensive simulations. Since the system dynamics is unknown a priori
Battery level (kWh)
Computing power demand (kW)
PDS policy ( = 10, h = 100 ms, e = Low)
PDS policy ( = 20, h = 150 ms, e = Medium)
Myopic policy ( = 10, h = 100 ms, e = Low)
Myopic policy ( = 20, h = 150 ms, e = Medium)
Fig. 5. Computing power demand policy
and may change over time, using a ﬁxed computing power scheme may cause signiﬁcant
performance loss.
• The performance of Q-learning is much worse than our proposed PDS learning since it
converges very slowly due to the large state space. Although there is a trend of declining in
the time average cost, even after 10000 time slots, there is still a considerable performance
gap compared with our scheme. On the other hand, our proposed PDS scheme converges
very quickly.
C. Learned Optimal Policy
Figure 5 further explains why the proposed algorithm outperforms the myopic solution by
showing the learned optimal policy. When the workload demand is low and the network is not
congested, the policy learned by the proposed algorithm tends to be conservative in using local
computing power if the battery level is low. In this way, more power can be saved for future
when the workload is high and the network congestion state degrades, thereby reducing the
long-term system cost. On the other hand, the myopic policy ignores this temporal correlation,
it activates local servers to process workload even if the battery level is not so high. As a result,
even though it achieves slight improvement in the current slot, it wastes power for potentially
reducing signiﬁcant cost in the future. Figure 5 also validates our theoretical results in Theorem
2 on the structure of the optimal policy: The optimal power demand increases in the battery
Insufficient
Battery level (kWh)
Distribution
PDS policy (proposed)
Q-learning
Myopic optimization
Fixed (0.4 kW)
Fixed (1 kW)
(a) Battery state distribution
Battery level (kWh)
Distribution
Insufficient
PDS learning (proposed)
Q-learning
Myopic optimization
Fixed 0.4 kW
Fixed 1.0 kW
(b) Battery state distribution (ﬁtted)
Fig. 6. Battery state distributions
D. Battery State Distribution
Figure 6(a) shows the distributions of the battery state over the simulated 10000 time slots
in one representative simulation run for the various schemes, and Figure 6(b) shows the ﬁtted
curves (polynomial ﬁt) for better inspection. As can be seen, Myopic optimization results in a
large portion of time when the system is in the insufﬁcient battery zone, incurring signiﬁcant
backup power costs. If a too small ﬁxed power demand is used (e.g. 0.4kW), the battery state
may spend a considerable amount of time in the high battery level zone (i.e. 0.7 – 1kWh).
This implies that much of the green power cannot be harvested and hence is wasted due to the
limited battery capacity constraint. Moreover, using a smaller ﬁxed power for computation does
not guarantee that it has a smaller chance to get into the insufﬁcient battery zone. This is because
when the battery state is slightly higher than the level that can support basic operation, using
a smaller ﬁxed power can easily make battery state drop to the insufﬁcient battery zone in the
subsequent time slot whereas if a larger ﬁxed power scheme is used, the system will decide to
ofﬂoad all workload to the cloud without using the local battery power. Although a proper ﬁxed
power demand is able to strike a decent balance, it does not well adapt to the changing system
dynamics. The proposed PDS-based algorithm achieves the highest harvesting energy efﬁciency
by keeping the battery at a relatively low state while above the insufﬁcient level.
E. Cost Composition
Figure 7 shows the cost compositions of the PDS-based algorithm and Myopic optimization
in 10000 time slots. It can be observed that the proposed PDS-based algorithm signiﬁcantly
(a) Run-time cost composition (PDS)
(b) Run-time cost composition (Myopic)
Fig. 7. Run-time cost composition
MyopicQ-learning 0.4kW
Time Average Cost
Backup power cost
Delay cost
Fig. 8. Time-average cost composition (T = 104)
cuts the back-up power cost by taking conservative action at low battery states which avoids the
usage of backup power. By contrast, Myopic optimization frequently leads the battery state into
the insufﬁcient zone as shown in ﬁgure 6 and results in signiﬁcant backup power costs. Figure
8 presents the composition of time-average cost at the end of simulation. It can be observed that
the PDS-based algorithm and Q-leaning reduce the total cost by considering the future system
dynamics and incur low backup power cost accounting for 12.6% and 16.7% of the total cost,
respectively. These fractions are much lower than those of the remaining schemes which do not
consider the long-term system performance.
F. Optimal Ofﬂoading Strategy
Finally, we visualize the optimal ofﬂoading strategy in Figure 9 given a ﬁxed number of active
servers under various system states. As the network becomes more congested and there are more
(a) Optimal ofﬂoading policy (m = 4)
(b) Optimal ofﬂoading policy (m = 10)
Fig. 9. Optimal ofﬂoading policy
active edge servers, the optimal strategy chooses to process more workload at the local edge
system. However, as the workload arrival rate increases, the amount of workload that can be
processed at the local edge system is saturated after certain workload arrival rate.
VIII. CONCLUSION
In this paper, we studied the joint ofﬂoading and autoscaling problem in energy harvesting
MEC systems. We found that foresightedness and adaptivity are keys to reliable and efﬁcient operation of renewable-powered MEC. To enable fast learning in the presence of a priori unknown
system parameters, a PDS-based reinforcement learning algorithm was developed to learn the
optimal ofﬂoading and autoscaling policy by exploiting the special structure of the considered
problem. Our simulations showed that the proposed scheme can signiﬁcantly improve the edge
computing performance even if it is powered by intermittent and unpredictable renewable energy.
Future work includes investigating large-scale edge computing systems powered by renewable
energy, e.g. green power-aware geographical load balancing.