Keypoint Recognition using Randomized Trees
Vincent Lepetit and Pascal Fua1
Ecole Polytechnique Fédérale de Lausanne (EPFL)
Computer Vision Laboratory, I&C Faculty
CH-1015 Lausanne, Switzerland
{Vincent.Lepetit,
Pascal.Fua}@epfl.ch
 
To appear in IEEE PAMI
In many 3–D object-detection and pose-estimation problems, run-time performance is of critical
importance. However, there usually is time to train the system, which we will show to be very useful.
Assuming that several registered images of the target object are available, we developed a keypoint-based
approach that is effective in this context by formulating wide-baseline matching of keypoints extracted
from the input images to those found in the model images as a classiﬁcation problem. This shifts much
of the computational burden to a training phase, without sacriﬁcing recognition performance. As a result,
the resulting algorithm is robust, accurate, and fast-enough for frame-rate performance.
This reduction in run-time computational complexity is our ﬁrst contribution. Our second contribution is to show that, in this context, a simple and fast keypoint detector sufﬁces to support detection and
tracking even under large perspective and scale variations. While earlier methods require a detector that
can be expected to produce very repeatable results in general, which usually is very time-consuming,
we simply ﬁnd the most repeatable object keypoints for the speciﬁc target object during the training
We have incorporated these ideas into a real-time system that detects planar, non-planar, and
deformable objects. It then estimates the pose of the rigid ones and the deformations of the others.
Index Terms
Image Processing and Computer Vision, Object recognition, Tracking, Statistical, Classiﬁer design
and evaluation, Edge and feature detection.
1This work was supported in part by the Swiss National Science Foundation.
I. INTRODUCTION
In many 3–D object-detection and pose estimation problems ranging from Augmented Reality
to Visual Servoing, run-time performance is of critical importance. However, there usually is
time to train the system before actually using it. Furthermore 3–D models, or multiple images
from which such models can be built, tend to be available. As shown in Figures 1 and 2, we
describe here a technique designed to operate effectively in this context by shifting much of
the computational burden to the training phase so that run-time detection becomes both fast and
Our approach, like many others, relies on matching interest points extracted from training
images and those extracted from input images acquired at run-time under potentially large
perspective and scale variations. What is new is to formulate this wide-baseline matching problem
as a classiﬁcation problem. More speciﬁcally, we consider the set of all possible appearances of
each individual object keypoint as a class, which we refer to as the view-set. During training,
given at least one image of the target object, we extract interest points and generate numerous
synthetic views of their possible appearance under perspective distortion, which are then used
to train a classiﬁer. It is used at run-time to recognize the keypoints under perspective and scale
variations by deciding to which view-set, if any, their appearance belongs. We advocate the use
of randomized trees as the classiﬁcation technique, because they naturally handle multi-class
problems and are robust and fast, while remaining reasonable easy to train.
Not only is this approach more principled than many earlier ones, but it yields a reduction in
run-time computational complexity, which is our ﬁrst contribution. Our method does away with
having to compute ad hoc descriptors, rectify patches, and search for nearest-neighbors, which
are time-consuming steps common in earlier methods , , , , , , , .
Another contribution is to show that, in this context, a simple and fast keypoint detector sufﬁces
for operation even under large perspective and scale variations, which results in a further increase
in performance. While earlier methods require detectors that can be depended upon to produce
very repeatable results, which can be very time-consuming, we simply ﬁnd the most repeatable
object keypoints for the speciﬁc target object during the training phase,
In the remainder of the paper, we ﬁrst discuss related work and formulate wide-baseline
matching as a classiﬁcation problem. We then discuss the building of our view-sets and our use
17th August 2006
Detection of a book in a video sequence: As shown by the white outline, the book is detected independently and
successfully in all frames at 25Hz in 640×480 images on a standard PC, in spite of partial occlusion, cluttered background,
motion blur, large illumination and pose changes. In the last two frames, we add the inevitable virtual teapot to show we also
recover 3–D pose. The corresponding video sequence is submitted as supplementary material.
of randomized-trees to perform the classiﬁcation. Finally, we present our results.
II. RELATED WORK
In the area of automated 3D object detection, we can place existing approaches on a continuum
ranging from purely “Global” ones to purely “Local” one. The former typically use machine
learning techniques while the latter usually rely on less principled methods. A number of practical
techniques, such as the coarse to ﬁne method proposed in , combine the strengths of both
kinds of methods. We will argue that our approach also does this by applying machine learning
techniques for the recognition of local parts, while providing an accurate 3D pose. For clarity’s
sake, in this section, we nevertheless classify approaches as either global or local according to
which aspect dominates.
Global approaches use statistical classiﬁcation techniques to compare an input image to several
training images of an object of interest and decide whether or not it appears in this input
image. The methods used range from relatively simple methods such as Principal Component
Analysis and Nearest Neighbor search to more sophisticated ones such as AdaBoost and
classiﬁers cascade to achieve real-time detection of human faces at varying scales , . These
approaches focus on recognizing instances of generic classes without providing an accurate 3D
pose estimation. Some of them can handle tens of instances of the object class in one image
17th August 2006
but are not designed for robustness to occlusions, cluttered backgrounds, or poses different from
those in the training set.
By contrast, local approaches use simple 2D features such as corners or edges, which makes
them resistant to partial occlusions and cluttered backgrounds: Even if some features are missing,
the object can still be detected as long as enough are found and matched. Spurious matches can be
removed by enforcing geometric constraints, such as epipolar constraints between different views
or full 3D constraints if an object model is available. The use of weaker geometric constraints
is discussed in , and is shown to achieve robustness to occlusion and clutter. However, to
be effective in our context, the feature extraction and characterization should also be insensitive
to viewpoint and illumination changes.
As proposed in , scale-invariant extraction can be achieved by taking the local extrema
of a Laplacian-of-Gaussian pyramid in scale-space as feature points. To increase computational
efﬁciency, the Laplacian can be approximated by a Difference-of-Gaussian . More recent
work has focused on achieving afﬁne invariant region detection to handle large perspective
distortions as well. , , used an afﬁne invariant point detector based on the Harris
detector, where the afﬁne transformation that equalizes the two eigenvalues of the auto-correlation
matrix is evaluated to rectify the patch appearance. achieves invariance by ﬁtting an ellipse
to the local texture. proposes a fast algorithm to extract Maximally Stable Extremal Regions.
 gives an extensive study on these afﬁne invariant regions detectors.
Given the extracted feature points, various local descriptors have been proposed , .
Among these, the SIFT descriptor has been shown to be one of the most effective .
It relies on local orientation histograms and tolerates signiﬁcant local deformations. In ,
it is applied to rectiﬁed afﬁne invariant regions to achieve perspective invariance. In ,
a similar result is obtained by training the system using multiple views of a target object,
storing all the SIFT features from these views, and matching against all of them. performs
Principal Component Analysis on such local orientation histograms, which appears to improve
the reliability of this representation. However, such descriptors can be costly, and whatever
the chosen descriptor is, matching is performed by nearest-neighbor search, which tends to be
computationally expensive, even when using an efﬁcient data structure .
By contrast, in earlier work , we argued that formulating wide-baseline matching as a
classiﬁcation problem let us shift much of the computational burden to a training phase. This
17th August 2006
The method is just as effective for 3–D objects. In this experiment, we detected the stuffed tiger in the three images to
the right using a 3–D model reconstructed from several views such as the two ﬁrst images on the left. Note that it reprojects at
the right place in all three images.
reduces the cost of online matching while increasing its robustness. In this early work, we
used PCA as the classiﬁcation technique. Here, we advocate further reducing the run-time
computational complexity by using Randomized Trees instead. They have been extensively
used for character recognition and more recently for image classiﬁcation . They require
additional training in exchange for increased run-time efﬁciency because they let us replace
projection in the eigenspace and nearest-neighbor search by simple binary tests on image graylevels.
Classiﬁcation as a technique for wide baseline matching has also been explored in parallel to
our own work . In this approach, the training set is iteratively built from incoming frames.
While this is well-adapted for applications that do not allow for a training stage, this approach
was not designed to allow recognition from views that are very different from those already seen.
Furthermore, it uses kernel PCA, which is even more computationally expensive than PCA-based
classiﬁcation.
III. WIDE BASELINE POINT MATCHING AS A CLASSIFICATION PROBLEM
Our approach relies on matching keypoints found in an input image against those on a target
object O. Once potential correspondences have been established, we apply standard techniques
to estimate 3–D pose. Therefore, the critical step in achieving results such as those depicted by
Figures 1 and 2 is the fast and robust wide-baseline matching that handling large perspective
and scale changes implies, which we formulate below in terms of a classiﬁcation problem.
During training, we construct a set K = {k1 . . . kN} of N prominent keypoints lying on the
object model. At runtime, given an input patch p(kinput) centered at a keypoint kinput extracted
from the input image, we want to decide whether or not its appearance matches that one of
17th August 2006
Sampling the view-set. (a) For a keypoint on the cover of the book of Figure 1, we synthesize new views using random
afﬁne transformations and adding white noise. (b) Same thing for another keypoint located on the border of the book. (c, d): In
the case of the stuffed tiger, the sampling is obtained using a textured 3–D model seen from different viewpoints.
the N keypoints ki. In other words, we want to ﬁnd for p(kinput) its class label Y (p) ∈C =
{−1, 1, 2, . . . , N}, where the −1 label denotes all the points that do not belong to K. Since Y
cannot be directly observed, we build a classiﬁer ˆY such as P(Y (p) ̸= ˆY (p)) is small.
In other tasks such as face detection or character recognition, large training sets of labeled
data are usually available. However, for automated pose estimation, it would be impractical to
require a very large number of sample images. Instead, to achieve robustness with respect to
pose and complex illumination changes, we use a small number of images and synthesize many
new views of the object using simple rendering techniques. For each keypoint, this gives us a
sampling of its view set, that is the set of all its possible appearances under different viewing
conditions. The ﬁrst two rows of Figure 3 depict such a sampling for two keypoints detected
on the book of Figure 1, the two last rows correspond to two keypoints detected on the stuffed
tiger of Figure 2.
These samplings are virtually inﬁnite training sets that serve as input to the tree-building
algorithms. The resulting trees form a very fast ˆY run-time classiﬁer as introduced above. Its
output is a set of matches that we use to estimate the pose using a standard robust estimation
technique.
17th August 2006
Building the view-sets. (a) A synthetic view for the book cover, with extracted keypoints, (b) The most stable keypoints
selected by our method. (c, d) Same thing for the stuffed tiger.
IV. BUILDING THE VIEW SETS
A simple approach to building the view sets would be to extract keypoints from the original
images and then process them independently as we did in . However, a more effective
approach is to generate new views of the whole object such as those of Figure 4, and extract
keypoints from these. In this way, we can easily select keypoints that are stable under noise and
perspective distortion, which helps making the matching robust to noise and cluttered background
at no additional run-time computational cost.
Recall from Section III, that, for detection purposes, we describe the target object as a set of
keypoints K = {ki} lying on the target object, and expressed in a reference system related to
it. We discuss below the construction of the view-sets given the keypoints and then the process
of extracting and selecting them.
A. Sampling the View-Sets
If the object is of uniformly low curvature, patches surrounding the ki keypoints can be treated
as locally planar and their distortions under perspective projection as homographies. In this case,
only one frontal view of the target object is enough to generate new views. We approximate them
by afﬁne transformations that we draw randomly to sample the view-set. An afﬁne transformation
can be decomposed as A = RθR−1
φ SRφ, where Rθ and Rφ are two rotation matrices respectively
parameterized by the angles θ and φ, and S = diag [λ1, λ2] is a scaling matrix. For all the planar
object examples shown in this paper, θ and φ are drawn uniformly from the interval [−π; +π],
and λ1 and λ2 from the interval [0.6; 1.5]. This range of scales is sufﬁcient to handle variations
17th August 2006
within a single octave, while larger scale changes are handled by interest point detection at
several scales, as discussed below.
If the object is more complex, we can take advantage of a 3–D model that has been built
either automatically or by hand using several images of the object. We use it in conjunction with
standard texture-mapping techniques to generate new views under perspective transformations.
In the case of the stuffed tiger of Figure 2, we used the ImageModeler software package2 to
quickly build a very coarse 3–D model, which has proved to be sufﬁcient. Random proﬁle and
frontal views of the tiger were generated by moving the camera around it while maintaining
the distance between 30 to 50 cm and the camera tilt angle between -30 and 30 degrees. As
a result, we can reliably detect the object from images acquired with cameras moving within
those bounds. Furthermore, thanks to the multi-scale matching scheme, we can actually place
the camera either further or closer.
We experimented with objects that exhibit relatively few specularities and therefore synthesized
our training images without accounting for lighting effects. We can nevertheless handle changes
in lighting because the tests we perform to classify patches, which we discuss in more detail in
Section V, rely on binary comparisons between image intensities. As a result, they are invariant
to the often monotonous intensity changes that lighting differences tend to produce in any given
neighborhood and lighting effects only perturb a very small fraction of the matches. Those
erroneous matches, being few in number, can easily be discarded by the robust estimator we
use for pose estimation. This is why the specular reﬂections and image saturation effects on
the book cover and the plastic part of the stuffed tiger do not degrade the performance of our
system, even though it has not been trained using images that exhibit such lighting effects. For
more complex cases, it should be possible to capture the material properties and generate very
realistic images . However, it would be cumbersome and we have not found it to be necessary.
B. Fast Multiscale Keypoint Extraction
Our approach does not rely on a speciﬁc method for extracting keypoints, and we could
have used any of the many methods for multiscale detection that have recently been proposed.
However since we focus on real-time applications we developed our own method, which is
2ImageModeler is a commercial product from Realviz(tm) that allows semi-automated 3–D reconstruction from several views.
17th August 2006
sufﬁciently fast and yet stable for our purposes. As was done in , , we look for extrema
of the Laplacian of Gaussian that are sufﬁciently “cornerlike.” However, instead of computing
some score map such as the Laplacian or the Harris matrix at each location and then searching
for the keypoints in this map, we proceed as follows.
Following a philosophy similar to the one proposed in , for each pixel m, we consider the
intensities along a discretized circle centered at m. We then eliminate all pixels whose gray level
is close to those of any two diametrically opposed pixels on this circle and that are therefore
unlikely to be stable keypoints. Among the remaining ones, we estimate the Laplacian using gray
level differences between pixels on the circle and the central one and retain only the locations
where this estimate is largest. This very simple approach often requires only a few intensity
comparisons to eliminate points in uniform areas and along edges and a few more to select the
maxima of the Laplacian. As a result, it is very fast and has proved sufﬁciently robust for our
We run this algorithm on the ﬁrst few octaves of the image and simultaneously use the interest
points detected at each octave to train the classiﬁer, as described below. Figure 5 illustrates how
this simple procedure and the keypoint classiﬁer work in tandem to recognize the keypoints
under large variation of both scale and appearance. This contrasts with earlier techniques 
that depend on much more sophisticated and expensive methods to accurately extract the afﬁne
deformation of a feature.
C. Keypoint Selection
Ideally, all the ki keypoints in K should have a high probability P(ki) to be found if they
are visible, perspective distortion and image noise notwithstanding.
Let T be the geometric transformation used to synthesize a new view as described in Section IV-A, and ek an interest point extracted from this view using the procedure of Section IV-B.
T is either an afﬁne transformation or a projection and by applying T −1 to ek, we can recover
a corresponding keypoint k in the reference system. Thus, given several synthetic views, P(k)
can be estimated by simply counting how often it is found. The set K is then constructed by
only retaining keypoints with a high P(k). In our experiments, we retain the 200 keypoints with
highest P(k). Figure 4 shows the keypoints selected on the book cover and the stuffed tiger. For
each keypoint ki ∈K, we build the corresponding view set by collecting the p neighborhood
17th August 2006
Robustness to scale and perspective changes. First row: The image on the left shows a keypoint selected on the original
image, the three images on the right show the same keypoint retrieved at different scales under perspective distortion, and some
saturation and blur effects. Second row: Same for another keypoint.
of the corresponding ek in the generated images, as shown in Figure 4.
The above procedure accounts for sensitivity of the detector to perspective distortions. However, this may not be sufﬁcient because, when a keypoint is detected in two different images,
its precise location may shift a bit due to image noise and viewpoint change. In practice, such a
positional shift results in large errors of direct cross-correlation measures. One solution would be
to iteratively reﬁne the keypoint localization , which could be costly. Instead, we solve this
problem by adding white noise to the synthetic views before keypoint extraction. The resulting
view sets thus capture the positional shift, and force the classiﬁer to learn invariance to this shift.
Each view is rendered against a different, complex random background. The classiﬁer is
therefore trained to recognize the keypoints on cluttered background, including points that are
close to the object visual boundary. This contrasts with other patch-based methods that fail to
match a keypoint when the corresponding patch overlaps the background.
V. KEYPOINT CLASSIFICATION AND RECOGNITION
Several classiﬁcation algorithms, such as K-Nearest Neighbor, Support Vector Machines or
neural networks could have been chosen to implement the classiﬁer Y introduced in Section III.
Among those, we have found randomized trees to be eminently suitable because they naturally
17th August 2006
I( ) > I( )
I( ) < I( )
Generic tree used for keypoint recognition. When using C2 tests, the nodes contain tests comparing two pixels in the
keypoint neighborhood; the leaves contain the Pη(l,p)(Y (p) = c) posterior probabilities.
handle multi-class problems and are robust and fast, while remaining reasonably easy to train.
They are simple but powerful tools for classiﬁcation, introduced and applied to recognition of
handwritten digits in . They are closely related to the regression trees in the CART method .
Several trees are grown with some form of randomization as in for example, but the queries
can be more complex than those of regression trees. In this section we ﬁrst describe them brieﬂy
in the context of our problem for the beneﬁt of the unfamiliar reader. We then study their
properties and justify our implementation choices.
A. Randomized Trees
Figure 6 depicts a generic tree. Each internal node contains a simple test that splits the space
of data to be classiﬁed, in our case the space of image patches. Each leaf contains an estimate
based on training data of the posterior distribution over the classes. A new patch is classiﬁed
by dropping it down the tree and performing an elementary test at each node that sends it to
one side or the other. When it reaches a leaf, it is assigned probabilities of belonging to a
class depending on the distribution stored in the leaf. Since the numbers of classes, training
17th August 2006
What makes the Randomized Trees tick. (a) and (b) are two partitions, which result in a ﬁner one (c) when they are
superimposed. In a similar manner, each tree performs a different partition of the patch space, and combining their responses
results in a ﬁner partition.
examples and possible tests are large in our case, building the optimal tree quickly becomes
intractable. Instead, multiple trees are grown so that each tree yields a different partition of the
space of image patches. We discuss two different ways to build the trees in Section V-C. Once
the trees T1, . . . , TL are built, their responses are combined during classiﬁcation to achieve a
better recognition rate that a single tree could. More formally, the tree leaves store posterior
probabilities Pη(l,p)(Y (p) = c), where c is a label in C and η(l, p) is the leaf of tree Tl reached
by the patch p. Such probabilities are evaluted during training as the ratio of the number of
patches of class c in the training set that reach η and the total number of patches that reach η.
Following , p is classiﬁed by considering the average of the probabilities Pη(l,p)(Y (p) = c):
ˆY (p) = argmax
pc(p) = argmax
Pη(l,p)(Y (p) = c)
Figure 7 gives an intuitive idea of what makes this approach a good one. Each tree performs
a different partition depending on the speciﬁc tests it contains. Combining the output of all the
trees results in a ﬁner partition that yields a better classiﬁcation. As the depth and number of
trees are increased, this partition becomes ﬁner and ﬁner, and the estimated distribution becomes
closer and closer to the actual one, at the cost of increasing both computational expense and
memory requirements. This trade-off will be studied in Section V-C.
pc(p) is the average of the posterior probabilities of class c and constitutes a good measure
of the match conﬁdence. We estimate during training a threshold Tc to decide if the match is
17th August 2006
correct or not with a given conﬁdence s that is
P(Y (p) = c| ˆY (p) = c, pc(p) > Tc) > s .
In practice, we take s between 60% and 90%. Keypoints for which pc(p) is lower than Tc are
considered as keypoints detected on the background, or misclassiﬁed keypoints, and are therefore
rejected. This leaves only a small number of erroneous matches that RANSAC can easily handle.
The drawback of Randomized Trees is their greedy use of memory. Their size in memory
increases exponentially with the depth, and linearly with the number of trees. For example, a
single tree of depth 15 uses about 32 Mo for a 200 classes problem. Therefore, the chosen
number of trees and their depth are a trade-off between the computer memory dedicated to store
them and the recognition rate. In the following, we study the inﬂuence of these parameters on
the recognition rate.
B. Node Tests
In our implementation, the tests performed at the nodes are simple binary tests based on the
difference of intensities of two pixels m1 and m2 taken in the neighborhood of the keypoint.
We write these tests as
C2(m1, m2) =
If Iσ(p, m1) ≤Iσ(p, m2)
go to left child
go to right child
where Iσ(p, m) is the intensity of patch p at pixel location m, after Gaussian smoothing to
reduce inﬂuence of noise. Such a test can be seen as a test on the polarity between the two
locations m1 and m2. In all our experiments, the patches are of size 32 × 32, so that the total
number of possible C2 tests is 219. Fortunately, since real-world images exhibit spatial coherence,
only a very small subset is required to yield good recognition rates.
As shown below, a few hundreds of these simple tests are usually enough to classify a patch.
This involves only a few hundreds intensity comparisons and additions per patch, and is therefore
very fast. Furthermore, because they only depend on the order of the pixel intensities between
neighbors, they tend to be fairly insensitive to illumination changes other than those caused by a
moving shadow. In other words, to achieve the robustness to illumination effects demonstrated in
Figure 1, our technique, unlike many others, does not require us to normalize the pixel intensities,
for example by setting the L2 norm of the intensities to one.
17th August 2006
Note, however, that one advantage of randomized trees is that they impose no restriction on
the kind of tests performed at the nodes. A tree can even contain different kinds of tests. An
inﬁnite number of tests other than introduced above could have been designed, most of which
would be computationally more demanding. To show that the ones we chose represent a good
compromise between recognition ability and run-time speed, we will compare in Section V-D
their performance with those of more complex tests, including tests based on histograms of local
orientations and inspired by the SIFT detector .
C. Growing the Trees
To improve the recognition rate, we use multiple trees that should partition the patches space
in different manners, as depicted by Figure 7. We experimented with two different methods for
building such trees.
The ﬁrst method is the one used in : The trees are constructed in the classical, top-down
manner, where the tests are chosen by a greedy algorithm to best separate the given examples.
The expected gain in information is used to evaluate the separation efﬁciency. The gain caused
by partitioning a set S of examples in several subsets Si according to a given test is measured
|S| E(Si) ,
where E(s) is the Shannon’s entropy −PN
j=1 pj log2(pj) with pj the proportion examples in s
belonging to class j, and |.| denotes the size of the set. The process of selecting a test is repeated
for each non-terminal node, using only the training examples falling in that node. The recursion
is stopped when the node receives too few examples, or when it reaches a given depth. In our
implementation, the depth varies between 10 and 15, and the minimum of examples is ﬁxed to
The second method is much faster and simpler: Instead of picking questions according to a
criterion, we simply pick a random set. This can be seen as an extreme simpliﬁcation of the ﬁrst
method. For example, in the case of the C2 test, the two locations m1 and m2 for each node
are picked at random within the patch, independently of the training samples that fall into the
node and of the tests performed further up in the tree.
17th August 2006
To compare the two tree-building methods we have introduced, we used them both on the set
of 200 keypoints depicted by Figure 4. This resulted in two sets of trees whose nodes contained
C2 binary tests and whose depth was limited to the same value.
When using the simpler approach, we grew the trees by randomly picking locations for each
node, as discussed above. When using the entropy minimizing approach, we ﬁrst synthesized
100 new views. We then recursively built the trees by trying n different tests at each node and
keeping the best one according to the criterion of Equation (2). For the root node, we chose
n = 10, a very small number, to reduce the correlation between the resulting trees. For all other
nodes, we used n = 100d, where d is the depth of the node. Note that this heuristic involves
randomizing on both tests and training data. As noted in , the randomizing on tests is far more
powerful than randomizing on data. We do the latter, not to improve classiﬁcation performance,
but to make our greedy algorithm tractable. Since intra-class variations are large, without it, too
many examples would be needed to sample a class in a representative way.
In the case of the completely random approach to building trees, m1 and m2 were simply
chosen at random. For the two sets, the tree depth is limited to a given maximal depth, and the
posterior probabilities are estimated from 1000 new random views per keypoint.
We present here results for trees with a depth limited to 12, which was found to be a good
trade-off between the memory requirements and recognition rate. After having grown the trees,
the posterior probabilities in the terminal nodes were estimated using 5000 new training images.
We then measured the recognition rate R of the two sets of trees by generating new images
under random poses, as the ratio of the number of correctly recognized patches and the total
number of generated patches. The evolution of R for the two sets of trees with respect to the
number of trees is depicted Figure 8(a). Taking the tests at random usually results in a small
loss of reliability at least when the number of trees is not large enough but considerably reduces
the learning time. The time dedicated to growing the trees drops from tens of minutes to a few
seconds on a 2.8 GHz machine.
We also experimented with normalizing the p patches of Section III both during training and at
run-time to achieve higher recognition rates for a given number of trees. As in we attribute
a 2–D orientation to the keypoints that is estimated from the histogram of gradient directions in
a patch centered at the keypoint. Note that by contrast with , we do not require a particularly
repeatable method. We just want it to be reliable enough to reduce variation within classes. Once
17th August 2006
Recognition rate (in percent)
Tree Number
entropy optimization
random tests
Recognition rate (in percent)
Tree Number
entropy optimization
random tests
Comparing the classiﬁcation rates obtained using trees grown in two different manners, as a function of the number
of trees. (a) Without and (b) with patch orientation normalization. The thick lines depict results obtained by selecting tests that
maximize the information gain. The thin lines depict results obtained by randomly chosen tests, which result in a small loss of
reliability but considerably reduces the training time. Note that in all cases the normalization lets us achieve better results with
fewer trees. However when enough trees are used, it does not improve the rates anymore.
the orientation of an extracted keypoint is estimated, its neighborhood is rectiﬁed. Figure 8(b)
compares the recognition rates with this normalization step for the two different methods of
selecting the tests. Taking the tests at random results in a slightly larger but still small loss of
reliability. More importantly, the normalization gives us signiﬁcantly improved rates when using
only a small number of trees. However, when using a large number of trees, the recognition
rates are similar with and without the normalization.
We draw two practical conclusions from these experiments. First, using random tests is sufﬁcient and keeps the learning time reasonable for practical applications. Second, the orientation
normalization step is not required, but lets us reduce the number of trees. Therefore the choice
of using such a normalization becomes a trade-off between the amount of time required to
normalize and to classify, which is proportional to the number of trees. The amount of memory
used by the trees should also be taken into account. In practice, we have found it more effective
to normalize and use fewer trees, in part because the normalization we use is much simpler than
a full afﬁne rectiﬁcation. Therefore, in the remainder of the paper, we normalize the patches and
use randomly chosen tests.
17th August 2006
D. Comparing Different Node Tests on Different Image Types
The above results were obtained using binary tests involving the comparison of gray levels of
two neighboring pixels. Here we discuss the value of replacing these tests by more sophisticated
ones involving additional pixels. In addition to the family of C2 binary tests, we also consider
tests involving more pixels locations. We deﬁne the C4 family made of tests that compare the
differences of intensities of two pairs of pixel locations:
C4(m1, m2, m3, m4) =
If Iσ(p, m1) −Iσ(p, m2)
≤Iσ(p, m3) −Iσ(p, m4)
go to left child;
go to right child.
These tests compare both the strength and polarity of the edge between m1 and m2, and those
of the edge between m3 and m4.
We also deﬁne the Ch family made of more sophisticated tests based on local orientation
histograms computed as follows. Like for the SIFT characterization, each patch is divided into
4×4 subregions, and an array of histograms with 8 orientation bins is computed for each region.
The tests in the Ch family compare the values of two bins:
Ch(u1, v1, o1, u2, v2, o2) =
If Bin(u1, v1, o1) ≤Bin(u2, v2, o2)
go to left child;
go to right child.
The responses of the C2, C4 and Ch families of tests were compared using two kinds of feature
points. In one case, we used a set we denote as “Title”. It includes 100 keypoints detected on
the title of the book cover of Figure 1, which represents strong and structured edges. The second
set of keypoints denoted “Eyes” is made of 100 keypoints detected on the picture of the same
book cover, which presents mostly textured areas. For both sets, we grew several sets of trees
by varying the tests and tree depths. We tested them for depths ranging from 10 to 15, as larger
values quickly become intractable due to the increasing memory requirements. Figures 9 and 10
summarize the results as a function of the number of trees and of their depth.
Somewhat surprisingly, the C4 tests results are slightly worse than the C2 ones. The Ch
tests slightly outperform the C2 tests on the Title set, which is not very textured, and yield
approximately the same recognition rate on the more textured Eyes set.
However, and this is remarkable, the differences are not really signiﬁcant. To illustrate that,
in Figure 11, we superpose the results using the three kinds of tests and the same tree depth
equal to 15. This is a very interesting property of the classiﬁcation approach: Complex tests are
17th August 2006
Recognition rate (in percent)
Tree Number
Recognition rate (in percent)
Tree Number
Recognition rate (in percent)
Tree Number
Recognition rate (in percent)
Tree Number
Recognition rate (in percent)
Tree Number
Recognition rate (in percent)
Tree Number
Comparison of recognition rates as a function of the number of trees, for different tree depths and different tests,
applied to the “Title” (left) and the “Eyes” (right) keypoints sets. First row: using the C2 family tests; Second row: using the
C4 family tests; Third row: using the Ch family tests.
not necessary, simple ones sufﬁce to reach similar performances. This can be explained by the
fact that the partition obtained when combining the trees becomes sufﬁciently ﬁne when enough
trees are used, provided that each individual tree partitions the patch space in a different way.
Since the Ch tests are computationally much more costly, in practice we use the C2 tests as
the slight loss in performance does not appear to have any ill-effect on our RANSAC-based
17th August 2006
Classiﬁcation rates using either the C2, C4 and Ch test families using 50 trees. Tests from the Ch family slightly
outperform the ones from C2, at an additional computation cost.
Recognition rate (in percent)
Tree Number
Recognition rate (in percent)
Tree Number
Classiﬁcation rates for C2, C4 and Ch tests families as a function of the number of trees. (a) “Title” set, (b) “Eyes”
set. The depth of the trees is 15.
approach to pose estimation.
VI. RESULTS
For planar objects such as the books of Figures 1 and 13 and the mouse pad of Figure 12,
we ﬁrst use RANSAC to estimate an afﬁne transformation between the reference image and the
input image. It is then reﬁned by robust least-squares estimation. As can be seen in the ﬁgures
and the video sequences submitted as supplementary material, the pose estimation is robust to
illuminations changes, scale changes, occlusions, and some image blur. As shown in Figure 14,
we also applied our method for the detection of a sail over a 4000 thousand frame video taken
with a home camcorder during a regatta. Despite the bad condition—the sail is not very textured,
17th August 2006
Detection of a mouse pad at different scales on a cluttered background.
Another example on which our system has been tested.
it moves in and out of the ﬁeld of view, the camera motion is very jerky and the illumination
changes all the time—the sail is detected in all frames where a sufﬁcient portion of the sail is
Our implementation has been tested on numerous objects under different lighting conditions
using a simple webcam, and an executable can be downloaded from our website. It runs at 25
frames per second on a 2.8 GHz PC.
Detecting a sail. Four frames from a 4000 frame video acquired using a home camcorder during a regatta. Even
though the camera jerks, the zoom changes and the lighting conditions are poor, the sail is detected in all frames, such as those
shown above, where a sufﬁcient portion of the sail is seen.
17th August 2006
Detection of the book: The white lines represent the inlier matches established in real-time under several poses. The
corresponding video sequence is submitted as supplementary material.
Figures 2 and 18 show detection results for the stuffed tiger for which a quickly built 3–D
model. We use a P3P algorithm and RANSAC to robustly estimate its pose. The object object is
successfully detected from different sides, different distances and both from below and above.
We compared our results with those obtained using the executable that implements the SIFT
method kindly provided by David Lowe. As shown in Figures 16 and 17, when there is little
distortion, the SIFT approach yields a few more matches. However, when too much perspective
distorts the object image, it produces far fewer, while our approach is not perturbed.
To be fair, we note again that this robustness comes at the cost of a training stage that
SIFT does not require. If training is possible, as suggested in and demonstrated in ,
SIFT can be made more robust to distortions by using multiple views of the target object,
storing all the SIFT features from these views, and matching against all of them. This does not
17th August 2006
Comparison with SIFT (left image) and our approach (right image). When there is little distortion, the SIFT approach
gives a few more matches, but when too much perspective distorts the object image, it gives only few matches, while our
approach is not perturbed.
signiﬁcantly increase the matching time when approximate nearest-neighbor k-D tree search is
used. It remains, however, less computationally effective than ours, which depends only on a
limited number of pixel intensity comparisons.
As shown Figures 19 and 20, our method can also be used to detect deformable objects and
estimate their deformation at 10 frames per second on a 2.8 GHz PC. As described in ,
objects are modeled by deformable meshes. The keypoints positions are expressed as weighted
sums of the mesh vertices in the model image and change as the mesh is deformed. Fitting then
amounts to minimizing a criterion that is the sum of two terms. The ﬁrst is a robust estimate
of the square distances of the keypoints in the model image to that of the corresponding ones
in the input image. The second is a quadratic deformation energy . This quadratic term
17th August 2006
Comparison with SIFT (left image) and our approach (right image) on the mouse pad sequence.
allows the use of a semi-implicit minimization scheme that converges even when the initial
estimate is very far from the solution, which, in our context, is what happens when the object
is severely deformed. When combined with an appropriately deﬁned robust estimator for the
keypoint distances and optimization schedule, this approach to minimization allows real-time
detection in under 100 milliseconds while being robust to large deformations, severe occlusions,
and changes in lighting.
17th August 2006
Our method can take advantage of a 3–D model when available, to detect the target and estimate its pose from different
viewpoints.
Detecting a deforming sheet of paper at 10Hz on a 2.8 GHz PC. (a) The left image is the input image in which the
sheet of paper is detected and its deformation estimated. The right one is the training image. The lines represent the matches
recovered using our method. Black ones correspond to those estimated to be outliers and the white ones to inliers. (b) Same
thing for a different input image.
VII. CONCLUSION AND PERSPECTIVES
We have developed an approach to 3–D object-detection and pose estimation that relies on
statistical learning techniques to perform much of the required computation during a training
17th August 2006
Detecting a deforming T-Shirt. (a) Model image used for training purposes. (b) To illustrate the mapping our algorithm
computes, we ﬁnd the contours of the model using a simple gradient operator and we use them as a validation texture (c) which
is overlaid on the input image using the recovered transformation (d). Additional results are obtained in different conditions (e
to j). Note that in all cases, including the one where the T-shirt is replaced by a cup (j), the white outlines project almost exactly
at the right place, thus indicating a correct registration and shape estimation.
phase so that, at run-time, we can achieve both speed and reliability. Like many others, our
approach relies on matching keypoints extracted from one or more training images of the target
object against those extracted from input images. What is new is to have reformulated the widebaseline matching problem, which this involves, as a classiﬁcation problem that can be effectively
solved using randomized trees that are both fast and easily implemented.
We have shown that very good results can be obtained using a very simple approach to building
the trees. More sophisticated building methods yield slight performance increases, but at the cost
of much larger requirements both in terms of computation and memory. In practice, given the
fact that we use robust techniques to estimate 3–D poses from the matches, we have not found
it worthwhile to impose that extra burden as the simpler techniques are sufﬁcient to achieve
robust frame-rate detection and pose estimation. However, we could easily replace individual
components of our approach, such as the keypoint detector, by improved or more generic ones
as they become available without changing its overall philosophy.
Our approach is well adapted to cases where one or more images of the target object are
available for off-line training purposes. If the object is either planar or nearly so, the images
17th August 2006
can be directly used without any preprocessing. If the object is fully 3–D, the images can be
used to build the rough 3–D model required to train the system. Our next step is to speed up
the training procedure itself so that it can also become an in-line process, thereby removing
the major limitation of our approach when compared to state-of-the-art ones that do not require
any a priori training. One obvious way to achieve this is to ﬁrst track the target object under
favorable conditions using standard techniques, which will allow us to follow keypoints across
frames and to incrementally build the view-sets and the corresponding trees. This will constitute
a starting point for our future investigations.
ACKNOWLEDGEMENTS
The authors would like to thank François Fleuret for suggesting the use of randomized trees
and for his insightful comments, and Tom Drummond for discussions on keypoint detection.