Taskonomy: Disentangling Task Transfer Learning
Amir R. Zamir1,2
Alexander Sax1∗William Shen1∗Leonidas Guibas1 Jitendra Malik2 Silvio Savarese1
1 Stanford University
2 University of California, Berkeley
 
Do visual tasks have a relationship, or are they unrelated?
For instance, could having surface normals simplify estimating the depth of an image? Intuition answers
these questions positively, implying existence of a structure
among visual tasks. Knowing this structure has notable values; it is the concept underlying transfer learning and provides a principled way for identifying redundancies across
tasks, e.g., to seamlessly reuse supervision among related
tasks or solve many tasks in one system without piling up
the complexity.
We proposes a fully computational approach for modeling the structure of space of visual tasks. This is done via
ﬁnding (ﬁrst and higher-order) transfer learning dependencies across a dictionary of twenty six 2D, 2.5D, 3D, and
semantic tasks in a latent space. The product is a computational taxonomic map for task transfer learning. We study
the consequences of this structure, e.g. nontrivial emerged
relationships, and exploit them to reduce the demand for labeled data. For example, we show that the total number of
labeled datapoints needed for solving a set of 10 tasks can
be reduced by roughly 2
3 (compared to training independently) while keeping the performance nearly the same. We
provide a set of tools for computing and probing this taxonomical structure including a solver that users can employ
to devise efﬁcient supervision policies for their use cases.
1. Introduction
Object recognition, depth estimation, edge detection,
pose estimation, etc are examples of common vision tasks
deemed useful and tackled by the research community.
Some of them have rather clear relationships: we understand that surface normals and depth are related (one is a
derivate of the other), or vanishing points in a room are useful for orientation. Other relationships are less clear: how
keypoint detection and the shading in a room can, together,
perform pose estimation.
Autoencoding
Object Class.
(1000 class)
Z-Depth Distance
2D Keypoints
2.5D Segm.
(non-fixated)
Vanishing Pts
Figure 1: A sample task structure discovered by the computational
task taxonomy (taskonomy). It found that, for instance, by combining the
learned features of a surface normal estimator and occlusion edge detector,
good networks for reshading and point matching can be rapidly trained
with little labeled data.
The ﬁeld of computer vision has indeed gone far without
explicitly using these relationships. We have made remarkable progress by developing advanced learning machinery
(e.g. ConvNets) capable of ﬁnding complex mappings from
X to Y when many pairs of (x, y) s.t. x ∈X, y ∈Y are
given as training data. This is usually referred to as fully supervised learning and often leads to problems being solved
in isolation. Siloing tasks makes training a new task or a
comprehensive perception system a Sisyphean challenge,
whereby each task needs to be learned individually from
scratch. Doing so ignores their quantiﬁably useful relationships leading to a massive labeled data requirement.
Alternatively, a model aware of the relationships among
tasks demands less supervision, uses less computation, and
behaves in more predictable ways.
Incorporating such
a structure is the ﬁrst stepping stone towards develop-
 
ing provably efﬁcient comprehensive/universal perception
models , i.e. ones that can solve a large set of tasks
before becoming intractable in supervision or computation
demands. However, this task space structure and its effects
are still largely unknown. The relationships are non-trivial,
and ﬁnding them is complicated by the fact that we have
imperfect learning models and optimizers. In this paper,
we attempt to shed light on this underlying structure and
present a framework for mapping the space of visual tasks.
Here what we mean by “structure” is a collection of computationally found relations specifying which tasks supply
useful information to another, and by how much (see Fig. 1).
We employ a fully computational approach for this purpose, with neural networks as the adopted computational
function class. In a feedforward network, each layer successively forms more abstract representations of the input containing the information needed for mapping the input to the
output. These representations, however, can transmit statistics useful for solving other outputs (tasks), presumably if
the tasks are related in some form . This is
the basis of our approach: we computes an afﬁnity matrix
among tasks based on whether the solution for one task can
be sufﬁciently easily read out of the representation trained
for another task. Such transfers are exhaustively sampled,
and a Binary Integer Programming formulation extracts a
globally efﬁcient transfer policy from them. We show this
model leads to solving tasks with far less data than learning them independently and the resulting structure holds on
common datasets (ImageNet and Places ).
Being fully computational and representation-based, the
proposed approach avoids imposing prior (possibly incorrect) assumptions on the task space. This is crucial because
the priors about task relations are often derived from either
human intuition or analytical knowledge, while neural networks need not operate on the same principles . For instance, although we might expect depth
to transfer to surface normals better (derivatives are easy),
the opposite is found to be the better direction in a computational framework (i.e. suited neural networks better).
An interactive taxonomy solver which uses our model
to suggest data-efﬁcient curricula, a live demo, dataset, and
code are available at 
2. Related Work
Assertions of existence of a structure among tasks date
back to the early years of modern computer science, e.g.
with Turing arguing for using learning elements 
rather than the ﬁnal outcome or Jean Piaget’s works on
developmental stages using previously learned stages as
sources , and have extended to recent works . Here we make an attempt to actually ﬁnd this structure. We acknowledge that this is related
to a breadth of topics, e.g. compositional modeling , homomorphic cryptography , lifelong learning , functional maps , certain
aspects of Bayesian inference and Dirichlet processes , few-shot learning ,
transfer learning , un/semi/selfsupervised learning , which are studied across various ﬁelds . We review the topics
most pertinent to vision within the constraints of space:
Self-supervised learning methods leverage the inherent
relationships between tasks to learn a desired expensive one
(e.g. object detection) via a cheap surrogate (e.g. colorization) . Speciﬁcally, they use a
manually-entered local part of the structure in the task space
(as the surrogate task is manually deﬁned). In contrast, our
approach models this large space of tasks in a computational
manner and can discover obscure relationships.
Unsupervised learning is concerned with the redundancies in the input domain and leveraging them for forming
compact representations, which are usually agnostic to the
downstream task . Our approach is not
unsupervised by deﬁnition as it is not agnostic to the tasks.
Instead, it models the space tasks belong to and in a way
utilizes the functional redundancies among tasks.
Meta-learning generally seeks performing the learning
at a level higher than where conventional learning occurs,
e.g. as employed in reinforcement learning ,
optimization , or certain architectural mechanisms . The motivation behind meta learning has similarities to ours and our outcome can be seen as
a computational meta-structure of the space of tasks.
Multi-task learning targets developing systems that can
provide multiple outputs for an input in one run .
Multi-task learning has experienced recent progress and the
reported advantages are another support for existence of a
useful structure among tasks . Unlike multi-task learning, we explicitly model
the relations among tasks and extract a meta-structure. The
large number of tasks we consider also makes developing
one multi-task network for all infeasible.
Domain adaption seeks to render a function that is developed on a certain domain applicable to another . It often addresses a shift in the input domain, e.g. webcam images to D-SLR , while the task
is kept the same. In contrast, our framework is concerned
with output (task) space, hence can be viewed as task/output
adaptation. We also perform the adaptation in a larger space
among many elements, rather than two or a few.
In the context of our approach to modeling transfer learning across tasks:
Learning Theoretic approaches may overlap with any
of the above topics and usually focus on providing generalization guarantees. They vary in their approach: e.g. by
modeling transferability with the transfer family required
Task-speciﬁc
3D Keypoints
3D Keypoints
(I) Task-specific Modeling
(II) Transfer Modeling
(III) Task Affinity
Normalization
(IV) Compute Taxonomy
Output space
Task Space
(representation)
Input space
Object Class. (100)
Object Class. (1000)
Scene Class.
) Semantic Segm.
3D Keypoints
Autoencoding
2D Segm.2D Edges
2D Keypoints
In-painting
Colorization
2.5D Segm.
Occlusion Edges
se Vanishing Pts.
Random Proj.
Binary Integer
AHP task affinities
Figure 2: Computational modeling of task relations and creating the taxonomy. From left to right: I. Train task-speciﬁc networks. II. Train (ﬁrst
order and higher) transfer functions among tasks in a latent space. III. Get normalized transfer afﬁnities using AHP (Analytic Hierarchy Process). IV. Find
global transfer taxonomy using BIP (Binary Integer Program).
to map a hypothesis for one task onto a hypothesis for another , through information-based approaches , or
through modeling inductive bias . For these guarantees,
learning theoretic approaches usually rely on intractable
computations, or avoid such computations by restricting the
model or task. Our method draws inspiration from theoretical approaches but eschews (for now) theoretical guarantees
in order to use modern neural machinery.
We deﬁne the problem as follows: we want to maximize the collective performance on a set of tasks T
{t1, ..., tn}, subject to the constraint that we have a limited
supervision budget γ (due to ﬁnancial, computational, or
time constraints). We deﬁne our supervision budget γ to be
the maximum allowable number of tasks that we are willing
to train from scratch (i.e. source tasks). The task dictionary
is deﬁned as V=T ∪S where T is the set of tasks which we
want solved (target), and S is the set of tasks that can be
trained (source). Therefore, T −T ∩S are the tasks that
we want solved but cannot train (“target-only”), T ∩S are
the tasks that we want solved but could play as source too,
and S −T ∩S are the “source-only” tasks which we may
not directly care about to solve (e.g. jigsaw puzzle) but can
be optionally used if they increase the performance on T .
The task taxonomy (taskonomy) is a computationally
found directed hypergraph that captures the notion of task
transferability over any given task dictionary. An edge between a group of source tasks and a target task represents a
feasible transfer case and its weight is the prediction of its
performance. We use these edges to estimate the globally
optimal transfer policy to solve T . Taxonomy produces a
family of such graphs, parameterized by the available supervision budget, chosen tasks, transfer orders, and transfer
functions’ expressiveness.
Taxonomy is built using a four step process depicted in
Fig. 2. In stage I, a task-speciﬁc network for each task in S
Query Image
Autoencoding
In-painting
Object Class.
Scene Class.
Jigsaw puzzle
Colorization
2.5D Segm.
Semantic Segm.
Vanishing Points
2D Keypoints
3D Keypoints
3D Curvature
Image Reshading
Cam. Pose (non-fixated)
Cam. Pose (fixated)
Triplet Cam. Pose
Room Layout
Point Matching
Top 5 prediction:
sliding door
home theater, home theatre
studio couch, day bed
china cabinet, china closet
entertainment center
Eucl. Distance
Surface Normals
Top 2 prediction:
living room
television room
Figure 3: Task Dictionary. Outputs of 24 (of 26) task-speciﬁc networks
for a query (top left). See results of applying frame-wise on a video here.
is trained. In stage II, all feasible transfers between sources
and targets are trained. We include higher-order transfers
which use multiple inputs task to transfer to one target. In
stage III, the task afﬁnities acquired from transfer function
performances are normalized, and in stage IV, we synthesize a hypergraph which can predict the performance of any
transfer policy and optimize for the optimal one.
A vision task is an abstraction read from a raw image.
We denote a task t more formally as a function ft which
maps image I to ft(I). Our dataset, D, contains for each
task t a set of training pairs (I, ft(I)), e.g. (image, depth).
Source Task Encoder
Target Task Output
(e.g., curvature)
Representation
Transfer Function
(e.g., surface normal)
Figure 4: Transfer Function. A small readout function is trained to map
representations of source task’s frozen encoder to target task’s labels. If
order> 1, transfer function receives representations from multiple sources.
Task Dictionary: Our mapping of task space is done
via (26) tasks included in the dictionary, so we ensure they
cover common themes in computer vision (2D, 3D, semantics, etc) to the elucidate ﬁne-grained structures of task
space. See Fig. 3 for some of the tasks with detailed definition of each task provided in the supplementary material.
We include tasks with various levels of abstraction, ranging
from solvable by a simple kernel convolved over the image
(e.g. edge detection) to tasks requiring basic understanding
of scene geometry (e.g. vanishing points) and more abstract
ones involving semantics (e.g. scene classiﬁcation).
It is critical to note the task dictionary is meant to be a
sampled set, not an exhaustive list, from a denser space of
all conceivable visual tasks. Sampling gives us a tractable
way to sparsely model a dense space, and the hypothesis is
that (subject to a proper sampling) the derived model should
generalize to out-of-dictionary tasks. The more regular /
better sampled the space, the better the generalization. We
evaluate this in Sec. 4.2 with supportive results. For evaluation of the robustness of results w.r.t the choice of dictionary, see the supplementary material.
Dataset: We need a dataset that has annotations for every task on every image. Training all of our tasks on exactly
the same pixels eliminates the possibility that the observed
transferabilities are affected by different input data peculiarities rather than only task intrinsics. There has not been
such a dataset of scale made of real images, so we created
a dataset of 4 million images of indoor scenes from about
600 buildings; every image has an annotation for every task.
The images are registered on and aligned with buildingwide meshes similar to enabling us to programmatically compute the ground truth for many tasks without
human labeling. For the tasks that still require labels (e.g.
scene classes), we generate them using Knowledge Distillation from known methods . See the
supplementary material for full details of the process and
a user study on the ﬁnal quality of labels generated using
Knowledge Distillation (showing < 7% error).
3.1. Step I: Task-Speciﬁc Modeling
We train a fully supervised task-speciﬁc network for
each task in S. Task-speciﬁc networks have an encoderdecoder architecture homogeneous across all tasks, where
Transfers Results (2k training images)
Segmentation
Surface Normal
Estimation
Figure 5: Transfer results to normals (upper) and 2.5D Segmentation
(lower) from 5 different source tasks. The spread in transferability among
different sources is apparent, with reshading among top-performing ones in
this case. Task-speciﬁc networks were trained on 60x more data. “Scratch”
was trained from scratch without transfer learning.
the encoder is large enough to extract powerful representations, and the decoder is large enough to achieve a good
performance but is much smaller than the encoder.
3.2. Step II: Transfer Modeling
Given a source task s and a target task t, where s ∈S
and t ∈T , a transfer network learns a small readout function for t given a statistic computed for s (see Fig 4). The
statistic is the representation for image I from the encoder
of s: Es(I). The readout function (Ds→t) is parameterized
by θs→t minimizing the loss Lt:
Ds→t := arg min
where ft(I) is ground truth of t for image I. Es(I) may or
may not be sufﬁcient for solving t depending on the relation
between t and s (examples in Fig. 5). Thus, the performance
of Ds→t is a useful metric as task afﬁnity. We train transfer
functions for all feasible source-target combinations.
Accessibility: For a transfer to be successful, the latent
representation of the source should both be inclusive of suf-
ﬁcient information for solving the target and have the information accessible, i.e. easily extractable (otherwise, the
raw image or its compression based representations would
be optimal). Thus, it is crucial for us to adopt a low-capacity
(small) architecture as transfer function trained with a small
amount of data, in order to measure transferability conditioned on being highly accessible. We use a shallow fully
convolutional network and train it with little data (8x to
120x less than task-speciﬁc networks).
Higher-Order Transfers: Multiple source tasks can
contain complementary information for solving a target task
(see examples in Fig 6). We include higher-order transfers
which are the same as ﬁrst order but receive multiple representations in the input. Thus, our transfers are functions
D : ℘(S) →T , where ℘is the powerset operator.
As there is a combinatorial explosion in the number of
feasible higher-order transfers (|T | ×
for kth order),
we employ a sampling procedure with the goal of ﬁltering
out higher-order transfers that are less likely to yield good
results, without training them. We use a beam search: for
GT (Normals)
Fully Supervised
GT (Reshade)
Fully Supervised
{ 3D Keypoints
Surface Normals } 2
order transfer
{ Occlusion Edges
order transfer
Figure 6: Higher-Order Transfers. Representations can contain complementary information.
by transferring simultaneously from 3D
Edges and Curvature individual stairs were brought out. See our publicly
available interactive transfer visualization page for more examples.
transfers of order k ≤5 to a target, we select its 5 best
sources (according to 1st order performances) and include
all of their order-k combination. For k ≥5, we use a beam
of size 1 and compute the transfer from the top k sources.
Transitive Transfers: We examined if transitive task
transfers (s →t1 →t2) could improve the performance
over their direct counterpart (a →t2), but found that the
two had equal performance in almost all cases in both highdata and low-data scenarios. The experiment is provided in
the supplementary material. Therefore, we need not consider the cases where branching would be more than one
level deep when searching for the optimal transfer path.
3.3. Step III: Ordinal Normalization using Analytic
Hierarchy Process (AHP)
We want to have an afﬁnity matrix of transferabilities
across tasks. Aggregating the raw losses/evaluations Ls→t
from transfer functions into a matrix is obviously problematic as they have vastly different scales and live in different
spaces (see Fig. 7-left). Hence, a proper normalization is
needed. A naive solution would be to linearly rescale each
row of the matrix to the range . This approach fails
when the actual output quality increases at different speeds
w.r.t. the loss. As the loss-quality curve is generally unknown, such approaches to normalization are ineffective.
Instead, we use an ordinal approach in which the output
quality and loss are only assumed to change monotonically.
For each t, we construct Wt a pairwise tournament matrix
between all feasible sources for transferring to t. The element at (i, j) is the percentage of images in a held-out test
set, Dtest, on which si transfered to t better than sj did (i.e.
Dsi→t(I) > Dsj→t(I)).
We clip this intermediate pairwise matrix Wt to be in
[0.001, 0.999] as a form of Laplace smoothing. Then we
divide W ′
t = Wt/W T
t so that the matrix shows how many
times better si is compared to sj. The ﬁnal tournament ratio
matrix is positive reciprocal with each element w′
i,j of W ′
i,j = EI∈Dtest[Dsi→t(I) > Dsj→t(I)]
EI∈Dtest[Dsi→t(I) < Dsj→t(I)].
We quantify the ﬁnal transferability of si to t as the cor-
Autoencoding
Scene Class
Occlusion Edges
2D Keypoint
3D Keypoint
Vanishing Pts.
2.5D Segm.
Cam. Pose (fix)
Cam. Pose (nonfix)
Semantic Segm.
In-Painting
Colorization
Random Proj.
Task-Specific
Object Class (100)
Autoencoding
Scene Class
Object Class (100)
Colorization
Occlusion Edges
Cam. Pose (fix)
In-Painting
2D Keypoint
3D Keypoint
Cam. Pose (nonfix)
Random Proj.
2.5D Segm.
Semantic Segm.
Task-Specific
Vanishing Pts.
Autoencoding
Object Class. (1000)
Scene Class
Occlusion Edges
Cam. Pose (fix)
2D Keypoint
2.5D Segm.
3D Keypoint
Cam. Pose (nonfix)
Semantic Segm.
Vanishing Pts.
Object Class. (1000)
Object Class. (1000)
Figure 7: First-order task afﬁnity matrix before (left) and after (right)
Analytic Hierarchy Process (AHP) normalization. Lower means better
transfered. For visualization, we use standard afﬁnity-distance method
dist = e−β·P (where β = 20 and e is element-wise matrix exponential).
See supplementary material for the full matrix with higher-order transfers.
responding (ith) component of the principal eigenvector of
t (normalized to sum to 1). The elements of the principal
eigenvector are a measure of centrality, and are proportional
to the amount of time that an inﬁnite-length random walk on
t will spend at any given source . We stack the principal eigenvectors of W ′
t for all t ∈T , to get an afﬁnity
matrix P (‘p’ for performance)—see Fig. 7, right.
This approach is derived from Analytic Hierarchy Process , a method widely used in operations research to
create a total order based on multiple pairwise comparisons.
3.4. Step IV: Computing the Global Taxonomy
Given the normalized task afﬁnity matrix, we need to
devise a global transfer policy which maximizes collective
performance across all tasks, while minimizing the used supervision. This problem can be formulated as subgraph selection where tasks are nodes and transfers are edges. The
optimal subgraph picks the ideal source nodes and the best
edges from these sources to targets while satisfying that
the number of source nodes does not exceed the supervision budget. We solve this subgraph selection problem using Boolean Integer Programming (BIP), described below,
which can be solved optimally and efﬁciently .
Our transfers (edges), E, are indexed by i with the form
1, . . . , si
mi}, ti) where {si
1, . . . , si
mi} ⊂S and ti ∈T .
We deﬁne operators returning target and sources of an edge:
1, . . . , si
7−−−−−→{si
1, . . . , si
1, . . . , si
Solving a task t by fully supervising it is denoted as
We also index the targets T with j so that in this section, i
is an edge and j is a target.
The parameters of the problem are: the supervision budget (γ) and a measure of performance on a target from each
of its transfers (pi), i.e. the afﬁnities from P. We can also
optionally include additional parameters of: rj specifying
the relative importance of each target task and ℓi specifying
the relative cost of acquiring labels for each task.
The BIP is parameterized by a vector x where each transfer and each task is represented by a binary variable; x indicates which nodes are picked to be source and which transfers are selected. The canonical form for a BIP is:
maximize cT x ,
subject to Ax ⪯b
and x ∈{0, 1}|E|+|V| .
Each element ci for a transfer is the product of the importance of its target task and its transfer performance:
ci := rtarget(i) · pi .
Hence, the collective performance on all targets is the summation of their individual AHP performance, pi, weighted
by the user speciﬁed importance, ri.
Now we add three types of constraints via matrix A to
enforce each feasible solution of the BIP instance corresponds to a valid subgraph for our transfer learning problem: Constraint I: if a transfer is included in the subgraph,
all of its source nodes/tasks must be included too, Constraint II: each target task has exactly one transfer in, Constraint III: supervision budget is not exceeded.
Constraint I: For each row ai in A we require ai ·x ≤bi,
|sources(i)|
if (k −|E|) ∈sources(i)
Constraint II: Via the row a|E|+j, we enforce that each
target has exactly one transfer:
a|E|+j,i := 2 · 1{target(i)=j},
b|E|+j := −1.
Constraint III: the solution is enforced to not exceed the
budget. Each transfer i is assigned a label cost ℓi, so
a|E|+|V|+1,i := ℓi,
b|E|+|V|+1 := γ.
The elements of A not deﬁned above are set to 0. The
problem is now a valid BIP and can be optimally solved in
a fraction of a second . The BIP solution ˆx corresponds
to the optimal subgraph, which is our taxonomy.
4. Experiments
With 26 tasks in the dictionary (4 source-only tasks), our
approach leads to training 26 fully supervised task-speciﬁc
networks, 22 × 25 transfer networks in 1st order, and 22 ×
for kth order, from which we sample according to the
procedure in Sec. 3. The total number of transfer functions
trained for the taxonomy was ∼3,000 which took 47,886
GPU hours on the cloud.
Out of 26 tasks, we usually use the following 4 as sourceonly tasks (described in Sec. 3) in the experiments: colorization, jigsaw puzzle, in-painting, random projection.
However, the method is applicable to an arbitrary partitioning of the dictionary into T and S. The interactive solver
avg rand Task
avg rand Task
Denoising 100 99.9
Scene Class. 97.0 93.4
2D Edges 100 99.9
Occ. Edges
Reshading 94.9 95.2
Pose (ﬁx) 76.3 79.5
Pose (nonﬁx) 60.2 61.9
Inpainting 99.9 -
2D Segm. 97.7 95.7
2.5D Segm.
Curvature 78.7 93.4
Matching 86.8 84.6
Vanishing 99.5 96.4
2D Keypnt.
3D Keypnt.
Table 1: Task-Speciﬁc Networks’ Sanity: Win rates vs. random (Gaussian) network representation readout and statistically informed guess avg.
website allows the user to specify any desired partition.
Network Architectures: We preserved the architectural
and training details across tasks as homogeneously as possible to avoid injecting any bias. The encoder architecture is
identical across all task-speciﬁc networks and is a fully convolutional ResNet-50 without pooling. All transfer functions include identical shallow networks with 2 conv layers
(concatenated channel-wise if higher-order). The loss (Lt)
and decoder’s architecture, though, have to depend on the
task as the output structures of different tasks vary; for all
pixel-to-pixel tasks, e.g. normal estimation, the decoder is a
15-layer fully convolutional network; for low dimensional
tasks, e.g. vanishing points, it consists of 2-3 FC layers.
All networks are trained using the same hyperparameters
regardless of task and on exactly the same input images.
Tasks with more than one input, e.g. relative camera pose,
share weights between the encoder towers. Transfer networks are all trained using the same hyperparameters as the
task-speciﬁc networks, except that we anneal the learning
rate earlier since they train much faster. Detailed deﬁnitions
of architectures, training process, and experiments with different encoders can be found in the supplementary material.
Data Splits: Our dataset includes 4 million images. We
made publicly available the models trained on full dataset,
but for the experiments reported in the main paper, we
used a subset of the dataset as the extracted structure stabilized and did not change when using more data (explained
in Sec. 5.2). The used subset is partitioned into training
(120k), validation (16k), and test (17k) images, each from
non-overlapping sets of buildings. Our task-speciﬁc networks are trained on the training set and the transfer networks are trained on a subset of validation set, ranging from
1k images to 16k, in order to model the transfer patterns under different data regimes. In the main paper, we report all
results under the 16k transfer supervision regime (∼10% of
the split) and defer the additional sizes to the supplementary
material and website (see Sec. 5.2). Transfer functions are
evaluated on the test set.
How good are the trained task-speciﬁc networks? Win
rate (%) is the proportion of test set images for which a
baseline is beaten. Table 1 provides win rates of the taskspecifc networks vs. two baselines. Visual outputs for a ran-
Autoencoding
2D Keypoints
Object Class. (1000)
Scene Class.
Occlusion Edges
Cam. Pose (fix)
3D Keypoints
Cam. Pose (nonfix)
2.5D Segm.
Semantic Segm.
Vanishing Pts.
Colorization
In-painting
Random Projo .
3D Keypoints
Autoencoding
Object Class.
2D Keypoints
2.5D Segm.
Scene Class.
Cam. Pose (fix)
Occlusion Edges
Semantic Segm.
Cam. Pose (nonfix)
Vanishing Pts.
Colorization
In-painting
Random Projo .
Scene Class.
Object Class.
Autoencoding
2D Keypoints
Occlusion Edges
Cam. Pose (fix)
3D Keypoints
2.5D Segm.
Vanishing Pts.
Colorization
Random Projo .
Scene Class.
Object Class.
Autoencoding
2D Keypoints
In-painting
3D Keypoints
2.5D Segm.
Cam. Pose (fix)
Occlusion Edges
Cam. Pose (nonfix)
Layout Vanishing Pts.
Colorization
Random Projo .
Object Class. (1000)
Scene Class.
Semantic Segm.
3D Keypoints
Autoencoding
2D Segm.2D Edges
2D Keypoints
In-painting
Colorization
2.5D Segm.
Occlusion Edges
Vanishing Pts.
Random Projo .
Object Class.
2.5D Segm.
Occlusion Edges
Cam. Pose (fix)
Cam. Pose (nonfix)
Semantic Segm.
Colorization
In-painting
2D Keypoints
Random Projo .
Vanishing Pts.
Autoencoding
Scene Class.
3D Keypoints
Object Class. (1000)
2D Keypoints
3D Keypoints
2.5D Segm.
Occlusion Edges
Semantic Segm.
Cam. Pose (nonfix)
Vanishing Pts.
Autoencoding
Scene Class.
Colorization
In-painting
Random Projo .
Autoencoding
Object Class.
Semantic Segm.
3D Keypoints
2.5D Segm.
Occlusion Edges
Cam. Pose (nonfix)
Cam. Pose (fix)
Vanishing Pts.
Scene Class.
Colorization
In-painting
2D Keypoints
andom Projo .
2.5D Segm.
Autoencoding
Object Class. (1000)
Scene Class.
Colorization
Occlusion Edges
Cam. Pose (fix)
In-painting
2D Keypoints
Cam. Pose (nonfix)
Random Projo .
Semantic Segm.
Vanishing Pts.
3D Keypoints
3D Keypoints
2.5D Segm.
Cam. Pose (fix)
Autoencoding
Object Class.
Scene Class.
Colorization
Occlusion Edges
In-painting
2D Keypoints
Cam. Pose (nonfix)
Random Projo .
Vanishing Pts.
Semantic Segm.
3D Keypoints
2.5D Segm.
Cam. Pose (fix)
Cam. Pose (nonfix)
Vanishing Pts.
Autoencoding
Object Class.
Scene Class.
Colorization
In-painting
2D Keypoints
Random Projo .
Supervision Budget 2
Transfer Order 1
Transfer Order 2
Transfer Order 4
Supervision Budget 8
Supervision Budget 15
Supervision Budget 26
Object Class.
Scene Class.
3D Keypoints
Autoencoding
2D Keypoints
In-painting
Colorization
Occlusion Edges
Vanishing Pts.
Random Projo .
Supervision Budget 8 - Order 4 (zoomed)
3D Keypoints
Autoencoding
Object Class.
2D Keypoints
2.5D Segm.
Scene Class
Cam. Pose (fix)
Occlusion Edges
Semantic Segm.
Cam. Pose (nonfix)
Vanishing Pts.
Colorization
In-painting
Random Projo .
In-painting
Figure 8: Computed taxonomies for solving 22 tasks given various supervision budgets (x-axes), and maximum allowed transfer orders (y-axes). One
is magniﬁed for better visibility. Nodes with incoming edges are target tasks, and the number of their incoming edges is the order of their chosen transfer
function. Still transferring to some targets when tge budget is 26 (full budget) means certain transfers started performing better than their fully supervised
task-speciﬁc counterpart. See the interactive solver website for color coding of the nodes by Gain and Quality metrics. Dimmed nodes are the source-only
tasks, and thus, only participate in the taxonomy if found worthwhile by the BIP optimization to be one of the sources.
dom test sample are in Fig. 3. The high win rates in Table 1
and qualitative results show the networks are well trained
and stable and can be relied upon for modeling the task
space. See results of applying the networks on a YouTube
video frame-by-frame here. A live demo for user uploaded
queries is available here.
To get a sense of the quality of our networks vs. state-ofthe-art task-speciﬁc methods, we compared our depth estimator vs. released models of which led to outperforming with a win rate of 88% and losses of 0.35 vs. 0.47
(further details in the supplementary material). In general,
we found the task-speciﬁc networks to perform on par or
better than state-of-the-art for many of the tasks, though we
do not formally benchmark or claim this.
4.1. Evaluation of Computed Taxonomies
Fig. 8 shows the computed taxonomies optimized to
solve the full dictionary, i.e. all tasks are placed in T and S
(except for 4 source-only tasks that are in S only). This was
done for various supervision budgets (columns) and maximum allowed order (rows) constraints. Still seeing transfers to some targets when the budget is 26 (full dictionary)
means certain transfers became better than their fully supervised task-speciﬁc counterpart.
While Fig. 8 shows the structure and connectivity, Fig. 9
quantiﬁes the results of taxonomy recommended transfer
max transfer order=1
max transfer order=4
max transfer order=1
max transfer order=4
Supervision Budget Increase (→)
Figure 9: Evaluation of taxonomy computed for solving the full task
dictionary. Gain (left) and Quality (right) values for each task using the
policy suggested by the computed taxonomy, as the supervision budget
increases(→). Shown for transfer orders 1 and 4.
policies by two metrics of Gain and Quality, deﬁned as:
Gain: win rate (%) against a network trained from scratch
using the same training data as transfer networks’. That
is, the best that could be done if transfer learning was not
utilized. This quantiﬁes the gained value by transferring.
Quality: win rate (%) against a fully supervised network
trained with 120k images (gold standard).
Red (0) and Blue (1) represent outperforming the reference method on none and all of test set images, respec-
Order Increase (→)
ImageNet 
Agrawal. 
Zamir. 
Zhang. 
Noroozi. 
88 88 93 89 88 84 86 43
Scene Cls.
80 52 83 74 74 71 75 15
Sem. Segm. 78 79 82 85 76 78 84 21
Object Cls.
79 54 82 76 75 76 76 34
97 98 98 98 98 97 97 6
2.5D Segm. 80 93 92 89 90 84 87 40
Occ. Edges 93 96 95 93 94 93 94 42
88 94 89 85 88 92 88 29
79 78 83 77 76 74 71 59
80 76 85 79 77 78 70 36
Figure 10: Generalization to Novel Tasks. Each row shows a novel
test task. Left: Gain and Quality values using the devised “all-for-one”
transfer policies for novel tasks for orders 1-4. Right: Win rates (%) of the
transfer policy over various self-supervised methods, ImageNet features,
and scratch are shown in the colored rows. Note the large margin of win
by taxonomy. The uncolored rows show corresponding loss values.
tively (so the transition Red→White→Blue is desirable.
White (.5) represents equal performance to reference).
Each column in Fig. 9 shows a supervision budget. As
apparent, good results can be achieved even when the supervision budget is notably smaller than the number of solved
tasks, and as the budget increases, results improve (expected). Results are shown for 2 maximum allowed orders.
4.2. Generalization to Novel Tasks
The taxonomies in Sec. 4.1 were optimized for solving
all tasks in the dictionary. In many situations, a practitioner
is interested in a single task which even may not be in the
dictionary. Here we evaluate how taxonomy transfers to a
novel out-of-dictionary task with little data.
This is done in an all-for-one scenario where we put one
task in T and all others in S. The task in T is target-only
and has no task-speciﬁc network. Its limited data (16k) is
used to train small transfer networks to sources. This basically localizes where the target would be in the taxonomy.
Fig. 10 (left) shows the Gain and Quality of the transfer
policy found by the BIP for each task. Fig. 10 (right) compares the taxonomy suggested policy against some of the
best existing self-supervised methods ,
ImageNet FC7 features , training from scratch, and a
fully supervised network (gold standard).
The results in Fig. 10 (right) are noteworthy. The large
win margin for taxonomy shows that carefully selecting
transfer policies depending on the target is superior to ﬁxed
transfers, such as the ones employed by self-supervised
methods. ImageNet features which are the most popular
off-the-shelf features in vision are also outperformed by
those policies. Additionally, though the taxonomy transfer
policies lose to fully supervised networks (gold standard) in
Taxonomy Significance Test
Supervision Budget
Supervision Budget
Figure 11: Structure Signiﬁcance. Our taxonomy compared with random transfer policies (random feasible taxonomies that use the maximum
allowable supervision budget). Y-axis shows Quality or Gain, and X-axis
is the supervision budget. Green and gray represent our taxonomy and random connectivities, respectively. Error bars denote 5th–95th percentiles.
most cases, the results often get close with win rates in 40%
range. These observations suggests the space has a rather
predicable and strong structure. For graph visualization of
the all-for-one taxonomy policies please see the supplementary material. The solver website allows generating the taxonomy for arbitrary sets of target-only tasks.
5. Signiﬁcance Test of the Structure
The previous evaluations showed good transfer results in
terms of Quality and Gain, but how crucial is it to use our
taxonomy to choose smart transfers over just choosing any
transfer? In other words, how signiﬁcant/strong is the discovered structure of task space? Fig. 11 quantiﬁes this by
showing the performance of our taxonomy versus a large set
of taxonomies with random connectivities. Our taxonomy
outperformed all other connectivities by a large margin signifying both existence of a strong structure in the space as
well as a good modeling of it by our approach. Complete
experimental details is available in supplementary material.
5.1. Evaluation on MIT Places & ImageNet
To what extent are our ﬁndings dataset dependent, and
would the taxonomy change if done on another dataset? We
examined this by ﬁnding the ranking of all tasks for transferring to two target tasks of object classiﬁcation and scene
classiﬁcation on our dataset. We then ﬁne tuned our taskspeciﬁc networks on other datasets (MIT Places for
scene classiﬁcation, ImageNet for object classiﬁcation)
and evaluated them on their respective test sets and metrics.
Fig. 12 shows how the results correlate with taxonomy’s
ranking from our dataset. The Spearman’s rho between the
taxonomy ranking and the Top-1 ranking is 0.857 on Places
and 0.823 on ImageNet showing a notable correlation. See
supplementary material for complete experimental details.
5.2. Universality of the Structure
We employed a computational approach with various design choices. It is important to investigate how speciﬁc to
those the discovered structure is. We did stability tests by
Transferring to ImageNet
(Spearman’s correlation = 0.823)
Transferring to MIT Places
(Spearman’s correlation = 0.857)
Figure 12: Evaluating the discovered structure on other datasets:
ImageNet (left) for object classiﬁcation and MIT Places 
(right) for scene classiﬁcation. Y-axis shows accuracy on the external
benchmark while bars on x-axis are ordered by taxonomy’s predicted performance based on our dataset. A monotonically decreasing plot corresponds to preserving identical orders and perfect generalization.
computing the variance in our output when making changes
in one of the following system choices: I. architecture of
task-speciﬁc networks, II. architecture of transfer function networks, III. amount of data available for training
transfer networks, IV. datasets, V. data splits, VI. choice
of dictionary. Overall, despite injecting large changes (e.g.
varying the size of training data of transfer functions by 16x,
size and architecture of task-speciﬁc networks and transfer
networks by 4x), we found the outputs to be remarkably
stable leading to almost no change in the output taxonomy
computed on top. Detailed results and experimental setup
of each tests are reported in the supplementary material.
5.3. Task Similarity Tree
Thus far we showed the task space has a structure, measured this structure, and presented its utility for transfer
learning via devising transfer policies. This structure can
be presented in other manners as well, e.g. via a metric of
similarity across tasks. Figure 13 shows a similarity tree for
the tasks in our dictionary. This is acquired from agglomerative clustering of the tasks based on their transferring-out
behavior, i.e. using columns of normalized afﬁnity matrix
P as feature vectors for tasks. The tree shows how tasks
would be hierarchically positioned w.r.t. to each other when
measured based on providing information for solving other
tasks; the closer two tasks, the more similar their role in
transferring to other tasks. Notice that the 3D, 2D, low dimensional geometric, and semantic tasks are found to cluster together using a fully computational approach, which
matches the intuitive expectations from the structure of task
space. The transfer taxonomies devised by BIP are consistent with this tree as BIP picks the sources in a way that all
of these modes are quantitatively best covered, subject to
the given budget and desired target set.
6. Limitations and Discussion
We presented a method for modeling the space of visual
tasks by way of transfer learning and showed its utility in
Figure 13: Task Similarity Tree. Agglomerative clustering of tasks
based on their transferring-out patterns (i.e. using columns of normalized
afﬁnity matrix as task features). 3D, 2D, low dimensional geometric, and
semantic tasks clustered together using a fully computational approach.
reducing the need for supervision. The space of tasks is an
interesting object of study in its own right and we have only
scratched the surface in this regard. We also made a number
of assumptions in the framework which should be noted.
Model Dependence: We used a computational approach
and adopted neural networks as our function class. Though
we validated the stability of the ﬁndings w.r.t various architectures and datasets, it should be noted that the ﬁndings are
in principle model and data speciﬁc.
Compositionality: We performed the modeling via a set
of common human-deﬁned visual tasks. It is natural to consider a further compositional approach in which such common tasks are viewed as observed samples which are composed of computationally found latent subtasks.
Space Regularity: We performed modeling of a dense
space via a sampled dictionary. Though we showed a good
tolerance w.r.t. to the choice of dictionary and transferring
to out-of-dictionary tasks, this outcome holds upon a proper
sampling of the space as a function of its regularity. More
formal studies on properties of the computed space is required for this to be provably guaranteed for a general case.
Transferring to Non-visual and Robotic Tasks: Given
the structure of the space of visual tasks and demonstrated
transferabilities to novel tasks, it is worthwhile to question
how this can be employed to develop a perception module
for solving downstream tasks which are not entirely visual,
e.g. robotic manipulation, but entail solving a set of (a priori
unknown) visual tasks.
Lifelong Learning: We performed the modeling in one
go. In many cases, e.g. lifelong learning, the system is
evolving and the number of mastered tasks constantly
Such scenarios require augmentation of the
structure with expansion mechanisms based on new beliefs.
Acknowledgement: We acknowledge the support of NSF
(DMS-1521608), MURI (1186514-1-TBCJE), ONR MURI
(N00014-14-1-0671), Toyota(1191689-1-UDAWF), ONR
MURI (N00014-13-1-0341), Nvidia, Tencent, a gift by
Amazon Web Services, a Google Focused Research Award.