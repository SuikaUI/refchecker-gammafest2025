Principal Graphs and Manifolds
Alexander N. Gorban
University of Leicester, United Kingdom
Andrei Y. Zinovyev
Institut Curie, Paris, France
statistical,
biological
investigations it is desirable to approximate a system of
points by objects of lower dimension and/or complexity. For
this purpose, Karl Pearson invented principal component
analysis in 1901 and found ‘lines and planes of closest fit
to system of points’. The famous k-means algorithm solves the
approximation problem too, but by finite sets instead of
lines and planes. This chapter gives a brief practical
introduction into the methods of construction of general
principal objects, i.e. objects embedded in the ‘middle’ of
the multidimensional data set. As a basis, the unifying
framework of mean squared distance approximation of finite
datasets is selected. Principal graphs and manifolds are
constructed as generalisations of principal components and kmeans principal points. For this purpose, the family of
expectation/maximisation
algorithms
generalisations is presented. Construction of principal
graphs with controlled complexity is based on the graph
grammar approach.
INTRODUCTION
In many fields of science, one meets with multivariate (multidimensional)
distributions of vectors representing some observations. These distributions are
often difficult to analyse and make sense of due to the very nature of human brain
which is able to visually manipulate only with the objects of dimension no more
than three.
This makes actual the problem of approximating the multidimensional vector
distributions by objects of lower dimension and/or complexity while retaining the
most important information and structures contained in the initial full and
complex data point cloud.
The most trivial and coarse approximation is collapsing the whole set of vectors
into its mean point. The mean point represents the ‗most typical‘ properties of the
system, completely forgetting variability of observations.
The notion of the mean point can be generalized for approximating data by more
complex types of objects. In 1901 Pearson proposed to approximate multivariate
distributions by lines and planes . In this way the Principal
Component Analysis (PCA) was invented, nowadays a basic statistical tool.
Principal lines and planes go through the ‗middle‘ of multivariate data distribution
and correspond to the first few modes of the multivariate Gaussian distribution
approximating the data.
Starting from 1950s , it was
proposed to approximate the complex multidimensional dataset by several ‗mean‘
points. Thus k-means algorithm was suggested and nowadays it is one of the most
used clustering methods in machine learning .
Both these directions (PCA and K-Means) were further developed during last
decades following two major directions: 1) linear manifolds were generalised for
non-linear ones (in simple words, initial lines and planes were bended and
twisted), and 2) some links between the ‗mean‘ points were introduced. This led
to appearance of several large families of new statistical methods; the most
famous from them are Principal Curves, Principal Manifolds and Self-Organising
Maps (SOM). It was quickly realized that the objects that are constructed by these
methods are tightly connected theoretically. This observation allows now to
develop a common framework called ―Construction of Principal Objects‖. The
geometrical nature of these objects can be very different but all of them serve as
data approximators of controllable complexity. It allows using them in the tasks
of dimension and complexity reduction. In Machine Learning this direction is
connected with terms ‗Unsupervised Learning‘ and ‗Manifold Learning.‘
In this chapter we will overview the major directions in the field of principal
objects construction. We will formulate the problem and the classical approaches
such as PCA and k-means in a unifying framework, and show how it is naturally
generalised for the Principal Graphs and Manifolds and the most general types of
principal objects, Principal Cubic Complexes. We will systematically introduce
the most used ideas and algorithms developed in this field.
APPROXIMATIONS OF FINITE DATASETS
Definition. Dataset is a finite set X of objects representing N multivariate
(multidimensional) observations. These objects xiX, i =1…N, are embedded in
Rm and in the case of complete data are vectors xiRm. We will also refer to the
individual components of xi as
kx such that
; we can also
represent dataset as a data matrix
Definition. Distance function dist(x,y) is defined for any pair of objects x, y from
X such that three usual axioms are satisfied: dist(x,x) = 0, dist(x,y) = dist(y,x),
dist(x,y)+dist(y,z) ≤ dist(x,z).
Definition. Mean point MF(X) for X is a vector MFRm such
In this form the definition of the mean point goes back to Fréchet . Notice
that in this definition the mean point by Fréchet can be non-unique. However, this
definition allows multiple useful generalisations including using it in the abstract
metric spaces. It is easy to show that in the case of complete data and the
Euclidean distance function
, or, more generally, in the
case of any quadratic distance function (for example, Mahalanobis distance), the
mean point is the standard expectation
Definition. Orthogonal projection P(x,Y) is defined for an object x and a set (not
necessarily finite) of vectors Y as a vector in Y such that
. Notice that in principle, one can have non-unique
and even infinitely many projections of x on Y.
Definition. Mean squared distance MSD(X,Y) between a dataset X and a set of
vectors Y is defined as
. We will also
consider a simple generalisation of MSD: weighted mean squared
, where wi > 0 is a
weight for the object xi.
Our objective in the rest of the chapter is to briefly describe the methods for
constructing various approximations (principal objects) for a dataset X. In almost
all cases the principal objects will be represented as a finite or infinite set of
vectors YRm such that 1) it approximates the finite dataset X in the sense of
minimisation of MSD(X,Y), and 2) it answers some regularity conditions that will
be discussed below.
PROBABILISTIC INTERPRETATION OF STATISTICS AND NOTION OF SELF-
CONSISTENCY
In his original works, Pearson followed the principle that the only reality in data
analysis is the dataset, embedded in a multidimensional metric space. This
approach can be called geometrical. During the 20th century, probabilistic
interpretation of statistics was actively developed. Accordingly to this
interpretation, a dataset X is one particular of i.i.d. sample from a
multidimensional probability distribution F(x) which defines a probability of
appearance of a sample in the point xRm.
The probability distribution, if can be estimated, provides a very useful auxiliary
object allowing to define many notions in the theory of statistical data analysis. In
particular, it allows us to define principal manifolds as self-consistent objects.
The notion of self-consistency in this context was first introduced by Efron 
and developed in the works of Flury , where it is claimed
to be one of the most fundamental in statistical theory.
Definition. Given probability distribution F(x) and a set of vectors Y we say that
Y is self-consistent with respect to F(x) if
for every vector
yY. In words, it means that any vector yY is a conditional mean expectation of
point x under condition that x is orthogonally projected in y.
The disadvantage of this definition for finite datasets is that it is not always
possible to calculate the conditional mean, since typically for points yY it is only
one or zero point projected from X. This means that for finite datasets we should
develop coarse-grained self-consistency notion. Usually it means that for every
point yY one defines some kind of neighbourhood and introduces a modified
self-consistency with respect to this neighbourhood instead of y itself. Concrete
implementations of this idea are described further in this chapter. In all cases, the
effective size of the neighbourhood is a fundamental parameter in controlling the
complexity of the resulting approximator Y.
FOUR APPROACHES TO CLASSICAL PCA
We can define linear principal manifolds as mean squared distance data
approximators, constructed from linear manifolds embedded in Rm. In fact, this
corresponds to the original definition of principal lines and planes by Pearson
 . However, PCA method was re-invented in other fields and even
obtained different names , Hotteling transform , Proper
Orthogonal Decomposition ) and others. Here we formulate four
equivalent ways to define principal components that the user can meet in different
applications.
Let us consider a linear manifold Lk of dimension k in the parametric form
Lk = {a0 + 
1a1 + … + 
iR }, a0Rm and {a1,…, ak} is a set of
orthonormal vectors in Rm.
Definition of PCA problem #1 (data approximation by lines and planes):
PCA problem consists in finding such sequence Lk (k=1,2,…,m-1) that the sum of
squared distances from data points to their orthogonal projections on Lk is
minimal over all linear manifolds of dimension k embedded in Rm:
(k=1,2,…,m-1).
Definition of PCA problem #2 (variance maximisation):
For a set of vectors X and for a given ai, let us construct a one-dimensional
distribution 
i = {: 
= (x,ai), xX} where (·,·) denotes scalar vector product.
Then let us define empirical variance of X along ai as Var(Bi), where Var( ) is the
standard empirical variance. PCA problem consists in finding such Lk that the sum
of empirical variances of X along a1,…, ak would be maximal over all linear
manifolds of dimension k embedded in Rm:
. Let us also
consider an orthogonal complement {ak+1 , …, am} of the basis {a1 , …, ak}. Then
an equivalent definition (minimization of residue variance) is
Definition of PCA problem #3 (mean point-to-point squared distance
maximisation):
PCA problem consists in finding such sequence Lk that the mean point-to-point
squared distance between the orthogonal projections of data points on Lk is
maximal over all linear manifolds of dimension k embedded in Rm:
. Having in mind that all orthogonal
projections onto lower-dimensional space lead to contraction of all point-to-point
distances (except for some that do not change), this is equivalent to minimisation
of mean squared distance distortion:
In the three above mentioned definitions, the basis vectors are defined up to an
arbitrary rotation that does not change the manifold. To make the choice less
ambiguous, in the PCA method the following principle is applied: given
{a0, a1,…, ak}, any ‗embedded‘ linear manifold of smaller dimension s in the form
Ls = {a0 + 
1a1 + …+ 
iR, s < k}, must be itself a linear principal manifold
of dimension s for X (a flag of principal subspaces).
Definition of PCA problem #4 (correlation cancellation):
Find such an orthonormal basis (a1,…, as) in which the covariance matrix for x is
diagonal. Evidently, in this basis the distributions (ai,x) and (aj,x), for i ≠ j, have
zero correlation.
Definitions 1-3 were given for finite datasets while definition 4 is sensible both
for finite datasets and random vector x. For finite datasets the empiric correlation
should be cancelled. The empiric principal components which annul empiric
correlations could be considered as an approximation to the principal components
of the random vector.
Equivalence of the above-mentioned definitions in the case of complete data and
Euclidean space follows from Pythagorean Theorem and elementary algebra.
However, in practice this or that definition can be more useful for computations or
generalisations of the PCA approach. Thus, only definitions #1 and #3 are suitable
for working with incomplete data since they are defined with use of only distance
function that can be easily calculated for the ‗gapped‘ data vectors (see further).
The definition #1 can be generalized by weighting data points , while the definition #3 can be generalized by weighting pairs of data points
 . More details about PCA and generalisations could be
found in the fundamental book by Jollliffe .
BASIC EXPECTATION/MAXIMISATION ITERATIVE
PRINCIPAL OBJECTS
Most of the algorithms for finding principal objects for a given dataset X are
constructed accordingly to the classical expectation/maximisation (EM) splitting
scheme that was first formulated as a generic method by Dempster et al :
Generic Expectation-Maximisation algorithm for estimating principal objects
1) Initialisation step. Some initial configuration of the principal object Y is
generated;
2) Expectation (projection) step. Given configuration of Y, calculate
orthogonal projections P(x,Y), for all xX;
3) Maximisation step. Given the calculated projections, find more optimal
configuration of Y with respect to X.
4) (Optional) adaptation step. Using some strategy, change the properties
of Y (typically, add or remove points to Y).
5) Repeat steps 2-4 until some convergence criteria would be satisfied.
For example, for the principal line, we have the following implementation of the
above mentioned bi-iteration scheme and Gorban & Rossiev ).
Iterative algorithm for calculating the first principal component
1) Set a0 = MF(X) (i.e., zero order principal component is the mean
point of X);
2) Choose randomly a1;
3) Calculate
, i =1…N ;
4) Given bi, find new a1, such that
5) Re-normalize
6) Repeat steps 3-5 until the direction of a1 do not change more than on some
small angle .
Remark. To calculate all other principal components, deflation approach is
applied: after finding a1, one calculates new X(1) = X - a0 - a1(x,a1), and the
procedure is repeated for X(1).
Remark. The basic EM procedure has good convergence properties only if the
first eigenvalues of the empirical covariance matrix XTX are sufficiently well
separated. If this is not the case, more sophisticated approaches are needed
 .
The PCA method can be treated as spectral decomposition of the symmetric and
positively defined empirical covariance data matrix (defined in the case of
complete data)
, where without loss of
generality we suppose that the data are centered.
Definition. We call    a singular value for the data matrix X iff there exist two
vectors of unit length a and b such that
. Then the
vectors a
} and b
} are called left and right
singular vectors for the singular value .
If we know all p singular values of X, where p = rank(X) ≤ min(N, m), then we can
represent X as
. It is called the singular value
decomposition (SVD) of X. It is easy to check that the vectors alcorrespond to
the principal vectors of X and the eigenvectors of the empirical covariance matrix
C, whereas bl contain projections of N points onto the corresponding principal
vector. Eigenvalues 
l of C and singular values 
l of X and are connected by
The mathematical basis for SVD was introduced by Sylvester (1889) and it
represents a solid mathematical foundation for PCA . Although
formally the problems of spectral decomposition of X and eigen decomposition of
C are equivalent, the algorithms for performing singular decomposition directly
(without explicit calculation of C) can be more efficient and robust
 . Thus, the iterative EM algorithm for calculating the
first principal component described in the previous chapter indeed performs
singular decomposition (for centered data we simply put a0 = 0) and finds right
singular (principal) and left singular vectors one by one.
K-MEANS AND PRINCIPAL POINTS
K-means clustering goes back to 1950s ; Lloyd ; and
MacQueen ). It is another extreme in its simplicity case of finding a
principal object. In this case it is simply an unstructured finite (and usually, much
smaller than the number of points N in the dataset X) set of vectors (centroids).
One can say that the solution searched by the k-means algorithm is a set of k
principal points .
Definition. A set of k points Y={y1,..,yk}, yiRm is called a set of principal points
for dataset X if it approximates X with minimal mean squared distance error over
all sets of k-points in Rm (distortion):
, where P(x,Y) is
the point from Y closest to x. Note that the set of principal points can be not
The simplest implementation of the k-means procedure follows the classical EM
Basic k-means algorithm
1) Choose initial position of y1,..,yk randomly from xiX (with equal
probabilities);
2) Partition X into subsets Ki, i=1..k of data points by their proximity to yk:
3) Re-estimate
, i = 1..k;
4) Repeat steps 2-3 until complete convergence.
The method is sensitive to the initial choice of y1,..,yk . Arthur & Vassilvitskii
 demonstrated that the special construction of probabilities instead of
equidistribution gives serious advantages. The first centre, y1, they select
equiprobable from X. Let the centres y1,..,yj are chosen (j < k) and D(x) be the
squared shortest distance from a data point x to the closest centre we have already
chosen. Then, we select the next centre, yj+1, from xiX with probability
Evidently, any solution of k-means procedure converges to a self-consistent set of
points Y={y1,..,yk} (because Y = E[P(X,Y)]), but this solution may give a local
minimum of distortion and is not necessary the set of principal points (which is
the globally optimal approximator from all possible k-means solutions).
Multiple generalisations of k-means scheme have been developed based on the idea of ‗data recovering‘). The
most computationally expensive step of the algorithm, partitioning the dataset by
proximity to the centroids, can be significantly accelerated using kd-tree data
structure . Analysis of the effectiveness of EM algorithm
for the k-means problem was given by Ostrovsky et al. .
Notice that the case of principal points is the only in this chapter when selfconsistency and coarse-grained self-consistency coincide: centroid yk is the
conditional mean point for the data points belonging to the Voronoi region
associated with yk.
The term ‗Local PCA‘ was first used by Braverman and
Fukunaga & Olsen to denote the simplest cluster-wise PCA approach
which consists in 1) applying k-means or other type of clustering to a dataset and
2) calculating the principal components for each cluster separately. However, this
simple idea performs rather poorly in applications, and more interesting approach
consists in generalizing k-means by introducing principal hyperplane segments
proposed by Diday and called ‗k-segments‘ or local subspace analysis in a
more advanced version . The algorithm for their estimation follows the
classical EM scheme.
Further development of the local PCA idea went in two main directions. First,
Verbeek proposed a variant of the ‗k-segment‘ approach for onedimensional segments accompanied by a strategy to assemble disconnected line
segments into the global piecewise linear principal curve. Einbeck et al 
proposed an iterative cluster splitting and joining approach (recursive local PCA)
which helps to select the optimal number and configuration of disjoined segments.
Second direction is associated with a different understanding of ‗locality‘. It
consists in calculating local mean points and local principal directions and
following them starting from (may be multiple) seed points. Locality is introduced
using kernel functions defining the effective radius of neighborhood in the data
space. Thus, Delicado introduced principal oriented points (POP) based on
the variance maximisation-based definition of PCA (#2 in our chapter). POPs are
different from the principal points introduced above because they are defined
independently one from another, while the principal points are defined globally, as
a set. POPs can be assembled into the principal curves of oriented points (PCOP).
Einbeck proposed a simpler approach based on local tracing of principal
curves by calculating local centers of mass and the local first principal
components.
SOM APPROACH FOR PRINCIPAL MANIFOLD APPROXIMATION AND ITS
GENERALISATIONS
Kohonen in his seminal paper proposed to modify the k-means
approach by introducing connections between centroids such that a change in the
position of one centroid would also change the configuration of some neighboring
centroids. Thus Self-Organizing Maps (SOM) algorithm was developed.
With the SOM algorithm we take a finite metric space V with
metric ρ and try to map it into Rm with combinations of two criteria: (1) the best
preservation of initial structure in the image of V and (2) the best approximation
of the dataset X. In this way, SOMs give the most popular approximations for
principal manifolds: we can take for V a fragment of a regular s-dimensional grid
and consider the resulting SOM as the approximation to the s-dimensional
principal manifold .
The SOM algorithm has several setup variables to regulate the compromise
between these goals. In the original formulation by Kohonen, we start from some
initial approximation of the map, 1: V 
Rm. Usually this approximation lies on
the s-dimensional linear principal manifold. On each k-th step of the algorithm we
have a chosen datapoint xX and a current approximation k: V 
Rm. For these x
and k we define an ‗owner‘ of x in V:
. The next
approximation, k+1, is k+1(v) = hkw(ρ(v,vx))(x − k(v)). Here hk is a step size, 0 ≤
w(ρ(v,vx)) ≤ 1 is a monotonically decreasing neighborhood function. This process
proceeds in several epochs, with neighborhood radius decreasing during each next
The idea of SOM is flexible, was applied in many domains of science, and it lead
to multiple generalizations ). Some of the
algorithms for constructing SOMs are of EM type described above, such as the
Batch SOM Algorithm : it includes projecting step exactly the
same as in k-means and the maximization step at which all k(v) are modified
simultaneously.
One source of theoretical dissatisfaction with SOM is that it is not possible to
define an optimality criterion : SOM is a result of the algorithm
at work and there does not exist any objective function that is minimized by the
training process.
In attempt to resolve this issue, Bishop et al. developed the optimizationbased Generative Topographic Mapping (GTM) method. In this setting, it is
supposed that the observed data is i.i.d. sample from a mixture of Gaussian
distributions with the centers aligned along a two-dimensional grid, embedded in
the data space. Parameters of this mixture are determined by EM-based
maximization of the likelihood function (probability of observing X within this
data model).
PRINCIPAL MANIFOLDS BY HASTIE AND STUELZE
Principal curves and principal two-dimensional surfaces for a probability
distribution F(x) were introduced in the PhD thesis by Trevor Hastie as a
self-consistent (non-linear) one- and two-dimensional globally parametrisable
smooth manifolds without self-intersections.
Definition. Let G be the class of differentiable 1-dimensional curves in Rm,
parameterized by 
R1 and without self-intersections. The Principal Curve of the
probability distribution F(x) is such a Y()G that is self-consistent.
Remark. Usually, a compact subset of Rm and a compact interval of parameters 
R1 are considered. To discuss unbounded regions, it is necessary to add a
condition that Y() has finite length inside any bounded subset of Rm
 .
Definition. Let G2 be the class of differentiable 2-dimensional surfaces in Rm,
parameterized by 
R2 and without self-intersections. The Principal Surface of
the probability distribution F(x) is such a Y()G2 that is self-consistent. (Again,
for unbounded regions it is necessary to assume that for any bounded set B from
Rm the set of parameters 
for which Y()B is also bounded.)
First, Hastie and Stuelze proposed an algorithm for finding the principal curves
and principal surfaces for a probability distribution F(x), using the classical EM
splitting. We do not provide this algorithm here because for a finite dataset X it
can not be directly applied because in a typical point on Y() only zero or one data
point is projected, hence, one can not calculate the expectation. As mentioned
above, in this case we should use some kind of coarse-grained self-consistency. In
the original approach by Hastie , this is done through introducing
smoothers. This gives the practical formulation of the HS algorithm for estimating
the principal manifolds from a finite dataset X:
Hastie and Stuelze algorithm for finding principal curve for finite dataset
1) Initialize Y() = a0+a
where a0 is a mean point and a1 is the first
principal component;
2) Project every data point xi onto Y(): i.e., for each xi find 
i such that
. In practice it requires interpolation
procedure because Y() is determined in a finite number of points
N}. The simplest is the piecewise interpolation procedure, but more
sophisticated procedures can be proposed ;
3) Calculate new Y′() in the finite number of internal coordinates {
(found at the previous step) as the local average of points xi and some
other points, that have close to 
i projections onto Y. To do this, 1) a span
[wN] is defined ( [.] here is integer part ), where 0 < w << 1 is a
parameter of the method (coarse-grained self-consistency neighbourhood
radius); 2) for [wN] internal coordinates
closest to 
the corresponding
calculate weighted least squares linear
regression y() = a(i)
b(i); 3) define Y′(
i) as the value of the linear
regression in 
i) = a(i)
4) Reassign Y() ← Y′()
5) Repeat steps 2)-4) until Y does not change (approximately).
Remark. For the weights in the regression at the step 3) Hastie proposed to use
some symmetric kernel function that vanishes on the borders of the
neighbourhood. For example, for xi let us denote as
the most distant value
of the internal coordinate from [wN] ones closest to 
i. Then we can define
weight for the pair (
otherwise.
Remark. At the step 3) an alternative approach was also proposed with use of
cubic splines to approximate the smooth function Y′() from all pairs
i,xi), i = 1..N.
Non-linear Principal Manifolds constructed by this algorithm are usually called
Hastie-Stuelze (HS) principal manifolds. However, the global optimality of HS
principal manifolds is not guaranteed (only self-consistency in the case of
distribution or coarse-grained self-consistency in the case of dataset is guaranteed
by construction). For example, the second principal component of a sample X
from a normal distribution is self-consistent and will be correct HS principal curve
but of course not the optimal one.
We should also underline that our view on what is the object constructed by the
HS algorithm for a dataset X depends on 1) probabilistic interpretation of the
nature of X, and 2) the chosen heuristic approach to coarse-grained self-
consistency. If we do not suppose that the dataset is generated by i.i.d. sampling
from F(x) then the definition of HS principal manifold is purely operational: HS
principal manifold for X is the result of application of HS algorithm for finite
datasets. Analogous remark is applicable for all principal manifold approximators
constructed for finite datasets and described further in this chapter.
In his PhD thesis Hastie noticed that the HS principal curve does not coincide
with the generating curve in a very simple additive data generation model
X = f()+,
where f() is some curve embedded in data space and is noise distribution
independent on 
Because of the fact that if f() is not a straight line then it is not
self-consistent, HS principal curves were claimed to be ‗biased‘. This inspired
Tibshirani to introduce an alternative definition of the principal curve,
based directly on a continuous mixture model (1) and maximising regularized
likelihood.
KÉGL-KRYZHAK IMPROVEMENT
Kégl in his PhD thesis supervised by Kryzhak revised the existing
methods for estimating the principal curves. In particular, this led to the definition
of principal curves with limited length.
Definition. Principal curve YL() of length L is such a curve that the mean
squared distance from the dataset X to the curve YL() is minimal over all curves
of length less than or equal to L:
Theorem. Assume that X has finite second moments, i.e.
. Then for
any L > 0 there exists a principal curve of length L.
Principal curves of length L as defined by Kégl, are globally optimal
approximators as opposite to the HS principal curves that are only self-consistent.
However, all attempts to construct a practical algorithm for finding globally
optimal principal curves of length L were not successful. Instead Kégl developed
an efficient heuristic Polygonal line algorithm for constructing piecewise linear
principal curves.
Let us consider a piecewise curve Y composed from vertices located in points
{y1,…,yk+1} and k segments connecting pairs of vertices {yj,yj+1}, j=1..k. Kégl‘s
algorithm searches for a (local) optimum of the penalised mean squared distance
error function:
where CP(i) is a curvature penalty function for a vertex i chosen as
is the cosines of the angle between two
neighbouring segments at the vertex i,
is the ‗radius‘
of the dataset X, and  is a parameter controlling the curve global smoothness.
The Polygonal line algorithm follows the standard EM splitting
Polygonal line algorithm for estimating piece-wise linear principal curve
1) The initial approximation is constructed as a segment of principal line. The
length of the segment is the difference between the maximal and the
minimal projection value of X onto the first principal component. The
segment is positioned such that it contains all of the projected data points.
Thus in the initial approximation one has two vertices {y1,y2} and one
segment between them (k = 1).
2) Projection step. The dataset X is partitioned into 2k+1
subsets constructed by their
proximity to k+1 vertices and k segments. If a segment i and a vertex j are
equally distant from x then x is placed into Kj only.
3) Optimisation step. Given partitioning obtained at the step 2, the functional
U(X,Y) is optimised by use of a gradient technique. Fixing partitioning into
Ki is needed to calculate the gradient of U(X,Y) because otherwise it is not
a differentiable function with respect to the position of vertices {yi}.
4) Adaptation step. Choose the segment with the largest number of points
projected onto it. If more than one such segment exists then the longest
one is chosen. The new vertex is inserted in the midpoint of this segment;
all other segments are renumerated accordingly.
5) Stopping criterion. The algorithm stops when the number of segments
Heuristically, the default parameters of the method have been proposed  = 0.3,
, ′ = 0.13. The details of implementation together with
convergence and computational complexity study are provided elsewhere
 .
Smola et al. proposed a regularized principal manifolds framework, based
on minimization of quantization error functional with a large class of regularizers
that can be used and a universal EM-type algorithm. For this algorithm, the
convergence rates were analyzed and it was showed that for some regularizing
terms the convergence can be optimized with respect to the Kegl‘s polygonal line
algorithm.
ELASTIC MAPS APPROACH
In a series of works , the authors of this
chapter used metaphor of elastic membrane and plate to construct one-, two- and
three-dimensional principal manifold approximations of various topologies. Mean
squared distance approximation error combined with the elastic energy of the
membrane serves as a functional to be optimised. The elastic map algorithm is
extremely fast at the optimisation step due to the simplest form of the smoothness
penalty. It is implemented in several programming languages as software libraries
or front-end user graphical interfaces freely available from the web-site
 The software found applications in
microarray data analysis, visualization of genetic texts, visualization of
economical and sociological data and other fields .
Let G be a simple undirected graph with set of vertices V and set of edges E.
Definition. k-star in a graph G is a subgraph with k + 1 vertices v0,1,...,k  V and k
edges {(v0, vi)|i = 1, .., k}  E. The rib is by definition a 2-star.
Definition. Suppose that for each k ≥ 2, a family Sk of k-stars in G has been
selected. Then we define an elastic graph as a graph with selected families of
k-stars Sk and for which for all E(i)  E and
Sk, the corresponding elasticity
moduli λi > 0 and μkj > 0 are defined.
Definition. Primitive elastic graph is an elastic graph in which every non-terminal
node (with the number of neighbours more than one) is associated with a k-star
formed by all neighbours of the node. All k-stars in the primitive elastic graph are
selected, i.e. the Sk sets are completely determined by the graph structure.
Definition. Let E(i)(0), E(i)(1) denote two vertices of the graph edge E(i) and
(k) denote vertices of a k-star
(0) is the central vertex,
to which all other vertices are connected). Let us consider a map :V → Rm which
describes an embedding of the graph into a multidimensional space. The elastic
energy of the graph embedding in the Euclidean space is defined as
Fig. 1. Elastic nets used in practice.
Definition. Elastic net is a particular case of elastic graph which (1) contains only
ribs (2-stars) (the family Sk are empty for all k>2); and (2) the vertices of this
graph form a regular small-dimensional grid (Fig.1).
The elastic net is characterised by internal dimension dim(G). Every node vi in the
elastic net is indexed by the discrete values of internal coordinates
in such a way that the nodes close on the graph have similar internal coordinates.
The purpose of the elastic net is to introduce point approximations to manifolds.
Historically it was first explored and used in applications. To avoid confusion, one
should notice that the term elastic net was independently introduced by several
groups: for solving the traveling salesman problem , in
the context of principal manifolds and recently in the context
of regularized regression problem . These three notions are
completely independent and denote different things.
Definition. Elastic map is a continuous manifold YRm constructed from the
elastic net as its grid approximation using some between-node interpolation
procedure. This interpolation procedure constructs a continuous mapping 
dim(G)} → Rm from the discrete map 
V → Rmused to embed the
graph in Rm, and the discrete values of node indices
, i = 1...|V|. For
example, the simplest piecewise linear elastic map is built by piecewise linear
Definition. Elastic principal manifold of dimension s for a dataset X is an elastic
map, constructed from an elastic net Y of dimension s embedded in Rm using such
a map opt:Y → Rmthat corresponds to the minimal value of the functional
where the weighted mean squared distance from the dataset X to the elastic net Y
is calculated as the distance to the finite set of vertices {y1=
In the Euclidean space one can apply an EM algorithm for estimating the elastic
principal manifold for a finite dataset. It is based in turn on the general algorithm
for estimating the locally optimal embedding map for an arbitrary elastic graph
G, described below.
Optimisation of the elastic graph algorithm:
1) Choose some initial position of nodes of the elastic graph
vk}, where k is the number of graph nodes k = |V|;
2) Calculate two matrices eij and sij , using the following sub-algorithm:
i. Initialize the sij matrix to zero;
ii. For each k-star
with elasticity module μki, outer nodes
vN1 , ... ,vNk and the central node vN0, the sij matrix is updated
as follows (1 ≤ l,m ≤ k):
iii. Initialize the eij matrix to zero;
iv. For each edge E(i) with weight λi, one vertex vk1 and the
other vertex vk2, the ejk matrix is updated as follows:
3) Partition X into subsets Ki, i=1..k of data points by their proximity to
4) Given Ki , calculate matrix
js is the Kronecker‘s symbol.
5) Find new position of {y1
yk} by solving the system of linear
6) Repeat steps 3-5 until complete or approximate convergence of node
positions {y1
As usual, the EM algorithm described above gives only locally optimal solution.
One can expect that the number of local minima of the energy function U grows
with increasing the ‗softness‘ of the elastic graph (decreasing 
kj parameters).
Because of this, in order to obtain a solution closer to the global optimum, the
softening strategy has been proposed, used in the algorithm for estimating the
elastic principal manifold.
Algorithm for estimating the elastic principal manifold
1) Define a decreasing set of numbers {m1,…,mp}, mp=1 (for example, {103,
102, 10, 1}), defining p epochs for softening;
2) Define the base values of the elastic moduli
3) Initialize positions of the elastic net nodes {y1
yk} on the linear
principal manifold spanned by first dim(G) principal components;
4) Set epoch_counter = 1
5) Set the elastic moduli
6) Modify the elastic net using the algorithm for optimisation of the elastic
7) Repeat steps 5-6 for all values of epoch_counter = 2, … , p.
Remark. The values λi and μj are the coefficients of stretching elasticity of every
edge E(i) and of bending elasticity of every rib
. In the simplest case
λ1 = λ2 = ... = λs = λ(s), μ1 = μ2 = ... = μr = μ(r), where s and r are the numbers of
edges and ribs correspondingly. Approximately dependence on graph ‗resolution‘
is given by Gorban & Zinovyev :
This formula is applicable, of course, only for the elastic nets. In general a case λi
and μi are often made variable in different parts of the graph accordingly to some
adaptation strategy .
penalizes the total length (or, indirectly, ‗square‘, ‗volume, etc.)
of the constructed manifold and provides regularization of distances between node
positions at the initial steps of the softening. At the final stage of the softening λi
can be put to zero with little effect on the manifold configuration.
Elastic map post-processing such as map extrapolation can be applied to increase
its usability and avoid the ‗border effect‘, for details see .
PLURIHARMONIC GRAPHS AS IDEAL APPROXIMATORS
Approximating datasets by one dimensional principal curves is not satisfactory in
the case of datasets that can be intuitively characterized as branched. A principal
object which naturally passes through the ‗middle‘ of such a data distribution
should also have branching points that are missing in the simple structure of
principal curves. Introducing such branching points converts principal curves into
principal graphs.
Principal graphs were introduced by Kégl & Krzyzak as a natural
extension of one-dimensional principal curves in the context of skeletonisation of
hand-written symbols. The most important part of this definition is the form of the
penalty imposed onto deviation of the configuration of the branching points
embedment from their ‗ideal‘ configuration (end, line, corner, T-, Y- and Xconfiguration). Assigning types for all vertices serves for definition of the penalty
on the total deviation from the graph ‗ideal‘ configuration . Other
types of vertices were not considered, and outside the field of symbol
skeletonization applicability of such a definition of principal graph remains
Gorban & Zinovyev , Gorban et al. , and Gorban et al. 
proposed to use a universal form of non-linearity penalty for the branching points.
The form of this penalty is defined in the previous chapter for the elastic energy of
graph embedment. It naturally generalizes the simplest three-point second
derivative approximation squared:
for a 2-star (or rib) the penalty equals
for a 3-star it is
For a k-star this penalty equals to zero iff the position of the central node
coincides with the mean point of its neighbors. An embedment (G) is ‗ideal‘ if
all such penalties equal to zero. For a primitive elastic graph this means that this
embedment is a harmonic function on graph: its value in each non-terminal vertex
is a mean of the value in the closest neighbors of this vertex.
For non-primitive graphs we can consider stars which include not all neighbors of
their centers. For example, for a square lattice we create elastic graph (elastic net)
using 2-stars (ribs): all vertical 2-stars and all horizontal 2-stars. For such elastic
net, each non-boundary vertex belongs to two stars. For a general elastic graph G
with sets of k-stars
S we introduce the following notion of pluriharmoning
Definition. A map V→ Rm defined on vertices of G is pluriharmonic iff for any
with the central vertex
(0) and the neighbouring vertices
(i), i = 1...k, the equality holds:
Pluriharmonic maps generalize the notion of linear map and of harmonic map,
simultaneously. For example:
1D harmonic functions are linear;
If we consider an nD cubic lattice as a primitive graph (with 2n-stars for all
non-boundary vertices), then the correspondent pluriharmonic functions are
just harmonic ones;
If we create from nD cubic lattice a standard nD elastic net with 2-stars
(each non-boundary vertex is a center of n 2-stars, one 2-stars for each
coordinate direction), then pluriharmonic functions are linear.
Pluriharmonic functions have many attractive properties, for example, they satisfy
the following maximum principle. A vertex v of an elastic graph is called a corner
point or an extreme point of G iff v is not a centre of any k-star from
Theorem. Let 
V→ Rm be a pluriharmonic map, F be a convex function on Rm,
and a = maxxVF((x)). Then there is a corner point v of G such that F(
Convex functions achieve their maxima in corner points. Even a particular case of
this theorem with linear functions F is quite useful. Linear functions achieve their
maxima and minima in corner points.
In the theory of principal curves and manifolds the penalty functions were
introduced to penalise deviation from linear manifolds (straight lines or planes).
We proposed to use pluriharmonic embeddings (‗pluriharmonic graphs‘) as ‗ideal
objects‘ instead of manifolds and to introduce penalty (5) for deviation from this
ideal form.
GRAPH GRAMMARS AND THREE TYPES OF COMPLEXITY FOR PRINCIPAL GRAPHS
Principal graphs can be called data approximators of controllable complexity. By
complexity of the principal objects we mean the following three notions:
Geometric complexity: how far a principal object deviates from its ideal
configuration; for the elastic principal graphs we explicitly measure
deviation from the ‗ideal‘ pluriharmonic graph by the elastic energy U(G)
(3) (this complexity may be considered as a measure of non-linearity);
Structural complexity measure: it is some non-decreasing function of the
number of vertices, edges and k-stars of different orders
SC(G)=SC(|V|,|E|,|S2|,…,|Sm|); this function penalises for number of
structural elements;
Construction complexity is defined with respect to a graph grammar as a
number of applications of elementary transformations necessary to construct
given G from the simplest graph (one vertex, zero edges).
The construction complexity is defined with respect to a grammar of elementary
transformation. The graph grammars provide a welldeveloped formalism for the description of elementary transformations. An elastic
graph grammar is presented as a set of production (or substitution) rules. Each
rule has a form A → B, where A and B are elastic graphs. When this rule is applied
to an elastic graph, a copy of A is removed from the graph together with all its
incident edges and is replaced with a copy of B with edges that connect B to the
graph. For a full description of this language we need the notion of a labeled
graph. Labels are necessary to provide the proper connection between B and the
graph . An approach based on graph grammars to constructing
effective approximations of an elastic principal graph has been recently proposed
 .
Let us define graph grammar O as a set of graph grammar operations
O={o1,..,os}. All possible applications of a graph grammar operation oi to a graph
G gives a set of transformations of the initial graph oi(G) = {G1, G2, …, Gp},
where p is the number of all possible applications of oi to G. Let us also define a
sequence of r different graph grammars
Let us choose a grammar of elementary transformations, predefined boundaries of
structural complexity SCmax and construction complexity CCmax , and elasticity
coefficients λi and μkj .
Definition. Elastic principal graph for a dataset X is such an elastic graph G
embedded in the Euclidean space by the map 
V→ Rm that SC(G) ≤ SCmax ,
CC(G) ≤ CCmax , and U(G) → min over all possible elastic graphs G embeddings
Algorithm for estimating the elastic principal graph
Initialize the elastic graph G by 2 vertices v1 and v2 connected by an edge.
The initial map  is chosen in such a way that (v1) and (v2) belong to the
first principal line in such a way that all the data points are projected onto
the principal line segment defined by (v1), (v2);
For all j=1…r repeat steps 3-6:
Apply all grammar operations from O(j) to G in all possible ways; this gives
a collection of candidate graph transformations {G1, G2, …};
Separate {G1, G2, …} into permissible and forbidden transformations;
permissible transformation Gk is such that SC(Gk) ≤ SCmax , where SCmax is
some predefined structural complexity ceiling;
Optimize the embedment  and calculate the elastic energy U(G) of graph
embedment for every permissible candidate transformation, and choose such
a graph Gopt that gives the minimal value of the elastic functional:
permissibl
Substitute G →Gopt ;
Repeat steps 2-6 until the set of permissible transformations is empty or the
number of operations exceeds a predefined number – the construction
complexity.
PRINCIPAL TREES AND METRO MAPS
Let us construct the simplest non-trivial type of the principal graphs, called
principal trees. For this purpose let us introduce a simple ‗Add a node, bisect an
edge‘ graph grammar (see Fig. 2) applied for the class of primitive elastic graphs.
Definition. Principal tree is an acyclic primitive elastic principal graph.
Definition. „Remove a leaf, remove an edge‟ graph grammar O(shrink) applicable
for the class of primitive elastic graphs consists of two operations: 1) The
transformation ‗remove a leaf‘ can be applied to any vertex v of G with
connectivity degree equal to 1: remove v and remove the edge (v,v‘) connecting v
to the tree; 2) The transformation ‗remove an edge‘ is applicable to any pair of
graph vertices v, v‟ connected by an edge (v, v‟): delete edge (v, v‟), delete vertex
v‘, merge the k-stars for which v and v‟ are the central nodes and make a new
k-star for which v is the central node with a set of neighbors which is the union of
the neighbors from the k-stars of v and v‟.
Fig. 2. Illustration of the simple “add node to a node” or “bisect an edge” graph
grammar. a) We start with a simple 2-star from which one can generate three distinct
graphs shown. The “Op1” operation is adding a node to a node, operations “Op1” and
“Op2” are edge bisections (here they are topologically equivalent to adding a node to a
terminal node of the initial 2-star). For illustration let us suppose that the “Op2”
operation gives the biggest elastic energy decrement, thus it is the “optimal” operation.
b) From the graph obtained one can generate 5 distinct graphs and choose the optimal
one. c) The process is continued until a definite number of nodes are inserted.
Definition. „Add a node, bisect an edge‟ graph grammar O(grow) applicable for the
class of primitive elastic graphs consists of two operations: 1) The transformation
“add a node” can be applied to any vertex v of G: add a new node z and a new
edge (v, z); 2) The transformation “bisect an edge” is applicable to any pair of
graph vertices v, v‟ connected by an edge (v, v‟): delete edge (v, v‟), add a vertex z
and two edges, (v, z) and (z, v‟). The transformation of the elastic structure
(change in the star list) is induced by the change of topology, because the elastic
graph is primitive. Consecutive application of the operations from this grammar
generates trees, i.e. graphs without cycles.
Also we should define the structural complexity measure
SC(G)=SC(|V|,|E|,|S2|,…,|Sm|). Its concrete form depends on the application field.
Here are some simple examples:
1) SC(G) = |V| : i.e., the graph is considered more complex if it has more
i.e., only bmax simple branches (3-stars) are allowed in the principal tree.
Fig. 3. Principal manifold and principal tree for the Iris dataset. a) View of the principal
manifold projected on the first two principal components, the data points are shown
projected into the closest vertex of the elastic net; b) visualization of data points in the
internal coordinates, here classes are represented in the form of Hinton diagrams: the
size of the diagram is proportional to the number of points projected, the shape of the
diagram denote three different point classes; c) same as a), but the data points are shown
projected into the closest point of the piecewise linearly interpolated elastic map; d) same
as b), but based on projection shown in c); e)-g) First 50 iterations of the principal tree
algorithm, the tree is shown projected onto the principal plane; h) metro map
representation of the Iris dataset.
Using the sequence {O(grow), O(grow), O(shrink)} in the above-described algorithm for
estimating the elastic principal graph gives an approximation to the principal
trees. Introducing the ‗tree trimming‘ grammar O(shrink) allows to produce principal
trees closer to the global optimum, trimming excessive tree branching and fusing
k-stars separated by small ‗bridges‘.
Principal trees can have applications in data visualization. A principal tree is
embedded into a multidimensional data space. It approximates the data so that one
can project points from the multidimensional space into the closest node of the
tree. The tree by its construction is a one-dimensional object, so this projection
performs dimension reduction of the multidimensional data. The question is how
to produce a planar tree layout? Of course, there are many ways to layout a tree on
a plane without edge intersection. But it would be useful if both local tree
properties and global distance relations would be represented using the layout. We
can require that
In a two-dimensional layout, all k-stars should be represented equiangular;
this is the small penalty configuration;
The edge lengths should be proportional to their length in the
multidimensional embedding; thus one can represent between-node
distances.
This defines a tree layout up to global rotation and scaling and also up to changing
the order of leaves in every k-star. We can change this order to eliminate edge
intersections, but the result can not be guaranteed. In order to represent the global
distance structure, it was found that a good approximation
for the order of k-star leaves can be taken from the projection of every k-star on
the linear principal plane calculated for all data points, or on the local principal
plane in the vicinity of the k-star, calculated only for the points close to this star.
The resulting layout can be further optimized using some greedy optimization
The point projections are then represented as pie diagrams, where the size of the
diagram reflects the number of points projected into the corresponding tree node.
The sectors of the diagram allow us to show proportions of points of different
classes projected into the node (see an example on Fig. 3).
This data display was called a “metro map” since it is a schematic and ―idealized‖
representation of the tree and the data distribution with inevitable distortions made
to produce a 2D layout. However, using this map one can still estimate the
distance from a point (tree node) to a point passing through other points. This map
is inherently unrooted (as a real metro map). It is useful to compare this metaphor
with trees produced by hierarchical clustering where the metaphor is closer to a
―genealogy tree‖.
PRINCIPAL CUBIC COMPLEXES
Elastic nets introduced above are characterized by their internal dimension
dim(G). The way to generalize these characteristics on other elastic graphs is to
utilize the notion of cubic complex .
Definition. Elastic cubic complex K of internal dimension r is a Cartesian product
G1 ×…× Gr of elastic graphs G1, . . .Gr . It has the vertex set V1 × . . . × Vr. Let
1 ≤ i ≤ r and vj  Vj (j ≠ i). For this set of vertices, {vj}j ≠ i, a copy of Gi in
G1 × ... ×Gr is defined with vertices (v1, …, vi−1, v, vi+1, …, vr) (v  Vi), edges
((v1, …, vi−1, v, vi+1, …, vr), (v1, …, vi−1, v‟, vi+1, …, vr)), (v, v‟)  Ei ,
and, similarly, k-stars of the form (v1, …, vi−1, Sk, vi+1, …, vr), where Sk is a k-star
in Gi. For any Gi there are
copies of Gi in G. Sets of edges and k-stars for
Cartesian product are unions of that set through all copies of all factors. A map
φ : V1 × . . . × Vr 
Rm maps all the copies of factors into Rm too.
Remark. By construction, the energy of the elastic graph product is the energy
sum of all factor copies. It is, of course, a quadratic functional of .
If we approximate multidimensional data by an r-dimensional object, the number
of points (or, more generally, elements) in this object grows with r exponentially.
This is an obstacle for grammar–based algorithms even for modest r, because for
analysis of the rule A 
B applications we should investigate all isomorphic
copies of A in G. Introduction of a cubic complex is useful factorization of the
principal object which allows to avoid this problem.
The only difference between the construction of general elastic graphs and
factorized graphs is in the application of the transformations. For factorized
graphs, we apply them to factors. This approach significantly reduces the amount
of trials in selection of the optimal application. The simple grammar with two
rules, ―add a node to a node, or bisect an edge,‖ is also powerful here, it produces
products of primitive elastic trees. For such a product, the elastic structure is
defined by the topology of the factors.
INCOMPLETE DATA
Some of the methods described above allow us to use incomplete data in a natural
way. Let us represent an incomplete observation by
where the ‗@‘ symbol denotes a missing value.
Definition. Scalar product between two incomplete observations x and y is
. Then the Euclidean distance is
Remark. This definition has a very natural geometrical interpretation: an
incomplete observation with k missing values is represented by a k–dimensional
linear manifold Lk, parallel to k coordinate axes corresponding to the missing data.
Thus, any method which uses only scalar products or/and Euclidean distances can
be applied for incomplete data with some minimal modifications subject to
random and not too dense distribution of missing values in X. For example, the
iterative method for SVD for incomplete data matrix was developed ; Gorban & Rossiev, 1999).
There are, of course, other approaches to incomplete data in unsupervised learning
 ).
IMPLICIT METHODS
Most of the principal objects introduced in this paper are constructed as explicit
geometrical objects embedded in Rm to which we can calculate the distance from
any object in X. In this way, they generalize the ―data approximation‖-based (#1)
and the ―variation-maximization‖-based (#2) definitions of linear PCA. There also
exists the whole family of methods, which we only briefly mention here, that
generalize the ―distance distortion minimization‖ definition of PCA (#3).
First, some methods take as input a pairwise distance (or, more generally,
dissimilarity) matrix D and construct such a configuration of points in a lowdimensional Euclidean space that the distance matrix D‟ in this space reproduce D
with maximal precision. The most fundamental in this series is the metric
multidimensional scaling . The next is the Kernel PCA approach
 which takes advantage of the fact that for the linear PCA
algorithm one needs only the matrix of pairwise scalar products (Gramm matrix)
but not the explicit values of coordinates of X. It allows to apply the kernel trick
 and substitute the Gramm matrix by the scalar products
calculated with use of some kernel functions. Kernel PCA method is tightly
related to the classical multidimensional scaling .
Local Linear Embedding or LLE searches for such a N×N
matrix A that approximates given xi by a linear combination of n vectorsneighbours of xi:
, where only such
, if k is one
of the n closest to xi vectors. After one constructs such a configuration of points in
Rs, s << m, that
, yiRs , for all i = 1…N. The coordinates of such
embedding are given by the eigenvectors of the matrix (1-A)T(1-A).
ISOMAP and Laplacian eigenmap
 methods start with construction of
the neighbourhood graph, i.e. the graph in which close in some sense data points
are connected by (weighted) edges. This weighted graph can be represented in the
form of a weighted adjacency matrix W= {Wij}. From this graph, ISOMAP
constructs a new distance matrix D(ISOMAP), based on the path lengths between two
points in the neighbourhood graph, and the multidimensional scaling is applied to
D(ISOMAP). The Laplacian map solves the eigenproblem
, L = S – W is the Laplacian matrix. The trivial
constant solution corresponding to the smallest eigenvalue 
= 0 is discarded,
while the elements of the eigenvectors
give the s-dimensional projection of xi, i.e. P(xi)= {
Finally, one can implicitly construct projections into smaller dimensional spaces
by training auto-associative neural networks with narrow hidden layer. An
overview of the existing Neural PCA methods can be found in the recent
collection of review papers .
EXAMPLE: PRINCIPAL OBJECTS FOR THE IRIS DATASET
On Fig. 3 we show application of the elastic principal manifolds and principal
trees algorithms to the standard Iris dataset . As expected, twodimensional approximation of the principal manifold in this case is close to the
linear principal plane. One can also see that the principal tree illustrates well the
fact of almost complete separation of classes in data space.
EXAMPLE: PRINCIPAL OBJECTS FOR MOLECULAR SURFACES
A molecular surface defines the effective region of space which is occupied by a
molecule. For example, the Van-der-Waals molecular surface is formed by
surrounding every atom in the molecule by a sphere of radius equal to the
characteristic radius of the Van-der-Waals force. After all the interior points are
eliminated, this forms a complicated non-smooth surface in 3D. In practice, this
surface is sampled by a finite number of points.
Using principal manifolds methodology, we constructed a smooth approximation
of such molecular surface for a small piece of a DNA molecule (several
nucleotides long). First, we have made an approximation of this dataset by a 1D
principal curve. Interestingly, this curve followed the backbone of the molecule,
forming a helix (see Fig. 4). Second, we approximated the molecular surface by a
2D manifold. The topology of the surface is expected to be spherical, so we
applied spherical topology of the elastic net for optimisation.
Fig. 4. Principal objects approximating molecular surface of a short stretch of DNA
molecule. a) stick-and-balls model of the DNA stretch and the initial molecular surface
(black points); b) one- and two-dimensional spherical principal manifolds for the
molecular surface; c) simple principal cubic complex (product of principal trees) which
does not have any branching in this case.
We should notice that since it is impossible to make the lengths of all edges equal
for the spherical grid, corrections were performed for the edge elasticities during
the grid initialization (shorter edges are given larger 
is). Third, we applied the
method for constructing principal cubic complexes, namely, graph product of
principal trees, which produced somewhat trivial construction (because no
branching was energetically optimal): product of two short elastic principal
curves, forming a double helix.
Fig. 5. Seven cluster structures presented for 4 selected genomes. A genome is
represented as a collection of points (text fragments represented by their triplet
frequencies) in the 64-multidimensional space. Color codes denote point classes
corresponding to 6 possible frameshifts when a random fragment overlaps with a coding
gene (3 in the forward and 3 in the backward direction of the gene), and the black color
corresponds to non-coding regions. For every genome a principal tree (“metro map”
layout) is shown together with 2D PCA projection of the data distribution. Note that the
clusters that appear to be mixed on the PCA plot for Escherichia coli (they remain mixed
in 3D PCA as well) are well separated on the “metro map”. This proves that they are
well-separated in R64.
EXAMPLE: PRINCIPAL OBJECTS DECIPHER GENOME
A dataset X can be constructed for a string sequence using a short word frequency
dictionary approach in the following way: 1) the notion of word is defined; 2) the
set of all possible short words is defined, let us say that we have m of them; 3) a
number N of text fragments of certain width is sampled from the text; 4) in each
fragment the frequency of occurrences of all possible short words is calculated
and, thus, each fragment is represented as a vector in multidimensional space Rm.
The whole text then is represented as a dataset of N vectors embedded in Rm.
We systematically applied this approach to available bacterial genomic sequences
 . In our case we defined: 1) a word is a sequence of
three letters from the {A,C,G,T} alphabet (triplet); 2) evidently, there are 64
possible triplets in the {A,C,G,T} alphabet; 3) we sampled 5000-10000 fragments
of width 300 from a genomic sequence; 4) we calculated the frequencies of nonoverlapping triplets for every fragment.
The constructed datasets are interesting objects for data-mining, because 1) they
have a non-trivial cluster structure which usually contains various configurations
of 7 clusters (see Fig. 5); 2) class labels can be assigned to points accordingly to
available genome annotations; in our case we put information about presence (in
one of six possible frameshifts) or absence of the coding information in the
current position of a genome; 3) using data mining techniques here has immediate
applications in the field of automatic gene recognition and in others, see, for
example, . On Fig. 5 we show application of both classical
PCA and the metro map methods for several bacterial genomes. Look at
 web-site for further information.
EXAMPLE: NON-LINEAR PRINCIPAL MANIFOLDS FOR MICROARRAY DATA
VISUALIZATION
DNA microarray data is a rich source of information for molecular biology ). This technology
found numerous applications in understanding various biological processes
including cancer. It allows to screen simultaneously the expression of all genes in
a cell exposed to some specific conditions (for example, stress, cancer, treatment,
normal conditions). Obtaining a sufficient number of observations (chips), one
can construct a table of "samples vs genes", containing logarithms of the
expression levels of, typically several thousands (n) of genes, in typically several
tens (m) of samples.
On Fig. 6 we provide a comparison of data visualization scatters after projection
of the breast cancer dataset, provided by Wang et al. , onto the linear two-
and non-linear two-dimensional principal manifold. The latter one is constructed
by the elastic maps approach. Each point here represents a patient treated from
cancer. Before dimension reduction it is represented as a vector in Rn, containing
the expression values for all n genes in the tumor sample. Linear and non-linear
2D principal manifolds provide mappings Rn 
R2, drastically reducing vector
dimensions and allowing data visualization. The form, the shape and the size of
the point on the Fig.6 represent various clinical data (class labels) extracted from
the patient‘s disease records.
Practical experience from bioinformatics studies shows that two-dimensional data
visualization using non-linear projections allow to catch more signals from data
(in the form of clusters or specific regions of higher point density) than linear
projections, see Fig. 6 and a good example by Ivakhno & Armstrong .
Figure 6. Visualization of breast cancer microarray dataset using elastic maps. Ab initio
classifications are shown using points size (ER, estrogen receptor status), shape (Group
A – patients with aggressive cancer, Group B – patients with non-aggressive cancer) and
color (TYPE, molecular type of breast cancer). a) Configuration of nodes projected into
the three-dimensional principal linear manifold. One clear feature is that the dataset is
curved such that it can not be mapped adequately onto a two-dimensional principal
plane. b) The distribution of points in the internal non-linear manifold coordinates is
shown together with estimation of the two-dimensional density of points. c) The same as
b) but for the linear two-dimensional manifold. One can notice that the ``basal'' breast
cancer subtype is much better separated on the non-linear mapping and some features of
the distribution become better resolved.
In addition to that, Gorban & Zinovyev performed a systematic
comparison of performance of low-dimensional linear and non-linear principal
manifolds for microarray data visualization, using the following four criteria:
1) mean-square distance error; 2) distortions in mapping the big distances between
points; 3) local point neighbourhood preservation; 4) compactness of point class
labels after projection. It was demonstrated that non-linear two-dimensional
principal manifolds provide systematically better results accordingly to all these
criteria, achieving the performance of three- and four- dimensional linear principal
manifolds (principal components).
The interactive ViMiDa (Visualization of Microarray Data) and ViDaExpert
software allowing microarray data visualization with use of non-linear principal
manifolds are available on the web-site of Institut Curie (Paris):
 and 
CONCLUSION
In this chapter we gave a brief practical introduction into the methods of
construction of principal objects, i.e. objects embedded in the ‗middle‘ of the
multidimensional data set. As a basis, we took the unifying framework of mean
squared distance approximation of finite datasets which allowed us to look at the
principal graphs and manifolds as generalizations of the mean point notion.