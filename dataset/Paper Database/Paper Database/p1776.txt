Playlist Prediction via Metric Embedding
Cornell University
Dept. of Computer Science
Ithaca, NY, USA
 
Joshua L. Moore
Cornell University
Dept. of Computer Science
Ithaca, NY, USA
 
Douglas Turnbull
Ithaca College
Dept. of Computer Science
Ithaca, NY, USA
 
Thorsten Joachims
Cornell University
Dept. of Computer Science
Ithaca, NY, USA
 
Digital storage of personal music collections and cloud-based
music services (e.g. Pandora, Spotify) have fundamentally
changed how music is consumed. In particular, automatically generated playlists have become an important mode of
accessing large music collections. The key goal of automated
playlist generation is to provide the user with a coherent listening experience. In this paper, we present Latent Markov
Embedding (LME), a machine learning algorithm for generating such playlists.
In analogy to matrix factorization
methods for collaborative ﬁltering, the algorithm does not
require songs to be described by features a priori, but it
learns a representation from example playlists. We formulate this problem as a regularized maximum-likelihood embedding of Markov chains in Euclidian space, and show how
the resulting optimization problem can be solved eﬃciently.
An empirical evaluation shows that the LME is substantially
more accurate than adaptations of smoothed n-gram models
commonly used in natural language processing.
Categories and Subject Descriptors
I.2.6 [Artiﬁcial Intelligence]: Learning; I.5.1 [Pattern
Recognition]: Models
General Terms
Algorithms, Experimentation, Human Factors
Music Playlists, Recommendation, User Modeling, Sequences
INTRODUCTION
A music consumer can store thousands of songs on his or
her computer, portable music player, or smart phone. In
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
KDD’12, August 12–16, 2012, Beijing, China.
Copyright 2012 ACM 978-1-4503-1462-6 /12/08 ...$15.00.
addition, when using a cloud-based service like Rhapsody
or Spotify, the consumer has instant on-demand access to
millions of songs. This has created substantial interest in
automatic playlist algorithms that can help consumers explore large collections of music. Companies like Apple and
Pandora have developed successful commercial playlist algorithms, but relatively little is known about how these algorithms work and how well they perform in rigorous evaluations.
Despite the large commercial demand, comparably little
scholarly work has been done on automated methods for
playlist generation (e.g., ), and the results to
date indicate that it is far from trivial to operationally de-
ﬁne what makes a playlist coherent. The most comprehensive study was done by . Working under a model where
a coherent playlist is deﬁned by a Markov chain with transition probabilities reﬂecting similarity of songs, they ﬁnd that
neither audio-signal similarity nor social-tag-based similarity naturally reﬂect manually constructed playlists.
In this paper, we therefore take an approach to playlist
prediction that does not rely on content-based features, and
that is analogous to matrix decomposition methods in collaborative ﬁltering . Playlists are treated as Markov chains
in some latent space, and our algorithm – called Logistic
Markov Embedding (LME) – learns to represent each song
as one (or multiple) points in this space. Training data for
the algorithm consists of existing playlists, which are widely
available on the web. Unlike other collaborative ﬁltering approaches to music recommendation like , ours is
among the ﬁrst (also see ) to directly model the sequential
and directed nature of playlists, and that includes the ability
to sample playlists in a well-founded and eﬃcient way.
In empirical evaluations, the LME algorithm substantially
outperforms traditional n-gram sequence modeling methods
from natural language processing. Unlike such methods, the
LME algorithm does not treat sequence elements as atomic
units without metric properties, but instead provides a generalizing representation of songs in Euclidean space. Technically, it can be viewed as a multi-dimensional scaling problem , where the algorithm infers the metric from a stochastic sequence model. While we focus exclusively on playlist
prediction in this paper, the LME algorithm also provides
interesting opportunities for other sequence prediction problems (e.g. language modeling).
RELATED WORK
Personalized Internet radio has become a popular way of
listening to music. A user seeds a new stream of music by
specifying a favorite artist, a speciﬁc song, or a semantic
tag (e.g., genre, emotion, instrument.) A backend playlist
algorithm then generates a sequence of songs that is related
to the seed concept. While the exact implementation details
of various commercial systems are trade secrets, diﬀerent
companies use diﬀerent forms of music metadata to identify
relevant songs. For example, Pandora relies on the contentbased music analysis by human experts while Apple
iTunes Genius relies on preference ratings and collaborative
ﬁltering . What is not known is the mechanism by which
the playlist algorithms are used to order the set of relevant
songs, nor is it known how well these playlist algorithms
perform in rigorous evaluations.
In the scholarly literature, two recent papers address the
topic of playlist prediction. First, Maillet et al. formulate the playlist ordering problem as a supervised binary
classiﬁcation problem that is trained discriminatively. Positive examples are pairs of songs that appeared in this order
in the training playlists, and negative examples are pairs of
songs selected at random which do not appear together in
order in historical data. Second, McFee and Lanckriet 
take a generative approach by modeling historical playlists
as a Markov chain. That is, the probability of the next song
in a playlist is determined only by acoustic and/or socialtag similarly to the current song. We take a similar Markov
chain approach, but do not require any acoustic or semantic
information about the songs.
While relatively little work has been done on explicitly
modeling playlists, considerably more research has focused
on embedding songs (or artists) into a similarity-based music
space (e.g., .) Our work is most closely related
to research that involves automatically learning the music
embedding. For example, Platt et al. use semantic tags to
learn a Gaussian process kernel function between pairs of
songs . More recently, Weston et al. learn an embedding over a joint semantic space of audio features, tags and
artists by optimizing an evaluation metric (Precision at k)
for various music retrieval tasks . Our approach, however, is substantially diﬀerent from these existing methods,
since it explicitly models the sequential nature of playlists.
Modeling playlists as a Markov chain connects to a large
body of work on sequence modeling in natural language
processing and speech recognition.
In those applications,
a language model of the target language is used to disambiguate uncertainty in the acoustic signal or the translation
model. Smoothed n-gram models (see e.g. ) are the most
commonly used method in language modeling, and we will
compare against such models in our experiments. However,
in natural language processing and speech recognition ngrams are typically used as part of a Hidden Markov Model
(HMM) , not in a plain Markov Model as in our paper.
In the HMM model, each observation in sequence is governed by an hidden state that evolves in Markovian fashion.
The goal for learning to estimate the transition probability
between hidden states as well as the probability of the observations conditioned on the hidden states. Using singular
value decomposition, recent works on embedding the HMM
distribution into a reproducing kernel Hilbert space 
circumvent the inference of the hidden states and make the
model usable as long as kernel can be deﬁned on the domain
of observation. While both this work and our work make
use of embeddings in the context of Markov chains, the two
approaches solve very diﬀerent problems.
Sequenced prediction also has important applications and
related work in other domains. For example, Rendle et al.
 consider the problem of predicting what a customer
would have in his next basket of online purchasing. They
model the transition probabilities between items in two consecutive baskets, and the tensor decomposition technique
they use can be viewed as embedding in a way.
both are sequence prediction problems, the precise modeling
problems are diﬀerent.
Independent of and concurrent with our work, Aizenberg
et al. developed a model related to ours. The major difference lies in two aspects. First, they focus less on the sequential aspect of playlists, but more on using radio playlists
as proxies for user preference data. Second, their model is
based on inner products, while we embed using Euclidean
Euclidian distance seems a more natural choice
for rendering an easy-to-understand visualization from the
embeddings.
Related is also work by Zheleva et al.
Their model, however, is diﬀerent from ours. They use a
Latent Dirichlet Allocation-like graphical model to capture
the hidden taste and mood of songs, which is diﬀerent from
our focus.
METRIC MODEL OF PLAYLISTS
Our goal is to estimate a generative model of coherent playlists which will enable us to eﬃciently sample new
playlists. More formally, given a collection S = {s1, ..., s|S|}
of songs si, we would like to estimate the distribution Pr(p)
of coherent playlists p = (p , ..., p[kp]). Each element p[i] of
a playlist refers to one song from S.
A natural approach is to model playlists as a Markov
chain, where the probability of a playlist p = (p , ..., p[kp])
is decomposed into the product of transition probabilities
Pr(p[i]|p[i−1]) between adjacent songs p[i−1] and p[i].
Pr(p[i]|p[i−1])
For ease of notation, we assume that p is a dedicated
start symbol. Such bigram (or n-gram models more generally) have been widely used in language modeling for speech
recognition and machine translation with great success .
In these applications, the O(|S|n) transition probabilities
Pr(p[i]|p[i−1]) are estimated from a large corpus of text using sophisticated smoothing methods.
While such n-gram approaches can be applied to playlist
prediction in principle, there are fundamental diﬀerence between playlists and language. First, playlists are less constrained than language, so that transition probabilities between songs are closer to uniform. This means that we need
a substantially larger training corpus to observe all of the
(relatively) high-probability transitions even once. Second,
and in contrast to this, we have orders of magnitude less
playlist data to train from than we have written text.
To overcome these problems, we propose a Markov-chain
sequence model that produces a generalizing representation
of songs and song sequences.
Unlike n-gram models that
treat words as atomic units without metric relationships
between each other, our approach seeks to model coherent
Illustration of the Single-Point Model.
The probability of some other song following s depends on its Euclidean distance to s.
playlists as paths through a latent space. In particular, songs
are embedded as points (or multiple points) in this space so
that Euclidean distance between songs reﬂects the transition probabilities. The key learning problem is to determine
the location of each song using existing playlists as training
data. Once each song is embedded, our model can assign
meaningful transition probabilities even to those transitions
that were not seen in the training data.
Note that our approach does not rely on explicit features
describing songs. However, explicit song features can easily
be added to our transition model as outlined below. We will
now introduce two approaches to modeling Pr(p) that both
create an embedding of playlists in Euclidean space.
Single-Point Model
In the simplest model as illustrated in Figure 1, we represent each song s as a single vector X(s) in d-dimensional
Euclidean space M. The key assumption of our model is
that the transition probabilities Pr(p[i]|p[i−1]) are related to
the Euclidean distance ||X(p[i])−X(p[i−1])||2 between p[i−1]
and p[i] in M through the following logistic model:
Pr(p[i]|p[i−1]) =
e−||X(p[i])−X(p[i−1])||2
j=1 e−||X(sj)−X(p[i−1])||2
We will typically abbreviate the partition function in the
denominator as Z(p[i−1]) and the distance ||X(s) −X(s′)||2
as ∆(s, s′) for brevity.
Using a Markov model with this
transition distribution, we can now deﬁne the probability
the of an entire playlist of a given length kp as
Pr(p[i]|p[i−1]) =
e−∆(p[i],p[i−1])2
Our method seeks to discover an embedding of the songs
into this latent space which causes “good” playlists to have
high probability of being generated by this process. This is
inspired by collaborative ﬁltering methods such as ,
which similarly embed users and items into a latent space
to predict users’ ratings of items. However, our approach
diﬀers from these methods in that we wish to predict paths
through the space, as opposed to independent item ratings.
In order to learn the embedding of songs, we use a sample
D = (p1, ..., pn) of existing playlists as training data and
take a maximum likelihood approach. Denoting with X the
matrix of feature vectors describing all songs in the collection
Figure 2: Illustration of the Dual-Point Model. The
probability of some other song following s depends
on the Euclidean distance from the exit vector V (s)
of s to the target song’s entry vector U(·).
S, this leads to the following training problem:
X = argmax
e−∆(p[i],p[i−1])2
Equivalently, we can maximize the log-likelihood
−∆(p[i], p[i−1])
2 −log(Z(p[i−1])).
In Section 5, we describe how to solve this optimization
problem eﬃciently, and we explore various methods for avoiding overﬁtting through regularization in Section 3.3. First,
however, we extend the basic single-point model to a model
that represents each song through a pair of points.
Dual-Point Model
Representing each song using a single point X(s) as in
the previous section has at least two limitations. First, the
Euclidean metric ||X(s)−X(s′)||2 that determines the transition distribution is symmetric, even though the end of a
song may be drastically diﬀerent from its beginning. In this
case, the beginning of song s may be incompatible with song
s′ altogether, and a transition in the opposite direction –
from s′ to s – should be avoided. Second, some songs may
be good transitions between genres, taking a playlist on a
trajectory away from the current location in latent space.
To address these limitations, we now propose to model
each song s using a pair (U(s), V (s)) of points.
U(s) the“entry vector”of song s, and V (s) the“exit vector”.
An illustration of this model is shown in Figure 2.
song s is depicted as an arrow connecting U(s) to V (s).
The “entry vector” U(s) models the interface to the previous
song in the playlist, while the “exit vector” V (s) models the
interface to the next song. The transition from song s to
s′ is then described by a logistic model relating the exit
vector V (s) of song s to the entry vector U(s′) of song s′.
Adapting our notation for this setting by representing the
asymmetric song divergence ||V (s)−U(s′)||2 as ∆2(s, s′) and
the corresponding dual-point partition function as Z2(s), we
obtain the following probabilistic model of a playlist.
Pr(p[i]|p[i−1]) =
e−∆2(p[i],p[i−1])2
Z2(p[i−1])
Similar to Eq. (4), computing the embedding vectors (U(s),
V (s)) for each song can be phrased as a maximum-likelihood
problem for a given training sample of playlists D = (p1, ..., pn),
where V and U are the matrices containing the respective
entry and exit vectors for all songs.
V,U∈ℜ|S|×d
e−∆2(p[i],p[i−1])2
Z2(p[i−1])
As in the single-point case, it is again equivalent to maximize
the log-likelihood:
L(D|V, U) =
−∆2(p[i], p[i−1])
2 −log(Z2(p[i−1])) (8)
Regularization
While the choice of dimensionality d of the latent space
M provides some control of overﬁtting, it is desirable to
have more ﬁne-grained control. We therefore introduce the
following norm-based regularizers that get added to the loglikelihood objective.
The ﬁrst regularizer penalizes the Frobenius norm of the
matrix of feature vectors, leading to
X = argmax
X∈ℜ|S|×d L(D|X) −λ||X||2
for the single point model, and
V,U∈ℜ|S|×d L(D|V, U) −λ(||V ||2
F + ||U||2
for the dual point model. λ is the regularization parameter
which we will set by cross-validation. For increasing values
of λ, this regularizer encourages vectors to stay closer to the
origin. This leads to transition distributions Pr(p[i]|p[i−1])
that are closer to uniform.
For the dual-point model, it also makes sense to regularize
by the distance between the entry and exit vector of each
For most songs, these two vectors should be close.
This leads to the following formulation,
V,U∈ℜ|S|×d L(D|V, U) −λ(||V ||2
F + ||U||2
where ν is a second regularization parameter.
Extending the Model
The basic LME model can be extended in a variety of
ways. We have already seen how the dual-point model can
account for the directionality of playlists. To further demonstrate its modeling ﬂexibility, consider the following extensions to the single-point model. These extension can also be
added to the dual-point model in a straightforward way.
Popularity. The basic LME models have only limited
means of expressing the popularity of a song. By adding a
separate “popularity boost” bi to each song si, the resulting
transition model
Pr(p[i]|p[i−1]) =
e−∆(p[i],p[i−1])2+bi
j e−∆(sj,p[i−1])2+bj
can separate the eﬀect of a song’s popularity from the eﬀect
of its similarity in content to other songs. This can normalize the resulting embedding space with respect to popularity,
and it is easy to see that training the popularity scores bi as
part of Eq. (12) does not substantially change the optimization problem.
User Model. The popularity score is a simple version of
a preference model. In the same way, more complex models
of song quality and user preference can be included as well.
For example, one can add a matrix factorization model to
explain user preferences independent of the sequence context, leading to the following transition model.
Pr(p[i]|p[i−1], u) =
e−∆(p[i],p[i−1])2+A(p[i])T B(u)
j e−∆(sj,p[i−1])2+A(sj)T B(u)
Analogous to models like in , A(s) is a vector describing
song s and B(u) is a vector describing the preferences of
Semantic Tags.
Many songs have semantic tags that
describe genre and other qualitative attributes of the music.
However, not all songs are tagged, and tags do not follow
a standardized vocabulary. It would therefore be desirable
to embed semantic tags in the same Euclidean space as the
songs, enabling the computation of (semantic) distances between tags, as well as between tags and (untagged) songs.
This can be achieved by modeling the prior distribution of
the location of song s based on its tags T(s) in the following
Pr(X(s)|T(s)) = N
Note that this deﬁnition of Pr(X(s)|T(s)) nicely generalizes
the regularizer in (4), which corresponds to an “uninformed”
Normal prior Pr(X(s)) = N(0,
2λId) centered at the origin
of the embedding space. Again, simultaneously optimizing
song embeddings X(s) and tag embeddings M(t) does not
substantially change the optimization problem during training. This extended embedding model for songs and tags is
described in more detail in .
Observable Features.
Some features may be universally available for all songs, in particular features derived
from the audio signal via automated classiﬁcation. Denote
these observable features of song s as O(s). We can then
learn a positive-semideﬁnite matrix W similar to , leading to the following transition model.
Pr(p[i]|p[i−1]) =
e−∆(p[i],p[i−1])2+O(p[i])T W O(p[i−1])
j e−∆(sj,p[i−1])2+O(sj)T W O(p[i−1])
Long-Range Dependencies. A more fundamental problem is the modeling of long-range dependencies in playlists.
While it is straightforward to add extensions for modeling
closeness to some seed song – either during training, or at
the time of playlist generation as discussed in Section 4 –
modeling dependencies beyond n-th order Markov models
is an open question.
However, submodular diversiﬁcation
models from information retrieval (e.g. ) may provide
interesting starting points.
GENERATING PLAYLISTS
computational
perspective,
generating
playlists is very straightforward. Given a seed location in the
embedding space, a playlist is generated through repeated
sampling from the transition distribution. From a usability
perspective, however, there are two problems.
First, how can the user determine a seed location for a
playlist? Fortunately, the metric nature of our models gives
many opportunities for letting the user specify the seed location. It can be either a single song, the centroid of a set
of songs (e.g. by a single artist), or a user may graphically
select a location through a map similar to the one in Figure 3. Furthermore, we have shown in other work how
songs and social tags can be jointly embedded in the metric
space, making it possible to specify seed locations through
keyword queries for semantic tags.
Second, the playlist model that is learned represents an
average model of what constitutes a good playlists. Each
particular user, however, may have preferences that are different from this average model at any particular point in
time. It is therefore important to give the user some control
over the playlist generation process. Fortunately, our model
allows a straightforward parameterization of the transition
distribution. For example, through the parameters α, β and
γ in the following transition distribution
Pr(p[i]|p[i−1], p ) = e−α∆(p[i],p[i−1])2+βbi−γ∆(p[i],p )2
Z(p[i−1], p , α, β, γ)
the user can inﬂuence meaningful and identiﬁable properties
of the playlists that get generated. For example, by setting
α to a value that is less than 1, the model will take larger
steps. By increasing β to be greater than 1, the model will
focus on popular songs. And by setting γ to a positive value,
the playlists will tend to stay close to the seed location. It is
easy to imagine other terms and parameters in the transition
distribution as well.
To give an impression of the generated playlists and the
eﬀects of the parameters, we provide an online demo at
 
SOLVING THE OPTIMIZATION PROB-
In the previous section, the training problems were formulated as the optimization problems in Eq. (5) and (8).
While both have a non-convex objective, we ﬁnd that the
stochastic gradient algorithm described in the following robustly ﬁnds a good solution.
Furthermore, we propose a
heuristic for accelerating gradient computations that substantially improves runtime.
Stochastic Gradient Training
We propose to solve optimization problems (5) and (8)
using the following stochastic gradient method.
describe the algorithm for the dual-point model, since the
algorithm for the single-point model is easily derived from
We start with random initializations for U and V . We also
calculate a matrix T whose elements Tab are the number of
transitions from the sa to sb in the training set. Note that
this matrix is sparse and always requires less storage than
the original playlists. Recall that we have deﬁned ∆2(sa, sb)
as the song divergence ||U(sa) −V (sb)||2 and Z2(sa) as the
dual-point partition function P|S|
l=1 e−∆2(sa,sl)2. We can now
equivalently write the objective in Eq. (8) as
L(D|U, V ) =
Tab l(sa, sb) −Ω(V, U)
where Ω(V, U) is the regularizer and l(sa, sb) is the “local”
log-likelihood term that is concerned with the transition
from sa to sb.
l(sa, sb) =
−∆2(sa, sb)2 −log(Z2(sa))
Denoting with 1[x=y] the indicator function that returns 1 if
the equality is true and 0 otherwise, we can write the derivatives of the local log-likelihood terms and the regularizer as
∂l(sa, sb)
∆2(sa,sb)+
l=1 e−∆2(sa,sl)2−→
∆2(sa, sl)
∂l(sa, sb)
= 1[b=q]2−→
∆2(sa, sb) −2e−∆2(sa,sq)2−→
∆2(sa, sq)
= 2λU(sp) −2ν−→
∆2(sp, sp)
= 2λV (sp) + 2ν−→
∆2(sp, sp)
where we used −→
∆2(s, s′) to denote the vector V (s) −U(s′).
We can now describe the actual stochastic gradient algorithm. The algorithm iterates through all songs sp in turn
and updates the exit vectors for each sp by
U(sp) ←U(sp) + τ
Tpb ∂l(sp, sb)
∂U(sp) −∂Ω(V, U)
For each sp, it also updates the entry vector for each possible
transition (sp, sq) via
V (sq) ←V (sq) + τ
Tpb ∂l(sp, sb)
∂V (sq) −∂Ω(V, U)
τ is a predeﬁned learning rate and N is the number of transitions in training set.
Note that grouping the stochastic
gradient updates by exit songs sp as implemented above is
advantageous, since we can save computation by reusing the
partition function in the denominator of the local gradients
of both U(sp) and V (sq).
More generally, by storing intermediate results of the gradient computation, a complete
iteration of the stochastic gradient algorithm through the
full training set can be done in time O(|S|2). We typically
run the algorithm for T = 100 or 200 iterations, which we
ﬁnd is suﬃcient for convergence.
Landmark Heuristic for Acceleration
The O(|S|2) runtime of the algorithm makes it too slow
for practical applications when the size of S is suﬃciently
large. The root of the problem lies in the gradient computation, since for every local gradient one needs to consider
the transition from the exit song to all the songs in S. This
leads to O(|S|) complexity for each update steps. However,
considering all songs is not really necessary, since most songs
are not likely targets for a transition anyway. These songs
contribute very little mass to the partition function and excluding them will only marginally change the training objective.
We therefore formulate the following modiﬁed training
problem, where we only consider a subset Ci as possible
successors for si.
L(D|U, V ) =
Tab l(sa, sb) −Ω(V, U)
This reduces the complexity of a gradient step to O(|Ci|).
The key problem lies in identifying a suitable candidate set
Ci for each si. Clearly, each Ci should include at least most
of the likely successors of si, which lead us to the following
landmark heuristic.
We randomly pick a certain number (typically 50) of songs
and call them landmarks, and assign each song to the nearest landmark. We also need to specify a threshold r ∈ .
Then for each si, its direct successors observed in the training set are ﬁrst added to the subset Cr
i , because these songs
are always needed to compute the local log-likelihood. We
keep adding songs from nearby landmarks to the subset, until ratio r of the total songs has been included. This deﬁnes
the ﬁnal subset Cr
i . By adopting this heuristic, the gradients
of the local log-likelihood become
∂U(sp) =1[a=p]2
∆2(sa,sb)+
sl∈Crp e−∆2(sa,sl)2−→
∂V (sq) =1[b=q]2−→
∆2(sa, sb) −2e−∆2(sa,sq)2−→
∆2(sa, sq)
where Zr(sa) is the partition function restricted to Cr
sl∈Cra e−∆2(sa,sl)2. Empirically, we update the landmarks
every 10 iterations1, and ﬁx them after 100 iterations to
ensure convergence.
Implementation
We implemented our methods in C. The code is available
online at 
EXPERIMENTS
In the following experiments we will analyze the LME in
comparison to n-gram baselines, explore the eﬀect of the
popularity term and regularization, and assess the computational eﬃciency of the method.
To collect a dataset of playlists for our empirical evaluation, we crawled Yes.com during the period from Dec.
2010 to May 2011. Yes.com is a website that provides radio
playlists of hundreds of stations in the United States. By
using the web based API2, one can retrieve the playlists of
the last 7 days for any station speciﬁed by its genre. Without taking any preference, we collect as much data as we can
by specifying all the possible genres. We then generated two
datasets, which we refer to as yes small and yes big. In the
small dataset, we removed the songs with less than 20, in the
large dataset we only removed songs with less than 5 appearances. The smaller one is composed of 3, 168 unique songs.
It is then divided into into a training set with 134, 431 transitions and a test set with 1, 191, 279 transitions. The larger
one contains 9, 775 songs, a training set with 172, 510 transitions and a test set with 1, 602, 079 transitions. The datasets
are available for download at 
Unless noted otherwise, experiments use the following
setup. Any model (either the LME or the baseline model)
is ﬁrst trained on the training set and then tested on
the test set.
We evaluate test performance using the
average log-likelihood as our metric.
It is deﬁned as
log(Pr(Dtest))/Ntest, where Ntest is the number of transitions in test set. One should note that the division of train-
1A iteration means a full pass on the training dataset.
2 
Garth Brooks
Bob Marley
The Rolling Stones
Michael Jackson
Visual representation of an embedding
in two dimensions with songs from selected artists
highlighted
ing and test set is done so that each song appears at least
once in the training set. This was done to exclude the case
of encountering a new song when doing testing, which any
method would need to treat as a special case and impute
some probability estimate.
What do embeddings look like?
We start with giving a qualitative impression of the embeddings that our method produces. Figure 3 shows the twodimensional single-point embedding of the yes small dataset.
Songs from a few well-known artists are highlighted to provide reference points in the embedding space.
First, it is interesting to note that songs by the same artist
cluster tightly, even though our model has no direct knowledge of which artist performed a song. Second, logical connections among diﬀerent genres are well-represented in the
For example, consider the positions of songs from
Michael Jackson, T.I., and Lady Gaga.
Pop songs from
Michael Jackson could easily transition to the more electronic and dance pop style of Lady Gaga.
Lady Gaga’s
songs, in turn, could make good transitions to some of the
more dance-oriented songs (mainly collaborations with other
artists) of the rap artist T.I., which could easily form a gateway to other hip hop artists.
While the visualization provides interesting qualitative insights, we now provide a quantitative evaluation of model
quality based on predictive power.
How does the LME compare to n-gram
We ﬁrst compare our models against baseline methods
from Natural Language Processing. We consider the following models.
Uniform Model. The choices of any song are equally
likely, with the same probability of 1/|S|.
Avg. log likelihood
single-point LME
dual-point LME
Figure 4: Single/Dual-point LME against baseline
on yes small(left) and yes big(right).
d is the dimensionality of the embedded space.
Unigram Model. Each song si is sampled with probability p(si) =
j nj , where ni is the number of appearances
of si in the training set. p(si) can be considered as the popularity of si. Since each song appears at least once in the
training set, we do not need to worry about the possibility
of p(si) being zero in the testing phase.
Bigram Model. Similar to our models, the bigram model
is also a ﬁrst-order Markov model.
However, transition
probabilities p(sj|si) are estimated directly for every pair
of songs. Note that not every transition from si to sj in
the test set also appears in the training set, and the corresponding p(si|sj) will just give us minus inﬁnity log likelihood contribution when testing. We adopt the Witten-Bell
smoothing technique to solve this problem. The main
idea is to use the transition we have seen in the training set
to estimate the counts of the transitions we have not seen,
and then assign them nonzero probabilities.
We train our LME models without heuristic on both
yes small and yes big. The resulting log-likelihood on the
test set is reported in Figure 4, where d is the dimensionality
of the embedding space. Over the full range of d the singlepoint LME outperforms the baselines by at least one order
of magnitude in terms of likelihood. While the likelihoods
on the big dataset are lower as expected (i.e. there are more
songs to choose from), the relative gain of the single-point
LME over the baselines is even larger for yes big.
The dual-point model performs equally well for models
with low dimension, but shows signs of overﬁtting for higher
dimensionality. We will see in Section 6.4 that regularization
can mitigate this problem.
Among the conventional sequence models, the bigram
model performs best on yes small. However, it fails to beat
the unigram model on yes big (which contains roughly 3
times the number of songs), since it cannot reliably estimate
the huge number of parameters it entails.
Note that the
number of parameters in the bigram model scales quadratically with the number of songs, while it scales only linearly
in the LME models. The following section analyzes in more
detail where the conventional bigram model fails, while the
single-point LME shows no signs of overﬁtting.
Where does the LME win over the n-gram
We now explore in more detail why the LME model out-
Avg. log likelihood
Fraction of transitions
Freq. of transitions in training set
LME log-likelihood
Bigram log-likelihood
Fraction of transitions
Figure 5: Log likelihood on testing transitions with
respect to their frequencies in the training set on
performs the conventional bigram model. In particular, we
explore the extent to which the generalization performance
of the methods depends on whether (and how often) a test
transition was observed in the training set. The ability to
produce reasonable probability estimates even for transitions that were never observed is important, since about
64 percent of the test transitions were not at all observed in
our training set.
For both the single-point LME and the bigram model on
the small dataset, Figure 5 shows the log-likelihood of the
test transitions conditioned on how often that transition was
observed in the training set. The bar graph illustrates what
percentage of test transitions had that given number of occurrences in the training set (i.e.
64% for zero).
be seen that the LME performs comparably to the bigram
model for transitions that were seen in the training set at
least once, but it performs substantially better on previously
unseen transitions. This is a key advantage of the generalizing representation that the LME provides.
What are the effects of regularization?
We now explore whether additional regularization as proposed in Section 3.3 can further improve performance.
For the single-point model on yes small, Figure 6 shows
a comparison between the norm-based regularizer (R1) and
the unregularized models across dimensions 2, 5, 10, 25, 50
and 100. For each dimension, the optimal value of λ was
selected out of the set {0.0001, 0.001, 0.01, 0.1, 1, 10, 20,
50, 100, 500, 1000}.
It can be seen that the regularized
models oﬀer no substantial beneﬁt over the unregularized
model. We conjecture that the amount of training data is
already suﬃcient to estimate the (relatively small) number
of parameters of the single-point model.
Figure 7 shows the results for dual-point models using
three modes of regularization. R1 denotes models with ν =
0, R2 denotes models with λ = 0, and R3 denotes models
trained with ν = λ. Here, the regularized models consistently outperform the unregularized ones. Starting from dimensionality 25, the improvement of adding regularization
is drastic, which saves the dual-point model from being unusable for high dimensionality. It is interesting to note the
eﬀect of R2, which constrains the exit and entry points for
each song to be near each other. Eﬀectively, this squeezes
Avg. log likelihood
No regularization
Eﬀect of regularization for single-point
model on yes small
Avg. log likelihood
No regularization
Eﬀect of regularization for dual-point
model on yes small
the distance between the two points, bringing the dual-point
model closer to the single-point model.
How directional are radio playlists?
Since the single-point model appears to perform better
than the dual-point model, it raises the question of how important directionality is in playlists. We therefore conducted
the following experiment. We train the dual-point model as
usual for d = 5 on yes small, but then reverse all test transitions. The average log-likelihood (over 10 training runs)
on the reversed test transition is −5.960 ± 0.003, while the
log-likelihood of the test transitions in the normal order is
−5.921±0.003. While this diﬀerence is signiﬁcant according
to a binomial sign test (i.e. the reversed likelihood was indeed worse on all 10 runs), the diﬀerence is very small. This
provides evidence that radio playlists appear to not have
many directional constraints. However, playlists for other
settings (e.g. club, tango) may be more directional.
What is the effect of modeling popularity?
As discussed in Section 3.4, an added term for each song
can be used to separate popularity from the geometry of
the resulting embedding. In Figure 8, a comparison of the
popularity-augmented model to the standard model (both
with single-point) on the two datasets is shown. Adding the
popularity terms substantially improves the models for lowdimensional embeddings. Even though the term adds only
one parameter for each song, it can be viewed as adding
Avg. log likelihood
With popularity term
Without popularity term
Figure 8: Eﬀect of popularity term on model likelihood in yes small (left) and yes big (right)
as much expressive power as dozens of additional spatial
parameters per song.
How does the landmark heuristic affect
model quality?
We take the single-point model with d = 5 without regularization as an example in this part. We list the CPU time
per iteration and log-likelihood on both datasets in Table 1
and Table 2. The landmark heuristic signiﬁcantly reduces
the training iteration time to what is almost proportional to
r. However, for low r we see some overhead introduced by
building the landmark data structure. The heuristic yields
results comparable in quality to models trained without the
heuristic when r reaches 0.3 on both datasets. It even gets
slightly better than the no-heuristic method for higher r.
This may be because we excluded songs that are very unlikely to be transitioned to, resulting in some additional regularization.
CPU time/s
Test log-likelihood
No heuristic
Table 1: CPU time and log-likelihood on yes small
CPU time/s
Test log-likelihood
No heuristic
Table 2: CPU time and log-likelihood on yes big
Does our method capture the coherency of
playlists?
We designed the following experiment to see whether our
method captures the coherency of playlists. We train our
Avg. log likelihood
Figure 9: n-hop results on yes small
model on the 1-hop transitions in training dataset, which is
the same as what we did before. However, the test is done
on the n-hop transitions (consider the current song and the
nth song after it as a transition pair) in the test dataset.
The experiments was run on yes small for various values of
d without regularization. Results are reported in Figure 9.
One can observe that for all values of d, the log-likelihood
consistently decreases as n increases.
As n goes up to 6
and above, the curves ﬂatten out. This is evidence that our
method does capture the coherency of the playlists, since
songs that are sequentially close to each other in the playlists
are more likely to form a transition pair.
CONCLUSIONS
We presented a new family of methods for learning a generative model of music playlists using existing playlists as
training data. The methods do not require content features
about songs, but automatically embed songs in Euclidean
space similar to a collaborative ﬁltering method. Our approach oﬀers substantial modeling ﬂexibility, including the
ability to represent song as multiple points, to make use of
regularization for improved robustness in high-dimensional
embeddings, and to incorporate popularity of songs, giving
users more freedom to steer their playlists. Empirically, the
LME outperforms smoothed bigram models from natural
language processing and leads to embeddings that qualitatively reﬂect our intuition of music similarity.
ACKNOWLEDGMENTS
This work was funded in part by NSF Awards IIS-0812091,
IIS-0905467, and IIS-1217686.