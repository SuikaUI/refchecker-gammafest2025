The Annals of Statistics
2008, Vol. 36, No. 3, 1171–1220
DOI: 10.1214/009053607000000677
⃝Institute of Mathematical Statistics, 2008
KERNEL METHODS IN MACHINE LEARNING1
By Thomas Hofmann, Bernhard Sch¨olkopf
and Alexander J. Smola
Darmstadt University of Technology, Max Planck Institute for Biological
Cybernetics and National ICT Australia
We review machine learning methods employing positive deﬁnite
kernels. These methods formulate learning and estimation problems
in a reproducing kernel Hilbert space (RKHS) of functions deﬁned
on the data domain, expanded in terms of a kernel. Working in linear
spaces of function has the beneﬁt of facilitating the construction and
analysis of learning algorithms while at the same time allowing large
classes of functions. The latter include nonlinear functions as well as
functions deﬁned on nonvectorial data.
We cover a wide range of methods, ranging from binary classiﬁers
to sophisticated methods for estimation with structured data.
1. Introduction.
Over the last ten years estimation and learning methods utilizing positive deﬁnite kernels have become rather popular, particularly in machine learning. Since these methods have a stronger mathematical
slant than earlier machine learning methods (e.g., neural networks), there
is also signiﬁcant interest in the statistics and mathematics community for
these methods. The present review aims to summarize the state of the art on
a conceptual level. In doing so, we build on various sources, including Burges
 , Cristianini and Shawe-Taylor , Herbrich and Vapnik and,
in particular, Sch¨olkopf and Smola , but we also add a fair amount of
more recent material which helps unifying the exposition. We have not had
space to include proofs; they can be found either in the long version of the
present paper (see Hofmann et al. ), in the references given or in the
above books.
The main idea of all the described methods can be summarized in one
paragraph. Traditionally, theory and algorithms of machine learning and
Received December 2005; revised February 2007.
1Supported in part by grants of the ARC and by the Pascal Network of Excellence.
AMS 2000 subject classiﬁcations. Primary 30C40; secondary 68T05.
Key words and phrases. Machine learning, reproducing kernels, support vector machines, graphical models.
This is an electronic reprint of the original article published by the
Institute of Mathematical Statistics in The Annals of Statistics,
2008, Vol. 36, No. 3, 1171–1220. This reprint diﬀers from the original in
pagination and typographic detail.
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
statistics has been very well developed for the linear case. Real world data
analysis problems, on the other hand, often require nonlinear methods to detect the kind of dependencies that allow successful prediction of properties
of interest. By using a positive deﬁnite kernel, one can sometimes have the
best of both worlds. The kernel corresponds to a dot product in a (usually
high-dimensional) feature space. In this space, our estimation methods are
linear, but as long as we can formulate everything in terms of kernel evaluations, we never explicitly have to compute in the high-dimensional feature
The paper has three main sections: Section 2 deals with fundamental
properties of kernels, with special emphasis on (conditionally) positive deﬁnite kernels and their characterization. We give concrete examples for such
kernels and discuss kernels and reproducing kernel Hilbert spaces in the context of regularization. Section 3 presents various approaches for estimating
dependencies and analyzing data that make use of kernels. We provide an
overview of the problem formulations as well as their solution using convex
programming techniques. Finally, Section 4 examines the use of reproducing kernel Hilbert spaces as a means to deﬁne statistical models, the focus
being on structured, multidimensional responses. We also show how such
techniques can be combined with Markov networks as a suitable framework
to model dependencies between response variables.
2. Kernels.
2.1. An introductory example.
Suppose we are given empirical data
(x1,y1),...,(xn,yn) ∈X × Y.
Here, the domain X is some nonempty set that the inputs (the predictor
variables) xi are taken from; the yi ∈Y are called targets (the response variable). Here and below, i,j ∈[n], where we use the notation [n] := {1,...,n}.
Note that we have not made any assumptions on the domain X other
than it being a set. In order to study the problem of learning, we need
additional structure. In learning, we want to be able to generalize to unseen
data points. In the case of binary pattern recognition, given some new input
x ∈X , we want to predict the corresponding y ∈{±1} (more complex output
domains Y will be treated below). Loosely speaking, we want to choose y
such that (x,y) is in some sense similar to the training examples. To this
end, we need similarity measures in X and in {±1}. The latter is easier,
as two target values can only be identical or diﬀerent. For the former, we
require a function
k :X × X →R,
(x,x′) 7→k(x,x′)
KERNEL METHODS IN MACHINE LEARNING
A simple geometric classiﬁcation algorithm: given two classes of points (depicted by “o” and “+”), compute their means c+,c−and assign a test input x to the
one whose mean is closer. This can be done by looking at the dot product between x −c
[where c = (c+ + c−)/2] and w := c+ −c−, which changes sign as the enclosed angle passes
through π/2. Note that the corresponding decision boundary is a hyperplane (the dotted
line) orthogonal to w (from Sch¨olkopf and Smola ).
satisfying, for all x,x′ ∈X ,
k(x,x′) = ⟨Φ(x),Φ(x′)⟩,
where Φ maps into some dot product space H, sometimes called the feature
space. The similarity measure k is usually called a kernel, and Φ is called its
feature map.
The advantage of using such a kernel as a similarity measure is that
it allows us to construct algorithms in dot product spaces. For instance,
consider the following simple classiﬁcation algorithm, described in Figure 1,
where Y = {±1}. The idea is to compute the means of the two classes in
the feature space, c+ =
{i:yi=+1} Φ(xi), and c−=
{i:yi=−1} Φ(xi),
where n+ and n−are the number of examples with positive and negative
target values, respectively. We then assign a new point Φ(x) to the class
whose mean is closer to it. This leads to the prediction rule
y = sgn(⟨Φ(x),c+⟩−⟨Φ(x),c−⟩+ b)
with b = 1
2(∥c−∥2 −∥c+∥2). Substituting the expressions for c± yields
⟨Φ(x),Φ(xi)⟩
⟨Φ(x),Φ(xi)⟩
where b = 1
{(i,j):yi=yj=−1} k(xi,xj) −
{(i,j):yi=yj=+1} k(xi,xj)).
Let us consider one well-known special case of this type of classiﬁer. Assume that the class means have the same distance to the origin (hence,
b = 0), and that k(·,x) is a density for all x ∈X. If the two classes are
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
equally likely and were generated from two probability distributions that
are estimated
p+(x) := 1
p−(x) := 1
then (5) is the estimated Bayes decision rule, plugging in the estimates p+
and p−for the true densities.
The classiﬁer (5) is closely related to the Support Vector Machine (SVM )
that we will discuss below. It is linear in the feature space (4), while in the
input domain, it is represented by a kernel expansion (5). In both cases, the
decision boundary is a hyperplane in the feature space; however, the normal
vectors [for (4), w = c+ −c−] are usually rather diﬀerent.
The normal vector not only characterizes the alignment of the hyperplane,
its length can also be used to construct tests for the equality of the two classgenerating distributions (Borgwardt et al. ).
As an aside, note that if we normalize the targets such that ˆyi = yi/|{j :yj =
yi}|, in which case the ˆyi sum to zero, then ∥w∥2 = ⟨K, ˆyˆy⊤⟩F , where ⟨·,·⟩F
is the Frobenius dot product. If the two classes have equal size, then up to a
scaling factor involving ∥K∥2 and n, this equals the kernel-target alignment
deﬁned by Cristianini et al. .
2.2. Positive deﬁnite kernels.
We have required that a kernel satisfy (3),
that is, correspond to a dot product in some dot product space. In the
present section we show that the class of kernels that can be written in the
form (3) coincides with the class of positive deﬁnite kernels. This has farreaching consequences. There are examples of positive deﬁnite kernels which
can be evaluated eﬃciently even though they correspond to dot products in
inﬁnite dimensional dot product spaces. In such cases, substituting k(x,x′)
for ⟨Φ(x),Φ(x′)⟩, as we have done in (5), is crucial. In the machine learning
community, this substitution is called the kernel trick.
Definition 1 (Gram matrix).
Given a kernel k and inputs x1,...,xn ∈
X , the n × n matrix
K := (k(xi,xj))ij
is called the Gram matrix (or kernel matrix) of k with respect to x1,...,xn.
Definition 2 (Positive deﬁnite matrix).
A real n×n symmetric matrix
Kij satisfying
cicjKij ≥0
for all ci ∈R is called positive deﬁnite. If equality in (8) only occurs for
c1 = ··· = cn = 0, then we shall call the matrix strictly positive deﬁnite.
KERNEL METHODS IN MACHINE LEARNING
Definition 3 (Positive deﬁnite kernel).
Let X be a nonempty set. A
function k :X × X →R which for all n ∈N,xi ∈X , i ∈[n] gives rise to a
positive deﬁnite Gram matrix is called a positive deﬁnite kernel. A function
k :X × X →R which for all n ∈N and distinct xi ∈X gives rise to a strictly
positive deﬁnite Gram matrix is called a strictly positive deﬁnite kernel.
Occasionally, we shall refer to positive deﬁnite kernels simply as kernels.
Note that, for simplicity, we have restricted ourselves to the case of real
valued kernels. However, with small changes, the below will also hold for the
complex valued case.
i,j cicj⟨Φ(xi),Φ(xj)⟩= ⟨P
i ciΦ(xi), P
j cjΦ(xj)⟩≥0, kernels of the
form (3) are positive deﬁnite for any choice of Φ. In particular, if X is already
a dot product space, we may choose Φ to be the identity. Kernels can thus be
regarded as generalized dot products. While they are not generally bilinear,
they share important properties with dot products, such as the Cauchy–
Schwarz inequality: If k is a positive deﬁnite kernel, and x1,x2 ∈X , then
k(x1,x2)2 ≤k(x1,x1) · k(x2,x2).
2.2.1. Construction of the reproducing kernel Hilbert space.
We now de-
ﬁne a map from X into the space of functions mapping X into R, denoted
as RX , via
where x 7→k(·,x).
Here, Φ(x) = k(·,x) denotes the function that assigns the value k(x′,x) to
We next construct a dot product space containing the images of the inputs
under Φ. To this end, we ﬁrst turn it into a vector space by forming linear
combinations
αik(·,xi).
Here, n ∈N, αi ∈R and xi ∈X are arbitrary.
Next, we deﬁne a dot product between f and another function g(·) =
j=1 βjk(·,x′
j) (with n′ ∈N, βj ∈R and x′
αiβjk(xi,x′
To see that this is well deﬁned although it contains the expansion coeﬃcients
and points, note that ⟨f,g⟩= Pn′
j=1 βjf(x′
j). The latter, however, does not
depend on the particular expansion of f. Similarly, for g, note that ⟨f,g⟩=
i=1 αig(xi). This also shows that ⟨·,·⟩is bilinear. It is symmetric, as ⟨f,g⟩=
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
⟨g,f⟩. Moreover, it is positive deﬁnite, since positive deﬁniteness of k implies
that, for any function f, written as (11), we have
αiαjk(xi,xj) ≥0.
Next, note that given functions f1,...,fp, and coeﬃcients γ1,...,γp ∈R, we
γiγj⟨fi,fj⟩=
Here, the equality follows from the bilinearity of ⟨·,·⟩, and the right-hand
inequality from (13).
By (14), ⟨·,·⟩is a positive deﬁnite kernel, deﬁned on our vector space of
functions. For the last step in proving that it even is a dot product, we note
that, by (12), for all functions (11),
⟨k(·,x),f⟩= f(x)
and, in particular,
⟨k(·,x),k(·,x′)⟩= k(x,x′).
By virtue of these properties, k is called a reproducing kernel (Aronszajn
Due to (15) and (9), we have
|f(x)|2 = |⟨k(·,x),f⟩|2 ≤k(x,x) · ⟨f,f⟩.
By this inequality, ⟨f,f⟩= 0 implies f = 0, which is the last property that
was left to prove in order to establish that ⟨·,·⟩is a dot product.
Skipping some details, we add that one can complete the space of functions (11) in the norm corresponding to the dot product, and thus gets a
Hilbert space H, called a reproducing kernel Hilbert space (RKHS).
One can deﬁne a RKHS as a Hilbert space H of functions on a set X with
the property that, for all x ∈X and f ∈H, the point evaluations f 7→f(x)
are continuous linear functionals [in particular, all point values f(x) are well
deﬁned, which already distinguishes RKHSs from many L2 Hilbert spaces].
From the point evaluation functional, one can then construct the reproducing kernel using the Riesz representation theorem. The Moore–Aronszajn
theorem (Aronszajn ) states that, for every positive deﬁnite kernel on
X × X , there exists a unique RKHS and vice versa.
There is an analogue of the kernel trick for distances rather than dot
products, that is, dissimilarities rather than similarities. This leads to the
larger class of conditionally positive deﬁnite kernels. Those kernels are de-
ﬁned just like positive deﬁnite ones, with the one diﬀerence being that their
Gram matrices need to satisfy (8) only subject to
KERNEL METHODS IN MACHINE LEARNING
Interestingly, it turns out that many kernel algorithms, including SVMs and
kernel PCA (see Section 3), can be applied also with this larger class of
kernels, due to their being translation invariant in feature space (Hein et al.
 and Sch¨olkopf and Smola ).
We conclude this section with a note on terminology. In the early years of
kernel machine learning research, it was not the notion of positive deﬁnite
kernels that was being used. Instead, researchers considered kernels satisfying the conditions of Mercer’s theorem (Mercer , see, e.g., Cristianini
and Shawe-Taylor and Vapnik ). However, while all such kernels do
satisfy (3), the converse is not true. Since (3) is what we are interested in,
positive deﬁnite kernels are thus the right class of kernels to consider.
2.2.2. Properties of positive deﬁnite kernels.
We begin with some closure
properties of the set of positive deﬁnite kernels.
Proposition 4.
Below, k1,k2,... are arbitrary positive deﬁnite kernels
on X × X , where X is a nonempty set:
(i) The set of positive deﬁnite kernels is a closed convex cone, that is,
(a) if α1,α2 ≥0, then α1k1 + α2k2 is positive deﬁnite; and (b) if k(x,x′) :=
limn→∞kn(x,x′) exists for all x,x′, then k is positive deﬁnite.
(ii) The pointwise product k1k2 is positive deﬁnite.
(iii) Assume that for i = 1,2, ki is a positive deﬁnite kernel on Xi × Xi,
where Xi is a nonempty set. Then the tensor product k1 ⊗k2 and the direct
sum k1 ⊕k2 are positive deﬁnite kernels on (X1 × X2) × (X1 × X2).
The proofs can be found in Berg et al. .
It is reassuring that sums and products of positive deﬁnite kernels are
positive deﬁnite. We will now explain that, loosely speaking, there are no
other operations that preserve positive deﬁniteness. To this end, let C denote the set of all functions ψ:R →R that map positive deﬁnite kernels to
(conditionally) positive deﬁnite kernels (readers who are not interested in
the case of conditionally positive deﬁnite kernels may ignore the term in
parentheses). We deﬁne
C := {ψ|k is a p.d. kernel ⇒ψ(k) is a (conditionally) p.d. kernel},
C′ = {ψ| for any Hilbert space F,
ψ(⟨x,x′⟩F) is (conditionally) positive deﬁnite},
C′′ = {ψ| for all n ∈N:K is a p.d.
n × n matrix ⇒ψ(K) is (conditionally) p.d.},
where ψ(K) is the n × n matrix with elements ψ(Kij).
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
Proposition 5.
C = C′ = C′′.
The following proposition follows from a result of FitzGerald et al. for
(conditionally) positive deﬁnite matrices; by Proposition 5, it also applies for
(conditionally) positive deﬁnite kernels, and for functions of dot products.
We state the latter case.
Proposition 6.
Let ψ :R →R. Then ψ(⟨x,x′⟩F) is positive deﬁnite for
any Hilbert space F if and only if ψ is real entire of the form
with an ≥0 for n ≥0.
Moreover, ψ(⟨x,x′⟩F) is conditionally positive deﬁnite for any Hilbert
space F if and only if ψ is real entire of the form (18) with an ≥0 for
There are further properties of k that can be read oﬀthe coeﬃcients an:
• Steinwart showed that if all an are strictly positive, then the kernel of Proposition 6 is universal on every compact subset S of Rd in the
sense that its RKHS is dense in the space of continuous functions on S in
the ∥· ∥∞norm. For support vector machines using universal kernels, he
then shows (universal) consistency (Steinwart ). Examples of universal kernels are (19) and (20) below.
• In Lemma 11 we will show that the a0 term does not aﬀect an SVM.
Hence, we infer that it is actually suﬃcient for consistency to have an > 0
We conclude the section with an example of a kernel which is positive deﬁnite
by Proposition 6. To this end, let X be a dot product space. The power series
expansion of ψ(x) = ex then tells us that
k(x,x′) = e⟨x,x′⟩/σ2
is positive deﬁnite (Haussler ). If we further multiply k with the positive
deﬁnite kernel f(x)f(x′), where f(x) = e−∥x∥2/2σ2 and σ > 0, this leads to
the positive deﬁniteness of the Gaussian kernel
k′(x,x′) = k(x,x′)f(x)f(x′) = e−∥x−x′∥2/(2σ2).
KERNEL METHODS IN MACHINE LEARNING
2.2.3. Properties of positive deﬁnite functions.
We now let X = Rd and
consider positive deﬁnite kernels of the form
k(x,x′) = h(x −x′),
in which case h is called a positive deﬁnite function. The following characterization is due to Bochner . We state it in the form given by Wendland
Theorem 7.
A continuous function h on Rd is positive deﬁnite if and
only if there exists a ﬁnite nonnegative Borel measure µ on Rd such that
Rd e−i⟨x,ω⟩dµ(ω).
While normally formulated for complex valued functions, the theorem
also holds true for real functions. Note, however, that if we start with an
arbitrary nonnegative Borel measure, its Fourier transform may not be real.
Real-valued positive deﬁnite functions are distinguished by the fact that the
corresponding measures µ are symmetric.
We may normalize h such that h(0) = 1 [hence, by (9), |h(x)| ≤1], in
which case µ is a probability measure and h is its characteristic function. For
instance, if µ is a normal distribution of the form (2π/σ2)−d/2e−σ2∥ω∥2/2 dω,
then the corresponding positive deﬁnite function is the Gaussian e−∥x∥2/(2σ2);
Bochner’s theorem allows us to interpret the similarity measure k(x,x′) =
h(x −x′) in the frequency domain. The choice of the measure µ determines
which frequency components occur in the kernel. Since the solutions of kernel
algorithms will turn out to be ﬁnite kernel expansions, the measure µ will
thus determine which frequencies occur in the estimates, that is, it will
determine their regularization properties—more on that in Section 2.3.2
Bochner’s theorem generalizes earlier work of Mathias, and has itself been
generalized in various ways, that is, by Schoenberg . An important
generalization considers Abelian semigroups (Berg et al. ). In that case,
the theorem provides an integral representation of positive deﬁnite functions
in terms of the semigroup’s semicharacters. Further generalizations were
given by Krein, for the cases of positive deﬁnite kernels and functions with
a limited number of negative squares. See Stewart for further details
and references.
As above, there are conditions that ensure that the positive deﬁniteness
becomes strict.
Proposition 8 (Wendland ).
A positive deﬁnite function is strictly
positive deﬁnite if the carrier of the measure in its representation (22) contains an open subset.
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
This implies that the Gaussian kernel is strictly positive deﬁnite.
An important special case of positive deﬁnite functions, which includes
the Gaussian, are radial basis functions. These are functions that can be
written as h(x) = g(∥x∥2) for some function g : [0,∞[→R. They have the
property of being invariant under the Euclidean group.
2.2.4. Examples of kernels.
We have already seen several instances of
positive deﬁnite kernels, and now intend to complete our selection with a
few more examples. In particular, we discuss polynomial kernels, convolution
kernels, ANOVA expansions and kernels on documents.
Polynomial kernels.
From Proposition 4 it is clear that homogeneous polynomial kernels k(x,x′) = ⟨x,x′⟩p are positive deﬁnite for p ∈N and x,x′ ∈Rd.
By direct calculation, we can derive the corresponding feature map (Poggio
[x]j1 · ··· · [x]jp · [x′]j1 · ··· · [x′]jp = ⟨Cp(x),Cp(x′)⟩,
where Cp maps x ∈Rd to the vector Cp(x) whose entries are all possible
pth degree ordered products of the entries of x (note that [d] is used as a
shorthand for {1,...,d}). The polynomial kernel of degree p thus computes
a dot product in the space spanned by all monomials of degree p in the input
coordinates. Other useful kernels include the inhomogeneous polynomial,
k(x,x′) = (⟨x,x′⟩+ c)p
where p ∈N and c ≥0,
which computes all monomials up to degree p.
Spline kernels.
It is possible to obtain spline functions as a result of kernel
expansions (Vapnik et al. simply by noting that convolution of an even
number of indicator functions yields a positive kernel function. Denote by
IX the indicator (or characteristic) function on the set X, and denote by
⊗the convolution operation, (f ⊗g)(x) :=
Rd f(x′)g(x′ −x)dx′. Then the
B-spline kernels are given by
k(x,x′) = B2p+1(x −x′)
where p ∈N with Bi+1 := Bi ⊗B0.
Here B0 is the characteristic function on the unit ball in Rd. From the
deﬁnition of (25), it is obvious that, for odd m, we may write Bm as the
inner product between functions Bm/2. Moreover, note that, for even m, Bm
is not a kernel.
KERNEL METHODS IN MACHINE LEARNING
Convolutions and structures.
Let us now move to kernels deﬁned on structured objects (Haussler and Watkins ). Suppose the object x ∈X is
composed of xp ∈Xp, where p ∈[P] (note that the sets Xp need not be equal).
For instance, consider the string x = ATG and P = 2. It is composed of the
parts x1 = AT and x2 = G, or alternatively, of x1 = A and x2 = TG. Mathematically speaking, the set of “allowed” decompositions can be thought
of as a relation R(x1,...,xP ,x), to be read as “x1,...,xP constitute the
composite object x.”
Haussler investigated how to deﬁne a kernel between composite objects by building on similarity measures that assess their respective parts;
in other words, kernels kp deﬁned on Xp × Xp. Deﬁne the R-convolution of
k1,...,kP as
[k1 ⋆··· ⋆kP ](x,x′) :=
¯x∈R(x),¯x′∈R(x′)
kp(¯xp, ¯x′
where the sum runs over all possible ways R(x) and R(x′) in which we
can decompose x into ¯x1,..., ¯xP and x′ analogously [here we used the convention that an empty sum equals zero, hence, if either x or x′ cannot be
decomposed, then (k1 ⋆··· ⋆kP )(x,x′) = 0]. If there is only a ﬁnite number
of ways, the relation R is called ﬁnite. In this case, it can be shown that the
R-convolution is a valid kernel (Haussler ).
ANOVA kernels.
Speciﬁc examples of convolution kernels are Gaussians
and ANOVA kernels (Vapnik and Wahba ). To construct an ANOVA
kernel, we consider X = SN for some set S, and kernels k(i) on S × S, where
i = 1,...,N. For P = 1,...,N, the ANOVA kernel of order P is deﬁned as
kP (x,x′) :=
1≤i1<···<iP ≤N
k(ip)(xip,x′
Note that if P = N, the sum consists only of the term for which (i1,...,iP ) =
(1,... ,N), and k equals the tensor product k(1) ⊗··· ⊗k(N). At the other
extreme, if P = 1, then the products collapse to one factor each, and k equals
the direct sum k(1) ⊕···⊕k(N). For intermediate values of P, we get kernels
that lie in between tensor products and direct sums.
ANOVA kernels typically use some moderate value of P, which speciﬁes
the order of the interactions between attributes xip that we are interested
in. The sum then runs over the numerous terms that take into account
interactions of order P; fortunately, the computational cost can be reduced
to O(Pd) cost by utilizing recurrent procedures for the kernel evaluation.
ANOVA kernels have been shown to work rather well in multi-dimensional
SV regression problems (Stitson et al. ).
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
Bag of words.
One way in which SVMs have been used for text categorization (Joachims ) is the bag-of-words representation. This maps a given
text to a sparse vector, where each component corresponds to a word, and
a component is set to one (or some other number) whenever the related
word occurs in the text. Using an eﬃcient sparse representation, the dot
product between two such vectors can be computed quickly. Furthermore,
this dot product is by construction a valid kernel, referred to as a sparse
vector kernel. One of its shortcomings, however, is that it does not take into
account the word ordering of a document. Other sparse vector kernels are
also conceivable, such as one that maps a text to the set of pairs of words
that are in the same sentence (Joachims and Watkins ).
n-grams and suﬃx trees.
A more sophisticated way of dealing with string
data was proposed by Haussler and Watkins . The basic idea is
as described above for general structured objects (26): Compare the strings
by means of the substrings they contain. The more substrings two strings
have in common, the more similar they are. The substrings need not always
be contiguous; that said, the further apart the ﬁrst and last element of a
substring are, the less weight should be given to the similarity. Depending
on the speciﬁc choice of a similarity measure, it is possible to deﬁne more
or less eﬃcient kernels which compute the dot product in the feature space
spanned by all substrings of documents.
Consider a ﬁnite alphabet Σ, the set of all strings of length n, Σn, and
the set of all ﬁnite strings, Σ∗:= S∞
n=0 Σn. The length of a string s ∈Σ∗is
denoted by |s|, and its elements by s(1)...s(|s|); the concatenation of s and
t ∈Σ∗is written st. Denote by
#(x,s)#(x′,s)cs
a string kernel computed from exact matches. Here #(x,s) is the number of
occurrences of s in x and cs ≥0.
Vishwanathan and Smola provide an algorithm using suﬃx trees,
which allows one to compute for arbitrary cs the value of the kernel k(x,x′)
in O(|x| + |x′|) time and memory. Moreover, also f(x) = ⟨w,Φ(x)⟩can be
computed in O(|x|) time if preprocessing linear in the size of the support
vectors is carried out. These kernels are then applied to function prediction
(according to the gene ontology) of proteins using only their sequence information. Another prominent application of string kernels is in the ﬁeld of
splice form prediction and gene ﬁnding (R¨atsch et al. ).
For inexact matches of a limited degree, typically up to ǫ = 3, and strings
of bounded length, a similar data structure can be built by explicitly generating a dictionary of strings and their neighborhood in terms of a Hamming
distance (Leslie et al. ). These kernels are deﬁned by replacing #(x,s)
KERNEL METHODS IN MACHINE LEARNING
by a mismatch function #(x,s,ǫ) which reports the number of approximate
occurrences of s in x. By trading oﬀcomputational complexity with storage
(hence, the restriction to small numbers of mismatches), essentially lineartime algorithms can be designed. Whether a general purpose algorithm exists
which allows for eﬃcient comparisons of strings with mismatches in linear
time is still an open question.
Mismatch kernels.
In the general case it is only possible to ﬁnd algorithms
whose complexity is linear in the lengths of the documents being compared,
and the length of the substrings, that is, O(|x| · |x′|) or worse. We now
describe such a kernel with a speciﬁc choice of weights (Cristianini and
Shawe-Taylor and Watkins ).
Let us now form subsequences u of strings. Given an index sequence i :=
(i1,...,i|u|) with 1 ≤i1 < ··· < i|u| ≤|s|, we deﬁne u := s(i) := s(i1)...s(i|u|).
We call l(i) := i|u| −i1 + 1 the length of the subsequence in s. Note that if i
is not contiguous, then l(i) > |u|.
The feature space built from strings of length n is deﬁned to be Hn :=
R(Σn). This notation means that the space has one dimension (or coordinate)
for each element of Σn, labeled by that element (equivalently, we can think
of it as the space of all real-valued functions on Σn). We can thus describe
the feature map coordinate-wise for each u ∈Σn via
[Φn(s)]u :=
Here, 0 < λ ≤1 is a decay parameter: The larger the length of the subsequence in s, the smaller the respective contribution to [Φn(s)]u. The sum
runs over all subsequences of s which equal u.
For instance, consider a dimension of H3 spanned (i.e., labeled) by the
string asd. In this case we have [Φ3(Nasdaq)]asd = λ3, while [Φ3(lass das)]asd =
2λ5. In the ﬁrst string, asd is a contiguous substring. In the second string,
it appears twice as a noncontiguous substring of length 5 in lass das, the
two occurrences are lass das and lass das.
The kernel induced by the map Φn takes the form
[Φn(s)]u[Φn(t)]u =
(i,j):s(i)=t(j)=u
λl(i)λl(j).
The string kernel kn can be computed using dynamic programming; see
Watkins .
The above kernels on string, suﬃx-tree, mismatch and tree kernels have
been used in sequence analysis. This includes applications in document analysis and categorization, spam ﬁltering, function prediction in proteins, annotations of dna sequences for the detection of introns and exons, named
entity tagging of documents and the construction of parse trees.
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
Locality improved kernels.
It is possible to adjust kernels to the structure
of spatial data. Recall the Gaussian RBF and polynomial kernels. When
applied to an image, it makes no diﬀerence whether one uses as x the image
or a version of x where all locations of the pixels have been permuted. This
indicates that function space on X induced by k does not take advantage of
the locality properties of the data.
By taking advantage of the local structure, estimates can be improved.
On biological sequences (Zien et al. ) one may assign more weight to the
entries of the sequence close to the location where estimates should occur.
For images, local interactions between image patches need to be considered. One way is to use the pyramidal kernel (DeCoste and Sch¨olkopf 
and Sch¨olkopf ). It takes inner products between corresponding image
patches, then raises the latter to some power p1, and ﬁnally raises their sum
to another power p2. While the overall degree of this kernel is p1p2, the ﬁrst
factor p1 only captures short range interactions.
Tree kernels.
We now discuss similarity measures on more structured objects. For trees Collins and Duﬀy propose a decomposition method which
maps a tree x into its set of subtrees. The kernel between two trees x,x′ is
then computed by taking a weighted sum of all terms between both trees.
In particular, Collins and Duﬀy show a quadratic time algorithm, that
is, O(|x| · |x′|) to compute this expression, where |x| is the number of nodes
of the tree. When restricting the sum to all proper rooted subtrees, it is
possible to reduce the computational cost to O(|x| + |x′|) time by means of
a tree to string conversion (Vishwanathan and Smola ).
Graph kernels.
Graphs pose a twofold challenge: one may both design a
kernel on vertices of them and also a kernel between them. In the former
case, the graph itself becomes the object deﬁning the metric between the
vertices. See G¨artner and Kashima et al. for details on the latter.
In the following we discuss kernels on graphs.
Denote by W ∈Rn×n the adjacency matrix of a graph with Wij > 0 if an
edge between i,j exists. Moreover, assume for simplicity that the graph is
undirected, that is, W ⊤= W. Denote by L = D −W the graph Laplacian
and by ˜L = 1 −D−1/2WD−1/2 the normalized graph Laplacian. Here D is
a diagonal matrix with Dii = P
j Wij denoting the degree of vertex i.
Fiedler showed that, the second largest eigenvector of L approximately decomposes the graph into two parts according to their sign. The
other large eigenvectors partition the graph into correspondingly smaller
portions. L arises from the fact that for a function f deﬁned on the vertices
of the graph P
i,j(f(i) −f(j))2 = 2f ⊤Lf.
Finally, Smola and Kondor show that, under mild conditions and
up to rescaling, L is the only quadratic permutation invariant form which
can be obtained as a linear function of W.
KERNEL METHODS IN MACHINE LEARNING
Hence, it is reasonable to consider kernel matrices K obtained from L
(and ˜L). Smola and Kondor suggest kernels K = r(L) or K = r(˜L),
which have desirable smoothness properties. Here r :[0,∞) →[0,∞) is a
monotonically decreasing function. Popular choices include
r(ξ) = exp(−λξ)
diﬀusion kernel,
r(ξ) = (ξ + λ)−1
regularized graph Laplacian,
r(ξ) = (λ −ξ)p
p-step random walk,
where λ > 0 is chosen such as to reﬂect the amount of diﬀusion in (30), the
degree of regularization in (31) or the weighting of steps within a random
walk (32) respectively. Equation (30) was proposed by Kondor and Laﬀerty
 . In Section 2.3.2 we will discuss the connection between regularization
operators and kernels in Rn. Without going into details, the function r(ξ)
describes the smoothness properties on the graph and L plays the role of
the Laplace operator.
Kernels on sets and subspaces.
Whenever each observation xi consists of
a set of instances, we may use a range of methods to capture the speciﬁc
properties of these sets (for an overview, see Vishwanathan et al. ):
• Take the average of the elements of the set in feature space, that is, φ(xi) =
j φ(xij). This yields good performance in the area of multi-instance
• Jebara and Kondor extend the idea by dealing with distributions
pi(x) such that φ(xi) = E[φ(x)], where x ∼pi(x). They apply it to image
classiﬁcation with missing pixels.
• Alternatively, one can study angles enclosed by subspaces spanned by
the observations. In a nutshell, if U,U′ denote the orthogonal matrices
spanning the subspaces of x and x′ respectively, then k(x,x′) = detU⊤U′.
Fisher kernels.
 have designed kernels building on probability density
models p(x|θ). Denote by
Uθ(x) := −∂θ log p(x|θ),
I := Ex[Uθ(x)U⊤
the Fisher scores and the Fisher information matrix respectively. Note that
for maximum likelihood estimators Ex[Uθ(x)] = 0 and, therefore, I is the
covariance of Uθ(x). The Fisher kernel is deﬁned as
k(x,x′) := U⊤
θ (x)I−1Uθ(x′) or k(x,x′) := U⊤
θ (x)Uθ(x′)
depending on whether we study the normalized or the unnormalized kernel
respectively.
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
In addition to that, it has several attractive theoretical properties: Oliver
et al. show that estimation using the normalized Fisher kernel corresponds to estimation subject to a regularization on the L2(p(·|θ)) norm.
Moreover, in the context of exponential families (see Section 4.1 for a
more detailed discussion) where p(x|θ) = exp(⟨φ(x),θ⟩−g(θ)), we have
k(x,x′) = [φ(x) −∂θg(θ)][φ(x′) −∂θg(θ)]
for the unnormalized Fisher kernel. This means that up to centering by
∂θg(θ) the Fisher kernel is identical to the kernel arising from the inner
product of the suﬃcient statistics φ(x). This is not a coincidence. In fact,
in our analysis of nonparametric exponential families we will encounter this
fact several times (cf. Section 4 for further details). Moreover, note that the
centering is immaterial, as can be seen in Lemma 11.
The above overview of kernel design is by no means complete. The reader
is referred to books of Bakir et al. , Cristianini and Shawe-Taylor ,
Herbrich , Joachims , Sch¨olkopf and Smola , Sch¨olkopf and
Shawe-Taylor and Cristianini for further examples and details.
2.3. Kernel function classes.
2.3.1. The representer theorem.
From kernels, we now move to functions
that can be expressed in terms of kernel expansions. The representer theorem (Kimeldorf and Wahba and Sch¨olkopf and Smola ) shows that
solutions of a large class of optimization problems can be expressed as kernel
expansions over the sample points. As above, H is the RKHS associated to
the kernel k.
Theorem 9 (Representer theorem).
Denote by Ω:[0,∞) →R a strictly
monotonic increasing function, by X a set, and by c:(X × R2)n →R ∪{∞}
an arbitrary loss function. Then each minimizer f ∈H of the regularized
risk functional
c((x1,y1,f(x1)),...,(xn,yn,f(xn))) + Ω(∥f∥2
admits a representation of the form
αik(xi,x).
Monotonicity of Ωdoes not prevent the regularized risk functional (37)
from having multiple local minima. To ensure a global minimum, we would
need to require convexity. If we discard the strictness of the monotonicity,
then it no longer follows that each minimizer of the regularized risk admits
KERNEL METHODS IN MACHINE LEARNING
an expansion (38); it still follows, however, that there is always another
solution that is as good, and that does admit the expansion.
The signiﬁcance of the representer theorem is that although we might be
trying to solve an optimization problem in an inﬁnite-dimensional space H,
containing linear combinations of kernels centered on arbitrary points of X ,
it states that the solution lies in the span of n particular kernels—those
centered on the training points. We will encounter (38) again further below,
where it is called the Support Vector expansion. For suitable choices of loss
functions, many of the αi often equal 0.
Despite the ﬁniteness of the representation in (38), it can often be the
case that the number of terms in the expansion is too large in practice.
This can be problematic in practice, since the time required to evaluate (38)
is proportional to the number of terms. One can reduce this number by
computing a reduced representation which approximates the original one in
the RKHS norm (e.g., Sch¨olkopf and Smola ).
2.3.2. Regularization properties.
The regularizer ∥f∥2
H used in Theorem 9,
which is what distinguishes SVMs from many other regularized function estimators (e.g., based on coeﬃcient based L1 regularizers, such as the Lasso
(Tibshirani ) or linear programming machines (Sch¨olkopf and Smola
 )), stems from the dot product ⟨f,f⟩k in the RKHS H associated with a
positive deﬁnite kernel. The nature and implications of this regularizer, however, are not obvious and we shall now provide an analysis in the Fourier domain. It turns out that if the kernel is translation invariant, then its Fourier
transform allows us to characterize how the diﬀerent frequency components
of f contribute to the value of ∥f∥2
H. Our exposition will be informal (see
also Poggio and Girosi and Smola et al. ), and we will implicitly
assume that all integrals are over Rd and exist, and that the operators are
well deﬁned.
We will rewrite the RKHS dot product as
⟨f,g⟩k = ⟨Υf,Υg⟩= ⟨Υ2f,g⟩,
where Υ is a positive (and thus symmetric) operator mapping H into a
function space endowed with the usual dot product
f(x)g(x) dx.
Rather than (39), we consider the equivalent condition (cf. Section 2.2.1)
⟨k(x,·),k(x′,·)⟩k = ⟨Υk(x,·),Υk(x′,·)⟩= ⟨Υ2k(x,·),k(x′,·)⟩.
If k(x,·) is a Green function of Υ2, we have
⟨Υ2k(x,·),k(x′,·)⟩= ⟨δx,k(x′,·)⟩= k(x,x′),
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
which by the reproducing property (15) amounts to the desired equality
For conditionally positive deﬁnite kernels, a similar correspondence can
be established, with a regularization operator whose null space is spanned
by a set of functions which are not regularized [in the case (17), which is
sometimes called conditionally positive deﬁnite of order 1, these are the
constants].
We now consider the particular case where the kernel can be written
k(x,x′) = h(x −x′) with a continuous strictly positive deﬁnite function
h ∈L1(Rd) (cf. Section 2.2.3). A variation of Bochner’s theorem, stated by
Wendland , then tells us that the measure corresponding to h has a
nonvanishing density υ with respect to the Lebesgue measure, that is, that
k can be written as
e−i⟨x−x′,ω⟩υ(ω)dω =
e−i⟨x,ω⟩e−i⟨x′,ω⟩υ(ω)dω.
We would like to rewrite this as ⟨Υk(x,·),Υk(x′,·)⟩for some linear operator
Υ. It turns out that a multiplication operator in the Fourier domain will do
the job. To this end, recall the d-dimensional Fourier transform, given by
F[f](ω) := (2π)−d/2
f(x)e−i⟨x,ω⟩dx,
with the inverse F −1[f](x) = (2π)−d/2
f(ω)ei⟨x,ω⟩dω.
Next, compute the Fourier transform of k as
F[k(x,·)](ω) = (2π)−d/2
(υ(ω′)e−i⟨x,ω′⟩)ei⟨x′,ω′⟩dω′e−i⟨x′,ω⟩dx′
= (2π)d/2υ(ω)e−i⟨x,ω⟩.
Hence, we can rewrite (43) as
k(x,x′) = (2π)−d
Z F[k(x,·)](ω)F[k(x′,·)](ω)
If our regularization operator maps
Υ:f 7→(2π)−d/2υ−1/2F[f],
we thus have
(Υk(x,·))(ω)(Υk(x′,·))(ω) dω,
that is, our desired identity (41) holds true.
As required in (39), we can thus interpret the dot product ⟨f,g⟩k in the
RKHS as a dot product
R (Υf)(ω)(Υg)(ω) dω. This allows us to understand
KERNEL METHODS IN MACHINE LEARNING
regularization properties of k in terms of its (scaled) Fourier transform υ(ω).
Small values of υ(ω) amplify the corresponding frequencies in (48). Penalizing ⟨f,f⟩k thus amounts to a strong attenuation of the corresponding
frequencies. Hence, small values of υ(ω) for large ∥ω∥are desirable, since
high-frequency components of F[f] correspond to rapid changes in f. It
follows that υ(ω) describes the ﬁlter properties of the corresponding regularization operator Υ. In view of our comments following Theorem 7, we
can translate this insight into probabilistic terms: if the probability measure
υ(ω)dω describes the desired ﬁlter properties, then the natural translation
invariant kernel to use is the characteristic function of the measure.
2.3.3. Remarks and notes.
The notion of kernels as dot products in
Hilbert spaces was brought to the ﬁeld of machine learning by Aizerman
et al. , Boser at al. , Sch¨olkopf at al. and Vapnik . Aizerman
et al. used kernels as a tool in a convergence proof, allowing them to apply the Perceptron convergence theorem to their class of potential function
algorithms. To the best of our knowledge, Boser et al. were the ﬁrst to
use kernels to construct a nonlinear estimation algorithm, the hard margin
predecessor of the Support Vector Machine, from its linear counterpart, the
generalized portrait (Vapnik and Vapnik and Lerner ). While all
these uses were limited to kernels deﬁned on vectorial data, Sch¨olkopf 
observed that this restriction is unnecessary, and nontrivial kernels on other
data types were proposed by Haussler and Watkins . Sch¨olkopf et al.
 applied the kernel trick to generalize principal component analysis and
pointed out the (in retrospect obvious) fact that any algorithm which only
uses the data via dot products can be generalized using kernels.
In addition to the above uses of positive deﬁnite kernels in machine learning, there has been a parallel, and partly earlier development in the ﬁeld of
statistics, where such kernels have been used, for instance, for time series
analysis (Parzen ), as well as regression estimation and the solution of
inverse problems (Wahba ).
In probability theory, positive deﬁnite kernels have also been studied in
depth since they arise as covariance kernels of stochastic processes; see,
for example, Lo`eve . This connection is heavily being used in a subset
of the machine learning community interested in prediction with Gaussian
processes (Rasmussen and Williams ).
In functional analysis, the problem of Hilbert space representations of
kernels has been studied in great detail; a good reference is Berg at al. ;
indeed, a large part of the material in the present section is based on that
work. Interestingly, it seems that for a fairly long time, there have been
two separate strands of development (Stewart ). One of them was the
study of positive deﬁnite functions, which started later but seems to have
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
been unaware of the fact that it considered a special case of positive deﬁnite
kernels. The latter was initiated by Hilbert and Mercer , and was
pursued, for instance, by Schoenberg . Hilbert calls a kernel k deﬁnit if
k(x,x′)f(x)f(x′)dxdx′ > 0
for all nonzero continuous functions f, and shows that all eigenvalues of the
corresponding integral operator f 7→
a k(x,·)f(x)dx are then positive. If k
satisﬁes the condition (50) subject to the constraint that
a f(x)g(x)dx = 0,
for some ﬁxed function g, Hilbert calls it relativ deﬁnit. For that case, he
shows that k has at most one negative eigenvalue. Note that if f is chosen
to be constant, then this notion is closely related to the one of conditionally
positive deﬁnite kernels; see (17). For further historical details, see the review
of Stewart or Berg at al. .
3. Convex programming methods for estimation.
As we saw, kernels
can be used both for the purpose of describing nonlinear functions subject
to smoothness constraints and for the purpose of computing inner products
in some feature space eﬃciently. In this section we focus on the latter and
how it allows us to design methods of estimation based on the geometry of
the problems at hand.
Unless stated otherwise, E[·] denotes the expectation with respect to all
random variables of the argument. Subscripts, such as EX[·], indicate that
the expectation is taken over X. We will omit them wherever obvious. Finally, we will refer to Eemp[·] as the empirical average with respect to an
n-sample. Given a sample S := {(x1,y1),...,(xn,yn)} ⊆X × Y, we now aim
at ﬁnding an aﬃne function f(x) = ⟨w,φ(x)⟩+ b or in some cases a function f(x,y) = ⟨φ(x,y),w⟩such that the empirical risk on S is minimized.
In the binary classiﬁcation case this means that we want to maximize the
agreement between sgnf(x) and y.
• Minimization of the empirical risk with respect to (w,b) is NP-hard (Minsky and Papert ). In fact, Ben-David et al. show that even approximately minimizing the empirical risk is NP-hard, not only for linear
function classes but also for spheres and other simple geometrical objects.
This means that even if the statistical challenges could be solved, we still
would be confronted with a formidable algorithmic problem.
• The indicator function {yf(x) < 0} is discontinuous and even small changes
in f may lead to large changes in both empirical and expected risk. Properties of such functions can be captured by the VC-dimension (Vapnik
and Chervonenkis ), that is, the maximum number of observations
which can be labeled in an arbitrary fashion by functions of the class.
Necessary and suﬃcient conditions for estimation can be stated in these
KERNEL METHODS IN MACHINE LEARNING
terms (Vapnik and Chervonenkis ). However, much tighter bounds
can be obtained by also using the scale of the class (Alon et al. ). In
fact, there exist function classes parameterized by a single scalar which
have inﬁnite VC-dimension (Vapnik ).
Given the diﬃculty arising from minimizing the empirical risk, we now discuss algorithms which minimize an upper bound on the empirical risk, while
providing good computational properties and consistency of the estimators.
A discussion of the statistical properties follows in Section 3.6.
3.1. Support vector classiﬁcation.
Assume that S is linearly separable,
that is, there exists a linear function f(x) such that sgnyf(x) = 1 on S. In
this case, the task of ﬁnding a large margin separating hyperplane can be
viewed as one of solving (Vapnik and Lerner )
subject to
yi(⟨w,x⟩+ b) ≥1.
Note that ∥w∥−1f(xi) is the distance of the point xi to the hyperplane
H(w,b) := {x|⟨w,x⟩+ b = 0}. The condition yif(xi) ≥1 implies that the
margin of separation is at least 2∥w∥−1. The bound becomes exact if equality
is attained for some yi = 1 and yj = −1. Consequently, minimizing ∥w∥
subject to the constraints maximizes the margin of separation. Equation (51)
is a quadratic program which can be solved eﬃciently (Fletcher ).
Mangasarian devised a similar optimization scheme using ∥w∥1 instead of ∥w∥2 in the objective function of (51). The result is a linear program. In general, one can show (Smola et al. ) that minimizing the ℓp
norm of w leads to the maximizing of the margin of separation in the ℓq
norm where 1
q = 1. The ℓ1 norm leads to sparse approximation schemes
(see also Chen et al. ), whereas the ℓ2 norm can be extended to Hilbert
spaces and kernels.
To deal with nonseparable problems, that is, cases when (51) is infeasible,
we need to relax the constraints of the optimization problem. Bennett and
Mangasarian and Cortes and Vapnik impose a linear penalty on the
violation of the large-margin constraints to obtain
subject to
yi(⟨w,xi⟩+ b) ≥1 −ξi and ξi ≥0,∀i ∈[n].
Equation (52) is a quadratic program which is always feasible (e.g., w,b = 0
and ξi = 1 satisfy the constraints). C > 0 is a regularization constant trading
oﬀthe violation of the constraints vs. maximizing the overall margin.
Whenever the dimensionality of X exceeds n, direct optimization of (52)
is computationally ineﬃcient. This is particularly true if we map from X
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
into an RKHS. To address these problems, one may solve the problem in
dual space as follows. The Lagrange function of (52) is given by
L(w,b,ξ,α,η) = 1
αi(1 −ξi −yi(⟨w,xi⟩+ b)) −
where αi,ηi ≥0 for all i ∈[n]. To compute the dual of L, we need to identify
the ﬁrst order conditions in w,b. They are given by
αiyixi = 0
∂ξiL = C −αi + ηi = 0.
This translates into w = Pn
i=1 αiyixi, the linear constraint Pn
i=1 αiyi = 0,
and the box-constraint αi ∈[0,C] arising from ηi ≥0. Substituting (54) into
L yields the Wolfe dual
subject to
α⊤y = 0 and αi ∈[0,C], ∀i ∈[n].
Q ∈Rn×n is the matrix of inner products Qij := yiyj⟨xi,xj⟩. Clearly, this can
be extended to feature maps and kernels easily via Kij := yiyj⟨Φ(xi),Φ(xj)⟩=
yiyjk(xi,xj). Note that w lies in the span of the xi. This is an instance of
the representer theorem (Theorem 9). The KKT conditions (Boser et al.
 , Cortes and Vapnik , Karush and Kuhn and Tucker ) require
that at optimality αi(yif(xi) −1) = 0. This means that only those xi may
appear in the expansion (54) for which yif(xi) ≤1, as otherwise αi = 0. The
xi with αi > 0 are commonly referred to as support vectors.
Note that Pn
i=1 ξi is an upper bound on the empirical risk, as yif(xi) ≤0
implies ξi ≥1 (see also Lemma 10). The number of misclassiﬁed points xi
itself depends on the conﬁguration of the data and the value of C. Ben-David
et al. show that ﬁnding even an approximate minimum classiﬁcation
error solution is diﬃcult. That said, it is possible to modify (52) such that
a desired target number of observations violates yif(xi) ≥ρ for some ρ ∈
R by making the threshold itself a variable of the optimization problem
(Sch¨olkopf et al. ). This leads to the following optimization problem
(ν-SV classiﬁcation):
KERNEL METHODS IN MACHINE LEARNING
subject to
yi(⟨w,xi⟩+ b) ≥ρ −ξi and ξi ≥0.
The dual of (56) is essentially identical to (55) with the exception of an
additional constraint:
subject to
α⊤y = 0 and α⊤1 = nν and αi ∈ .
One can show that for every C there exists a ν such that the solution of
(57) is a multiple of the solution of (55). Sch¨olkopf et al. prove that
solving (57) for which ρ > 0 satisﬁes the following:
1. ν is an upper bound on the fraction of margin errors.
2. ν is a lower bound on the fraction of SVs.
Moreover, under mild conditions, with probability 1, asymptotically, ν equals
both the fraction of SVs and the fraction of errors.
This statement implies that whenever the data are suﬃciently well separable (i.e., ρ > 0), ν-SV classiﬁcation ﬁnds a solution with a fraction of at
most ν margin errors. Also note that, for ν = 1, all αi = 1, that is, f becomes
an aﬃne copy of the Parzen windows classiﬁer (5).
3.2. Estimating the support of a density.
We now extend the notion of
linear separation to that of estimating the support of a density (Sch¨olkopf
et al. and Tax and Duin ). Denote by X = {x1,...,xn} ⊆X the
sample drawn from P(x). Let C be a class of measurable subsets of X and
let λ be a real-valued function deﬁned on C. The quantile function (Einmal
and Mason ) with respect to (P,λ,C) is deﬁned as
U(µ) = inf{λ(C)|P(C) ≥µ,C ∈C}
where µ ∈(0,1].
We denote by Cλ(µ) and Cm
λ (µ) the (not necessarily unique) C ∈C that
attain the inﬁmum (when it is achievable) on P(x) and on the empirical
measure given by X respectively. A common choice of λ is the Lebesgue
measure, in which case Cλ(µ) is the minimum volume set C ∈C that contains
at least a fraction µ of the probability mass.
Support estimation requires us to ﬁnd some Cm
λ (µ) such that |P(Cm
µ| is small. This is where the complexity trade-oﬀenters: On the one hand,
we want to use a rich class C to capture all possible distributions, on the
other hand, large classes lead to large deviations between µ and P(Cm
Therefore, we have to consider classes of sets which are suitably restricted.
This can be achieved using an SVM regularizer.
SV support estimation works by using SV support estimation related
to previous work as follows: set λ(Cw) = ∥w∥2, where Cw = {x|fw(x) ≥ρ},
fw(x) = ⟨w,x⟩, and (w,ρ) are respectively a weight vector and an oﬀset.
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
Stated as a convex optimization problem, we want to separate the data
from the origin with maximum margin via
subject to
⟨w,xi⟩≥ρ −ξi and ξi ≥0.
Here, ν ∈(0,1] plays the same role as in (56), controlling the number of
observations xi for which f(xi) ≤ρ. Since nonzero slack variables ξi are
penalized in the objective function, if w and ρ solve this problem, then the
decision function f(x) will attain or exceed ρ for at least a fraction 1 −ν of
the xi contained in X, while the regularization term ∥w∥will still be small.
The dual of (59) yield:
subject to
α⊤1 = νn and αi ∈ .
To compare (60) to a Parzen windows estimator, assume that k is such that
it can be normalized as a density in input space, such as a Gaussian. Using
ν = 1 in (60), the constraints automatically imply αi = 1. Thus, f reduces to
a Parzen windows estimate of the underlying density. For ν < 1, the equality
constraint (60) still ensures that f is a thresholded density, now depending
only on a subset of X—those which are important for deciding whether
3.3. Regression estimation.
SV regression was ﬁrst proposed in Vapnik
 and Vapnik et al. using the so-called ǫ-insensitive loss function. It
is a direct extension of the soft-margin idea to regression: instead of requiring
that yf(x) exceeds some margin value, we now require that the values y −
f(x) are bounded by a margin on both sides. That is, we impose the soft
constraints
yi −f(xi) ≤ǫi −ξi
f(xi) −yi ≤ǫi −ξ∗
where ξi,ξ∗
i ≥0. If |yi −f(xi)| ≤ǫ, no penalty occurs. The objective function
is given by the sum of the slack variables ξi,ξ∗
i penalized by some C > 0 and
a measure for the slope of the function f(x) = ⟨w,x⟩+ b, that is, 1
Before computing the dual of this problem, let us consider a somewhat
more general situation where we use a range of diﬀerent convex penalties
for the deviation between yi and f(xi). One may check that minimizing
2∥w∥2 + C Pm
i=1 ξi + ξ∗
i subject to (61) is equivalent to solving
ψ(yi −f(xi))
where ψ(ξ) = max(0,|ξ| −ǫ).
Choosing diﬀerent loss functions ψ leads to a rather rich class of estimators:
KERNEL METHODS IN MACHINE LEARNING
• ψ(ξ) = 1
2ξ2 yields penalized least squares (LS) regression (Hoerl and Kennard , Morozov , Tikhonov and Wahba ). The corresponding optimization problem can be minimized by solving a linear system.
• For ψ(ξ) = |ξ|, we obtain the penalized least absolute deviations (LAD)
estimator (Bloomﬁeld and Steiger ). That is, we obtain a quadratic
program to estimate the conditional median.
• A combination of LS and LAD loss yields a penalized version of Huber’s
robust regression (Huber and Smola and Sch¨olkopf ). In this case
we have ψ(ξ) = 1
2σξ2 for |ξ| ≤σ and ψ(ξ) = |ξ| −σ
2 for |ξ| ≥σ.
• Note that also quantile regression can be modiﬁed to work with kernels
(Sch¨olkopf et al. ) by using as loss function the “pinball” loss, that
is, ψ(ξ) = (1 −τ)ψ if ψ < 0 and ψ(ξ) = τψ if ψ > 0.
All the optimization problems arising from the above ﬁve cases are convex
quadratic programs. Their dual resembles that of (61), namely,
2(α −α∗)⊤K(α −α∗) + ǫ⊤(α + α∗) −y⊤(α −α∗)
subject to
(α −α∗)⊤1 = 0 and αi,α∗
Here Kij = ⟨xi,xj⟩for linear models and Kij = k(xi,xj) if we map x →Φ(x).
The ν-trick, as described in (56) (Sch¨olkopf et al. ), can be extended
to regression, allowing one to choose the margin of approximation automatically. In this case (63a) drops the terms in ǫ. In its place, we add a linear
constraint (α −α∗)⊤1 = νn. Likewise, LAD is obtained from (63) by dropping the terms in ǫ without additional constraints. Robust regression leaves
(63) unchanged, however, in the deﬁnition of K we have an additional term
of σ−1 on the main diagonal. Further details can be found in Sch¨olkopf and
Smola . For quantile regression we drop ǫ and we obtain diﬀerent constants C(1 −τ) and Cτ for the constraints on α∗and α. We will discuss
uniform convergence properties of the empirical risk estimates with respect
to various ψ(ξ) in Section 3.6.
3.4. Multicategory classiﬁcation, ranking and ordinal regression.
estimation problems cannot be described by assuming that Y = {±1}. In
this case it is advantageous to go beyond simple functions f(x) depending on x only. Instead, we can encode a larger degree of information by
estimating a function f(x,y) and subsequently obtaining a prediction via
ˆy(x) := arg maxy∈Y f(x,y). In other words, we study problems where y is
obtained as the solution of an optimization problem over f(x,y) and we
wish to ﬁnd f such that y matches yi as well as possible for relevant inputs
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
Note that the loss may be more than just a simple 0–1 loss. In the following
we denote by ∆(y,y′) the loss incurred by estimating y′ instead of y. Without
loss of generality, we require that ∆(y,y) = 0 and that ∆(y,y′) ≥0 for all
y,y′ ∈Y. Key in our reasoning is the following:
Let f :X × Y →R and assume that ∆(y,y′) ≥0 with
∆(y,y) = 0. Moreover, let ξ ≥0 such that f(x,y) −f(x,y′) ≥∆(y,y′) −ξ
for all y′ ∈Y. In this case ξ ≥∆(y,argmaxy′∈Y f(x,y′)).
The construction of the estimator was suggested by Taskar et al. and
Tsochantaridis et al. , and a special instance of the above lemma is given
by Joachims . While the bound appears quite innocuous, it allows us to
describe a much richer class of estimation problems as a convex program.
To deal with the added complexity, we assume that f is given by f(x,y) =
⟨Φ(x,y),w⟩. Given the possibly nontrivial connection between x and y, the
use of Φ(x,y) cannot be avoided. Corresponding kernel functions are given
by k(x,y,x′,y′) = ⟨Φ(x,y),Φ(x′,y′)⟩. We have the following optimization
problem (Tsochantaridis et al. ):
subject to
⟨w,Φ(xi,yi) −Φ(xi,y)⟩≥∆(yi,y) −ξi,∀i ∈[n],y ∈Y.
This is a convex optimization problem which can be solved eﬃciently if the
constraints can be evaluated without high computational cost. One typically employs column-generation methods (Bennett et al. , Fletcher ,
Hettich and Kortanek and Tsochantaridis et al. ) which identify
one violated constraint at a time to ﬁnd an approximate minimum of the
optimization problem.
To describe the ﬂexibility of the framework set out by (64) we give several
examples below:
• Binary classiﬁcation can be recovered by setting Φ(x,y) = yΦ(x), in which
case the constraint of (64) reduces to 2yi⟨Φ(xi),w⟩≥1−ξi. Ignoring constant oﬀsets and a scaling factor of 2, this is exactly the standard SVM
optimization problem.
• Multicategory classiﬁcation problems (Allwein et al. , Collins and
Crammer and Singer ) can be encoded via Y = [N], where N is the
number of classes and ∆(y,y′) = 1 −δy,y′. In other words, the loss is 1
whenever we predict the wrong class and 0 for correct classiﬁcation. Corresponding kernels are typically chosen to be δy,y′k(x,x′).
• We can deal with joint labeling problems by setting Y = {±1}n. In other
words, the error measure does not depend on a single observation but on
KERNEL METHODS IN MACHINE LEARNING
an entire set of labels. Joachims shows that the so-called F1 score
(van Rijsbergen ) used in document retrieval and the area under the
ROC curve (Bamber ) fall into this category of problems. Moreover,
Joachims derives an O(n2) method for evaluating the inequality constraint over Y.
• Multilabel estimation problems deal with the situation where we want to
ﬁnd the best subset of labels Y ⊆2[N] which correspond to some observation x. Elisseeﬀand Weston devise a ranking scheme where
f(x,i) > f(x,j) if label i ∈y and j /∈y. It is a special case of an approach
described next.
Note that (64) is invariant under translations Φ(x,y) ←Φ(x,y) + Φ0 where
Φ0 is constant, as Φ(xi,yi) −Φ(xi,y) remains unchanged. In practice, this
means that transformations k(x,y,x′,y′) ←k(x,y,x′,y′) + ⟨Φ0,Φ(x,y)⟩+
⟨Φ0,Φ(x′,y′)⟩+ ∥Φ0∥2 do not aﬀect the outcome of the estimation process.
Since Φ0 was arbitrary, we have the following lemma:
Let H be an RKHS on X × Y with kernel k. Moreover, let
g ∈H. Then the function k(x,y,x′,y′)+f(x,y)+f(x′,y′)+∥g∥2
H is a kernel
and it yields the same estimates as k.
We need a slight extension to deal with general ranking problems. Denote
by Y = Graph[N] the set of all directed graphs on N vertices which do not
contain loops of less than three nodes. Here an edge (i,j) ∈y indicates that
i is preferred to j with respect to the observation x. It is the goal to ﬁnd
some function f :X × [N] →R which imposes a total order on [N] (for a
given x) by virtue of the function values f(x,i) such that the total order
and y are in good agreement.
More speciﬁcally, Crammer and Singer and Dekel et al. propose a
decomposition algorithm A for the graphs y such that the estimation error
is given by the number of subgraphs of y which are in disagreement with
the total order imposed by f. As an example, multiclass classiﬁcation can
be viewed as a graph y where the correct label i is at the root of a directed
graph and all incorrect labels are its children. Multilabel classiﬁcation is
then a bipartite graph where the correct labels only contain outgoing arcs
and the incorrect labels only incoming ones.
This setting leads to a form similar to (64), except for the fact that we
now have constraints over each subgraph G ∈A(y). We solve
subject to
⟨w,Φ(xi,u) −Φ(xi,v)⟩≥1 −ξiG and ξiG ≥0
for all (u,v) ∈G ∈A(yi).
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
That is, we test for all (u,v) ∈G whether the ranking imposed by G ∈yi is
Finally, ordinal regression problems which perform ranking not over labels y but rather over observations x were studied by Herbrich et al. and
Chapelle and Harchaoui in the context of ordinal regression and conjoint
analysis respectively. In ordinal regression x is preferred to x′ if f(x) > f(x′)
and, hence, one minimizes an optimization problem akin to (64), with constraint ⟨w,Φ(xi) −Φ(xj)⟩≥1 −ξij. In conjoint analysis the same operation
is carried out for Φ(x,u), where u is the user under consideration. Similar
models were also studied by Basilico and Hofmann . Further models will
be discussed in Section 4, in particular situations where Y is of exponential
size. These models allow one to deal with sequences and more sophisticated
structures.
3.5. Applications of SVM algorithms.
When SVMs were ﬁrst presented,
they initially met with skepticism in the statistical community. Part of the
reason was that, as described, SVMs construct their decision rules in potentially very high-dimensional feature spaces associated with kernels. Although
there was a fair amount of theoretical work addressing this issue (see Section 3.6 below), it was probably to a larger extent the empirical success of
SVMs that paved its way to become a standard method of the statistical
toolbox. The ﬁrst successes of SVMs on practical problems were in handwritten digit recognition, which was the main benchmark task considered in the
Adaptive Systems Department at AT&T Bell Labs where SVMs were developed. Using methods to incorporate transformation invariances, SVMs were
shown to beat the world record on the MNIST benchmark set, at the time
the gold standard in the ﬁeld (DeCoste and Sch¨olkopf ). There has been
a signiﬁcant number of further computer vision applications of SVMs since
then, including tasks such as object recognition and detection. Nevertheless,
it is probably fair to say that two other ﬁelds have been more inﬂuential in
spreading the use of SVMs: bioinformatics and natural language processing.
Both of them have generated a spectrum of challenging high-dimensional
problems on which SVMs excel, such as microarray processing tasks and
text categorization. For references, see Joachims and Sch¨olkopf et al.
Many successful applications have been implemented using SV classiﬁers;
however, also the other variants of SVMs have led to very good results,
including SV regression, SV novelty detection, SVMs for ranking and, more
recently, problems with interdependent labels (McCallum et al. and
Tsochantaridis et al. ).
At present there exists a large number of readily available software packages for SVM optimization. For instance, SVMStruct, based on Tsochantaridis et al. solves structured estimation problems. LibSVM is an
KERNEL METHODS IN MACHINE LEARNING
open source solver which excels on binary problems. The Torch package
contains a number of estimation methods, including SVM solvers. Several
SVM implementations are also available via statistical packages, such as R.
3.6. Margins and uniform convergence bounds.
While the algorithms
were motivated by means of their practicality and the fact that 0–1 loss
functions yield hard-to-control estimators, there exists a large body of work
on statistical analysis. We refer to the works of Bartlett and Mendelson ,
Jordan et al. , Koltchinskii , Mendelson and Vapnik for
details. In particular, the review of Bousquet et al. provides an excellent summary of the current state of the art. Speciﬁcally for the structured
case, recent work by Collins and Taskar et al. deals with explicit
constructions to obtain better scaling behavior in terms of the number of
class labels.
The general strategy of the analysis can be described by the following
three steps: ﬁrst, the discrete loss is upper bounded by some function, such
as ψ(yf(x)), which can be eﬃciently minimized [e.g. the soft margin function
max(0,1−yf(x)) of the previous section satisﬁes this property]. Second, one
proves that the empirical average of the ψ-loss is concentrated close to its
expectation. This will be achieved by means of Rademacher averages. Third,
one shows that under rather general conditions the minimization of the ψloss is consistent with the minimization of the expected risk. Finally, these
bounds are combined to obtain rates of convergence which only depend on
the Rademacher average and the approximation properties of the function
class under consideration.
4. Statistical models and RKHS.
As we have argued so far, the reproducing kernel Hilbert space approach oﬀers many advantages in machine
learning: (i) powerful and ﬂexible models can be deﬁned, (ii) many results
and algorithms for linear models in Euclidean spaces can be generalized
to RKHS, (iii) learning theory assures that eﬀective learning in RKHS is
possible, for instance, by means of regularization.
In this chapter we will show how kernel methods can be utilized in the
context of statistical models. There are several reasons to pursue such an avenue. First of all, in conditional modeling, it is often insuﬃcient to compute a
prediction without assessing conﬁdence and reliability. Second, when dealing
with multiple or structured responses, it is important to model dependencies between responses in addition to the dependence on a set of covariates.
Third, incomplete data, be it due to missing variables, incomplete training
targets or a model structure involving latent variables, needs to be dealt
with in a principled manner. All of these issues can be addressed by using
the RKHS approach to deﬁne statistical models and by combining kernels
with statistical approaches such as exponential models, generalized linear
models and Markov networks.
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
4.1. Exponential RKHS models.
4.1.1. Exponential models.
Exponential models or exponential families
are among the most important class of parametric models studied in statistics. Given a canonical vector of statistics Φ and a σ-ﬁnite measure ν over
the sample space X , an exponential model can be deﬁned via its probability
density with respect to ν (cf. Barndorﬀ-Nielsen ),
p(x;θ) = exp[⟨θ,Φ(x)⟩−g(θ)]
where g(θ) := ln
e⟨θ,Φ(x)⟩dν(x).
The m-dimensional vector θ ∈Θ with Θ := {θ ∈Rm :g(θ) < ∞} is also called
the canonical parameter vector. In general, there are multiple exponential
representations of the same model via canonical parameters that are aﬃnely
related to one another (Murray and Rice ). A representation with minimal m is called a minimal representation, in which case m is the order of
the exponential model. One of the most important properties of exponential
families is that they have suﬃcient statistics of ﬁxed dimensionality, that is,
the joint density for i.i.d. random variables X1,X2,...,Xn is also exponential, the corresponding canonical statistics simply being Pn
i=1 Φ(Xi). It is
well known that much of the structure of exponential models can be derived
from the log partition function g(θ), in particular,
▽θ g(θ) = µ(θ) := Eθ[Φ(X)],
θg(θ) = Vθ[Φ(X)],
where µ is known as the mean-value map. Being a covariance matrix, the
Hessian of g is positive semi-deﬁnite and, consequently, g is convex.
Maximum likelihood estimation (MLE) in exponential families leads to
a particularly elegant form for the MLE equations: the expected and the
observed canonical statistics agree at the MLE ˆθ. This means, given an
i.i.d. sample S = (xi)i∈[n],
Eˆθ[Φ(X)] = µ(ˆθ) = 1
Φ(xi) := rES[Φ(X)].
4.1.2. Exponential RKHS models.
One can extend the parameteric exponential model in (66) by deﬁning a statistical model via an RKHS H
with generating kernel k. Linear function ⟨θ,Φ(·)⟩over X are replaced with
functions f ∈H, which yields an exponential RKHS model
p(x;f) = exp[f(x) −g(f)],
αxk(·,x),S ⊆X,|S| < ∞
KERNEL METHODS IN MACHINE LEARNING
A justiﬁcation for using exponential RKHS families with rich canonical
statistics as a generic way to deﬁne nonparametric models stems from the
fact that if the chosen kernel k is powerful enough, the associated exponential
families become universal density estimators. This can be made precise using
the concept of universal kernels (Steinwart , cf. Section 2).
Proposition 12 (Dense densities).
Let X be a measurable set with a
ﬁxed σ-ﬁnite measure ν and denote by P a family of densities on X with
respect to ν such that p ∈P is uniformly bounded from above and continuous.
Let k : X × X →R be a universal kernel for H. Then the exponential RKHS
family of densities generated by k according to equation (69) is dense in P
in the L∞sense.
4.1.3. Conditional exponential models.
For the rest of the paper we will
focus on the case of predictive or conditional modeling with a—potentially
compound or structured—response variable Y and predictor variables X.
Taking up the concept of joint kernels introduced in the previous section, we
will investigate conditional models that are deﬁned by functions f : X ×Y →
R from some RKHS H over X × Y with kernel k as follows:
p(y|x;f) = exp[f(x,y) −g(x,f)]
where g(x,f) := ln
ef(x,y) dν(y).
Notice that in the ﬁnite-dimensional case we have a feature map Φ:X ×Y →
Rm from which parametric models are obtained via H := {f :∃w,f(x,y) =
f(x,y;w) := ⟨w,Φ(x,y)⟩} and each f can be identiﬁed with its parameter
w. Let us discuss some concrete examples to illustrate the rather general
model equation (70):
• Let Y be univariate and deﬁne Φ(x,y) = yΦ(x). Then simply f(x,y;w) =
⟨w,Φ(x,y)⟩= y ˜f(x;w), with ˜f(x;w) := ⟨w,Φ(x)⟩and the model equation
in (70) reduces to
p(y|x;w) = exp[y⟨w,Φ(x)⟩−g(x,w)].
This is a generalized linear model (GLM) (McCullagh and Nelder )
with a canonical link, that is, the canonical parameters depend linearly
on the covariates Φ(x). For diﬀerent response scales, we get several wellknown models such as, for instance, logistic regression where y ∈{−1,1}.
• In the nonparameteric extension of generalized linear models following
Green and Yandell and O’Sullivan the parametric assumption
on the linear predictor ˜f(x;w) = ⟨w,Φ(x)⟩in the GLMs is relaxed by
requiring that ˜f comes from some suﬃciently smooth class of functions,
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
namely, an RKHS deﬁned over X . In combination with a parametric part,
this can also be used to deﬁne semi-parametric models. Popular choices of
kernels include the ANOVA kernel investigated by . This is a special
case of deﬁning joint kernels from an existing kernel k over inputs via
k((x,y),(x′,y′)) := yy′k(x,x′).
• Joint kernels provide a powerful framework for prediction problems with
structured outputs. An illuminating example is statistical natural language parsing with lexicalized probabilistic context free grammars (Magerman ). Here x will be an English sentence and y a parse tree for x,
that is, a highly structured and complex output. The productions of the
grammar are known, but the conditional probability p(y|x) needs to be
estimated based on training data of parsed/annotated sentences. In the
simplest case, the extracted statistics Φ may encode the frequencies of the
use of diﬀerent productions in a sentence with a known parse tree. More
sophisticated feature encodings are discussed in Taskar et al. and
Zettlemoyer and Collins . The conditional modeling approach provide alternatives to state-of-the art approaches that estimate joint models
p(x,y) with maximum likelihood or maximum entropy and obtain predictive models by conditioning on x.
4.1.4. Risk functions for model ﬁtting.
There are diﬀerent inference principles to determine the optimal function f ∈H for the conditional exponential model in (70). One standard approach to parametric model ﬁtting is to
maximize the conditional log-likelihood—or equivalently—minimize a logarithmic loss, a strategy pursued in the Conditional Random Field (CRF)
approach of Laﬀerty . Here we consider the more general case of minimizing a functional that includes a monotone function of the Hilbert space norm
∥f∥H as a stabilizer (Wahba ). This reduces to penalized log-likelihood
estimation in the ﬁnite-dimensional case,
Cll(f;S) := −1
lnp(yi|xi;f),
ˆf ll(S) := arg min
H + Cll(f;S).
• For the parametric case, Laﬀerty et al. have employed variants of
improved iterative scaling (Darroch and Ratcliﬀ and Della Pietra
 ) to optimize equation (72), whereas Sha and Pereira have investigated preconditioned conjugate gradient descent and limited memory
quasi-Newton methods.
• In order to optimize equation (72) one usually needs to compute expectations of the canonical statistics Ef[Φ(Y,x)] at sample points x = xi, which
requires the availability of eﬃcient inference algorithms.
KERNEL METHODS IN MACHINE LEARNING
As we have seen in the case of classiﬁcation and regression, likelihoodbased criteria are by no means the only justiﬁable choice and large margin
methods oﬀer an interesting alternative. To that extend, we will present
a general formulation of large margin methods for response variables over
ﬁnite sample spaces that is based on the approach suggested by Altun et al.
 and Taskar et al. . Deﬁne
r(x,y;f) := f(x,y) −max
y′̸=y f(x,y′) = min
y′̸=y log p(y|x;f)
i=1 r(xi,yi;f).
Here r(S;f) generalizes the notion of separation margin used in SVMs.
Since the log-odds ratio is sensitive to rescaling of f, that is, r(x,y;βf) =
βr(x,y;f), we need to constrain ∥f∥H to make the problem well deﬁned. We
thus replace f by φ−1f for some ﬁxed dispersion parameter φ > 0 and deﬁne
the maximum margin problem ˆf mm(S) := φ−1 argmax∥f∥H=1 r(S;f/φ). For
the sake of the presentation, we will drop φ in the following. (We will not
deal with the problem of how to estimate φ here; note, however, that one
does need to know φ in order to make an optimal deterministic prediction.)
Using the same line of arguments as was used in Section 3, the maximum
margin problem can be re-formulated as a constrained optimization problem
ˆf mm(S) := arg min
r(xi,yi;f) ≥1,∀i ∈[n],
provided the latter is feasible, that is, if there exists f ∈H such that r(S;f) >
0. To make the connection to SVMs, consider the case of binary classi-
ﬁcation with Φ(x,y) = yΦ(x), f(x,y;w) = ⟨w,yΦ(x)⟩, where r(x,y;f) =
⟨w,yΦ(x)⟩−⟨w,−yΦ(x)⟩= 2y⟨w,Φ(x)⟩= 2ρ(x,y;w). The latter is twice the
standard margin for binary classiﬁcation in SVMs.
A soft margin version can be deﬁned based on the Hinge loss as follows:
Chl(f;S) := 1
min{1 −r(xi,yi;f),0},
ˆf sm(S) := arg min
H + Chl(f,S).
• An equivalent formulation using slack variables ξi as discussed in Section 3
can be obtained by introducing soft-margin constraints r(xi,yi;f) ≥1−ξi,
ξi ≥0 and by deﬁning Chl = 1
nξi. Each nonlinear constraint can be further
expanded into |Y| linear constraints f(xi,yi) −f(xi,y) ≥1 −ξi for all
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
• Prediction problems with structured outputs often involve task-speciﬁc
loss function △:Y × Y →R discussed in Section 3.4. As suggested in
Taskar et al. cost sensitive large margin methods can be obtained by
deﬁning re-scaled margin constraints f(xi,yi) −f(xi,y) ≥△(yi,y) −ξi.
• Another sensible option in the parametric case is to minimize an exponential risk function of the following type:
ˆf exp(S) := arg min
exp[f(xi,yi;w) −f(xi,y;w)].
This is related to the exponential loss used in the AdaBoost method of
Freund and Schapire . Since we are mainly interested in kernel-based
methods here, we refrain from further elaborating on this connection.
4.1.5. Generalized representer theorem and dual soft-margin formulation.
It is crucial to understand how the representer theorem applies in the setting of arbitrary discrete output spaces, since a ﬁnite representation for the
optimal ˆf ∈{ ˆf ll, ˆf sm} is the basis for constructive model ﬁtting. Notice that
the regularized log-loss, as well as the soft margin functional introduced
above, depends not only on the values of f on the sample S, but rather on
the evaluation of f on the augmented sample ˜S := {(xi,y):i ∈[n],y ∈Y}.
This is the case, because for each xi, output values y ̸= yi not observed with
xi show up in the log-partition function g(xi,f) in (70), as well as in the
log-odds ratios in (73). This adds an additional complication compared to
binary classiﬁcation.
Corollary 13.
Denote by H an RKHS on X × Y with kernel k and
let S = ((xi,yi))i∈[n]. Furthermore, let C(f;S) be a functional depending
on f only via its values on the augmented sample ˜S. Let Ωbe a strictly
monotonically increasing function. Then the solution of the optimization
problem ˆf(S) := arg minf∈H C(f; ˜S) + Ω(∥f∥H) can be written as
βiyk(·,(xi,y)).
This follows directly from Theorem 9.
Let us focus on the soft margin maximizer ˆf sm. Instead of solving (75)
directly, we ﬁrst derive the dual program, following essentially the derivation
in Section 3.
Proposition 14 (Tsochantaridis et al. ).
The minimizer ˆf sm(S)
can be written as in Corollary 13, where the expansion coeﬃcients can be
KERNEL METHODS IN MACHINE LEARNING
computed from the solution of the following convex quadratic program:
α∗= arg min
αiyαjy′Kiy,jy′ −
αiy ≤1, ∀i ∈[n];αiy ≥0,∀i ∈[n],y ∈Y,
where Kiy,jy′ := k((xi,yi),(xj,yj)) + k((xi,y),(xj,y′)) −k((xi,yi),(xj,y′)) −
k((xi,y),(xj,yj)).
• The multiclass SVM formulation of can be recovered as a special
case for kernels that are diagonal with respect to the outputs, that is,
k((x,y),(x′,y′)) = δy,y′k(x,x′). Notice that in this case the quadratic part
in equation (78a) simpliﬁes to
αiyαjy[1 + δyi,yδyj,y −δyi,y −δyj,y].
• The pairs (xi,y) for which αiy > 0 are the support pairs, generalizing
the notion of support vectors. As in binary SVMs, their number can be
much smaller than the total number of constraints. Notice also that in the
ﬁnal expansion contributions k(·,(xi,yi)) will get nonnegative weights,
whereas k(·,(xi,y)) for y ̸= yi will get nonpositive weights. Overall one
gets a balance equation βiyi −P
y̸=yi βiy = 0 for every data point.
4.1.6. Sparse approximation.
Proposition 14 shows that sparseness in
the representation of ˆf sm is linked to the fact that only few αiy in the solution to the dual problem in equation (78) are nonzero. Note that each of
these Lagrange multipliers is linked to the corresponding soft margin constraints f(xi,yi)−f(xi,y) ≥1−ξi. Hence, sparseness is achieved, if only few
constraints are active at the optimal solution. While this may or may not be
the case for a given sample, one can still exploit this observation to deﬁne
a nested sequence of relaxations, where margin constraint are incrementally
added. This corresponds to a constraint selection algorithm (Bertsimas and
Tsitsiklis ) for the primal or, equivalently, a variable selection or column generation method for the dual program and has been investigated in
Tsochantaridis et al. . Solving a sequence of increasingly tighter relaxations to a mathematical problem is also known as an outer approximation.
In particular, one may iterate through the training examples according to
some (fair) visitation schedule and greedily select constraints that are most
violated at the current solution f, that is, for the ith instance one computes
ˆyi = argmax
f(xi,y) = arg max
p(y|xi;f),
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
and then strengthens the current relaxation by including αiˆyi in the optimization of the dual if f(xi,yi) −f(xi, ˆyi) < 1 −ξi −ǫ. Here ǫ > 0 is a
pre-deﬁned tolerance parameter. It is important to understand how many
strengthening steps are necessary to achieve a reasonable close approximation to the original problem. The following theorem provides an answer:
Theorem 15 (Tsochantaridis et al. ).
Let ¯R = maxi,y Kiy,iy and
choose ǫ > 0. A sequential strengthening procedure, which optimizes equation (75) by greedily selecting ǫ-violated constraints, will ﬁnd an approximate solution where all constraints are fulﬁlled within a precision of ǫ, that
is, r(xi,yi;f) ≥1 −ξi −ǫ after at most 2n
ǫ · max{1, 4 ¯R2
λn2ǫ} steps.
Corollary 16.
Denote by ( ˆf, ˆξ) the optimal solution of a relaxation
of the problem in Proposition 14, minimizing R(f,ξ,S) while violating no
constraint by more than ǫ (cf. Theorem 15). Then
R( ˆf, ˆξ,S) ≤R( ˆf sm,ξ∗,S) ≤R( ˆf, ˆξ,S) + ǫ,
where ( ˆf sm,ξ∗) is the optimal solution of the original problem.
• Combined with an eﬃcient QP solver, the above theorem guarantees a
runtime polynomial in n, ǫ−1, ¯R and λ−1. This holds irrespective of special properties of the data set utilized, the only exception being the dependency on the sample points xi is through the radius ¯R.
• The remaining key problem is how to compute equation (79) eﬃciently.
The answer depends on the speciﬁc form of the joint kernel k and/or
the feature map Φ. In many cases, eﬃcient dynamic programming techniques exists, whereas in other cases one has to resort to approximations
or use other methods to identify a set of candidate distractors Yi ⊂Y for
a training pair (xi,yi) (Collins ). Sometimes one may also have search
heuristics available that may not ﬁnd the solution to Equation (79), but
that ﬁnd (other) ǫ-violating constraints with a reasonable computational
4.1.7. Generalized
classiﬁcation.
equation (70) and the minimization of the regularized log-loss can be interpreted as a generalization of Gaussian process classiﬁcation (Altun et al.
 and Rasmussen and Williams ) by assuming that (f(x,·))x∈X is a
vector-valued zero mean Gaussian process; note that the covariance function
C is deﬁned over pairs X × Y. For a given sample S, deﬁne a multi-index
vector F(S) := (f(xi,y))i,y as the restriction of the stochastic process f to
the augmented sample ˜S. Denote the kernel matrix by K = (Kiy,jy′), where
Kiy,jy′ := C((xi,y),(xj,y′)) with indices i,j ∈[n] and y,y′ ∈Y, so that, in
KERNEL METHODS IN MACHINE LEARNING
summary, F(S) ∼N(0,K). This induces a predictive model via Bayesian
model integration according to
p(y|x;S) =
p(y|F(x,·))p(F|S)dF,
where x is a test point that has been included in the sample (transductive
setting). For an i.i.d. sample, the log-posterior for F can be written as
lnp(F|S) = −1
2F T K−1F +
[f(xi,yi) −g(xi,F)] + const.
Invoking the representer theorem for ˆF(S) := argmaxF lnp(F|S), we know
αiyKiy,jy′,
which we plug into equation (81) to arrive at
αT Keiyi + log
exp[αT Keiy]
where eiy denotes the respective unit vector. Notice that for f(·) = P
i,y αiyk(·,
(xi,y)) the ﬁrst term is equivalent to the squared RKHS norm of f ∈H since
⟨f,f⟩H = P
y,y′ αiyαjy′⟨k(·,(xi,y)),k(·,(xj,y′))⟩. The latter inner product reduces to k((xi,y),(xj,y′)) due to the reproducing property. Again, the
key issue in solving (83) is how to achieve spareness in the expansion for ˆF.
4.2. Markov networks and kernels.
In Section 4.1 no assumptions about
the speciﬁc structure of the joint kernel deﬁning the model in equation (70)
has been made. In the following, we will focus on a more speciﬁc setting
with multiple outputs, where dependencies are modeled by a conditional
independence graph. This approach is motivated by the fact that independently predicting individual responses based on marginal response models
will often be suboptimal and explicitly modeling these interactions can be
of crucial importance.
4.2.1. Markov networks and factorization theorem.
Denote predictor variables by X, response variables by Y and deﬁne Z := (X,Y ) with associated
sample space Z. We use Markov networks as the modeling formalism for representing dependencies between covariates and response variables, as well as
interdependencies among response variables.
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
Definition 17.
A conditional independence graph (or Markov network)
is an undirected graph G = (Z,E) such that for any pair of variables (Zi,Zj) /∈
E if and only if Zi ⊥⊥Zj|Z −{Zi,Zj}.
The above deﬁnition is based on the pairwise Markov property, but by
virtue of the separation theorem (see, e.g., Whittaker ) this implies
the global Markov property for distributions with full support. The global
Markov property says that for disjoint subsets U,V,W ⊆Z where W separates U from V in G one has that U ⊥⊥V |W. Even more important in
the context of this paper is the factorization result due to Hammersley and
Cliﬀord .
Theorem 18.
Given a random vector Z with conditional independence
graph G, any density function for Z with full support factorizes over C (G),
the set of maximal cliques of G as follows:
p(z) = exp
where fc are clique compatibility functions dependent on z only via the restriction on clique conﬁgurations zc.
The signiﬁcance of this result is that in order to specify a distribution for
Z, one only needs to specify or estimate the simpler functions fc.
4.2.2. Kernel decomposition over Markov networks.
It is of interest to
analyze the structure of kernels k that generate Hilbert spaces H of functions
that are consistent with a graph.
Definition 19.
A function f :Z →R is compatible with a conditional
independence graph G, if f decomposes additively as f(z) = P
c∈C (G) fc(zc)
with suitably chosen functions fc. A Hilbert space H over Z is compatible
with G, if every function f ∈H is compatible with G. Such f and H are also
called G-compatible.
Proposition 20.
Let H with kernel k be a G-compatible RKHS. Then
there are functions kcd : Zc × Zd →R such that the kernel decomposes as
kcd(uc,zd).
Let X be a set of n-tupels and fi,gi :X × X →R for i ∈[n]
functions such that fi(x,y) = fi(xi,y) and gi(x,y) = gi(x,yi). If P
i fi(xi,y) =
j gj(x,yj) for all x,y, then there exist functions hij such that P
i fi(xi,y) =
i,j hij(xi,yj).
KERNEL METHODS IN MACHINE LEARNING
• Proposition 20 is useful for the design of kernels, since it states that only
kernels allowing an additive decomposition into local functions kcd are
compatible with a given Markov network G. Laﬀerty et al. have pursued a similar approach by considering kernels for RKHS with functions
deﬁned over ZC := {(c,zc) : c ∈c,zc ∈Zc}. In the latter case one can even
deal with cases where the conditional dependency graph is (potentially)
diﬀerent for every instance.
• An illuminating example of how to design kernels via the decomposition in Proposition 20 is the case of conditional Markov chains, for which
models based on joint kernels have been proposed in Altun et al. ,
Collins , Laﬀerty et al. and Taskar et al. . Given an input
sequences X = (Xt)t∈[T], the goal is to predict a sequence of labels or
class variables Y = (Yt)t∈[T], Yt ∈Σ. Dependencies between class variables
are modeled in terms of a Markov chain, whereas outputs Yt are assumed
to depend (directly) on an observation window (Xt−r,...,Xt,...,Xt+r).
Notice that this goes beyond the standard hidden Markov model structure by allowing for overlapping features (r ≥1). For simplicity, we focus on a window size of r = 1, in which case the clique set is given by
C := {ct := (xt,yt,yt+1),c′
t := (xt+1,yt,yt+1):t ∈[T −1]}. We assume an
input kernel k is given and introduce indicator vectors (or dummy variates) I(Y{t,t+1}) := (Iω,ω′(Y{t,t+1}))ω,ω′∈Σ. Now we can deﬁne the local kernel functions as
d) := ⟨I(y{s,s+1})I(y′
k(xs,xt),
if c = cs and d = ct,
k(xs+1,xt+1),
s and d = c′
Notice that the inner product between indicator vectors is zero, unless the
variable pairs are in the same conﬁguration.
Conditional Markov chain models have found widespread applications
in natural language processing (e.g., for part of speech tagging and shallow
parsing, cf. Sha and Pereira ), in information retrieval (e.g., for information extraction, cf. McCallum et al. ) or in computational biology
(e.g., for gene prediction, cf. Culotta et al. ).
4.2.3. Clique-based sparse approximation.
Proposition 20 immediately
leads to an alternative version of the representer theorem as observed by
Laﬀerty et al. and Altum et al. .
Corollary 22.
If H is G-compatible then in the same setting as in
Corollary 13, the optimizer ˆf can be written as
kcd((xic,yc),ud),
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
here xic are the variables of xi belonging to clique c and Yc is the subspace
of Zc that contains response variables.
• Notice that the number of parameters in the representation equation (86)
scales with n · P
c∈C |Yc| as opposed to n · |Y| in equation (77). For cliques
with reasonably small state spaces, this will be a signiﬁcantly more compact representation. Notice also that the evaluation of functions kcd will
typically be more eﬃcient than evaluating k.
• In spite of this improvement, the number of terms in the expansion in
equation (86) may in practice still be too large. In this case, one can pursue
a reduced set approach, which selects a subset of variables to be included
in a sparsiﬁed expansion. This has been proposed in Taskar et al. for
the soft margin maximization problem, as well as in Altun et al. and
Laﬀerty et al. for conditional random ﬁelds and Gaussian processes.
For instance, in Laﬀerty et al. parameters βi
cyc that maximize the
functional gradient of the regularized log-loss are greedily included in the
reduced set. In Taskar et al. a similar selection criterion is utilized
with respect to margin violations, leading to an SMO-like optimization
algorithm (Platt ).
4.2.4. Probabilistic inference.
In dealing with structured or interdependent response variables, computing marginal probabilities of interest or computing the most probable response [cf. equation (79)] may be nontrivial.
However, for dependency graphs with small tree width, eﬃcient inference
algorithms exist, such as the junction tree algorithm (Dawid and Jensen
et al. ) and variants thereof. Notice that in the case of the conditional
or hidden Markov chain, the junction tree algorithm is equivalent to the
well-known forward–backward algorithm (Baum ). Recently, a number
of approximate inference algorithms have been developed to deal with dependency graphs for which exact inference is not tractable (see, e.g., Wainwright
and Jordan ).
5. Kernel methods for unsupervised learning.
This section discusses various methods of data analysis by modeling the distribution of data in feature
space. To that extent, we study the behavior of Φ(x) by means of rather simple linear methods, which have implications for nonlinear methods on the
original data space X . In particular, we will discuss the extension of PCA to
Hilbert spaces, which allows for image denoising, clustering, and nonlinear
dimensionality reduction, the study of covariance operators for the measure
of independence, the study of mean operators for the design of two-sample
tests, and the modeling of complex dependencies between sets of random
variables via kernel dependency estimation and canonical correlation analysis.
KERNEL METHODS IN MACHINE LEARNING
5.1. Kernel principal component analysis.
Principal component analysis (PCA) is a powerful technique for extracting structure from possibly
high-dimensional data sets. It is readily performed by solving an eigenvalue
problem, or by using iterative algorithms which estimate principal components.
PCA is an orthogonal transformation of the coordinate system in which
we describe our data. The new coordinate system is obtained by projection
onto the so-called principal axes of the data. A small number of principal
components is often suﬃcient to account for most of the structure in the
The basic idea is strikingly simple: denote by X = {x1,...,xn} an nsample drawn from P(x). Then the covariance operator C is given by C =
E[(x −E[x])(x −E[x])⊤]. PCA aims at estimating leading eigenvectors of
C via the empirical estimate Cemp = Eemp[(x −Eemp[x])(x −Eemp[x])⊤]. If
X is d-dimensional, then the eigenvectors can be computed in O(d3) time
(Press et al. ).
The problem can also be posed in feature space (Sch¨olkopf et al. )
by replacing x with Φ(x). In this case, however, it is impossible to compute the eigenvectors directly. Yet, note that the image of Cemp lies in the
span of {Φ(x1),...,Φ(xn)}. Hence, it is suﬃcient to diagonalize Cemp in
that subspace. In other words, we replace the outer product Cemp by an inner product matrix, leaving the eigenvalues unchanged, which can be computed eﬃciently. Using w = Pn
i=1 αiΦ(xi), it follows that α needs to satisfy
PKPα = λα, where P is the projection operator with Pij = δij −n−2 and
K is the kernel matrix on X.
Note that the problem can also be recovered as one of maximizing some
Contrast[f,X] subject to f ∈F. This means that the projections onto the
leading eigenvectors correspond to the most reliable features. This optimization problem also allows us to unify various feature extraction methods as
• For Contrast[f,X] = Varemp[f,X] and F = {⟨w,x⟩subject to ∥w∥≤1},
we recover PCA.
• Changing F to F = {⟨w,Φ(x)⟩subject to ∥w∥≤1}, we recover kernel
• For Contrast[f,X] = Curtosis[f,X] and F = {⟨w,x⟩subject to ∥w∥≤1},
we have Projection Pursuit (Friedman and Tukey and Huber ).
Other contrasts lead to further variants, that is, the Epanechikov kernel,
entropic contrasts, and so on (Cook et al. , Friedman and Jones
and Sibson ).
• If F is a convex combination of basis functions and the contrast function
is convex in w, one obtains computationally eﬃcient algorithms, as the
solution of the optimization problem can be found at one of the vertices
(Rockafellar and Sch¨olkopf and Smola ).
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
Subsequent projections are obtained, for example, by seeking directions orthogonal to f or other computationally attractive variants thereof.
Kernel PCA has been applied to numerous problems, from preprocessing and invariant feature extraction (Mika et al. ) to image denoising
and super-resolution (Kim et al. ). The basic idea in the latter case is
to obtain a set of principal directions in feature space w1,...,wl, obtained
from noise-free data, and to project the image Φ(x) of a noisy observation x
onto the space spanned by w1,...,wl. This yields a “denoised” solution ˜Φ(x)
in feature space. Finally, to obtain the pre-image of this denoised solution,
one minimizes ∥Φ(x′) −˜Φ(x)∥. The fact that projections onto the leading
principal components turn out to be good starting points for pre-image iterations is further exploited in kernel dependency estimation (Section 5.3).
Kernel PCA can be shown to contain several popular dimensionality reduction algorithms as special cases, including LLE, Laplacian Eigenmaps and
(approximately) Isomap (Ham et al. ).
5.2. Canonical correlation and measures of independence.
Given two samples X,Y , canonical correlation analysis (Hotelling ) aims at ﬁnding directions of projection u,v such that the correlation coeﬃcient between X
and Y is maximized. That is, (u,v) are given by
Varemp[⟨u,x⟩]−1 Varemp[⟨v,y⟩]−1
× Eemp[⟨u,x −Eemp[x]⟩⟨v,y −Eemp[y]⟩].
This problem can be solved by ﬁnding the eigensystem of C−1/2
where Cx,Cy are the covariance matrices of X and Y and Cxy is the covariance matrix between X and Y , respectively. Multivariate extensions are
discussed in Kettenring .
CCA can be extended to kernels by means of replacing linear projections
⟨u,x⟩by projections in feature space ⟨u,Φ(x)⟩. More speciﬁcally, Bach and
Jordan used the so-derived contrast to obtain a measure of independence
and applied it to Independent Component Analysis with great success. However, the formulation requires an additional regularization term to prevent
the resulting optimization problem from becoming distribution independent.
R´enyi showed that independence between random variables is equivalent to the condition of vanishing covariance Cov[f(x),g(y)] = 0 for all C1
functions f,g bounded by L∞norm 1 on X and Y. In Bach and Jordan
 , Das and Sen , Dauxois and Nkiet and Gretton et al. a
constrained empirical estimate of the above criterion is used. That is, one
Λ(X,Y,F,G) := sup
Covemp[f(x),g(y)]
subject to
f ∈F and g ∈G.
KERNEL METHODS IN MACHINE LEARNING
This statistic is often extended to use the entire series Λ1,...,Λd of maximal correlations where each of the function pairs (fi,gi) are orthogonal to
the previous set of terms. More speciﬁcally Douxois and Nkiet restrict
F,G to ﬁnite-dimensional linear function classes subject to their L2 norm
bounded by 1, Bach and Jordan use functions in the RKHS for which
some sum of the ℓn
2 and the RKHS norm on the sample is bounded.
Gretton et al. use functions with bounded RKHS norm only, which
provides necessary and suﬃcient criteria if kernels are universal. That is,
Λ(X,Y,F,G) = 0 if and only if x and y are independent. Moreover,
trPKxPKyP has the same theoretical properties and it can be computed
much more easily in linear time, as it allows for incomplete Cholesky factorizations. Here Kx and Ky are the kernel matrices on X and Y respectively.
The above criteria can be used to derive algorithms for Independent
Component Analysis (Bach and Jordan and Gretton et al. ). While
these algorithms come at a considerable computational cost, they oﬀer very
good performance. For faster algorithms, consider the work of Cardoso ,
Hyv¨arinen and Lee et al. . Also, the work of Chen and Bickel 
and Yang and Amari is of interest in this context.
Note that a similar approach can be used to develop two-sample tests
based on kernel methods. The basic idea is that for universal kernels the
map between distributions and points on the marginal polytope µ:p →
Ex∼p[φ(x)] is bijective and, consequently, it imposes a norm on distributions. This builds on the ideas of . The corresponding distance d(p,q) :=
∥µ[p] −µ[q]∥leads to a U-statistic which allows one to compute empirical
estimates of distances between distributions eﬃciently .
5.3. Kernel dependency estimation.
A large part of the previous discussion revolved around estimating dependencies between samples X and Y for
rather structured spaces Y, in particular, (64). In general, however, such
dependencies can be hard to compute. Weston et al. proposed an algorithm which allows one to extend standard regularized LS regression models,
as described in Section 3.3, to cases where Y has complex structure.
It works by recasting the estimation problem as a linear estimation problem for the map f :Φ(x) →Φ(y) and then as a nonlinear pre-image estimation problem for ﬁnding ˆy := argminy∥f(x)−Φ(y)∥as the point in Y closest
This problem can be solved directly (Cortes et al. ) without the need
for subspace projections. The authors apply it to the analysis of sequence
6. Conclusion.
We have summarized some of the advances in the ﬁeld
of machine learning with positive deﬁnite kernels. Due to lack of space,
this article is by no means comprehensive, in particular, we were not able to
T. HOFMANN, B. SCH ¨OLKOPF AND A. J. SMOLA
cover statistical learning theory, which is often cited as providing theoretical
support for kernel methods. However, we nevertheless hope that the main
ideas that make kernel methods attractive became clear. In particular, these
include the fact that kernels address the following three major issues of
learning and inference:
• They formalize the notion of similarity of data.
• They provide a representation of the data in an associated reproducing
kernel Hilbert space.
• They characterize the function class used for estimation via the representer theorem [see equations (38) and (86)].
We have explained a number of approaches where kernels are useful. Many
of them involve the substitution of kernels for dot products, thus turning
a linear geometric algorithm into a nonlinear one. This way, one obtains
SVMs from hyperplane classiﬁers, and kernel PCA from linear PCA. There
is, however, a more recent method of constructing kernel algorithms, where
the starting point is not a linear algorithm, but a linear criterion [e.g., that
two random variables have zero covariance, or that the means of two samples
are identical], which can be turned into a condition involving an eﬃcient
optimization over a large function class using kernels, thus yielding tests
for independence of random variables, or tests for solving the two-sample
problem. We believe that these works, as well as the increasing amount of
work on the use of kernel methods for structured data, illustrate that we
can expect signiﬁcant further progress in the years to come.
Acknowledgments.
We thank Florian Steinke, Matthias Hein, Jakob Macke,
Conrad Sanderson, Tilmann Gneiting and Holger Wendland for comments
and suggestions.
The major part of this paper was written at the Mathematisches
Forschungsinstitut Oberwolfach, whose support is gratefully acknowledged.
National ICT Australia is funded through the Australian Government’s
Backing Australia’s Ability initiative, in part through the Australian Research Council.