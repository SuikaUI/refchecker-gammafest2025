Abstract Interpretation Frameworks
Patrick Cousot
LIENS, École Normale Supérieure
45, rue d’Ulm
75230 Paris cedex 05 (France)
 
Radhia Cousot
LIX, École Polytechnique
91128 Palaiseau cedex (France)
 
We introduce abstract interpretation frameworks which are variations on the archetypal framework
using Galois connections between concrete and abstract semantics, widenings and narrowings and
are obtained by relaxation of the original hypotheses. We consider various ways of establishing the
correctness of an abstract interpretation depending on how the relation between the concrete and
abstract semantics is deﬁned. We insist upon those correspondences allowing for the inducing of
the approximate abstract semantics from the concrete one. Furthermore we study various notions
of widening and narrowing as a means of obtaining convergence in the iterations used in abstract
interpretation.
Keywords: Abstract interpretation; standard and collecting semantics; concrete and abstract se­
mantics; discrete approximation; soundness relation; abstraction; concretization; Galois connections;
widening; narrowing;
Introduction
The semantics of programs describes the set of all possible behaviours of these pro­
grams when executed for all possible input data. For example, these behaviours can
be non-termination, termination with an error or correct termination delivering one
or more output results.
Abstract interpretation is a method for designing approximate semantics of pro­
grams which can be used to gather information about programs in order to provide
sound answers to questions about their run-time behaviours. These semantics can
be used to design manual proof methods or to specify automatic program analysers.
When the semantic analysis of programs is to be automated, the answers can only
be partial or approximate since questions such as termination for all input data are
undecidable. The purpose of abstract interpretation is to prove the soundness of such
program analysis methods with respect to a semantics, or better to formally design
them by approximation of the semantics of programs. Hence from a theoretical point
of view, the purpose of abstract interpretation is to design hierarchies of interrelated
semantics specifying at various levels of details the behaviour of programs when exe­
cuted by computers. This corresponds to understanding of ‘interpret’ as ‘to explain
the meaning of’, the qualiﬁcation as ‘abstract’ enforcing ‘to understand in a speciﬁed
way’. From a practical point of view, the purpose of abstract interpretation is to de­
sign automatic program analysis tools for determining statically dynamic properties
of programs. This corresponds to understanding of ‘interpret’ as ‘to act as an inter­
preter’, the qualiﬁcation as ‘abstract’ enforcing the idea that the concrete domain of
values is replaced by a domain of descriptions of values and concrete operators are
given a corresponding non-standard interpretation.
P. Cousot and R. Cousot
The abstract interpretation framework that we introduced in is based on the use of Galois connections (or equivalently closure operators,
Moore families, complete join congruence relations or families of principal ideals) to
establish the correspondence between the domain of concrete or exact properties and
the domain of abstract or approximate properties.
This corresponds to a perfect
situation, where each concrete property has a unique best abstract approximation. It
is theoretically always possible to satisfy this hypothesis, by adding more properties
to the abstract domain.
However, in some practical cases, this might lead to a
combinatorial explosion (as observed in paragraph 9.2 of ).
In this case and
more generally, when the abstract domain is large or inﬁnite, widening and narrowing
operators should be used to tune the cost/precision compromise. In the following
presentation of this framework, we ﬁrst relax this uniqueness condition to study
more ﬂexible but less elaborated variants of the original framework, which is ﬁnally
obtained as a powerful special case. The study covers most of the cases that we have
encountered in our practical experience with abstract interpretation. However, not
all situations can be exhaustively considered so that the presentation of the abstract
interpretation frameworks should be understood as themes on which further variations
can be constructed.
Standard, collecting and abstract semantics
Since an abstract interpretation of programs is an approximation of their semantics,
the correctness proof of an abstract interpretation requires the existence of the stan­
dard semantics describing the possible behaviours of programs during their execution.
Then, the abstract interpretation focuses on a class of properties of program execu­
tions, which is usually deﬁned by a collecting semantics (also called static in ). This
collecting semantics can be an instrumented version of the standard semantics in or­
der to gather information about programs executions. Alternatively, it can also be a
version of the standard semantics reduced to essentials in order to ignore irrelevant
details about program execution. The main utilization of the collecting semantics is
to provide a sound and relatively complete proof method for the considered class of
properties. It can be used subsequently as a reference semantics for proving the cor­
rectness of all other approximate semantics for that class of properties. Finally, the
abstract semantics usually considers eﬀectively computable properties of programs.
It is therefore usually incomplete. The soundness of this abstract semantics is proved
with respect to the collecting semantics.
Example 2.1 (Invariants)
In , the standard semantics is an operational semantics speciﬁed by a transition
system ⟨S, t, ι, ς⟩which consists of a set S of states, a subset ι ⊆S of initial states,
a subset ς ⊆S of ﬁnal states and a binary transition relation t ∈℘(S × S) between
a state and its possible successors.1 Two collecting semantics of a program are con­
sidered where programs properties are represented by sets of ﬁnite partial execution
traces. In the forward collecting semantics, traces are ﬁnite sequences of states, start­
ing with an initial state and such that two consecutive states on the trace satisfy the
1 The fact that the abstract interpretation framework of is applicable not only to ﬂow­
chart programs but to other languages deﬁned by their operational semantics, including ﬁrst-order
functions considered in and parallel programs considered in , and more generally ﬁxpoint
based semantics, is sometimes misunderstood.
Abstract Interpretation Frameworks
transition relation. In the backward collecting semantics, traces are ﬁnite sequences
of states, starting with a ﬁnal state and such that two consecutive states on the trace
satisfy the inverse of the transition relation. Various abstractions are considered,
in particular the descendant states of the initial states, which happened to be the
collecting semantics considered in . This abstraction consists in approximating a
set of forward traces by the set of states which occur on any one of these traces. It
is appropriate for discussing invariance properties of programs.
Example 2.2 (Mycroft’s strictness analysis)
Another original and important example was given by Mycroft . Strictness
analysis, which consists in determining whether the result of a function is undeﬁned
whenever its argument is undeﬁned is useful for speeding up sequential or parallel
implementations of lazy functional languages . There the standard semantics is
a denotational semantics. The collecting semantics is obtained using powerdomains
so as to specify the possible results of a function given a set of possible values for
the actual arguments, including undeﬁned, that is non-terminating ones . The
abstract semantics concern strictness and termination analyses.
In order to describe the correspondences between standard and collecting, collect­
ing and abstract or standard and abstract semantics in a uniform formalism, we now
study such connections between concrete and abstract semantics. The fact of being
concrete or abstract is relative and simply means that the abstract semantics is an
approximation of the concrete semantics (including inducings into another semantic
domain without loss or gain of information). For example the collecting semantics is
abstract with respect to the standard semantics and concrete for subsequent abstract
interpretations.
We will examine various means of establishing a correspondence between concrete
and abstract semantics.
Iterative speciﬁcation of the concrete and
abstract semantics
But ﬁrst we must hypothesize how the concrete and abstract semantics are deﬁned.
Concrete semantic domain.
The concrete semantics describes properties of the
possible executions of a program represented by means of concrete semantic properties
c chosen in a given set P♮called the concrete semantic domain.
For example elements c of P♮can be a set of maximal execution traces, an in­
put-output relation, a function, a set of states, etc. The design of a concrete seman­
tics giving a semantic description of a class of properties of the possible executions
of a program may be a non-trivial task. This might not be so much a problem when
the properties of interest can be characterized directly with respect to the standard
semantics (this can be done for Mycroft’s strictness analysis as shown in forthcom­
ing Example 6.11) or when there is a simple construction for deriving the collecting
semantics from the standard semantics (which is the case for invariance properties as
shown in Example 3.2). This may be more diﬃcult in analyses such as binding-time
analysis, where the relevant properties are of second-order nature , or in an anal­
ysis of storage use, where the properties must be formulated with respect to some
P. Cousot and R. Cousot
model of the store . However, we deliberately ignore the distinction between the
semantics of a program and the properties that this program semantics satisﬁes so
as to remain fully comprehensive.
Concrete semantics.
A semantics deﬁnition associates with each program its con­
crete semantics , which is a concrete semantic property c chosen in P♮representing
some characteristics of its possible executions. Several hypotheses can be made on
the methods which can be used to deﬁne this concrete semantics of a program:
– It is usually obtained as the limit F ♮ϵ of a transﬁnite and ultimately stationary
sequence F ♮λ of elements of P♮, for all ordinals λ ∈Ord. This sequence F ♮λ ,
λ ∈Ord will be called the concrete iteration and its elements the concrete
– More speciﬁcally, the concrete iteration is often speciﬁed by transﬁnite recursion
using a basis ⊥- ♮∈P♮, a partial map F ♮∈P♮≻→P♮called the concrete semantic
function (where S ≻→T is the set of partial functions of the set S into the set
T ) and an inductive join ⨿♮∈℘(P♮) ≻→P♮so that:
when λ > 0 is a limit ordinal.
Since partial operations F ♮and ⨿♮are used, we say that the iteration is
total when all its iterates are well-deﬁned and otherwise that it is partial.
The iteration is said to be convergent with limit F ♮ϵ whenever it is total
and ultimately stationary, that is to say ∃ϵ ∈Ord : ∀λ ≥ϵ : F ♮λ = F ♮ϵ.
Many other forms of sequence deﬁnitions can be considered, such as F ♮λ =
for all λ ∈Ord.
– In particular, the concrete iterates may be in increasing order for a partial
order ⊑♮∈℘(P♮× P♮).
This partial order relation may induce a complete
partial order (cpo) or even a complete lattice structure on P♮and ⨿♮may
be the corresponding least upper bound ⊔♮whereas ⊥- ♮often happens to be
the inﬁmum ⊥♮. This ensures that the concrete iteration is convergent. Note,
however, that the least upper bounds ⊔♮
β<λF ♮β are needed for the iteration
sequence F ♮λ , λ ≤ϵ only, not for all directed sets of P♮. Whence the concrete
domain P♮needs not to be a cpo (and it is not for the Smyth order ).
Example 3.1 (Denotational semantics)
In denotational semantics , the domain ⟨D∂
−→D∂; ⊑∂, λ x.⊥∂, ⊔∂⟩of denota­
tions of recursively deﬁned functions is the cpo of continuous total functions from the
domain D∂into D∂ , the concrete iteration is given by means of a continuous map
−→D∂). Since the concrete iteration is increasing, its
limit exists and is ⊔∂
n≥0F ∂n(⊥∂). By continuity, ϵ = ω (where ω is the ﬁrst inﬁnite
ordinal and we can let subsequent iterates be equal to this limit).
Example 3.2 (Collecting semantics for invariance properties)
Another example is the forward collecting semantics for invariance properties of a
transition system ⟨S, t, ι, ς⟩, where S is the set of states, t ∈℘(S × S) is the
Abstract Interpretation Frameworks
transition relation, ι ⊆S is the set of initial states and ς ⊆S is the set of ﬁnal
states considered in . Program invariance properties can be characterized by sets
of states, that is elements of ℘(S) where ⟨℘(S); ⊆, ∅, ∪⟩is a complete lattice. The
concrete semantic function is the strongest post-condition operator spt
ι ∈℘(S) →
℘(S) (where S →T is the set of total functions of the set S into the set T ) such
= ι ∪{s | ∃s′ ∈I : ⟨s′, s⟩∈t}. If I is an invariant, then spt
ι(I) is the
invariant which holds after one more program step. The set of descendant states of
the initial states is given as the limit ∪n≥0spt
n(∅). ϵ = ω since spt
ι is a complete
∪-morphism, hence continuous. As observed in , backward collecting semantics
needs no more theoretical study since it is the forward collecting semantics for the
inverse transition system ⟨S, t−1, ς, ι⟩and therefore is obtained by duality. A defect
of denotational semantics is that this duality principle is not applicable (since the
inverse of a function is not a function). However, it is applicable to the relational
semantics considered in .
Abstract semantic domain.
The ﬁrst basic choice to be made in an abstract
interpretation is to design an abstract semantic domain P♯which is an approximate
version of the concrete semantic domain P♮. For example invariance properties, such
as partial correctness, can be represented by a set of states. In full generality, P♯is
just assumed to be a set without further hypotheses on its structure.
Abstract semantics.
The objective of an abstract interpretation is to ﬁnd an
abstract property a, if any, in the abstract semantic domain P♯which is a correct
approximation of the concrete semantics c ∈P♮of the program, in a sense which
remains to be deﬁned. Therefore the second basic choice in an abstract interpretation
is to design a method for associating an abstract semantics a ∈P♯to programs.
– A natural idea is to give an abstract interpretation of the concrete iteration F ♮λ ,
λ ∈Ord by means of an abstract iteration , F ♯λ , λ ∈Ord, which is ultimately
stationary and therefore has a limit F ♯ε.
– As this was the case for the concrete semantics, the abstract iteration can be
speciﬁed by transﬁnite recursion using an abstract basis ⊥- ♯∈P♯, an abstract
semantic function F ♯∈P♯≻→P♯and an abstract inductive join ⨿♯∈℘(P♯) ≻→
P♯so that:
when λ > 0 is a limit ordinal.
– In particular, the abstract iterates may be in increasing order for a partial order
⊑♯∈℘(P♯×P♯) which may induce an order structure ⟨P♯; ⊑♯, ⊥♯, ⊔♯⟩ensuring
that the abstract iteration is convergent.
Soundness correspondence between concrete and
abstract semantics
We start with the use of a soundness relation σ to reason about the correspondence
between a concrete and an abstract semantics. Early examples are the relation be­
P. Cousot and R. Cousot
tween direct and continuation denotational semantics given by and the weakest
pre-condition wp(S , P) understood as a relation between the semantics of statement
S and the set of states satisfying predicate P .
Soundness relation between concrete and abstract semantics.
basic choice to be made in the design of an abstract interpretation is to specify the
correspondence between the concrete and abstract properties.
We can deﬁne the
meaning of the abstract properties by means of a soundness relation:
σ ∈℘(P♮× P♯) .
⟨c, a⟩∈σ means that the concrete semantics c of the program has the abstract
property a.
Example 4.1 (Invariance properties as an abstraction of execution traces)
If the concrete semantics of a program is the set of its maximal execution traces
and its abstract property is invariance represented as a set of states then the corre­
spondence between the concrete semantics and the abstract properties can be deﬁned
by a relation which associates with a set of traces any superset of the set of states
encountered along these traces (see Example 7.1 for more details).
Example 4.2 (Mycroft’s strictness analysis)
In strictness analysis, Mycroft proposed to use D♯= {0, 1} and 0 ⊑♯0 ⊑♯1 ⊑♯1,
which is extended pointwise to functions and componentwise to vectors of functions
so as to obtain continuous functions F ♯∈(D♯
−→D♯) on a cpo
−→D♯; ⊑♯, ⊥♯, ⊔♯⟩where ⊥♯= λ x.0. Since the abstract iteration is increasing
and the domain is ﬁnite, its limit ⊔♯
n≥0F ♯n(⊥♯) is reached after ﬁnitely many steps.
−→D♯is a sound abstraction of ϕ∂∈D∂
−→D∂if and only if ⟨ϕ∂, ϕ♯⟩∈
 (ϕ♯(0) = 0 ⇒ϕ∂(⊥∂) = ⊥∂) ∧
(ϕ♯(1) = 0 ⇒∀x ∈D∂: ϕ∂(x) = ⊥∂)
Observe that ϕ♯= λx.1 is a trivial solution to the strictness analysis problem so that
the soundness relation σ provides no information on the best abstract interpretations.
On the existence of abstract approximations.
Very few hypotheses need to
be made on the abstract semantic domain P♯and the soundness relation σ. A com­
mon although not indispensable one is a very weak form of expressiveness. Observe
that the abstract interpretation problem would have no solution for a program with
semantics c when the set {a | ⟨c, a⟩∈σ } is empty. Therefore a common assumption
is that every concrete property has an abstract approximation. This is the existence
of abstract approximations assumption stating:
∀c ∈P♮: ∃a ∈P♯: ⟨c, a⟩∈σ .
Proof of soundness of the abstract semantics.
To prove the soundness condi­
tion, ⟨F ♮ϵ, F ♯ε⟩∈σ , one can imagine proceeding by induction: the basis ⟨F ♮0, F ♯0⟩∈
σ and induction step ∀λ, λ′ ∈Ord : ⟨F ♮λ, F ♯λ′⟩∈σ ⇒∃µ > λ, µ′ > λ′ ∈Ord :
Abstract Interpretation Frameworks
⟨F ♮µ, F ♯µ′⟩∈σ ensure ⟨F ♮ϵ, F ♯ε⟩∈σ for convergent iteration sequences. In general
(4.5) ensures the existence of the F ♯λ. In particular when using semantic functions
and inductive joins, we obtain:
Proposition 4.3 (Inductive soundness proof)
Given the set P♮of concrete properties, the set P♯of abstract properties, the relation
ρ ∈℘(P♮× P♯),2 the bases ⊥- ♮∈P♮and ⊥- ♯∈P♯such that ⟨⊥- ♮, ⊥- ♯⟩∈ρ, the
concrete F ♮∈P♮→P♮and abstract F ♯∈P♯→P♯semantic functions such that
∀c ∈P♮: ∀a ∈P♯: ⟨c, a⟩∈ρ ⇒⟨F ♮(c), F ♯(a)⟩∈ρ, the concrete ⨿♮∈℘(P♮) ≻→P♮
and abstract ⨿♯∈℘(P♯) ≻→P♯inductive joins such that (∀β < λ : ⟨F ♮β, F ♯β⟩∈ρ)
β<λF ♮β, ⨿♯
β<λF ♯β⟩∈ρ for all limit ordinals λ > 0 3 and assuming that the
concrete and abstract iteration sequences are convergent 4 then their respective limits
F ♮ϵ and F ♯ε are such that ⟨F ♮ϵ, F ♯ε⟩∈ρ.
Proof. By transﬁnite induction on λ, we have ⟨F ♮λ, F ♯λ⟩∈ρ for all λ ∈Ord. Since
both sequences are convergent, we have F ♮ϵ = F ♮µ , F ♯ε = F ♯µ and ⟨F ♮µ, F ♯µ⟩∈ρ
for the maximum µ of ϵ and ε.
This proposition has numerous corollaries, in particular when the limits are ﬁx­
points of monotonic or continuous semantic functions on cpos or lattices.
Example 4.4 (Soundness proof of strictness analysis)
For strictness analysis, the basis ⟨λ x.⊥∂, λ x.0⟩∈σ is obvious. For the induction
step we have to prove ⟨ϕ∂, ϕ♯⟩∈σ ⇒⟨F ∂(ϕ∂), F ♯(ϕ♯)⟩∈σ and proceed by induction
on the syntax of programs using the equations deﬁning F ∂and F ♯. It remains to
prove the last condition which, by continuity and termination of the abstract iteration,
follows, for example, from the fact that if ϕ∂
n, n ≥0 is an increasing chain for ⊑∂such
that ∀n ≥0 : ⟨ϕ∂
n, ϕ♯⟩∈σ then ⟨⊔∂
n, ϕ♯⟩∈σ. This immediately follows from
the remark that ⊔∂
n(x) = ⊥∂when ϕ∂
n(x) = ⊥∂for all n ≥0.
Other examples of application are given in .
Inducing the abstract semantics using extrapolation operators.
soundness relation σ is one to many, the concrete iterates F ♮λ , λ ∈Ord may have
many abstract approximations F ♯λ , λ ∈Ord which are sound, that is ∀λ ∈Ord :
⟨F ♮λ, F ♯λ⟩∈σ. In this case the soundness relation σ is not very helpful for inducing
the abstract semantics from the concrete semantics since a discriminating choice must
be done among all possibilities. To discriminate, we can use extrapolation operators:5
▽♯∈℘(P♯) ≻→P♯
△♯∈℘(P♯) ≻→P♯
2 Subsequently, ρ can be σ , α or γ−1.
3 For λ = 0 this condition subsumes ⟨⊥- ♮, ⊥- ♯⟩∈ρ when ⨿♮∅= ⊥- ♮and ⨿♯∅= ⊥- ♯.
4 Convergent iterates have been deﬁned as total, that is well-deﬁned which ensures existence, and
ultimately stationary, which ensures convergence.
5 This is the ﬁrst use of the widening and narrowing as sound choice functions (which are partial
since they are needed in the abstract iteration only), the second one is to ensure convergence, the
third is to guarantee rapid termination.
P. Cousot and R. Cousot
which preserve soundness so that for all A ⊆P♯, we have:
▽♯A exists
∀c ∈P♮: (∃a ∈A : ⟨c, a⟩∈σ) ⇒
⟨c, ▽♯A⟩∈σ
△♯A exists
∀c ∈P♮: (∀a ∈A : ⟨c, a⟩∈σ) ⇒
⟨c, △♯A⟩∈σ
Proposition 4.5 (Soundness of the induced iterates using extrapolation operators)
Let P♮be the set of concrete properties, ⊥- ♮∈P♮be the concrete basis, F ♮∈P♮≻→P♮
be the concrete semantic function and ⨿♮∈℘(P♮) ≻→P♮be the concrete inductive
join such that the concrete iteration F ♮λ , λ ∈Ord converges with limit F ♮ϵ. Let ▽♯
be a widening and △♯be a narrowing satisfying (4.6), (4.7) and (4.8). Deﬁne the
abstract iteration F ♯λ , λ ∈Ord using:
  c ∈P♮∧⟨c, a⟩∈σ
  ∀i ∈I : ci ∈P♮∧⟨ci, ai⟩∈σ
where α ∈P♮≻→P♯is deﬁned by α(c)
= △♯{a | ⟨c, a⟩∈σ}. If the abstract iteration
is convergent with limit F ♯ε then ⟨F ♮ϵ, F ♯ε⟩∈σ.
Proof. By (4.8) we have ⟨c, α(c)⟩∈σ for all c ∈P♮for which α(c) exists, whence
in particular (4.9) implies ⟨⊥- ♮, ⊥- ♯⟩∈σ. Assume that c ∈P♮and a ∈P♯satisfy
⟨c, a⟩∈σ. We have ⟨F ♮(c), α(F ♮(c))⟩∈σ so that by (4.7) and (4.10) it follows that
⟨F ♮(c), F ♯(a)⟩∈σ. Assume that ∀β < λ : ⟨F ♮β, F ♯β⟩∈σ where λ > 0 is a limit
ordinal. We have ⟨⨿♮
β<λ F ♮β, α
⟩∈σ so that by (4.7) and (4.11) we infer that
β<λ F ♮β, ⨿♯
β<λ F ♯β⟩∈σ. We conclude using Proposition 4.3.
Example 4.6 (The Galois connection framework)
In the classical framework of , the concrete properties ⟨P♮; ⊑♮, ⊔♮, ⊓♮⟩and
abstract properties ⟨P♯; ⊑♯, ⊔♯, ⊓♯⟩are complete lattices. The correspondence be­
tween concrete and abstract properties is given by a Galois connection ⟨P♮; ⊑♮⟩↼−
⟨P♯; ⊑♯⟩that is an abstraction map α ∈P♮→P♯and a concretization map
γ ∈P♯→P♮such that, by deﬁnition:6
∀c ∈P♮: ∀a ∈P♯: α(c) ⊑♯a ⇔c ⊑♮γ(a) .
The soundness relation is ⟨c, a⟩∈σ
= α(c) ⊑♯a ⇔c ⊑♮γ(a). Let us deﬁne ▽♯
⊔♯and △♯def
= ⊓♯so that, by deﬁnition of the greatest lower bound, for all c ∈P♮we
have △♯{a | ⟨c, a⟩∈σ} = ⊓♯
a | α(c) ⊑♯a
By (4.10) we have:
  α(c) ⊑♯a
6 Observe that γ and α are monotonic since α(c′) ⪯♯α(c′) ⇒c′ ⪯♮γ(α(c′)) whence c ⪯♮c′ ⇒
c ⪯♮γ(α(c′)) ⇒α(c) ⪯♯α(c′) and γ(a) ⪯♮γ(a) ⇒α(γ(a)) ⪯♯a whence a ⪯♯a′ ⇒α(γ(a)) ⪯♯
a′ ⇒γ(a) ⪯♮γ(a′) so that this requirement was redundant in deﬁnition 5.3.0.1 of .
Abstract Interpretation Frameworks
For Galois connections, α is a complete join morphism (theorem 5.3.0.5.(4) of ),
that is ∀S ⊆P♮: α(⊔♮S) = ⊔♯α⋆(S) where f ⋆(S)
= {f(x) | x ∈S} so that F ♯(a)
 α(c) ⊑♯a
). Moreover, α and F ♮are monotonic so that ⊔♮F ♮⋆(S)
⊑♮F ♮(⊔♮S) whence F ♯(a) ⊑♯α(F ♮(⊔♮
 α(c) ⊑♯a
)). For Galois connections we
∀a ∈P♯: γ(a) = ⊔♮
 α(c) ⊑♯a
∀c ∈P♮: α(c) = ⊓♯
 c ⊑♮γ(a)
(theorem of 5.3.0.5.(3) ) so that F ♯(a) ⊑♯α(F ♮(γ(a))). F ♮is often a complete
join morphism, in which case:
(where ◦denotes the composition of functions) as originally proposed in paragraph
4.1.7 of . Moreover, in , the inductive join ⨿♮is the least upper bound
⊔♮. Therefore (4.11) implies ⨿♯
  ∀i ∈I : ci ∈P♮∧α(ci) ⊑♯ai
Since α is a complete join morphism, this is equal to
 ∀i ∈I : ci ∈P♮∧
α(ci) ⊑♯ai
 α(c) ⊑♯ai
 α(c) ⊑♯ai
) and therefore
by (4.14) to α
, that is:
∀A ⊆P♯: ⊔♯A = α
We conclude that in the Galois connection framework Proposition 4.5 amounts to
theorem 4.1.7.1 of for lifting an abstract interpretation to higher-order functional
spaces, using the fact that if ⟨P♮
are Galois connections then:
2; ⊑♮⟩↼−−−−−
λ φ.γ2◦φ◦α1
λ ϕ.α2◦ϕ◦γ1 ⟨P♯
is also a Galois connection for the pointwise orderings ⊑♮and ⊑♯of monotonic maps.
Assessment of the soundness relation framework.
This soundness relation
framework is very general.
It dispenses with a collecting semantics but then no
sound and relatively complete method is oﬀered for proving the abstract properties.
We have shown that it is possible to infer the abstract semantics from the concrete
semantics using widening and narrowing operators generalizing the extrapolation op­
erators introduced in . The main weakness of that framework is that the relative
precisions of abstract properties is not taken into account in the approximation of
concrete properties.8
7 The notion of adjoinedness is also studied in category theory and there the equation (4.14)
introduced in is said to express a Kan extension, as ﬁrst observed by .
More generally,
abstract interpretation could be rephrased in category theory .
8 However, there is a natural notion of equivalence, since c ≡c′
= (∃a ∈P♯: ⟨c, a⟩∈σ)
∧(∀a ∈P♯: ⟨c, a⟩∈σ ⇔⟨c′, a⟩∈σ) is a PER, which is an equivalence relation when (4.5)
is satisﬁed.
The development of an abstract interpretation framework based upon this PER is
considered in paragraph 6.3 of where the additional existence of a best abstract approximation
hypothesis (4.25) leads to its further reﬁnement as a complete join congruence relation. This should
not be confused with the use of strict uniform inductive PERs by as elements of the concrete
semantic domain P♯.
P. Cousot and R. Cousot
Approximation and computational orderings
The next step introduces a notion of precision in order to compare properties.
Modelling precision by a pre-order.
In general, a program may satisfy many
concrete properties c and each one may be approximated by many abstract properties
a (according to the soundness condition ⟨c, a⟩∈σ). In order to distinguish the more
precise ones, one can introduce a notion of approximation on the domain of concrete
properties, on the domain of abstract properties or on both. In the absence of a
metric distance specifying closeness of properties, one often indicates their relative
precision using a pre-order relation ⪯∈℘(P × P) which is reﬂexive and transitive.
p ⪯p′ means that “p is more precise than p′ ” or “p logically implies p′ ”. ⪯can
be called the approximation relation. It may not be antisymmetric when the same
property can be expressed by several elements of P. One can take advantage of the
existence of a normal form for such elements, by considering the quotient set P/≈for
the equivalence relation ≈deﬁned by p ≈p′ def
= (p ⪯p′)∧(p′ ⪯p) which is tantamount
to assuming that ⪯is a partial order.
Example 5.1 (Relative precision of invariance properties)
In the case of invariance properties, this approximation relation would be set inclusion
⊆since I is approximated by J if and only if I ⊆J in the sense that any superset of
the reachable states during execution represents a correct but approximate invariant.
If, for example, the value of an integer variable is strictly positive during execution
then it is sound, but less precise, to assert that it is positive or zero.
Observe that, in general, the computational ordering , that is the partial order
⊑between the iterates, and the approximation ordering ⪯are totally unrelated (al­
though in , they happened to be the same, that is ⊆).
The approximation ordering can be deﬁned either on the abstract domain or on
the concrete domain or on both. We now examine these alternatives in turn.
Abstraction correspondence between concrete
and abstract semantics
We now examine a framework in which the notion of precision is formalized on the
abstract properties using an approximation relation ⪯♯:
is a pre-order,
(a ⪯♯a′) ∧(a′ ⪯♯a)
and the connection between the concrete and abstract semantics is established via an
abstraction relation or function α.
Soundness relation and abstract upper approximation.
The objective of an
abstract interpretation is to ﬁnd an abstract property a, if any, in the abstract se­
mantic domain P♯which is a correct approximation of the concrete semantics c ∈P♮
of the program, i.e. such that ⟨c, a⟩∈σ. In general, an approximation a′ ∈P♯
such that a ⪯♯a′ will also be a sound, although less precise, abstract property of
Abstract Interpretation Frameworks
c. Since the approximation is sound, we should also have ⟨c, a′⟩∈σ. A natural
abstract soundness of upper approximations assumption , for short abstract soundness
assumption is therefore:9
∀c ∈P♮: ∀a, a′ ∈P♯: (⟨c, a⟩∈σ ∧a ⪯♯a′) ⇒⟨c, a′⟩∈σ .
Example 6.1 (Supremum)
In the context of upper approximations (4.19), a very simple way to ensure the exis­
tence of an abstract approximation for all concrete properties (4.5) is to assume that
P♯has a supremum ⊤♯for ⪯♯such that ∀c ∈P♮: ⟨c, ⊤♯⟩∈σ. It follows that ⊤♯
represents the absence of information on the concrete semantics c. If absent from P♯,
such a supremum can be added to P♯. This can be justiﬁed for incomplete abstract
interpreters by the existence of input programs for which the only analysis which can
be done in a ﬁnite time is the output of a message indicating absence of information,
which is formalized by the supremum ⊤♯. For example in the case of invariance,
this supremum would be the set of all possible states which provides no information
about the run-time behaviours of a program. It has often been argued that such a
supremum is not natural in the domains used for denotational semantics, and by an
ill-considered generalization, this same claim has been made for the case of abstract
interpretations. But recall that ⊑♮and ⪯♯are, in general, unrelated and that the
supremum ⊤♯, corresponding to the “I don’t know” answer, is only for ⪯♯.
On the consequences of the abstract soundness assumption.
Assume that
the correctness of an abstract interpretation is speciﬁed using a soundness relation σ
and an abstract approximation relation ⪯♯satisfying (4.3), (4.5), (4.18) and (4.19).
Two diﬀerent roles can be given to σ that is either to specify which are all possible
abstract properties a that can be used to approximate a given concrete property c or
else to specify the preferred ones. The second role is useful, for example, when ⪯♯is
not antisymmetric. In this case all abstract properties in the equivalence class [a]≈♯
are equally precise for approximating c and σ might select a unique representative in
the class. Assumption (4.19) has the unfortunate consequence that this is not possible
since all a′ ∈[a]≈♯must be such that ⟨c, a′⟩∈σ. Requiring ⪯♯to be antisymmetric
would not help. For example, if we would like σ to be a bĳection (so as, for example,
to prove an equivalence between semantics in which case the abstract domain is just a
diﬀerent but equivalent representation of the concrete properties), then ⪯♯should be
equality. In order to avoid these troubles we have to separate the two roles that may
be given to σ. We think of σ as specifying which are all possible abstract properties
which can be used to approximate a given concrete property and look for another
way of specifying the preferred ones.
Abstraction relation between the concrete and abstract properties.
one can start by introducing an abstraction relation:
α ∈℘(P♮× P♯)
specifying which abstract properties can be used safely to represent concrete proper­
ties, together with a pre-order ⪯♯on P♯to specify the relative precision of abstract
9 As observed after deﬁnition 4.0.1 of : “The dual one might be useful (e.g. for proving termi­
nation)” and this is the case for Mycroft termination analysis. However, following a well-established
mathematical practice, we do not explicitely formulate dual results.
P. Cousot and R. Cousot
properties. Afterwards, the soundness relation σ ∈℘(P♮×P♯) can be deﬁned accord­
ing to the following abstraction based soundness assumption:
⟨c, a′⟩| ∃a ∈P♯: ⟨c, a⟩∈α ∧a ⪯♯a′
The relationship between ⪯♯and σ is that “less precise abstract properties approx­
imate greater sets of concrete properties”:
for all a, a′ in P♯, a ⪯♯a′ implies
{c | ⟨c, a⟩∈σ} ⊆{c′ | ⟨c′, a′⟩∈σ} by (4.21).
Minimal abstract approximations.
A possible trouble is now that α may be
equal to σ which is the case for example when α satisﬁes ⟨c, a⟩∈α ∧a ⪯♯a′ ⇒
⟨c, a′⟩∈α. To avoid this redundancy, the soundness assumption:
can sometimes be sharpened by requiring α to select minimal elements, that is the
most precise ones. This consists in assuming the abstract minimality assumption:
⟨c, a⟩∈σ | ∀a′ ∈P♯: (⟨c, a′⟩∈σ ∧a′ ⪯♯a) ⇒(a ⪯♯a′)
The intent is that σ speciﬁes the abstract properties which can be used to approximate
a given concrete property, α speciﬁes the preferred ones and ⪯♯speciﬁes their relative
precision. Hypotheses (4.21) and (4.23) are beneﬁcial to dispense with one of σ or α.
However, this is not always possible. For example in the case of a concrete property
c which can be approximated by an inﬁnite set aλ, λ < δ , ω ≤δ ∈Ord of abstract
properties forming a strictly decreasing chain for ⪯♯with no lower bound, (4.23)
would deﬁne α as the empty relation. In such a case, both σ and α are useful with α
specifying an arbitrary choice in the inﬁnite chain aλ, λ < δ.
On the uniqueness of the abstract interpretation.
The most common situ­
ation however is that the set {a | ⟨c, a⟩∈α} of minimal abstract properties of the
concrete semantics c of a program is not empty and has many elements. Therefore
it may be preferable to consider the set {a | ⟨c, a⟩∈α}/≈♯where equivalent abstract
properties have been identiﬁed. But this set can also have many incomparable ele­
ments. Positiveness and evenness of the value of a variable are examples of incompa­
rable invariance properties. This situation represents a lack of expressiveness of P♯in
that the best or more precise property of programs cannot be stated within the set of
abstract properties P♯(but can be in ℘(P♯), which is a form of completion considered
in paragraph 9.2 of , see Example 6.6 below). This is also somewhat impracti­
cal in that it either forces to switch to an abstract domain enriched by adding new
abstract properties expressing the conjunction of properties in ℘(P♯), which is equiv­
alent to assuming uniqueness of the abstract approximation of any concrete property
or to make an arbitrary choice among the possible properties of a program. We now
examine these two alternatives, ﬁrst exploring the advantages of the existence of a
best approximation and then investigating what is to be done in absence of a best
approximation.
Existence of a best abstract approximation.
The “very reasonable assump­
tion” of consists in reasoning about P♯/≈♯, which is equivalent to the assumption
Abstract Interpretation Frameworks
that ⪯♯is a partial order and in assuming the uniqueness of the approximation, more
precisely that any concrete property c has at least one sound approximation in P♯
and that among these sound abstract properties, there is a best one. After , this
is stated by the following best abstract approximation assumption:
∃a ∈P♯: ⟨c, a⟩∈σ
∀a′ ∈P♯: ⟨c, a′⟩∈σ ⇒a ⪯♯a′
We frequently use the conjunction of the existence of abstract approximations as­
sumption (4.5) and of the best abstract approximation assumption (4.24) which we
call the existence of a best abstract approximation assumption:
∀c ∈P♮: ∃a ∈P♯: ⟨c, a⟩∈σ ∧∀a′ ∈P♯: ⟨c, a′⟩∈σ ⇒a ⪯♯a′ .
In this case α is a function such that:
∀c ∈P♮: ∀a ∈P♯: ⟨c, a⟩∈σ ⇔α(c) ⪯♯a .
Proposition 6.2 (Existence of an abstraction function)
◦) Assume that ⪯♯is a partial order relation on P♯and that σ ∈℘(P♮×P♯) satisﬁes
the existence of a best abstract approximation assumption (4.25). If α ∈℘(P♮× P♯)
is deﬁned by (4.23) then α ∈P♮→P♯.
◦) If, moreover, σ satisﬁes the soundness assumption (4.19) then (4.26) holds.
◦) For all c ∈P♮, there exists a ∈P♯satisfying (4.25) which, by deﬁnition
of α, implies that ⟨c, a⟩∈α proving that α is total. Assume that ⟨c, a1⟩∈α and
⟨c, a2⟩∈α. Then, by deﬁnition of α, ⟨c, a1⟩∈σ and ⟨c, a2⟩∈σ so that by (4.25)
there exists a ∈P♯such that a ⪯♯a1 and a ⪯♯a2. By deﬁnition of α we infer that
a1 ⪯♯a and a2 ⪯♯a. By antisymmetry and transitivity, we conclude that a1 = a2
thus proving that α is a (total) function.
◦) We have seen that for all c ∈P♮, α(c) is the unique a satisfying (4.25), hence
∀a′ ∈P♯: ⟨c, a′⟩∈σ ⇒α(c) ⪯♯a′. Reciprocally, if α(c) ⪯♯a′ then ⟨c, α(c)⟩∈σ , by
deﬁnition of α, hence ⟨c, a′⟩∈σ according to the soundness assumption (4.19).
In the absence of a best abstract approximation.
Not all abstract interpreta­
tions satisfy the existence of a best abstract approximation assumption. There are
essentially two reasons why the existence of a best approximation fails. One is that
some concrete property c may have no abstract approximation, which is excluded by
(4.5). The other one is that the set of abstract approximations {a | ⟨c, a⟩∈σ } of
some concrete property c may be an inﬁnite strictly decreasing chain for ⪯♯or a set
of ﬁnite or inﬁnite non-comparable strictly decreasing chains.
Example 6.3 (Convex polyhedra)
 consider the approximation of vectors of reals, that is subsets S of Rn , by a
convex polyhedron P such that S ⊆P. If S is ﬁnite then the best P is the convex
hull of S , but a sphere for example, has no best upper approximation by a convex
polyhedron.
In the absence of a best approximation, several solutions are available:
P. Cousot and R. Cousot
Weakening the abstract properties.
If one insists upon having a best abstract up­
per approximation of concrete properties, one can choose weaker abstract properties,
that is a smaller set of choices.
Example 6.4 (Intervals)
Instead of convex polyhedra, one can choose cubes whose faces are parallel to the
axes as in , in which case any subset S of Rn has a best upper approximation.
However, with this approach, the results of the analysis (intervals of values in the
example) are much less precise than the original (conjunctions of linear inequalities
in the example).
Example 6.5 (Depth k abstraction of success patterns)
 have introduced an abstract interpretation for logic programs where expressions
(clauses, atoms or terms) e are approximated by replacing every level k subexpres­
sions of e by a newly created variable. and have established that there is no
best approximation. For example the depth 3 abstraction of e = p(g(f(u), f(f(v))), f(f(v)))
is e1 = p(g(f(u), f(x)), f(f(y))) but e2 = p(g(f(u), f(z)), f(z)) would be just as good
a choice. The two approximations e1 and e2 are sound since e is an instance of both
of them but they are not comparable since neither is an instance of the other. 
have shown the existence of a best abstract upper approximation by weakening 
depth k abstraction so that no variable occurs more than once (including at depth
less than k).
Strengthening the abstract properties.
If one insists upon having a best abstract
upper approximation of concrete properties, one can also chose stronger abstract
properties that is a larger set of choices. This approach was considered in paragraphs
5.2 and 9.2 of .
Example 6.6 (Conjunctive completion)
Given the set P♯of abstract properties, one can move to the set P
♯= {a ⊆P♯| ∀a, a′ ∈
a : ¬(a ⪯♯a′)} of subsets of incomparable properties of P♯.
The interpretation
of a is the conjunction of the interpretations of the original a ∈a. Therefore the
soundness relation σ is now ⟨c, a⟩∈σ if and only if ∀a ∈a : ⟨c, a⟩∈σ.
approximation relation ⪯
♯a′ if and only if ∀a′ ∈a′ : ∃a ∈a : a ⪯♯a′. ⪯
is a pre-order. If σ and ⪯♯satisfy any one of the existence of upper approximations
(4.5), abstract soundness (4.19) assumptions then so do σ and ⪯
If we deﬁne
= {a | ⟨c, a⟩∈σ } then it satisﬁes the abstract minimality
assumption (4.23) and the existence of a best abstract approximation assumption
(4.25): ∀c ∈P♮: ⟨c, α(c)⟩∈σ ∧∀a′ ∈P♯: ⟨c, a′⟩∈σ ⇒α(c) ⪯
construction generalizes the use of Moore families in theorem 5.2.0.4 of . It is
used in to strengthen the depth k abstraction of .
This conjunctive completion can introduce a combinatorial explosion since all
original possibilities have to be explored. For our convex polyhedra example, the
sphere would be approximated by inﬁnitely many incomparable convex polyhedra and
there are inﬁnitely many ways to do so. An implementation based upon backtracking
would not be much better since an eﬃcient choice function would not be easy to
design. Using convex sets instead of convex polyhedra would not be more helpful in
that they are not machine representable.
Abstract Interpretation Frameworks
Example 6.7 (Disjunctive completion)
Given the set P♯of abstract properties, one can move to the set
a ⊆P♯| ∀a, a′ ∈
a : ¬(a ⪯♯a′)} of subsets of incomparable properties of P♯. The interpretation of
the disjunction of the interpretations of the original a ∈
a. Therefore the soundness
σ is now ⟨c,
σ if and only if ∃a ∈
a : ⟨c, a⟩∈σ. The approximation
a′ if and only if ∀a ∈
a′ : a ⪯♯a′.
♯is a pre-order.
This disjunctive completion generalizes paragraph 9.2 of . As noted there,
it can introduce a combinatorial explosion. Even worse,
P♯might not be machine
representable whereas P♯was. For example, for constant propagation P♯= Z∪{⊥, ⊤}
is an inﬁnite lattice satisfying the ascending chain condition whereas
P♯= ℘(Z) does
not satisfy this condition for ⊆.
One can also strengthen the abstract properties by complementation and more
generally by considering various completion methods.
Discriminating between the abstract properties.
Given the soundness relation σ
and the problem of designing the abstract semantics ⟨⊥- ♯, F ♯, ⨿♯⟩starting from the
concrete semantics ⟨⊥- ♮, F ♮, ⨿♮⟩, one can abandon the idea of having a best abstract
upper approximation of concrete properties c by making an arbitrary choice α(c)
among all sound possibilities {a | ⟨c, a⟩∈σ }, or better among the minimal ones, as
suggested in Proposition 4.5 using a widening ▽♯.
In the design of the abstract
iteration F ♯λ , λ ∈Ord, the discretionary choice of the abstract approximation can
be made once for all, either:
– “statically”, independently of the behaviour of the abstract iteration, in that
the often implicit widening ▽♯is integrated in the abstract semantic function
F ♯(4.10); or
– “dynamically”, depending at each iteration step upon the previous abstract
iterates, in that the explicit widening ▽♯is made part of the iteration process.
We ﬁrst consider reﬁnements of Proposition 4.5 where the widening is hidden and
then where it is explicit.
On the inducing of the concrete iterates into the abstract domain using
an abstraction function.
Proposition 4.3 can be applied with the abstraction
function to get the following corollary (generalizing proposition 7.1.0.4.(3) of ):
Proposition 6.8 (Semantic inducing using an abstraction function)
Given the set P♮of concrete properties, the set P♯of abstract properties, the ab­
straction function α ∈P♮→P♯, the basis ⊥- ♯def
= α(⊥- ♮), the concrete F ♮∈P♮→P♮
and abstract F ♯∈P♯→P♯semantic functions such that α ◦F ♮= F ♯◦α, the con­
crete ⨿♮∈℘(P♮) ≻→P♮and abstract ⨿♯∈℘(P♯) ≻→P♯inductive joins such that
β<λF ♮β) = ⨿♯
β<λα(F ♮β) for all limit ordinals λ > 0 and assuming that the con­
crete and abstract iteration sequences are convergent then their respective limits F ♮ϵ
and F ♯ε are such that F ♯ε = α(F ♮ϵ).
Proof. Use Proposition 4.3 with ρ
⟨c, α(c)⟩| c ∈P♮
P. Cousot and R. Cousot
Observe that in this case the abstraction process consists in exhibiting an underlying
structure of the concrete properties P♮which can be induced without loss of informa­
tion, through the abstraction function α, into the set of abstract properties P♯. A
typical example consists in deriving an abstract semantics from a concrete one, as
illustrated by [19, theorem 10-4] to relate transition systems and predicate transform­
ers; by [2, fact 2.3] to relate denotational semantics or by [20, lemma 4.3] to relate
inﬁnite computations and denotational semantics.
We habitually use this proposition constructively in order to derive the abstract
semantics from the deﬁnition of the concrete semantics: for the basis we simply let
⊥- ♯be α(⊥- ♮). For the semantic function F ♯, starting from the term α(F ♮(c)), we
replace α and F ♮by their deﬁnitions and then simplify the expression in order to let
the term α(c) come out, in which case we let the resulting expression (where α(c)
is replaced by a) be the deﬁnition of F ♯(a). The same way, for the inductive join,
starting from α(⨿♮
β<λcβ), we derive ⨿♯. This will be illustrated in Example 6.11 by
the derivation of a strictness analysis algorithm from a denotational semantics. Such
a formal computation might be, hopefully, mechanizable since exactly the same proof
strategy, with similar substitutions and simpliﬁcations, can be used to derive many
diﬀerent abstract interpretations. The knowledge of this proof strategy would be a
great help for guiding mechanized proofs.
Depending on how the relation between the concrete and abstract properties is
deﬁned, Propositions 4.3 and 6.8 have numerous variants. When a concretization
function γ and an abstraction function α are available such that no information is
lost in the abstract interpretation (∀c ∈P♮: γ(α(c)) = c) we can use the following
(cf. theorem 7.1.0.4-3 of ):
Proposition 6.9 (Semantic inducing from a cpo using a pair of abstraction and
concretization functions)
◦) Let F ♮∈P♮
−→P♮be a total monotonic function on the cpo ⟨P♮; ⊑♮, ⊥♮, ⊔♮⟩.
Let α ∈P♮→P♯and γ ∈P♯→P♮be total maps such that ∀c ∈P♮: γ(α(c)) = c and
the basis ⊥- ♮∈P♮be such that ⊥- ♮⊑♮F ♮(⊥- ♮).10 Deﬁne ⊥- ♯def
= α(⊥- ♮), F ♯∈P♯→P♯
= α ◦F ♮◦γ , ⊔♯∈℘(P♯) ≻→P♯by ⊔♯X
= α(⊔♮γ⋆(X)). Then the abstract
iteration sequence F ♯0 def
= ⊥- ♯, F ♯λ+1 def
= F ♯(F ♯λ) for λ ∈Ord and F ♯λ def
β<λF ♯β for
all limit ordinals λ > 0 is increasing for ⊑♯def
 γ(x) ⊑♮γ(y)
and ultimately
stationary. Its limit F ♯ε is α(F ♮ϵ) with ε ≤ϵ and the limit of the concrete iterates is
F ♮ϵ = lfp
⊥- ♮F ♮(where lfp
x F is the least ﬁxpoint of F greater than or equal to x for
◦) If x is a ﬁxpoint of F ♮then α(x) is a ﬁxpoint of F ♯.
◦) α is monotonic with respect to ⊑♮and ⊑♯. Moreover, F ♯ε = lfp
◦) Let F ♮λ , λ ∈Ord be the concrete iteration sequence.
Since ⊥- ♮is a
pre-ﬁxpoint of the monotonic total function F ♮, it is increasing whence ultimately
stationary with limit F ♮ϵ = lfp
⊥- ♮F ♮. We have α(F ♮0) = α(⊥- ♮) = ⊥- ♯= F ♯0. If F ♯λ
= α(F ♮λ) then F ♯λ+1 = F ♯(F ♯λ) = α ◦F ♮◦γ ◦α(F ♮λ) = α(F ♮(F ♮λ)) = α(F ♮λ+1). If
F ♯β = α(F ♮β) for all β < λ then ⊔♯
β<λF ♯β = α
10 This condition is obviously satisﬁed when ⊥- ♮def
Abstract Interpretation Frameworks
= α(F ♮λ+1). We conclude by transﬁnite induction that ∀λ ∈Ord :
F ♯λ = α(F ♮λ).
◦) If x is a ﬁxpoint of F ♮then F ♯(α(x)) = α ◦F ♮◦γ ◦α(x) = α ◦F ♮(x) = α(x).
◦) Obviously α is monotonic since c ⊑♮c′ implies γ(α(c)) ⊑♮γ(α(c′)) whence α(c) ⊑♯
Let x ∈P♯be a ﬁxpoint of F ♯such that F ♯0 = ⊥- ♯⊑♯x.
Obviously γ
is monotonic by deﬁnition of ⊑♯.
It follows that F ♯is monotonic since it is the
composition of monotonic functions. Therefore if F ♯λ ⊑♯x then F ♯λ+1 = F ♯(F ♯λ)
⊑♯F ♯(x) = x. If F ♯β , β < λ is an increasing chain for ⊑♯and F ♯β ⊑♯x for all β <
λ, then γ(F ♯β), β < λ is an increasing chain for ⊑♮such that γ(F ♯β) ⊑♮γ(x) for all
β < λ hence ⊔♮
β<λγ(F ♯β) ⊑♮γ(x) by deﬁnition of well-deﬁned least upper bounds so
that γ ◦α(⊔♮
β<λγ(F ♯β)) ⊑♮γ(x) since γ ◦α is identity whence α(⊔♮
β<λγ(F ♯β)) ⊑♯x by
deﬁnition of ⊑♯so that ⊔♯
β<λF ♯β ⊑♯x by deﬁnition of ⊔♯. By transﬁnite induction,
for all λ ∈Ord, F ♯λ ⊑♯x, proving for λ = ε, that the limit of the iterates of F ♯is
less than or equal to x.
On the inducing of the approximate abstract iterates using an abstraction
Since the expressions involved in the formal computation for deriving F ♯
from F ♮and α are sometimes intricate or uncomputable, the approximation relation
⪯♯can be used to make further simpliﬁcations using abstract properties which are
approximations of concrete properties. Given α ∈P♮→P♯, the soundness relation
is expressed according to (4.21) by ⟨c, a⟩∈σ
= α(c) ⪯♯a (so that the abstract
minimality assumption (4.23) is obviously satisﬁed).
The general idea is that in
Proposition 4.5, the widening ▽♯can be replaced by a coarser one ▽♯∈℘(P♯) ≻→P♯
such that if ▽♯A exists then ▽♯A exists and ▽♯A ⪯♯▽♯A in which case ⟨c, a⟩∈σ
implies ⟨c, ▽♯A⟩∈σ by (4.7) whence α(c) ⪯♯▽♯A by (4.21) and therefore α(c) ⪯♯
▽♯A by transitivity, that is ⟨c, ▽♯A⟩∈σ. In the absence of an explicit widening, the
soundness of this approach can be justiﬁed by the following:
Proposition 6.10 (Semantic approximation using an abstraction function)
Given the sets P♮of concrete properties and ⟨P♯; ⪯♯⟩of abstract properties with
pre-order ⪯♯, the abstraction function α ∈P♮→P♯, the basis ⊥- ♮such that α(⊥- ♮)
⪯♯F ♯0 , the concrete semantic function F ♮∈P♮≻→P♮such that α(F ♮λ) ⪯♯F ♯λ ⇒
α(F ♮(F ♮λ)) ⪯♯F ♯λ+1 for all λ ∈Ord, the concrete inductive join ⨿♮∈℘(P♮) ≻→P♮
such that ∀β < λ : α(F ♮β) ⪯♯F ♯β ⇒α(⨿♮
β<λF ♮β) ⪯♯F ♯λ for all limit ordinals λ > 0
and assuming that the concrete and abstract iteration sequences are convergent then
their respective limits F ♮ϵ and F ♯ε are such that α(F ♮ϵ) ⪯♯F ♯ε.
Proof. By transﬁnite induction α(F ♮λ) ⪯♯F ♯λ for all λ ∈Ord.
Observe that in this case the abstraction iteration process omits certain details or
aspects of the concrete properties which causes some loss of information.
Example 6.11 (Inducing Burn, Hankin and Abramsky’s strictness analysis method
from a denotational semantics)
Let us illustrate the inducing of Burn, Hankin and Abramsky’s strictness analysis
method from a denotational semantics for the simple explicitly typed lambda
calculus considered in .
P. Cousot and R. Cousot
Given base types A, . . . including booleans B = {tt, ﬀ}, type expressions
have the form τ = A | τ2 →τ1.
Typed constants cτ such as a ﬁxpoint combinator ﬁx(τ→τ)→τ and a conditional
condB→τ→τ as well as typed variables xτ are given for each type τ. Terms e of type
τ are built as follows:
λ xτ2.e : τ2 →τ1
e1 : τ2 →τ1
Denotational semantics.
An interpretation is given by bounded complete do­
mains Dτ with inﬁmum ⊥τ for each type τ such that Dτ2→τ1 is the domain
−→Dτ1 of continuous functions with domain Dτ2 and codomain Dτ1 and values
cτ ∈Dτ for each constant cτ such that, in particular:
cond ⊥B xy
cond tt xy
Environments ρ ∈E map variables xτ to values ρ(xτ) ∈Dτ. ρ[x →ν] is the
environment mapping x to ν and everywhere else equal to ρ.
The concrete properties are P♮def
= E →D where D
τ Dτ. The concrete semantics
[[eτ]]♮ρ ∈E →Dτ of term eτ in environment ρ is deﬁned by:
[[λ xτ.e]]♮ρ
λ ν ∈Dτ.[[e]]♮ρ[xτ →ν]
[[e1e2]]♮ρ
([[e1]]♮ρ)([[e2]]♮ρ) .
Abstraction.
Following Mycroft, the abstract domain ⟨D♯
A⟩for base
types A is a complete lattice where D♯
A = {0, 1} and 0 ⊑♯
abstraction function αA ∈DA →D♯
= 0 and αA(ν)
= 1 when ν ∈DA −{⊥A} .
Given complete lattices ⟨D♯
τ2⟩and ⟨D♯
τ1⟩then ⟨D♯
τ2→τ1 , ⊥♯
τ2→τ1 , ⊔♯
τ2→τ1⟩is a complete lattice where D♯
τ2→τ1 is the pointwise ordering. The corresponding abstraction function ατ2→τ1 ∈
(Dτ2→τ1) →(D♯
τ2→τ1) is deﬁned, according to (4.13), as:
 ατ2(ν) ⊑♯
where ατ2 ∈Dτ2 →D♯
τ2 and ατ1 ∈Dτ1 →D♯
τ1. Observe that ατ is surjective.
Abstract environments ρ♯∈E♯map variables xτ to abstract values ρ♯(xτ) ∈D♯
and deﬁne αE ∈E →E♯such that αE(ρ)xτ
= ατ(ρ(xτ)).
The abstract properties are P♯def
= E♯→D♯where D♯def
Soundness.
This abstract interpretation is sound since if αA→A(ϕ) ⊑♯φ and
φ(0) = 0 then ⊔♯
 αA(ν) ⊑♯
⊑♯0 implies αA(ϕ(⊥A)) = 0 whence
ϕ(⊥A) = ⊥A. This strictness proof method is not relatively complete since values
are ignored.
Abstract Interpretation Frameworks
Inducing the abstract interpretation.
We look for [[eτ]]♯∈P♯such that ατ
τ [[eτ]]♯αE(ρ). We proceed by induction on eτ:11
= αE(ρ)xτ = [[xτ]]♯αE(ρ) by deﬁning [[xτ]]♯ρ♯def
= ατ(cτ) = [[cτ]]♯αE(ρ) by deﬁning [[cτ]]♯ρ♯def
[[λ xτ2.eτ1]]♮ρ
λν ∈Dτ2.[[eτ1]]♮ρ[xτ2 →ν]
by (4.29) which, by
(4.31), is equal to λa.⊔♯
ατ1([[eτ1]]♮ρ [xτ2 →ν])
 ατ2(ν) ⊑♯a
and, by induction
hypothesis, is less than or equal to λ a.⊔♯
[[eτ1]]♯αE(ρ [xτ2 →ν])
 ατ2(ν) ⊑♯a
By deﬁnition of αE , this is equal to λ a.⊔♯
[[eτ1]]♯αE(ρ) [xτ2 →ατ2(ν)]
. ατ2 is surjective so that for ν ∈Dτ2 such that a = ατ2(ν) this is ⊑♯
λ a.[[eτ1]]♯αE(ρ)[xτ2 →a]
♯by monotony and deﬁnition of least upper bounds
(implying ⊔{ϕ(x) | x ⊑y} ⊑ϕ(y)). This can be written as [[λ xτ2.eτ1]]♯αE(ρ)
by deﬁning [[λ xτ.e]]♯ρ♯
τ.[[e]]♯ρ♯[xτ →ν].
– We have ατ1(ϕ(ν)) ⊑♯⊔♯
ατ1(ϕ(υ)) | ατ2(υ) ⊑♯ατ2(ν)
= ατ2→τ1(ϕ) ατ2(ν)
by (4.31) and deﬁnition of least upper bounds when υ = ν. It follows that
[[e1e2]]♮ρ
([[e1]]♮ρ)([[e2]]♮ρ)
⊑♯ατ2→τ1([[e1]]♮ρ) ατ2([[e2]]♮ρ) by induc­
tion hypothesis and pointwise ordering.
Again by induction hypothesis and
monotony, we have ατ2→τ1([[e1]]♮ρ) ατ2([[e2]]♮ρ) ⊑♯
[[e1]]♯αE(ρ)
ατ2([[e2]]♮ρ)
[[e1]]♯αE(ρ)
[[e2]]♯αE(ρ)
= [[e1e2]]♯αE(ρ) if [[e1e2]]♯ρ♯def
[[e1]]♯ρ♯
[[e2]]♯ρ♯
To sum up, we have formally calculated that the abstract semantics [[eτ]]♯ρ♯of term
eτ in abstract environment ρ♯can be deﬁned as:
[[λ xτ.e]]♯ρ♯
τ.[[e]]♯ρ♯[xτ →ν]
[[e1e2]]♯ρ♯
[[e1]]♯ρ♯
[[e2]]♯ρ♯
The abstract interpretation of constants is:
For example, let us consider ﬁx♯. By induction on type τ , using (4.30) and (4.31),
ατ is a strict ατ(⊥τ) = ⊥♯
τ complete join morphism ατ
τατ(νi) when
i τνi exists. Moreover, we have proved that if ϕ = [[eτ]]♮ρ and ϕ♯= [[eτ]]♯αE(ρ) then
ατ→τ(ϕ) ⊑♯
τ→τ ϕ♯whence, by deﬁnition of the pointwise ordering, for all ν♯∈D♯τ :
(ατ→τ(ϕ))ν♯⊑♯
τ ϕ♯ν♯. It follows by (4.31) that ⊔♯
ατ(ϕ(ν)) | ατ(ν) ⊑♯
whence in particular for ν = ν♮, if ατ(ν♮) ⊑♯
τ ν♯then we have ατ(ϕ(ν♮)) ⊑♯
deﬁnition of least upper bounds. By Proposition 6.10, we conclude that α(ﬁx) ⊑♯ﬁx♯.
11 The objective of the following calculation is to illustrate the constructive aspect of the approach,
which we have found very useful in practice as a guideline for inferring abstract interpreters from a
semantics, as opposed to a posteriori veriﬁcations using a soundness relation, e.g. as in .
P. Cousot and R. Cousot
In general Proposition 6.10 is used with stronger hypotheses such as, for example,
that the abstract iteration is deﬁned inductively by ⟨⊥- ♯, F ♯, ⊔♯⟩where ⊥- ♯def
the inﬁmum for ⪯♯, ∀c ∈P♮: ∀a ∈P♯: α(c) ⪯♯a ⇒α(F ♮(c)) ⪯♯F ♯(a) (which holds
in particular when F ♯is monotonic for ⪯♯and α ◦F ♮⪯♯F ♯◦α), ⊔♯is the least upper
bound for ⪯♯and the abstract iterates are total because, among others, ⟨P♯; ⪯♯⟩is
a cpo or a complete lattice. Such hypotheses are satisﬁed in Example 6.11. See for
example proposition 7.1.0.4.(2) of , which can be stated as follows:
Proposition 6.12 (Semantic approximation using a Galois connection)
If ⟨P♮; ⊑♮, ⊥♮, ⊔♮⟩is a cpo, F ♮∈P♮
−→P♮, ⟨P♯; ⊑♯⟩is a poset, ⟨P♮; ⊑♮⟩↼−
⊑♯⟩, α(⊥♮) = ⊥- ♯, F ♯∈P♯→P♯is F ♯def
= α◦F ♮◦γ then the abstract iteration sequence
= ⊥- ♯, F ♯λ+1 def
= F ♯(F ♯λ) for λ ∈Ord and F ♯λ def
β<λF ♯β for all limit ordinals
λ > 0 is convergent such that α(lfp
⊥♮F ♮) ⊑♯F ♯ε = lfp
Proof. Follows from Proposition 6.10 since the Galois connection ensures the exis­
tence of the abstract least upper bounds ⊔♯
Example 6.13 (Collecting semantics for Burn, Hankin and Abramsky’s strictness
analysis method)
The original construction of is based upon Proposition 6.12 using Hoare power
domains for the collecting semantics (whereas used a variant of Plotkin’s power­
domain so as to handle also termination analysis) and Galois connections. The main
idea is to lift Mycroft’s abstraction (4.30) to higher-order function spaces. This idea
is of general use as shown by theorem 4.1.7.1 of based upon (4.17).
The speciﬁcation (4.9), (4.10) and (4.11) of an abstract interpreter is
not directly implementable since, in general, F ♮, α, σ and ⨿♯are not computable. The
ﬁrst solution considered in Propositions 6.8, 6.9, 6.10 and 6.12 consists in providing
an abstract semantic function F ♯which is an approximation of λa.▽♯
P♮∧⟨c, a⟩∈σ
. Another solution would consist in implementing the widening ▽♯
as well as an approximation F ♯∈P♯→℘(P♯) of λ a.
 c ∈P♮∧⟨c, a⟩∈σ
but we know very few examples of application of this approach since, for practical
reasons, one wants to avoid representing sets of abstract properties F ♯(a), just to
select one ▽♯(F ♯(a)).12
However, the idea has been generalized in by considering an abstract iteration
depending on previous iterates:
∪{⊥- ♯}) .
In it was observed that the widening may diﬀer at each iteration step which
consists in considering iterations of the form:
⟨β, F ♯(F ♯β)⟩
12 An example is where local decreasing iterations are considered to improve the conjunction
of abstract reductive operators which, for example, appears in tests.
Abstract Interpretation Frameworks
To simplify the presentation, one can consider only two consecutive iterates and deﬁne
the abstract iteration sequence with widening:
F ♯↑λ ▽♯F ♯(F ♯↑λ)
for limit ordinals λ > 0 .
The general soundness condition (4.7) for the widening can be reﬁned using the
approximation ordering ⪯♯. For example given an abstraction relation α and deﬁning
soundness by (4.21), we obtain:
▽♯A exists ∧c ∈P♮∧a′ ∈P♯∧a ∈A ⇒
(⟨c, a′⟩∈α ∧a′ ⪯♯a) ⇒(∃a′′ ∈P♯: ⟨c, a′′⟩∈α ∧a′′ ⪯♯▽♯A) .
In particular if α is an abstraction function this is equivalent to:
▽♯A exists ∧c ∈P♮∧a ∈A ∧α(c) ⪯♯a
α(c) ⪯♯▽♯A
which is implied by the stronger requirement:
▽♯A exists ∧a ∈A
which holds when the widening is a partially deﬁned upper bound in P♯(but not
necessarily the least one). The widening is also used as an abstract join, as in (4.34),
in the sense that:
i∈I ci exists ∧▽♯
i∈I ai exists ∧∀i ∈I : α(ci) ⪯♯ai
i∈I ai (4.40)
When using a widening, Proposition 6.10 becomes:
Proposition 6.14 (Semantic approximation using an abstraction function and a
Given the sets P♮of concrete properties and ⟨P♯; ⪯♯⟩of abstract properties with
pre-order ⪯♯, the abstraction function α ∈P♮→P♯, the bases ⊥- ♮and ⊥- ♯such that
α(⊥- ♮) ⪯♯⊥- ♯, the concrete F ♮∈P♮≻→P♮and abstract F ♯∈P♯≻→P♯semantic
functions such that ∀c ∈P♮: ∀a ∈P♯: α(c) ⪯♯a ⇒α(F ♮(c)) ⪯♯F ♯(a) (when
F ♮(c) and F ♯(a) are well-deﬁned and holds in particular when F ♯is monotonic for
⪯♯and α ◦F ♮⪯♯F ♯◦α), the concrete inductive join ⨿♮∈℘(P♮) ≻→P♮, the widening
▽♯∈℘(P♯) ≻→P♯satisfying (4.38) and (4.40) and assuming that the concrete
iteration sequence (4.1) and abstract iteration sequence with widening (4.36) are
convergent then their respective limits F ♮ϵ and F ♯↑ε are such that α(F ♮ϵ) ⪯♯F ♯↑ε.
Proof. If α(F ♮λ) ⪯♯F ♯↑λ then by (4.1) we have α(F ♮λ+1) = α(F ♮(F ♮λ)) ⪯♯F ♯(F ♯↑λ)
whence α(F ♮λ+1) ⪯♯F ♯↑λ ▽♯F ♯(F ♯↑λ) = F ♯↑λ+1 by (4.38) and (4.36). Moreover, for
all limit ordinals λ > 0, ∀β < λ: α(F ♮β) ⪯♯F ♯↑β implies α(⨿♮
β<λF ♮β) ⪯♯F ♯↑λ by
(4.40) and (4.36). We conclude by Proposition 6.10.
P. Cousot and R. Cousot
Convergence criteria.
Up to now, we have not discussed the convergence problem
for the abstract iteration F ♯λ , λ ∈Ord and assumed that it was “ultimately station­
ary”. When the abstract iteration is deﬁned by a semantic function this means that
a ﬁxpoint is reached since F ♯ε = F ♯ε+1 = F ♯(F ♯ε). When using Proposition 6.10 or
its corollary 6.14 where the iteration introduces further approximations than those re­
quired by α, stabilization on a ﬁxpoint may no longer be necessary. So a fourth basic
choice in the design of an abstract interpretation is to ﬁnd a convenient convergence
criterion, ensuring the best possible precision.
Example 6.15 (Minimal function graph)
The invariance analysis of side-eﬀect-free ﬁrst-order procedures with value and result
parameters which, but for syntactic sugaring, includes functions is considered in .
The standard semantics is relational in that the semantics of mutually recursive pro­
cedures is understood as a relation between the values of their value parameters and
that of their result parameters. It is obtained as the least ﬁxpoint of a higher-order
system of ﬁxpoint equations ⃗f ♮= ⃗F ♮( ⃗f ♮). An abstract interpretation ⃗f ♯= ⃗F ♯( ⃗f ♯)
is derived using (4.17). For example the abstract equation for program f(x) = if
x=0 then 0 else f(-x) is F(f) = λx.if x = ⊥then ⊥else 0 ⊔f(−x) for the rule of
signs lattice of Example 7.2. Two methods are considered for solving such equations:
1. An algebraic method using (4.2) and a symbolic representation of the abstract
functions f ♯which can be applied to relational abstract analyses so as to analyse
the (mutually recursive) procedure/function bodies, once for all, independently
of the main calls. For the above example the iterates would be f ♯0 = λa.⊥, f ♯1
= λa.0 ⊔f ♯0(−a) = λa.0, f ♯2 = f ♯1. For a recent application of this technique
see the“on-line” analyses of .
2. A chaotic iteration method (theorem 4.2.1.2 in , popularized as “minimal
function graph” by ), which is based on the observation that in practice
f ♯(a) needs to be known only for some, but not all its abstract arguments a
so that the abstract resolution of ⃗f ♯= ⃗F ♯( ⃗f ♯) demands collecting the set of
points on which the abstract functions f ♯are actually called with during the
computation on an initial set of abstract arguments, given by the main calls.
For the above example the iterates for f(+) would be f ♯0(a) = ⊥, f ♯1(+) =
0 ⊔f ♯0(−) = 0, f ♯1(−) = 0 ⊔f ♯1(+) = 0, f ♯2(+) = f ♯1(+), f ♯2(−) = f ♯1(−).
Observe that a ﬁxpoint is computed in case 1 whereas f ♯(⊥), f ♯(−) and f ♯(⊤) have
not be computed in case 2 so that the iterates do not stabilize on a ﬁxpoint, but on a
post-ﬁxpoint by considering that f ♯(⊥), f ♯(−) and f ♯(⊤) are unknown hence equal
Example 6.16 (post-ﬁxpoints)
Let us consider the case when the approximation ordering ⪯♯is a partial order, F ♯is a
monotonic operator on a complete lattice ⟨P♯; ⪯♯, ⊔♯, ⊓♯⟩and it is known that α(F ♮ϵ)
⪯♯lfp F ♯. Then, as suggested in deﬁnition 9.1.1.3 of , we can stop iterations (4.36)
as soon as a post-ﬁxpoint F ♯ε of F ♯(such that F ♯(F ♯ε) ⪯♯F ♯ε) is reached since, by
Tarski’s ﬁxpoint theorem, we have lfp F ♯= ⊓♯
X ∈P♯ F ♯(X) ⪯♯X
hence lfp F ♯
⪯♯F ♯ε , so that by transitivity α(F ♮ϵ) ⪯♯F ♯ε.
Convergence to a post-ﬁxpoint can be enforced using a widening satisfying (4.39) and
the result can then be improved using a narrowing. In this case the abstract iteration
Abstract Interpretation Frameworks
sequence with widening (4.36) becomes:
if F ♯(F ♯↑λ) ⪯♯F ♯↑λ
= F ♯↑λ ▽♯F ♯(F ♯↑λ)
if ∃β < λ : F ♯(F ♯↑β) ⪯♯F ♯↑β
λ > 0 limit
The following propositions which explain this use of widenings and narrowings in
abstract interpretation are a variation on paragraphs 9.1 and 9.3 of :
Proposition 6.17 (Convergence of the semantic approximation to a post-ﬁxpoint
using a widening)
Let P♯(⪯♯) be a partially ordered set of abstract properties, ⊥- ♯be an abstract basis,
F ♯∈P♯≻→P♯be an abstract semantic function and ▽♯∈℘(P♯) ≻→P♯be a
widening satisfying (4.39) such that the abstract iteration sequence with widening
(4.41) is total.
◦) This iteration sequence is increasing with respect to ⪯♯whence stationary. Its
limit F ♯↑ε is a post-ﬁxpoint of F ♯greater than or equal to ⊥- ♯.
◦) If F ♯is monotonic and ▽♯is the partially deﬁned least upper bound ⊔♯in P♯,
then F ♯↑ε is the least such post-ﬁxpoint.
◦) If F ♯is monotonic, ⊥- ♯is a pre-ﬁxpoint of F ♯and ▽♯is ⊔♯then F ♯↑ε is the least
ﬁxpoint of F ♯greater than or equal to ⊥- ♯.
◦) If the iteration sequence F ♯↑λ , for λ ∈Ord is total then its terms are all
well-deﬁned. Obviously, F ♯↑λ ⪯♯F ♯↑λ▽♯F ♯(F ♯↑λ) = F ♯↑λ+1 since, by (4.39), ▽♯is an
upper bound for the partial order ⪯♯. If λ > 0 is a limit ordinal and δ < λ then F ♯↑δ
β<λF ♯↑β = F ♯↑λ , proving that the iteration sequence is an increasing chain. It
cannot be strictly increasing since its cardinality must be less than or equal to that of
the set P♯and repetitions are disallowed by antisymmetry. Hence there is an ordinal
and therefore a smallest one, ε, such that F ♯↑ε = F ♯↑ε+1 = F ♯↑ε ▽♯F ♯(F ♯↑ε) hence
F ♯(F ♯↑ε) ⪯♯F ♯↑ε since ▽♯is an upper bound for ⪯♯. We have ⊥- ♯= F ♯↑0 ⪯♯F ♯↑ε.
◦) Let x be any post-ﬁxpoint of F ♯such that F ♯↑0 = ⊥- ♯⪯♯x.
If, by induction
hypothesis, F ♯↑λ ⪯♯x, then F ♯(F ♯↑λ) ⪯♯F ♯(x) ⪯♯x by monotony and post-ﬁxpoint
property, hence F ♯↑λ+1 = F ♯↑λ ▽♯F ♯(F ♯↑λ) ⪯♯x since ▽♯is the least upper bound
⊔♯. If, by induction hypothesis, F ♯↑β ⪯♯x for all β < λ then F ♯↑λ = ▽♯
β<λF ♯↑β ⪯♯x
since ▽♯is the least upper bound ⊔♯for ⪯♯. By transﬁnite induction, ∀λ ∈Ord : F ♯↑λ
⪯♯x so that, in particular, F ♯↑ε ⪯♯x.
◦) We have F ♯↑0 = ⊥- ♯⪯♯F ♯(⊥- ♯) ⪯♯F ♯↑1 by (4.39) and (4.41). If F ♯↑λ ⪯♯F ♯(F ♯↑λ) =
F ♯↑λ+1 then by monotony F ♯↑λ+1 = F ♯(F ♯↑λ) ⪯♯F ♯(F ♯↑λ+1) proving that F ♯↑λ+1 is
also a pre-ﬁxpoint of F ♯. Moreover, ∀β < λ : F ♯↑β ⪯♯⊔♯
β<λF ♯↑β hence, by monotony,
F ♯↑β ⪯♯F ♯(F ♯↑β) ⪯♯F ♯(⊔♯
β<λF ♯↑β) = F ♯(F ♯↑λ) so that F ♯↑λ = ⊔♯
β<λF ♯↑β ⪯♯F ♯(F ♯↑λ)
proving that F ♯↑λ is also a pre-ﬁxpoint of F ♯. By transﬁnite induction, all terms of
the iteration sequence are pre-ﬁxpoints of F ♯proving by antisymmetry that F ♯↑ε is
a ﬁxpoint of F ♯, since it has already been proved to be a post-ﬁxpoint. Since it is
P. Cousot and R. Cousot
the least post-ﬁxpoint greater than or equal to ⊥- ♯, it is also the least such ﬁxpoint,
since ⪯♯is reﬂexive.
Observe that the main use of the widening ▽♯in Proposition 6.17 is to serve as a
palliative to the non-existence of least upper bounds for ⪯♯in P♯. This is indispens­
able in for example since the limit of chains of convex polyhedra increasing for
inclusion may not be a convex polyhedron. To be more speciﬁc on the reasons for
convergence of (4.41), it can be assumed, for example, that ⟨P♯; ⊑♯, ▽♯⟩is a cpo and
that F ♯is total and either extensive or monotonic and ⊥- ♯is a pre-ﬁxpoint for ⊑♯or
that ultimate stabilization of the iteration sequence follows from metric arguments.
Narrowing.
Let us deﬁne the abstract iteration sequence with narrowing starting
from a ∈P♯:
F ♯↓λ △♯F ♯(F ♯↓λ)
for limit ordinals λ > 0 .
Deﬁnitions (4.36) and (4.42) are an oversimpliﬁcation since in practice :
– The deﬁnitions a ▽♯a′
= ▽♯{a, a′} and a △♯a′
= △♯{a, a′} do not take
non-commutativity into account (but see (4.46)).
– The widening and narrowing operators are not always between two consecutive
iterates since they are used only once within any loop or recursive call and more
than one iteration is needed to handle the loop or procedure/function body, so
– The widening and narrowing operators depend upon the rank of the iterates, as
in . For example, a simple way to balance the precision/cost tradeoﬀis to
deﬁne x▽λ y
= if λ < n then x else ⊤♯where n is a user adjustable parameter.
A similar simple narrowing would be x△λy
= if λ < n then x else y. In practice
such naïve operators would be eﬀective to handle loops and recursion only.
Hypotheses on the widening (4.39) and on the narrowing (4.44) diﬀer from the original
ones which admit several other slight variations (see, for example, ).
When soundness is deﬁned by (4.21), the general soundness condition (4.8) for
the narrowing can be reﬁned using the abstraction function α and the approximation
ordering ⪯♯:
∀A ⊆P♯: △♯A exists ∧c ∈P♮⇒
(∀a ∈A : α(c) ⪯♯a) ⇒(α(c) ⪯♯△♯A)
which is implied by the stronger requirement that a narrowing is a partially deﬁned
upper bound of greatest lower bounds in P♯:
∀A ⊆P♯: if △♯A exists then ⊓♯A exists and ∃a ∈A : ⊓♯A ⪯♯△♯X ⪯♯a .
A narrowing can be used to improve an abstract upper approximation a of a concrete
ﬁxpoint c (typically a is obtained by Proposition 6.14):
Abstract Interpretation Frameworks
Proposition 6.18 (Semantic approximation using an abstraction function and a
narrowing)
Given the sets P♮of concrete properties and ⟨P♯; ⪯♯⟩of abstract properties with
pre-order ⪯♯, the abstraction function α ∈P♮→P♯, the concrete F ♮∈P♮≻→P♮
and abstract F ♯∈P♯≻→P♯semantic functions such that ∀c ∈P♮: ∀a ∈P♯: α(c) ⪯♯a
⇒α(F ♮(c)) ⪯♯F ♯(a) (when F ♮(c) and F ♯(a) are well-deﬁned), the abstract upper
approximation a ∈P♯of the ﬁxpoint c = F ♮(c) of F ♮such that α(c) ⪯♯a and the
narrowing △♯∈℘(P♯) ≻→P♯satisfying (4.43) then the abstract iteration sequence
with narrowing (4.42) is such that if F ♯↓β is well-deﬁned for all β ≤λ then α(c) ⪯♯
Proof. The proof is by transﬁnite induction on λ. For the basis we have α(c) ⪯♯a =
F ♯↓0. Assume that α(c) ⪯♯F ♯↓λ and F ♯↓λ+1 is well-deﬁned. Then α(c) = α(F ♮(c)) ⪯♯
F ♯(α(c)) ⪯♯F ♯(F ♯↓λ) ⪯♯F ♯↓λ+1 by (4.42) and (4.43). If ∀β < λ : α(c) ⪯♯F ♯↓β then
β<λF ♯↓β = F ♯↓λ for limit ordinals λ > 0 by (4.43) when this is well-deﬁned.
Observe that in Propositions 6.14 and 6.18, α formalizes a “static” approximation,
prior to the elaboration of the abstract version F ♯of F ♮whereas the widening ▽♯and
narrowing △♯formalize a further “dynamic” approximation during the computation
of the abstract iteration sequences F ♯↑λ and F ♯↓λ for λ ∈Ord.
When starting from a post-ﬁxpoint the abstract iteration sequence with narrowing
(4.42) is decreasing and remains above any ﬁxpoint of F ♯:
Proposition 6.19 (Convergence of the semantic approximation from a post-ﬁxpoint
using a narrowing)
Let ⟨P♯; ⪯♯⟩be the partially ordered set of abstract properties, △♯be a narrowing
in P♯satisfying (4.44) and F ♯↓λ for λ ∈Ord be the abstract iteration sequence with
narrowing (4.42) starting from a ∈P♯such that F ♯(a) ⪯♯a.
◦) F ♯↓λ , λ ∈Ord is decreasing piecewise, that is F ♯(F ♯↓λ) ⪯♯F ♯↓λ+1 ⪯♯F ♯↓λ and
∃β < λ : F ♯↓λ ⪯♯F ♯↓β for limit ordinals λ > 0.
◦) If △♯is the partially deﬁned greatest lower bound ⊓♯in P♯and the sequence F ♯↓λ ,
λ ∈Ord is total then it is decreasing and convergent. Its limit F ♯↓∈is a ﬁxpoint of
◦) If, moreover, F ♯is monotonic then F ♯↓∈is the greatest ﬁxpoint of F ♯less than or
equal to a.
◦) If F ♯↓λ is a post-ﬁxpoint of F ♯then the greatest lower bound of F ♯↓λ and
F ♯(F ♯↓λ) is F ♯(F ♯↓λ) so that by (4.44), we have F ♯(F ♯↓λ) ⪯♯F ♯↓λ △♯F ♯(F ♯↓λ) which
is equal to F ♯↓λ+1 if well-deﬁned. Moreover, we must either have F ♯↓λ+1 ⪯♯F ♯↓λ or
else F ♯↓λ+1 ⪯♯F ♯(F ♯↓λ) in which case equality holds since ⪯♯is antisymmetric and
therefore F ♯↓λ+1 ⪯♯F ♯↓λ by post-ﬁxpoint property. For limit ordinals λ > 0, we have
F ♯↓λ = △♯
β<λF ♯↓β whence by (4.44) ∃β < λ : F ♯↓λ ⪯♯F ♯↓β.
◦) For limit ordinals λ > 0, we have F ♯↓λ = ⊓♯
β<λF ♯↓β hence ∀β < λ : F ♯↓λ ⪯♯F ♯↓β
when the greatest lower bound is well-deﬁned. By transﬁnite induction using 1
conclude that F ♯↓λ , λ ∈Ord is a decreasing chain. The sequence is assumed to be
total hence it is ultimately stationary since its cardinality is less than or equal to that
of P♯and ⪯♯is antisymmetric. Its limit F ♯↓∈is a ﬁxpoint of F ♯since F ♯(F ♯↓∈) ⪯♯
F ♯↓∈+1 = F ♯↓∈by 1
◦) hence F ♯↓∈= F ♯↓∈+1 = F ♯↓∈⊓♯F ♯(F ♯↓∈) = F ♯(F ♯↓∈).
P. Cousot and R. Cousot
◦) Let x be a ﬁxpoint of F ♯less than or equal to a = F ♯↓0. Assume by induction
hypothesis that x ⪯♯F ♯↓λ ⪯♯a. Then by monotony and 1
◦), x = F ♯(x) ⪯♯F ♯(F ♯↓λ)
⪯♯F ♯↓λ+1 ⪯♯F ♯↓λ ⪯♯a. The same way, if λ > 0 is a limit ordinal and ∀β < λ : x ⪯♯
F ♯↓β ⪯♯a then x ⪯♯⊓♯
β<λF ♯↓β ⪯♯a by deﬁnition of greatest lower bounds. Hence
∀λ ∈Ord : x ⪯♯F ♯↓λ ⪯♯a which holds in particular for λ = ∈.
The use of an increasing (upper) iteration to a post-ﬁxpoint followed by a de­
creasing (upper) iteration to a ﬁxpoint is a natural method to reach ﬁxpoints of
monotonic functions (or upper approximations of these), as shown by Propositions
6.17 and 6.19 and their duals, which is the basis to the constructive version of Tarski’s
ﬁxpoint proposition . The usual iteration from the inﬁmum ⊥to the least ﬁxpoint
is a degenerate case (where the decreasing iteration is constant).
An often misunderstood point is that the narrowing △is not the dual of a widen­
ing ▽. A widening is used to approximate an increasing iteration from above. Its
dual would approximate a decreasing sequence from below whereas the narrowing is
used to approximate a decreasing sequence from above, so as not to overshoot the
approximated and unknown ﬁxpoint. As usual, we do not state the dual of proposi­
tions, but in doing so we should follow and distinguish four operators ▽= ▽,
△= △for approximations from above and ▽, △for approximations from below
(which, for example, would be useful for model checking).
Termination.
In practice, automated abstract interpretations must terminate. There­
fore a ﬁfth basic choice in the design of an abstract interpretation is the method
ensuring termination of the abstract interpreter. Therefore an additional hypothesis
The abstract iteration sequences (4.36) and (4.42) are eventually stable
after ﬁnitely many steps.
In this case hypotheses such as (4.40) to handle transﬁnite abstract iteration se­
quences are useless and A can be assumed to be ﬁnite in (4.39), (4.43) and (4.44).
The resort to ﬁnite domains P♯of abstract properties, or to the non-existence of
strictly increasing chains is not always satisfactory since termination must also be
rapid. A widening/narrowing approach can be used to enforce quick termination as
in . In case of ﬁnite termination, Propositions 6.14 and 6.18 can be made more
speciﬁc as follows:
Proposition 6.20 (Finite semantic approximation using an abstraction function
and a widening)
Given the sets P♮of concrete properties and P♯of abstract properties with approx­
imation pre-order ⪯♯and computational partial order ⊑♯, the abstraction function
α ∈P♮→P♯, the bases ⊥- ♮∈P♮and ⊥- ♯∈P♯, the concrete F ♮∈P♮≻→P♮and
abstract F ♯∈P♯→P♯semantic functions, the concrete inductive join ⨿♮∈℘(P♮)≻→
Abstract Interpretation Frameworks
P♮, the widening ▽♯∈℘(P♯× P♯) →P♯such that:
α(⊥- ♮) ⪯♯⊥- ♯,
∀c ∈P♮: ∀a ∈P♯: α(c) ⪯♯a ⇒α(F ♮(c)) ⪯♯F ♯(a) (when F ♮(c) is
well-deﬁned),
(∀i ∈I : α(ci) ⪯♯a) ⇒α(⨿♮
i∈I ci) ⪯♯a (when ⨿♮
i∈I ci is well-deﬁned),
∀a, a′ ∈P♯: a ⊑♯a ▽♯a′ ,13
∀c ∈P♮: ∀a, a′ ∈P♯: α(c) ⪯♯a′ ⇒α(c) ⪯♯a ▽♯a′ ,13
For every N-termed sequence x0, . . . , xi, . . . in P♯, the chain y0 =
x0 ⊑♯. . . ⊑♯yi+1 = yi ▽♯xi ⊑♯. . . is not strictly increasing,14
and assuming that the concrete iteration sequence (4.1) is convergent with limit F ♮ϵ
then the abstract iteration sequence with widening:
F ♯↑i ▽♯F ♯(F ♯↑i)
is eventually stable after ℓ∈N steps and α(F ♮ϵ) ⪯♯F ♯↑ℓ.
Proof. The sequence F ♯↑i , i ∈N is increasing since F ♯↑i ⊑♯F ♯↑i ▽♯F ♯(F ♯↑i) =
F ♯↑i+1 but not strictly whence there exists a smallest ℓ∈N such that F ♯↑ℓ= F ♯↑ℓ+1
because ⊑♯is antisymmetric.
It ℓ≤k and F ♯↑ℓ= F ♯↑k then F ♯↑ℓ= F ♯↑ℓ+1 =
F ♯↑ℓ▽♯F ♯(F ♯↑ℓ) = F ♯↑k ▽♯F ♯(F ♯↑k) = F ♯↑k+1 proving stability after ℓsteps.
By (4.1) we have α(F ♮0) = α(⊥- ♮) ⪯♯⊥- ♯= F ♯↑0. If α(F ♮i) ⪯♯F ♯↑i then α(F ♮(F ♮i))
⪯♯F ♯(F ♯↑i) and therefore α(F ♮i+1) ⪯♯F ♯↑i▽♯F ♯(F ♯↑i) = F ♯↑i+1. By recurrence on i,
we have in particular α(F ♮ℓ) ⪯♯F ♯↑ℓ. Moreover, if α(F ♮λ) ⪯♯F ♯↑ℓthen α(F ♮(F ♮λ))
⪯♯F ♯(F ♯↑ℓ) and therefore α(F ♮λ+1) ⪯♯F ♯↑ℓ▽♯F ♯(F ♯↑ℓ) = F ♯↑ℓ. Finally if α(F ♮β)
⪯♯F ♯↑ℓfor all β < λ then α
⪯♯F ♯↑ℓso that by transﬁnite induction we
have α(F ♮ϵ) = α(F ♮µ) ⪯♯F ♯↑ℓfor the maximum µ of ϵ an ℓ.
Proposition 6.21 (Finite semantic approximation using an abstraction function
and a narrowing)
Given the sets P♮of concrete properties and P♯of abstract properties with approx­
imation pre-order ⪯♯and computational partial order ⊑♯, the abstraction function
α ∈P♮→P♯, the concrete F ♮∈P♮≻→P♮and abstract F ♯∈P♯→P♯semantic
functions, the approximation a ∈P♯of the ﬁxpoint c ∈P♮of F ♮, the narrowing
△♯∈℘(P♯× P♯) →P♯such that:
F ♮(c) = c and α(c) ⪯♯a,
∀a ∈P♯: α(c) ⪯♯a ⇒α(F ♮(c)) ⪯♯F ♯(a),
∀a, a′ ∈P♯: a △♯a′ ⊑♯a,15
∀c ∈P♮: ∀a, a′ ∈P♯: α(c) ⪯♯a ∧α(c) ⪯♯a′ ⇒α(c) ⪯♯a △♯a′ ,15
For every N-termed sequence x0, . . . , xi, . . . in P♯, the chain y0 =
x0 ⊒♯. . . ⊒♯yi+1 = yi △♯xi ⊒♯. . . is not strictly decreasing,16
13 if F ♯is monotonic for ⊑♯then we can assume that a ⊑♯a′ and that a ▽♯a′ is well-deﬁned only
in that case.
14 if F ♯is monotonic for ⊑♯then we can assume that xi , i ∈N is an increasing chain for ⊑♯.
P. Cousot and R. Cousot
then the abstract iteration sequence with narrowing:
F ♯↓i △♯F ♯(F ♯↓i)
is eventually stable after ℓ∈N steps and such that α(c) ⪯♯F ♯↓i for all i ∈N.
Proof. The sequence F ♯↓i , i ∈N is decreasing since F ♯↓i ⊒♯F ♯↓i △♯F ♯(F ♯↓i) =
F ♯↓i+1 but not strictly whence there exists a smallest ℓ∈N such that F ♯↓ℓ= F ♯↓ℓ+1
because ⊑♯is antisymmetric.
If ℓ≤k and F ♯↓ℓ= F ♯↓k then F ♯↓ℓ= F ♯↓ℓ+1 =
F ♯↓ℓ△♯F ♯(F ♯↓ℓ) = F ♯↓k △♯F ♯(F ♯↓k) = F ♯↓k+1 proving stability after ℓsteps.
We have α(c) ⪯♯a = F ♯↓0. If α(c) ⪯♯F ♯↓i then α(F ♮(c)) ⪯♯F ♯(F ♯↓i) and therefore
α(c) ⪯♯F ♯↓i △♯F ♯(F ♯↓i) = F ♯↓i+1. By recurrence, we have α(c) ⪯♯F ♯↓i for all i ∈N.
Concretization correspondence between concrete
and abstract semantics
We have studied the case when the connection between the concrete and abstract
semantics is established via an abstraction relation or function α and the notion of
precision is formalized using an approximation relation ⪯♯on the abstract properties.
We now shortly examine the case when the connection between the concrete and
abstract semantics is established via a concretization relation or function γ and the
notion of precision is formalized using an approximation relation ⪯♮on the concrete
properties:
is a pre-order,
(c ⪯♮c′) ∧(c′ ⪯♮c)
Both cases should be considered since in practice one way may be easier than the
Example 7.1 (Invariance)
Let S be the set of program states, Sω be the set of inﬁnite sequences τ of states
of length |τ| = ω , S⋆be the set of ﬁnite sequences τ of states of length |τ| ∈N,
S∞= S⋆∪Sω. We write τi for the ith state in τ counting from 0. The semantics of a
program is a set of ﬁnite or inﬁnite execution traces so that P♮= ℘(S∞). A property
is a set of states P♯= ℘(S) which characterizes the states reachable during program
execution so that α ∈P♮→P♯is deﬁned by α(T )
τ∈T α(τ) where α ∈S∞→P♯
is deﬁned by α(τ)
= {τi | 0 ≤i < |τ|}.
The invariance soundness relation σI ∈℘(P♮× P♯) is:
= {⟨T, P⟩| ∀τ ∈T : ∀i < |τ| : τi ∈P} .
Observe that σI satisﬁes ∀T ∈P♮: ∀P, P ′ ∈P♯: (⟨T, P⟩∈σI ∧P ⊆P ′)
⟨T, P ′⟩∈σI , that is (4.19), where the abstract approximation relation is deﬁned as
15 if F ♯is monotonic for ⊑♯then we can assume that a′ ⊑♯a and that a △♯a′ is well-deﬁned only
in that case.
16 if F ♯is monotonic for ⊑♯then we can assume that xi , i ∈N is a decreasing chain for ⊑♯.
Abstract Interpretation Frameworks
concretization
abstraction
more precise
less precise
is approximated by
approximates
increasing
decreasing
least ﬁxpoint
greatest ﬁxpoint
Galois connections
⟨S′; ⊒′⟩↼−
Set elements
Figure 1: Dual abstract interpretations
The concrete approximation relation is deﬁned as T ⪯♮T ′ def
= α(T ) ⊆α(T ′), that
is ∀τ ∈T : ∀i ∈|τ| : ∃τ′ ∈T ′ : ∃j ∈|τ′| : τi = τ ′j , so that the approximation relation
is easier to deﬁne in the abstract domain.
Example 7.2 (Signs)
Let s[x] be the value of variable x in state s ∈S , P♮
= ℘(S), P♯
= {⊥, 0, +, −,
⊤} and γ ∈P♯→P♮be such that:
{s ∈S | s[x] = 0}
{s ∈S | s[x] ≥0}
{s ∈S | s[x] ≤0}
The concrete approximation relation is ⪯♮def
= ⊆whereas the abstract approximation
relation ⪯♯is deﬁned by a ⪯♯a′
= γ(a) ⪯♮γ(a′). A direct deﬁnition is not so easy
since it involves the description of the above Hasse diagram by cases.
Dual abstract interpretations.
Abstract interpretation frameworks based upon
a concrete approximation relation ⪯♮and a concretization relation or function γ
can be obtained by duality from the abstract interpretation frameworks considered
in Section 6 which were based upon an abstract approximation relation ⪯♯and an
abstraction relation or function α. Duality of abstract interpretations is deﬁned in
Fig. 1. Observe that it diﬀers from order-theoretic duality where ⊑, ⊥, ⊤, ⊔and
⊓would be respectively replaced by ⊒, ⊤, ⊥, ⊓and ⊔but γ , α, σ , etc. would
be left unchanged. We will often consider the order-theoretic dual of a dual abstract
interpretation so as, for example, to stick with least ﬁxpoints but to use concretization
P. Cousot and R. Cousot
instead of abstraction relations or functions. For example the dual of (4.1) is (4.2).
The dual of (4.3) is σ−1 ∈℘(P♯× P♮), that is σ ∈℘(P♮× P♯), so that (4.3) is
self-dual.
The dual of the existence of abstract approximations assumption (4.5)
is ∀a ∈P♯: ∃c ∈P♮: ⟨a, c⟩∈σ−1 , that is the usefulness of abstract properties
assumption:
∀a ∈P♯: ∃c ∈P♮: ⟨c, a⟩∈σ .
This assumption states that an abstract property a such that
c ∈P♮| ⟨c, a⟩∈σ
is empty is useless in the sense that it can be used to approximate no concrete
property and therefore can be eliminated from P♯without harm, that is without losing
expressive power with respect to the given concrete properties P♮. For example in
strictness analysis non-monotonic abstract functions such as ϕ(0) = 1 and ϕ(1) = 0
are useless. Proposition 4.3 is self-dual since concrete and abstract properties are
treated on terms of equality when their correspondence is formalized using a relation.
In general the meaning {c | ⟨c, a⟩∈σ} of an abstract property a has no or multiple
maximal elements. In these circumstances the dual of Proposition 4.5 speciﬁes the
inducing of the concrete iterates from the abstract iterates by discriminating among
all sound possibilities. It uses concrete narrowing △♮and widening ▽♮to respectively
mitigate the absence of greatest lower bounds and least upper bounds for ⪯♮in P♮.
In general however, the concrete semantics is a given collecting semantics which is
intended to be more precise than its abstraction in which case one uses the dual of
Section 6.
Concretization relation between the concrete and abstract properties.
can start by introducing a concretization relation:
γ ∈℘(P♯× P♮)
specifying which concrete properties can be safely approximated by abstract proper­
ties, together with a pre-order ⪯♮on P♮to specify the relative precision of concrete
properties. Afterwards, the soundness relation σ ∈℘(P♮×P♯) can be deﬁned accord­
ing to the following concretization based soundness assumption:17
 ∃c′ ∈P♮: ⟨a, c′⟩∈γ ∧c ⪯♮c′ 
The relationship between ⪯♮and σ is that“more precise concrete properties are ap­
proximated by greater sets of abstract properties”: for all c, c′ in P♮, c ⪯♮c′ implies
{a′ | ⟨c′, a′⟩∈σ } ⊆{a | ⟨c, a⟩∈σ } by (4.53). Equations (4.50) and (4.53) imply:
∀c, c′ ∈P♮: ∀a ∈P♯: (⟨c, a⟩∈σ ∧c′ ⪯♮c) ⇒⟨c′, a⟩∈σ .
Redundancy between γ and σ can sometimes be avoided by requiring γ to select
the set of maximal concrete properties c in relation with a by the soundness relation
σ. In this case γ satisﬁes the concrete maximality assumption:
⟨a, c⟩∈σ−1  ∀c′ ∈P♮: (⟨c′, a⟩∈σ ∧c ⪯♮c′) ⇒(c′ ⪯♮c)
c | ⟨a, c⟩∈σ−1
may contain inﬁnite chains strictly increasing for ⪯♮, in
which case (4.55) would deﬁne γ as empty.
17 Observe that the set {c | ⟨c, a⟩∈σ} of concrete properties which can be approximated by a given
abstract property a is downwards closed. This remark leads to ideal-based abstract interpretation
frameworks as considered in paragraph 6.4 of .
Abstract Interpretation Frameworks
Figure 2: Dual deﬁnitions and assumptions
Concretization function from the concrete into the abstract properties.
When the abstract properties have best meanings:
∀a ∈P♯: ∃c ∈P♮: ⟨c, a⟩∈σ ∧∀c′ ∈P♮: ⟨c′, a⟩∈σ ⇒c′ ⪯♮c .
we can deﬁne γ by (4.55) so that, by the dual of Proposition 6.2, it is a concretization
function γ ∈P♯→P♮whenever ⪯♮is a partial ordering. The notion of soundness
can be deﬁned with respect to concrete properties as follows:
∀a ∈P♯: ∀c ∈P♮: ⟨c, a⟩∈σ ⇔c ⪯♮γ(a) .
The duality of the abstraction and concretization based abstract interpretation frame­
works is shown in Fig. 2.
The duals of Propositions 6.8 and 6.10 respectively deﬁne the inducing and the
approximation of the concrete iterates into the abstract domain using a concretization
function. Observe that the dual of corollary 6.9 of Proposition 6.8 involves greatest
ﬁxpoints on the cpo ⟨P♯; ⊒♯, ⊤♯, ⊓♯⟩therefore, as usual, it should be used in its
order-theoretic dual form for least ﬁxpoints on the cpo ⟨P♯; ⊑♮, ⊥♯, ⊔♯⟩to induce a
concrete form of abstract ﬁxpoints from a cpo by abstraction/concretization functions.
On the inducing of the abstract iterates using a concretization function.
The use of a concretization function is quite similar to that of an abstraction func­
tion for designing the abstract iterates.
In particular the soundness of widenings
and narrowings established in Propositions 6.14 and 6.18 can also be stated using a
concretization function, thanks to the following dual of Proposition 6.10:
Proposition 7.3 (Semantic approximation using a concretization function)
Given the sets ⟨P♮; ⪯♮⟩of concrete properties with pre-order ⪯♮and P♯of abstract
properties, the concretization function γ ∈P♯→P♮, the basis ⊥- ♯such that F ♮0 ⪯♮
γ(⊥- ♯), the abstract semantic function F ♯∈P♯≻→P♯such that F ♮λ ⪯♮γ(F ♯λ) ⇒
F ♮λ+1 ⪯♮γ(F ♯(F ♯λ)) for all λ ∈Ord, the abstract inductive join ⨿♯∈℘(P♯) ≻→P♯
such that ∀β < λ : F ♮β ⪯♮γ(F ♯β) ⇒F ♮λ ⪯♮γ(⨿♯
β<λF ♯β) for all limit ordinals λ > 0
and assuming that the concrete and abstract iteration sequences are convergent then
their respective limits F ♮ε and F ♯ϵ are such that F ♮ϵ ⪯♮γ(F ♯ε).
Observe that if we are interested in using the widening and narrowing operators on the
abstract domain (and not on the dual concrete domain as in dual propositions) then
Propositions 6.14, 6.17, 6.18 and 6.19 must be reformulated using a concretization
instead of an abstraction function. For short, this consists essentially in replacing the
soundness condition α(c) ⪯♯a by its substitute c ⪯♮γ(a).
P. Cousot and R. Cousot
Abstraction/concretization correspondence
between concrete and abstract semantics
We now examine the more symmetrical situation in which the notion of precision is
formalized on both concrete and abstract properties using the approximation rela­
tions ⪯♮and ⪯♯and the connection between the concrete and abstract semantics is
established via a pair of abstraction and concretization functions. In particular, ⟨P♮;
⟨P♯; ⪯♯⟩may be a Galois connection.
Weak abstraction/concretization connection with concrete approximation
pre-order.
A simple way to weaken the classical abstract interpretation framework
is to assume that the abstraction function α selects minimal abstract properties (but
not necessarily the best ones). Moreover, the notion of approximation can be deﬁned
on the concrete semantic domain P♮by a pre-order ⪯♮(4.50) (not necessarily a partial
order). If the meaning of abstract properties has been deﬁned by a concretization
function γ then the soundness relation σ deﬁned by (4.57) obviously satisﬁes the
concrete maximality assumption (4.55). It is possible to deﬁne the abstract approxi­
mation relation ⪯♯as the mere extension of ⪯♮onto P♯through γ:
= γ(a) ⪯♮γ(a′)
so that γ is monotonic by deﬁnition of ⪯♯. This situation is characterized by the
following:
Proposition 8.1 (Weak abstraction/concretization connection)
Let ⟨P♮; ⪯♮⟩by the set of concrete properties with pre-order ⪯♮, P♯be the set of
abstract properties, α ∈P♮→P♯be the abstraction and γ ∈P♯→P♮be the
concretization functions. Deﬁne the soundness relation σ ∈℘(P♮× P♯) by (4.57).
Deﬁne ⪯♯by (4.58).
If α satisﬁes the abstract minimality assumption (4.23), we
∀c ∈P♮: c ⪯♮γ(α(c)), which implies (4.5) in that ∀c ∈P♮: ⟨c, α(c)⟩∈σ
γ ≈♮γ ◦α ◦γ
∀c ∈P♮: ∀a ∈P♯: α(c) ⪯♯a ⇒c ⪯♮γ(a) ̸⇒α(c) ⪯♯a
∀c, c′ ∈P♮: c ⪯♮c′ ̸⇒α(c) ⪯♯α(c′)
◦) By (4.23), for all c ∈P♮, ⟨c, α(c)⟩belongs to σ so that (4.57) implies
c ⪯♮γ(α(c)) so that (4.5) is satisﬁed because α is total.
◦) For all a ∈P♯, we have γ(a) ⪯♮γ(α(γ(a))) by 1
◦). Replacing σ and ⪯♯by their
respective deﬁnitions (4.57) and (4.58) in (4.23), we get ∀c ∈P♮: ∀a′ ∈P♯: (c ⪯♮
γ(a′) ∧γ(a′) ⪯♮γ(α(c))) ⇒γ(α(c)) ⪯♮γ(a′), so that for c = γ(a) and a′ = a, we get
γ(α(γ(a))) ⪯♮γ(a). By deﬁnition (4.50) of ≈♮, we conclude that γ(a) ≈♮γ(α(γ(a))).
◦) If α(c) ⪯♯a then γ(α(c)) ⪯♮γ(a) by (4.58) hence c ⪯♮γ(a) by 1
◦) and transitivity.
Deﬁne P♯= {x, y , z} such that x ⪯♮x ⪯♮z ⪯♮z and x ⪯♮y ⪯♮y , P♮= {a, b}
such that a ⪯♯a and b ⪯♯b, α(x) = b, α(y) = b, α(z) = a, γ(a) = z , γ(b) = y. We
have σ = {⟨x, a⟩, ⟨x, b⟩, ⟨y, b⟩, ⟨z, a⟩} so that x ⪯♮γ(a) but α(x) ⪯♯a is not true.
◦) Deﬁne P♮= {x, y, z} with x ⪯♮x ⪯♮y ⪯♮y and x ⪯♮z ⪯♮z so that ⪯♮is a
partial order relation and ≈♮is equality. Deﬁne P♯= {a, b}, γ(a) = y and γ(b) = z.
a and b are not comparable since y and z are not comparable so that ⪯♯is equality.
By (4.57), we have σ =
⟨x, a⟩, ⟨x, b⟩, ⟨y, a⟩, ⟨z, b⟩
so that α(x) can be a or b to
Abstract Interpretation Frameworks
satisfy (4.23). Deﬁne α(x) = b so that x ⪯♮y but α(x) = b and α(y) = a are not
comparable by ⪯♯.
Let us deﬁne the normalization operator η ∈P♯→P♯by η
= α ◦γ. By Proposition
◦), we have c ⪯♮γ(a) ⇔c ⪯♮γ ◦η(a), a ≈♯η(a) and η is idempotent on P♯/≈♯so
that η can be used to provide a unique representation or normal form of equivalent
abstract properties. In , η would be the operator used at paragraph 3.3.1.2 to
simplify systems of linear inequalities.
Let us deﬁne the approximation operator ρ ∈P♮→P♮by ρ
= γ ◦α. It is extensive
(by Proposition 8.1–1
◦)) and idempotent (by Proposition 8.1–2
◦)), but not monotonic
(by Proposition 8.1–4
◦)). It reﬂects into P♮the a priori choice of approximations made
by α among the sound ones. It is a weakened form of the approximation operator
deﬁned at paragraph 5.2 of , since monotony is not required.
For a monotonic concrete semantic function F ♮∈P♮
−→P♮, the abstract se­
mantic function would be deﬁned by (4.15) so that c ⪯♮γ(α(c)) implies F ♮(c) ⪯♮
F ♮(γ(α(c))) whence F ♮(c) ⪯♮γ ◦α ◦F ♮(γ(α(c))) (by Proposition 8.1–1
◦) and transi­
tivity) and therefore F ♮(c) ⪯♮γ ◦F ♯◦α(c) by (4.15). The same way when deﬁning
⨿♯by (4.11), the hypotheses of Proposition 7.3 would be satisﬁed. Moreover, we can
require the abstract iterations to be normalized by application of the normalization
operator η to the basis and inductive joins, with no incidence on correctness.
Weak abstraction/concretization connection with abstract approximation
pre-order.
The construction is quite similar when starting from the abstract ap­
proximation ordering and the abstraction function using the duals of propositions as
deﬁned in Fig. 1. Observe that the roles of the normalization and approximation
operators are also exchanged. In particular, the approximation operator η = γ ◦α,
which is the dual normalization operator, shows that a concrete property and its
concrete approximation are equivalent when observed from an abstract point of view.
The normalization operator ρ = α ◦γ , which is the dual approximation operator,
replaces abstract properties by more precise ones in the abstract, without improv­
ing the accuracy of the corresponding concrete semantic properties. This explains
why it might be better to start with a concrete approximation ordering ⪯♮and a con­
cretization function when approximations with loss of information are considered: the
abstract ordering is then coarser than the concrete one and so deﬁning the abstract
approximation relation in terms of the concrete one is more informative.
Galois connection between the concrete and abstract semantics.
lois connection framework of , succinctly reviewed in Example 4.6, results from
the existence of best approximation assumption:
Proposition 8.2 (Galois connection framework)
Let ⟨P♮; ⪯♮⟩and ⟨P♯; ⪯♯⟩be partially ordered sets. Assume that the soundness
relation σ ∈℘(P♮× P♯) satisﬁes the existence of a best approximations assumptions
(4.25) and (4.56). Deﬁne α by (4.23) and γ by (4.55). Then ⟨P♮; ⪯♮⟩↼−
Proof. Follows from Proposition 6.2 and its dual.
Observe that the complete lattice or even cpo assumption is useless since the only
upper bounds which may be necessary in the poset P♮are those involved in the
P. Cousot and R. Cousot
concrete iteration (4.1) and that they are preserved by α, which gives a preference to
the use of the abstraction function in order to induce the abstract iterates from the
concrete ones. However, in a complete lattice each of γ and α uniquely determines
the other according to (4.14) so that the derivation of the abstract semantics from the
concrete semantics can be equivalently based upon the use of any of these adjoined
functions. Moreover, if all abstract properties are useful in the sense of (4.51) then α
is surjective, which for Galois connections is equivalent to ∀a ∈P♯: α ◦γ(a) = a, as
considered in .
In conclusion, which framework to use?
Starting from the deﬁnition of the concrete semantics ⟨P♮; ⊥- ♮, F ♮, ⨿♮⟩of programs,
the design of an abstract interpretation consists in choosing:
1. an abstract semantic domain P♯which is an approximate version of the concrete
semantic domain P♮; and
2. a method for deﬁning an abstract semantics ⟨⊥- ♯, F ♯, ⨿♯⟩of programs; and
3. the speciﬁcation of the soundness correspondence between the concrete and
abstract properties; and
4. a convergence criterion of the abstract iteration sequence, ensuring the best
possible precision; and
5. a convergence acceleration method ensuring rapid termination of the abstract
interpreter.
We have discussed several abstract interpretation frameworks, obtained by weakening
the hypotheses made in . Each one has many variants, most of them
have not been explicitly formulated for short (such as for example the use of an
abstraction function together with a concrete approximation relation). To simplify,
the principal alternatives are:
1. using a soundness relation σ; or
2. using an abstraction relation α ∈℘(P♮× P♯) and an abstract approximation
relation ⪯♯so that the soundness relation is ⟨c, a⟩∈σ ⇔∃a′ ∈P♯: ⟨c, a′⟩∈α
∧a′ ⪯♯a; or
3. using a concretization relation γ ∈℘(P♯× P♮) and a concrete approximation
relation ⪯♮so that the soundness relation is ⟨c, a⟩∈σ ⇔∃c′ ∈P♮: c ⪯♮c′ ∧
⟨a, c′⟩∈γ; or
4. using an abstraction function α ∈P♮→P♯and an abstract approximation
relation ⪯♯so that the soundness relation is ⟨c, a⟩∈σ ⇔α(c) ⪯♯a; or
5. using a concretization function γ ∈P♯→P♮and a concrete approximation
relation ⪯♮so that the soundness relation is ⟨c, a⟩∈σ ⇔c ⪯♮γ(a); or
6. using an Galois connection ⟨P♮; ⪯♮⟩
⟨P♯; ⪯♯⟩so that the soundness
relation is ⟨c, a⟩∈σ ⇔α(c) ⪯♯a ⇔c ⪯♮γ(a).
Moreover, the duality principle can be applied:
1. to the concrete ⊑♮and abstract ⊑♯computational orderings; and/or
Abstract Interpretation Frameworks
2. to the concrete ⪯♮and abstract ⪯♯approximation orderings; and/or
3. to the starting semantics (standard, collecting, etc.) which can be concrete or
abstract (which consists in exchanging α and γ); and/or
4. to the widening and narrowing (being applied to the abstract and/or concrete
semantics).
For a given application, the more powerful applicable framework should be chosen so
as to beneﬁt from the best possible guidelines for designing that application. This
choice should be guided by the following principles:
1. Preference should be given to the inducing of the abstract interpretation from
the starting semantics over empirical designs followed by a posteriori soundness
veriﬁcations; and
2. Eﬃciency of the implementation should be taken into account during the design
of the abstract interpretation (that is in the choice of P♯but, in addition, in
that of F ♯, ▽♯and △♯).
Numerous abstract interpretation frameworks exist and many more are to come in
order to take into account the peculiarities of each practical situation. We give our
preference to language and semantics independent formulations and hope that this
will lead to a cross-fertilization of the various domains of application of abstract
interpretation.
Acknowledgements.
We would like to thank Alan Mycroft for numerous judicial
and useful comments on a ﬁrst draft of this paper as well as the anonymous referees
for their constructive suggestions for improvement. This work was supported in part
by Esprit BRA 3124 Sémantique and CNRS PRC C3.