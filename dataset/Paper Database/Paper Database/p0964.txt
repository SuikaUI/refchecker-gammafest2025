A Survey on Session-based Recommender Systems
SHOUJIN WANGâˆ—, Macquarie University, Australia
LONGBING CAO, University of Technology Sydney, Australia
YAN WANG, QUAN Z. SHENG, MEHMET A. ORGUN, Macquarie University, Australia
DEFU LIAN, University of Science and Technology of China, China
Recommender systems (RSs) have been playing an increasingly important role for informed consumption,
services, and decision-making in the overloaded information era and digitized economy. In recent years,
session-based recommender systems (SBRSs) have emerged as a new paradigm of RSs. Different from other
RSs such as content-based RSs and collaborative filtering-based RSs which usually model long-term yet static
user preferences, SBRSs aim to capture short-term but dynamic user preferences to provide more timely
and accurate recommendations sensitive to the evolution of their session contexts. Although SBRSs have
been intensively studied, neither unified problem statements for SBRSs nor in-depth elaboration of SBRS
characteristics and challenges are available. It is also unclear to what extent SBRS challenges have been
addressed and what the overall research landscape of SBRSs is. This comprehensive review of SBRSs addresses
the above aspects by exploring in depth the SBRS entities (e.g., sessions), behaviours (e.g., usersâ€™ clicks on items)
and their properties (e.g., session length). We propose a general problem statement of SBRSs, summarize the
diversified data characteristics and challenges of SBRSs, and define a taxonomy to categorize the representative
SBRS research. Finally, we discuss new research opportunities in this exciting and vibrant area.
CCS Concepts: â€¢ Surveys and overviews;
Additional Key Words and Phrases: recommender systems, session-based recommender systems
ACM Reference Format:
Shoujin Wang, Longbing Cao, Yan Wang, Quan Z. Sheng, Mehmet A. Orgun, and Defu Lian. 2021. A Survey
on Session-based Recommender Systems. ACM Comput. Surv. 9, 4, Article 39 , 39 pages. https:
//doi.org/0000001.0000001
INTRODUCTION
Recommender Systems (RSs) have evolved into a fundamental tool for making more informative,
efficient and effective choices and decisions in almost every daily aspect of life, working, business
operations, study, entertaining and socialization . Their roles have become ever important in
the increasingly overloaded age of digital economy where users have to make choices from usually
massive and rapidly increasing contents, products and services (which are uniformly called items).
A variety of RS research areas have emerged with great success, such as content-based RSs ,
collaborative filtering based RSs , and hybrid RSs which combine the first two.
âˆ—Corresponding author: Shoujin Wang, 
Authorsâ€™ addresses: Shoujin Wang, Macquarie University, Sydney, Australia, ; Longbing Cao,
University of Technology Sydney, Sydney, Australia, ; Yan Wang, Quan Z. Sheng, Mehmet A. Orgun,
Macquarie University, Sydney, Australia, {yan.wang,michael.sheng,mehmet.orgun}@mq.edu.au; Defu Lian, University of
Science and Technology of China, Hefei, China, .
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and
the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored.
Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires
prior specific permission and/or a fee. Request permissions from .
Â© 2021 Association for Computing Machinery.
0360-0300/2021/5-ART39 $15.00
 
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
 
S. Wang et al.
However, those RSs tend to utilize all historical user-item interactions (interactions for short,
referring to the direct or indirect user actions on items, e.g., the list of a userâ€™s clicks on items) to
learn each userâ€™s long-term and static preferences on items. Such a practice is often associated with
an underlying assumption that all of the historical interactions of a user are equally important to
her current preference. This may not be the reality in the real-world cases and there are two major
reasons. First, a userâ€™s choice on items not only depends on her long-term historical preference but
also depends on her short-term recent preference and the time-sensitive context (e.g., the recently
viewed or purchased items). This short-term preference is embedded in the userâ€™s most recent
interactions , which often account for a small proportion of her historical interactions. Second,
a userâ€™s preference towards items tends to be dynamic rather than static, that is evolving over time.
To bridge these gaps in RSs, Session-based Recommender Systems (SBRSs) have emerged with
increasing attention in recent years. Different from the aforementioned RSs, SBRSs learn usersâ€™
preferences from the sessions associated and generated during the consumption process. Each session
is composed of multiple user-item interactions that happen together in a continuous period of time,
e.g., a basket of products purchased in one transaction visit, which usually lasts for several minutes
to several hours. By taking each session as the basic input unit, an SBRS is able to capture both a
userâ€™s short-term preference from her recent sessions and the preference dynamics reflecting the
change of preferences from one session to another for more accurate and timely recommendations.
In this paper, with the term SBRSs, we refer to all RSs that are centered on the session data to
recommend the next interaction or the next partial session (i.e., the remaining interactions) in
current session, or the next session with multiple interactions (cf. Section 2.2). This definition covers
those narrowly conceived SBRSs in some studies that recommend the next interaction in
the current session only. Also, it covers both session-based and session-aware RSs discussed in .
There are a variety of studies on SBRSs described by different terms in the literature with different
settings and assumptions, targeting different application domains. For example, Hidasi et al. 
built an SBRS on anonymous session data by assuming a strict order over the interactions (e.g.,
click an item or watch a movie) within each session to predict the next item to click or the next
video to watch. Hu et al. built another SBRS on non-anonymous session data without the order
assumption inside sessions to recommend the next item to purchase. Jing et al. devised an
SBRS on non-anonymous session data with order assumption inside sessions for the next music or
movie recommendations.
Although SBRSs are widespread in various domains and many related studies have been conducted, there are many inconsistencies in the area of SBRSs caused by the diverse descriptions,
settings, assumptions and application domains. There is not a unified framework that well categorize them and there are no unified problem statements for SBRSs. More importantly, no systematic
discussion is available on the unique characteristics of SBRSs including their problem and session
data, the research challenges incurred by the characteristics, and the research landscape and gaps
in addressing the challenges. There is not a systematic categorization of all the representative and
state-of-the-art approaches for SBRSs. These gaps have limited the theoretical development and
practical applications of SBRSs.
To address the above significant aspects and gaps, this paper provides a comprehensive and
systematic overview and survey of the field of SBRSs:
â€¢ We provide a unified framework to categorize the studies on SBRSs, which can reduce the
confusions and inconsistent views in the field of SBRSs.
â€¢ For the first time, our work proposes a unified problem statement of SBRSs, where an SBRS
is built on top of formal concepts: user, item, action, interaction and session.
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
â€¢ We provide a comprehensive overview of the unique characteristics of session data as well
as the challenges of SBRSs incurred by them. To the best of our knowledge, this is the first
such description.
â€¢ A systematic classification and comparison of SBRS approaches are made to provide an overall
view on how the challenges have been addressed and what progress has been achieved in
the SBRS area.
â€¢ Each class of approaches for SBRSs have been briefly introduced with key technical details to
provide an in-depth understanding of the progress achieved for SBRSs.
â€¢ Lastly, open issues and prospects for the SBRS research are discussed.
RELATED WORK
There are a variety of studies on not only SBRSs but also Sequential Recommender Systems (SRSs)
 . SRS is an area closely relevant to but different from SBRSs. Even in the area of SBRSs,
there are many different sub-areas, e.g., next-interaction (e.g., purchase an item) recommendations,
next-session (e.g., basket) recommendations. As a result, a variety of corresponding specific works
described by different terms exist in the literature, including session-based recommendations, nextitem/song recommendations, next-basket recommendations, session-based recommender systems,
sequential recommender systems, etc. Although quite similar, these works are usually applicable
for different scenarios, with different settings and assumptions, belonging to different areas, i.e.,
SBRSs or SRSs, or some of the above sub-areas. It is not uncommon that these superficially similar
but actually different works not only cause confusions between SBRSs and SRSs, but also lead
to significant inconsistencies within the area of SBRSs. Below, we first clarify the concepts and
differences between SBRSs and SRSs, then provide a framework to categorize the relevant SBRS
studies, and clarify the difference between this paper and the related work.
SBRSs vs. SRSs
SBRSs and SRSs are built on session data and sequence data respectively, while they are often
mixed up by some readers. So it is necessary to first clarify the difference between session data and
sequence data. A session is a list of interactions with a clear boundary, while the interactions may be
chronologically ordered (in ordered sessions) , or unordered (in unordered sessions) .
A boundary refers to the starting-ending interaction pair to start and end a specific session in a
transaction event. An ordered (unordered) session refers to a session in which the interactions
are (not) chronologically ordered. The session data from a given user usually consists of multiple
sessions happening at different time and separated by multiple boundaries with non-identical time
intervals between sessions (cf. Fig. 1 (a)). A sequence is a list of historical elements (e.g., item IDs)
with clear order. The sequence data from a given user often contains a single sequence with only
one boundary for it (cf. Fig. 1 (b)). In most sequence data, the timestamps are used to sort the
elements inside a sequence only while no explicit time intervals are included and considered . A
boundary usually indicates co-occurrence-based dependencies over the interactions or elements
within it. Co-occurrence-based dependencies constitute the foundation of SBRSs, especially for
those built on unordered session data. Order implies clear sequential dependencies among the
interactions or elements inside a session or a sequence. We show the difference between the session
data and the sequence data from a certain user in Table 1.
An SBRS aims to predict either the unknown part (e.g., an item or a batch of items) of a session
given the known part, or the future session (e.g., the next-basket) given the historical sessions via
learning the intra- or inter-session dependencies. Such dependencies usually largely rely on the
co-occurrence of interactions inside a session and they may be sequential or non-sequential .
In principle, an SBRS does not necessarily rely on the order information inside sessions, but for
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
(b). One movie-watching sequence from Alice
(a). Three product-purchasing sessions from Bob
Fig. 1. Session data vs. sequence data
ordered sessions, the naturally existing sequential dependencies can be utilized for recommendations. In comparison, an SRS predicts the successive elements given a sequence of historical ones
by learning the sequential dependencies among them. Several survey papers focus particularly
on SRSs, including sequence-aware recommender systems , deep learning for sequential recommendations and sequential recommender systems . In this survey, we particularly
focus on the area of SBRSs with an emphasis on the unique characteristics of session data together
with the corresponding challenges they have brought to SBRSs, and the representative and the
state-of-the-art approaches for SBRSs.
A Framework for Organizing SBRS Work
The variety of existing work on SBRSs can be generally categorized into three sub-areas fitting
a unified categorization framework to reduce the aforementioned inconsistencies and confusion.
According to the difference on the recommendation tasks, the sub-areas include next interaction
recommendation, next partial-session recommendation, and next session recommendation. Given the
known part (i.e., happened interactions) of a session, next interaction recommendation aims to
recommend the next possible interaction in the current session by mainly modeling intra-session
dependencies. It is usually simplified to predict the next item to interact, e.g., a product to click
or purchase. Given the known part of a session, next-partial session recommendation aims to
recommend all the remaining interactions to complete the current session, e.g., to predict all the
subsequent items to complete a basket given the purchased items in it, by mainly modelling intrasession dependencies. Although less studied, this sub-area is even more practical in real-world
cases since a user often does not interact with only one item in the next, but multiple items till
she finish the whole session. Given the historical sessions, next session recommendation aims to
recommend the next session, e.g., next basket, by mainly modeling inter-session dependencies.
Sometimes, inter-session dependencies are also incorporated into the first two sub-areas to improve
recommendation performance. A comparison of these sub-areas is presented in Table 2.
Related Surveys
Although many studies have been done in the area of SBRSs, to the best of our knowledge, there are
limited comprehensive and systematic reviews to shape this vibrant area and position the existing
works as well as the current progress. Although some works have attempted to comprehensively
evaluate and compare the performance of existing SBRS algorithms, we have not found any
Table 1. A comparison between session data and sequence data
Time interval
Main relations embedded
Unordered session
Non-identical
Co-occurrence-based dependencies
Ordered session
Non-identical
Co-occurrence-based dependencies and sequential dependencies
Sequence data
Not included
Sequential dependencies
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
Table 2. A comparison of different sub-areas in SBRSs
Typical research topic
Next interaction recommendation
Mainly known part
of the current session
interaction (item)
Next item recommendation, next song/movie recommendation, next POI recommendation, next web page
recommendation, next news recommendation, etc.
Next partial-session
recommendation
Mainly known part
of the current session
Subsequent part
of the session
Next items recommendation, session/basket completion
Next session recommendation
Historical sessions
Next session
Next basket recommendation, next bundle recommendation, etc.
studies which systematically formalize this research field, or comprehensively analyze the unique
characteristics of session data and the critical challenges faced by SBRSs. Let alone to provide an
in-depth summary of current efforts or detail the open research issues present in the field.
Several surveys focus on the conventional RSs or the emerging deep learning based RSs. Shi et al.
 comprehensively analyzed the recently proposed algorithms for collaborative filtering based
RSs and discussed the future challenges in the area. Lops et al. provided an overview of contentbased RSs by summarizing the corresponding representative and the state-of-the-art algorithms
and discussing the future trends. Burke et al. surveyed the landscape of hybrid RSs. Zhang et
al. provided a comprehensive review of recent research efforts on deep learning based RSs.
In addition, there are also several surveys on SRSs. For instance, Quadrana et al. conducted a
comprehensive survey on sequence-aware RSs from various aspects, including the recommendation
task, the algorithms and evaluations; Fang et al. provided a comprehensive survey on deep
learning based sequential recommendations from the aspects of algorithms, influential factors, and
evaluations; and Wang et al. conducted a brief review on the challenges and progress of SRSs.
However, there is a lack of an extensive review on SBRSs. Although SBRSs have been partially
discussed in , this work mainly focused on sequence-aware RSs and only discussed a small
proportion of works on SBRSs built on ordered session data, while ignoring SBRSs based on
unordered sessions. More importantly, a variety of recent progress has not been covered. To the
best of our knowledge, there are only three formally published review papers (include a short
one) particularly focusing on SBRSs. To be specific, Ludewig et al. provided a systematic
performance comparison of a number of SBRS algorithms, including Recurrent Neural Network
(RNN) based approaches, factorized Markov chain based approaches, and nearest neighbour based
approaches. Later, Ludewig et al. compared the performance of four neural network based
approaches and five conventional approaches based on rule learning or nearest neighbour, which
was further extended into a comprehensive empirical study of SBRS algorithms where 12 algorithmic
approaches were compared in terms of their recommendation performance . While focused on
the experimental perspective, these studies only covered a few approaches but did not provide a
comprehensive review and analysis from the theoretical perspective.
Given the rising popularity and potential of SBRSs and the steady flow of novel research contributions in this area, a comprehensive survey will be of high scientific and practical value. This
survey seeks to provide a comprehensive review of the current research on SBRSs to bridge these
gaps with the aim of supporting further development of SBRSs. As the first attempt, this paper
explores the field of SBRSs with an emphasis on the problem statement, analysis of challenges,
review of progress and discussion of future prospects.
SBRS PROBLEM STATEMENT
An RS can be seen as a system , which consists of multiple basic entities including users,
items and their behaviours, e.g., user-item interactions. These basic entities and behaviours form
the core constituents of a session, which is the core entity in an SBRS. Therefore, we first introduce
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
Table 3. Main notations in SBRSs
Description
Description
A set of users, i.e., ğ‘ˆ= {ğ‘¢1,ğ‘¢2, ...,ğ‘¢|ğ‘ˆ| }
A set of sessions
The ğ‘˜-th user of ğ‘ˆ, 1 â‰¤ğ‘˜â‰¤|ğ‘ˆ|
The ğ‘—â€²-th session of ğ‘†, which is a list of
interactions
A set of items, i.e., ğ‘‰= {ğ‘£1, ğ‘£2, ..., ğ‘£|ğ‘‰| }
A session context
The ğ‘–-th item of ğ‘‰, 1 â‰¤ğ‘–â‰¤|ğ‘‰|
A list of interactions
A set of actions, i.e., ğ´= {ğ‘1,ğ‘2, ...,ğ‘|ğ´| }
The representation1of ğ‘£ğ‘–
The ğ‘˜â€²-th action of ğ´, corresponding to the ğ‘˜â€²-th
type of action, e.g., purchase or click
The representation of ğ‘œğ‘–â€²
A set of interactions, i.e., ğ‘‚= {ğ‘œ1,ğ‘œ2, ...,ğ‘œ|ğ‘‚| }
The representation of ğ‘
The ğ‘–â€²-th interaction of ğ‘‚, which is a tuple of a
user, an item and an action
The hidden state2at time step ğ‘¡
1 A representation is often specified as a latent vector; 2 A hidden state is a latent vector from an RNN (cf. Sec. 8.1.1).
the definitions and properties of these entities and behaviours, and then define the SBRS problem
based on them. These definitions and properties will be further used for the characterization and
categorization of SBRSs, etc. The main notations are listed in Table 3.
User and User Properties
A user in an SBRS is the subject who takes actions, e.g., clicks, purchases, on items, e.g., products,
and receives the recommendation results. Let ğ‘¢denote a user and each user is associated with a
unique ID and a set of attributes to describe her, e.g., the gender of a user, and it has multiple values,
e.g., male and female. The attributes of a user could affect the actions she takes on items and further
affect the corresponding sessions. For instance, a boy may watch more action movies, leading to
more action movies in his watching sessions, while a girl may like to watch more love-story movies.
In addition to the explicit attributes that can be obviously observed, some implicit attributes that
reflect the userâ€™s internal states, e.g., her moods and intentions, may also have a significant impact
on her actions. All the users together form the user set, namely ğ‘ˆ= {ğ‘¢1,ğ‘¢2, ...,ğ‘¢|ğ‘ˆ|}. Note that the
user information of a session may not be always available for two reasons: (1) it is not recorded due
to the privacy protection; and (2) some users do not log in when interacting with online platforms
like amazon.com. Consequently, the session becomes anonymous.
Item and Item Properties
An item in an SBRS is an entity to be recommended, such as a product, e.g., a book, or a service,
e.g., a course. Let ğ‘£denote an item, which is associated with a unique ID and a set of attributes to
provide the description information of the item, such as the category and the price of an item. All
the items in a dataset form the item set, namely ğ‘‰= {ğ‘£1, ğ‘£2, ..., ğ‘£|ğ‘‰|}.
Usually, items are different in different domains. For instance, in the news recommendation
domain, an item is a news article posted on a news website, e.g., a report on artificial intelligence on
abc.com; in the e-commerce domain, an item is a product for sale, e.g., an earphone on amazon.com,
and in the service industry, an item is a specific service, e.g., the course "Machine Learning" provided
by Coursera ( 
Action and Action Properties
An action is often taken by a user on an item in a session, e.g., clicking an item. Let ğ‘denote
an action, which is associated with a unique ID and a set of attributes to provide its property
information e.g., the type of the action, and has multiple values, e.g., click, view, and purchase.
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
Note that some actions may not be associated with specific items, e.g., a search action or a catalog
navigation action. But they may still provide useful information to an SBRS as discussed in .
Interaction and Interaction Properties
Interaction is the most basic unit in sessions. Let ğ‘œdenote an interaction, which is a ternary tuple
consisting of a user ğ‘¢, an item ğ‘£and the action ğ‘taken by ğ‘¢on ğ‘£, namely ğ‘œ= âŸ¨ğ‘¢, ğ‘£,ğ‘âŸ©. In the case
where the user information is not available, the interaction become anonymous, i.e., ğ‘œ= âŸ¨ğ‘£,ğ‘âŸ©.
Moreover, in the case, where there is only one type of actions, e.g., clicks, the interaction ğ‘œcan be
further simplified as ğ‘œ= âŸ¨ğ‘£âŸ©, namely it only consists of an item. All the interactions together form
the interaction set ğ‘‚.
Session and Session Properties
Session is an important entity in an SBRS. Let ğ‘ denote a session, which is a non-empty bounded list
of interactions generated in a period of continuous time which may be connected with some user-
(e.g., user ID) or session-specific (e.g., a session-ID or a cookie) information, i.e., ğ‘ = {ğ‘œ1,ğ‘œ2, ...,ğ‘œ|ğ‘ |}.
Note that here we use the concept "list" instead of "set" to indicate that there may be duplicated
interactions in one session. For example, a user listens to a song for multiple times in a listening
session. Each session is associated with a set of attributes, e.g., the duration of ğ‘ , which have
multiple corresponding values, e.g., 20 minutes or 40 minutes. Some other important attributes of a
session include the time and the day when the session happens. Next, we discuss five important
properties of sessions that may have a great impact on SBRSs.
Property 1: session length. The length of a session is defined as the total number of interactions
contained in it. This is a basic property of sessions, which is taken as one of the statistical indicators
of experiment data in most literature . Sessions of different lengths may bring different
challenges for SBRSs and thus lead to different recommendation performance. The session characteristics related to session length together with the corresponding challenges for building SBRSs
are discussed in detail in Section 4.1.
Property 2: internal order. The internal order of a session refers to the order over interactions
within it. Usually, there are different kinds of order flexibility inside different sessions, i.e., no order,
flexible order and order. The existence of internal order leads to the sequential dependencies within
sessions which can be used for recommendations. The session characteristics related to internal
order and the corresponding challenges for building SBRSs are discussed in detail in Section 4.2.
Property 3: action type. In the real world, some sessions contain only one type of actions, e.g.,
purchase, while other sessions may contain multiple types of actions, e.g., click, purchase (cf. Fig. 2
(a)). The dependencies over different types of actions are often different. For instance, the items that
are clicked together in a session may be similar or competitive while the items purchased together in
one session may be complementary. Therefore, the number of action types in a session determines
whether the intra-session dependencies are homogeneous (based on a single type of actions) or
heterogeneous (based on multi-type actions), which is important for accurate recommendations.
The session characteristics related to action type as well as the corresponding challenges for
building SBRSs are discussed in detail in Section 4.3.
Property 4: user information. User information of a session mainly refers to the IDs of the users
in the session, and sometimes user attributes are also included. In this paper, the property of user
information refers to the availability of user information in a session. In the real word, the user
information of sessions is given in some cases, while it is not available in other cases (cf. Section
3.1) . User information plays an important role to connect sessions from the same
user happening at different time and thus its availability determines the possibility to model the
long-term personalized preference across multiple sessions for a specific user. In practice, SBRSs
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
(a). A multi-type-action session with order from Bob
(b). The hierarchical structure in the session data from Bob
session level relations
interaction level relations
attribute (e.g.,brand) level relations
Fig. 2. Toy examples for a typical session and session data with hierarchical structure
were initially proposed to handle those anonymous sessions where user information is not available
 . The session characteristics together with the corresponding challenges for building SBRSs are
discussed in detail in Section 4.4.
Property 5: session-data structure. Session-data structure refers to the session-related hierarchical
structure consisting of multiple levels , which intrinsically exists in some session data. For
example, the attribute level consists of the attributes of entities (e.g., users, items) in an interaction,
the interaction level consists of interactions in each session, and the session level consists of
multiple historical sessions from the current user (cf. Fig. 2 (b)). The interaction level is necessary
for a session, while the other levels depend on the specific session data. This is because either the
attribute information or the historical session information may not be available in all session data.
Usually, the number of levels included in a session data set determines the information volume
that can be used for recommendations. The session characteristics related to session-data structure
as well as the corresponding challenges for building SBRSs are discussed in detail in Section 4.5.
The SBRS Problem
From the system perspective, we formalize SBRS by first illustrating its input, output and work
mechanism, and then presenting the problem formalization.
Input. The basic input of an SBRS is the partially known session information that is used for
recommendations . According to the specific scenarios, the basic input has three cases: (1)
the known part of the current session (i.e., a list of happened interactions), which is the input of
the SBRSs modelling intra-session dependencies only for next interaction (item), or next partialsession recommendation (c.f. Section 2.2); (2) the list of known historical sessions, which is the
input of the SBRSs that mainly model inter-session dependencies for next session (e.g., a basket)
recommendation; and (3) the combination of the first two, which is the input of the SBRSs modelling
both intra- and inter-session dependencies for the recommendation of next interaction, or next
partial-session.
Most of the existing SBRSs mainly take the IDs of users (if not anonymous), items and actions as
the input while ignoring their attribute information . Only a minority of studies assume the attribute information is available and take it as part of the input. In a
specific case, the input part of the current session or historical sessions may be anonymous or
non-anonymous, ordered or unordered, with single- or multi-type actions. From our observation,
most of the existing SBRSs assume the input sessions are ordered and with single-type actions. In
an SBRS, the input is usually formalized as a session context (also called a context in this paper)
conditioned on which the recommendation is performed.
Output. The goal of an SBRS is to make recommendations according to a given session context,
i.e., the known session information. Accordingly, the output of an SBRS is a predicted interaction
or a predicted list of interactions that happen subsequently in the current session, or the predicted
next session that happens following the given historical sessions (cf. Section 2.2). In an SBRS, the
user information of a session is either not available and thus is not predictable (in anonymous
sessions) or given by default (in non-anonymous sessions), so it is usually unnecessary to predict
the user information. Consequently, each interaction in the output only contains an item and the
corresponding action taken on it , e.g., an item to purchase or click. Moreover, in most cases
where SBRSs are built on single-type-action sessions, the only action type is given by default, e.g.,
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
purchase or click, and thus each interaction in the output is further simplified to an item .
According to the specific sub-areas, there are three cases for the output (cf. Section 2.2): (1) in
next interaction recommendation, the output is a list of alternative interactions (items) ,
ranked by best match as the next interaction (item) in the session; (2) in next partial-session
recommendation, the output is a list of interactions (items) to complete the current session; and (3)
in next session recommendation, the output is a list of complementary interactions (items) to form
the next session , e.g., to purchase a basket of complementary products (e.g., milk, bread) to
achieve a unified goal (e.g., breakfast). In the last two cases, according to whether the session is
ordered or not, the interactions in the list may be ordered or unordered accordingly.
Work mechanism. In principle, the work mechanism of an SBRS is to first learn the comprehensive
dependencies among interactions within or/and between sessions and then to utilize the learned
dependencies to guide the prediction of the subsequent interactions or sessions to accomplish the
recommendation task. Next, we illustrate it in detail in the following problem formalization.
Problem formalization. There are many different types of SBRSs with their own specific characteristics and formalization. Here we give an abstract-level formalization that is suitable for different
SBRSs. Let ğ‘™= {ğ‘œ1, ...,ğ‘œğ‘—, ...,ğ‘œğ‘›} be a list of ğ‘›interactions, each of which is composed of an item
and the corresponding action taken on it. Recall that in SBRSs built on single-type-action sessions,
each interaction is simplified to an item and thus the interaction list ğ‘™is simplified to an item list ğ‘™ğ‘£,
i.e., ğ‘™ğ‘£= {ğ‘£1, ..., ğ‘£ğ‘—, ..., ğ‘£ğ‘›}(ğ‘£ğ‘—âˆˆğ‘‰). ğ¿is the set of lists, which contains all the possible interaction
lists derived from the candidate item set ğ‘‰and action set ğ´. ğ‘is the input, i.e., a session context,
consisting of all the session information used for the recommendation. All the session contexts
together form the session context setğ¶. Similar to sequence-aware RS , let ğ‘“be a utility function
to return the utility score of a candidate interaction list ğ‘™for a given session context ğ‘. An SBRS is
to select the recommended interaction list Ë†ğ‘™âˆˆğ¿by maximizing the utility score conditioned on the
given session context ğ‘, i.e.,
Ë†ğ‘™= ğ‘ğ‘Ÿğ‘”ğ‘šğ‘ğ‘¥ğ‘“(ğ‘,ğ‘™),ğ‘âˆˆğ¶,ğ‘™âˆˆğ¿,
where the utility function can be specified to multiple forms, e.g., likelihood, conditional probability.
The utility function is employed on the interaction list to optimize the candidate list as a whole
rather than optimising a single candidate interaction (item). This makes the formalization not only
cover all the aforementioned three cases for the output of SBRSs, but it also makes it possible to
characterize and evaluate the list as a whole from multiple aspects, e.g., the novelty or diversity of
the interactions (items) in the list .
CHARACTERISTICS AND CHALLENGES
SBRSs are built on session data, and different types of session data are usually associated with
different characteristics, which essentially bring different challenges to build SBRSs. Similar to
understanding data characteristics and challenges in other data-driven research , a deep understanding of the intrinsic characteristics of session data, and the challenges in modelling session data
for building SBRSs is fundamental for designing an appropriate SBRS. Therefore, in this section,
we systematically illustrate and summarize a variety of characteristics of session data as well as
the corresponding challenges caused by each of them in building SBRSs.
According to each of the session properties introduced in Section 3.5, sessions can be divided
into different types. For instance, according to the property "session length", sessions can be divided
into long sessions, medium sessions and short sessions. Next, we first present different types of
sessions categorized by each of their properties, and then discuss the characteristics and challenges
associated with each type of sessions.
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
Characteristics and Challenges Related to Session Length
According to session length, sessions can be roughly categorized into three types: long sessions,
medium sessions and short sessions, while the specific definitions for long, medium and short
sessions may vary upon the specific data sets.
Long sessions. A long session contains relatively more interactions, e.g., more than 10. In general,
with more interactions, long sessions can provide more contextual information for more accurate
recommendations. However, due to the uncertainty of user behaviours, a long session is more likely
to contain random interactions which are irrelevant to other interactions in it. This brings
noisy information and thus reduces the performance of recommendations . Therefore,
the first challenge for SBRSs built on long sessions is how to effectively reduce the noisy information
from the irrelevant interactions. In addition, there are usually more complex dependencies embedded
in a long session, e.g., long-range dependencies between two interactions that are far from
each other in a session or high-order dependencies across multiple interactions in a session.
Consequently, another challenge for SBRSs built on long sessions is how to effectively learn complex
dependencies for better recommendation performance.
Medium sessions. Medium sessions usually contain a medium number of interactions, e.g., 4 to 9.
From our observations on session data generated from transaction records in e-commerce industry,
medium sessions are the most common case . Compared with long and short sessions, a
medium session is less likely to contain too many irrelevant interactions while it usually contains
the necessary contextual information for Session-Based Recommendation (SBR). Although relatively
less challenging, building SBRSs on medium sessions still faces a general challenge, i.e., how to
effectively extract the relevant and accurate contextual information for accurate recommendations.
Short sessions. A short session consists of quite limited interactions, e.g., usually less than 4,
leading to limited information available for recommendation. For example, in an offline anonymous
session consisting of two interactions, the only contextual information that can be utilized to
recommend the second interaction (item) is the first interaction in the session. An extreme case is
to recommend the first interaction of a session. Consequently, the challenge for SBRSs built on
short sessions is how to effectively make recommendations with quite limited contextual information.
Characteristics and Challenges Related to Internal Order
According to whether there is an order over interactions inside a session or not, sessions can be
roughly divided into unordered sessions, ordered sessions and flexible-ordered sessions.
Unordered sessions. An unordered session contains interactions without any chronological order
between them, namely, whether an interaction happens earlier or later in the session makes no
difference . For example, the shopping sessions are sometimes unordered since users may pick
up a basket of items (e.g., {bread, milk, eggs}) without following an explicit order . In unordered
sessions, the dependencies among the interactions are based on their co-occurrence rather than the
sequences of them, and thus the generally utilized sequence models are not applicable. Compared
with sequential dependencies, co-occurrence based dependencies are usually relatively weak and
fuzzy, which are more difficult to learn. Furthermore, most of co-occurrence based dependencies
among interactions are collective dependencies , i.e., several contextual interactions in a
session collaboratively lead to the occurrence of the next interaction, which are even harder to
capture. Consequently, the challenge for SBRSs built on unordered sessions is how to effectively learn
the relatively weak and fuzzy dependencies among interactions, especially those collective dependencies.
Ordered sessions. An ordered session contains multiple interactions with strict order, and usually
strong sequential dependencies exist among them. For example, the session composed of a sequence
of online courses taken by a user is often ordered, since some prerequisite courses must be taken
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
first to gain prior-knowledge for the subsequent ones. Although it is relatively easy to learn the
strong sequential dependencies within ordered sessions, it is challenging to effectively learn the
cascaded long-term sequential dependencies which decay gradually with time in long ordered sessions.
Flexibly-ordered sessions. A flexibly-ordered session is neither totally unordered nor totally
ordered, i.e., some parts of the session are ordered while others are not . For example, a tourist
generates a session of check-ins at airport, hotel, shopping center, bar, and attraction successively. In
the session, the airport, hotel and attraction are actually sequentially dependent, while the shopping
center and bar are randomly inserted without any order. Therefore, the complex dependencies
inside flexibly-ordered sessions must be carefully considered and precisely learned for accurate
recommendation. Consequently, the challenge for SBRSs built on flexibly-ordered sessions comes
from how to effectively learn the complex and mixed dependencies, i.e., sequential dependencies among
ordered interactions and non-sequential dependencies among unordered ones.
Characteristics and Challenges Related to Action Type
According to the number of action types included in a session, sessions can be divided into singletype-action sessions and multi-type-action sessions.
Single-type-action sessions. A single-type-action session includes one type of actions only, e.g.,
clicks of items, and thus only one type of dependencies comes from the same type of actions, which
is relatively easy to learn.
Multi-type-action sessions. A multi-type-action session includes more than one types of actions
 , leading to multiple types of interactions. For example, in a real-world online shopping session,
a user usually first clicks several items for comparison and then purchases one or more items. Thus,
there are complex dependencies inside a multi-type-action session . Specifically, dependencies
not only exist over the interactions from the same type (e.g., clicks of items), but also exist over
interactions from different types (e.g., clicks and purchases). As a result, a big challenge for SBRSs
built on multi-type-action sessions is how to effectively and accurately learn both the intra- and
inter-action type dependencies for accurate recommendations.
Characteristics and Challenges Related to User Information
According to whether the user information is available or not, sessions can be divided into nonanonymous sessions and anonymous sessions.
Non-anonymous sessions. A non-anonymous sessions contains non-anonymous interactions with
the associated user information, which enables the connections of different sessions generated by
the same user at different time. This makes it possible to learn the userâ€™s long-term preference as
well as its evolution across sessions. However, due to the relative long time-span and preference
dynamics, it is quite challenging to precisely learn the personalized long-term preference over multiple
non-anonymous sessions.
Anonymous sessions. In anonymous sessions, due to the lack of user information to connect
multiple sessions generated by the same user, it is nearly impossible to collect the prior historical
sessions for the current session. As a result, only the contextual information from the current
session can be used for recommendations. Therefore, it is challenging to precisely capture the userâ€™s
personalized preference with limited contextual information to provide accurate recommendation.
Characteristics and Challenges Related to Session-data Structure
According to the number of levels of structures, session data can be roughly divided into single-level
session data and multi-level session data (cf. 3.5). Specifically, the interaction level naturally exists
in any session data, and thus single-level session data particularly refers to the data including the
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
interaction level only. Multi-level session data refers to the data including the attribute level or/and
the session level in addition to the interaction level.
Single-level session data. A single-level session data set is usually a set of anonymous sessions
where each consists of several interactions without attribute information or historical session
information. In such a case, only single-level dependencies, i.e., the inter-interaction dependencies
within sessions, can be utilized for recommendations. Hence, due to the lack of auxiliary information
from other levels, SBRSs built on single-level session data may easily suffer from the cold-start or
data sparsity issue . This leads to the challenge of how to overcome the cold-start and sparsity
issues for accurate recommendations when only the inter-interaction dependencies are available.
Multi-level session data. Multi-level session data involves a hierarchical structure of at least two
levels, i.e., the interaction level plus attribute level and/or session level. In this case, both the dependencies within each level and across different levels would affect the subsequent recommendations.
For example, the categories (the attribute level) of several items may have impact on whether these
items would be bought together (the interaction level) in one session. Consequently, how to comprehensively learn the intra- and inter-level dependencies for effective and accurate recommendations
becomes a key challenge for SBRSs built on multi-level session data.
A Summary of Characteristics and Challenges
In this subsection, we provide a summary of session characteristics and the corresponding challenges.
To be specific, a comparison of carefully selected representative and state-of-the-art works on
SBRSs regarding their targeted session types, basic model and the application domain is presented
in Table 4. Recall that each type of sessions have their own characteristics and challenges, therefore,
the session type in Table 4 actually reflects the corresponding session characteristics and challenges
for SBRSs that are targeted by each work. As a result, Table 4 provides a comprehensive overall
view on existing works from multiple perspectives. For instance, the second row on the left side
in Table 4 means that the association rule based SBRS in mainly targets the Flexible-Ordered
(FO), Single-Type-action (ST), Anonymous (A), and Single-Level (SL) sessions with associate rule
mining approach for web page recommendations.
CLASSIFICATION AND COMPARISON OF SBRS APPROACHES
To provide an overall view of the achieved progress in addressing the challenges introduced in
Section 4, we first classify the approaches for SBRSs from the technical perspective, i.e., the involved
method or model, in Section 5.1, and then compare different classes of approaches in Section 5.2.
A Classification of SBRS Approaches
The taxonomy of approaches for SBRS is presented in Fig. 3. According to the employed technique,
three super-classes of approaches for SBRSs are identified from the literature, i.e., conventional
SBRS approaches, latent representation approaches, and deep neural network approaches. These three
super-classes can be further divided into seven classes in total while each super-class contains
multiple classes. To be specific, conventional SBRS approaches contain four classes: pattern/rulebased approaches, KNN-based approaches, Markov chain based approaches, and generative probabilistic
model based approaches; latent representation approaches contain two classes: latent factor model
and distributed representation; and deep neural network approaches contain two classes: basic deep
neural networks and advanced models. In addition, the class of basic deep neural networks contains
four sub-classes while each corresponds to one basic deep neural network architecture, namely,
recurrent neural networks, multi-perceptron layer (MLP) networks, convolution neural networks and
graph neural neural networks. Similarly, the class of advanced model contains five sub-classes
while each corresponds to one type of models that are usually utilized for building SBRSs, i.e.,
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
Comparison of representative works regarding targeted session type, basic model and application domain
Session type
Session type
An SBRS based on association
rules 
FO, ST, A, SL
Attention-gated
(IARN) 
L, O, ST, NA,
Access Pattern Approach (APA)
UO, ST, NA,
KNN-GRU4Rec 
O, ST, A, SL
Personalized sequential pattern
L1, O, ST, NA,
structured
model (TDSSM) 
O, ST, NA, ML
Item/session KNN 
O/UO, ST, A,
List-wise deep neural network 
UO, MT, A, SL
Sequence and Time Aware Neighbourhood (STAN) 
O, ST, A, SL
DeepPredict 
UO, MT, NA,
Temporal-Item-Frequency-based
User (TIFU)-KNN 
UO, ST, NA,
ConvolutionAl Sequence Embedding
Recommendation Model (CASER) 
FO, ST, NA,
Page rank and Markov model 
O, ST, A, SL
3D Convolutional Neural Network (3D
CNN) 
O, ST, A, ML
Factorized Personalized Markov
Chain (FPMC) 
O, ST, NA, ML
Hierarchical Temporal Convolutional
Networks (HierTCN) 
L, O, MT, NA,
Dynamic emission and transition
model 
O, ST, NA, SL
Session-based Recommendation with
Graph Neural Network (SR-GNN) 
O, ST, A, SL
Personalized Ranking Metric Embedding (PRME) 
O, ST, NA, SL
Contextualized
Self-Attention
Network (GC-SAN) 
O, ST, A, SL
Personalized Markov Embedding
(PME) 
O, ST, NA, SL
Target Attentive Graph Neural Network
(TAGNN) 
O, ST, A, SL
Latent Markov Embedding (LME)
O, ST, NA, SL
Multi relational GNN for Session-based
Prediction (MGNN-SPred) 
O, MT, A, SL
FPMC-Localized
O, ST, NA, SL
Full GNN based on Broadly Connected
Session graph (FGNN-BCS) 
O, ST, A, ML
Co-factorization (CoFactor) 
UO, ST, NA,
Full GNN based on Weighted Graph ATtention layer (FGNN-WGAT) 
O, ST, A, SL
Category aware POI recommendation model 
O, ST, NA, SL
Hierarchical Attentive Transaction Embedding (HATE) 
UO, ST, NA,
Session-based Wide-In-Wide-Out
(SWIWO) networks 
UO, ST, NA,
Dynamic Co-attention Network for SBR
(DCN-SR) 
L, O & UO,
MT, NA, ML
Network-based Transaction Embedding Model (NTEM) 
UO, ST, A, ML
Encoder-Decoder
(EDRec) 
O, MT, NA, SL
Meta-Prod2Vec 
O, ST, A, ML
Neural Attentive Recommendation Machine (NARM) 
L, O, ST, A, SL
Music Embedding Model (MEM)
O, ST, NA, ML
Short-Term Attention/Memory Priority
(STAMP) model 
UO, ST, A, SL
Attention based Transaction Embedding Model (ATEM) 
UO, ST, A, SL
Streaming Session based Recommendation Machine (SSRM) 
O, ST, NA, ML
Hierarchical
Representation
Model (HRM) 
UO, ST, NA,
Sequential Hierarchical Attention Network (SHAN) 
FO, ST, NA,
GRU4Rec 
O, ST, A, SL
Memory-Augmented Neural Network
(MANN) 
FO, ST, NA,
GRU4Rec-BPR 
O, ST, A, SL
(MAN) 
FO, ST, A, SL
Improved RNN 
O, ST, A, SL
Hierarchical Memory Networks (HMN)
O, ST, A, SL
Hierarchical RNN (HRNN) 
L, O, ST, NA,
Collaborative
Session-based
Recommendation Machine (CSRM) 
O, ST, A, ML
User-based RNN 
O, ST, NA, SL
Multi-temporal-range Mixture Model
(M3) 
L, FO, ST, A,
Dynamic REcurrent bAsket Model
(DREAM) 
UO, ST, NA,
Mixture-Channel Purpose Routing Networks (MCPRN) 
FO, ST, A, SL
Recurrent Latent Variable network for SBR (ReLaVaR) 
O, ST, A, SL
Intention2basket 
FO, ST, A, ML
RNN-latent cross 
O, ST, NA, ML
Variational
O, ST, A, SL
Parallel RNN (P-RNN) 
O, ST, A, ML
VAriational SEssion-based Recommendation (VASER) 
O, ST, A, SL
recommender
O, ST, NA, SL
Convolutional
Generative
(NextItNet) 
O, ST, A, SL
Recommender
Networks (RRN) 
O, ST, NA, SL
LIst-wise Recommendation based on
Deep RL (LIRD) 
O, MT, NA, SL
Session-aware recommendations
with neural network 
L, O, MT, A,
DeepPage 
O, MT, NA, SL
Session type S: short, M: medium, L: long; O: ordered, UO: unordered, FO: flexible ordered; ST: single-type-action, MT: multi-type-action; A: anonymous, NA:
non-anonymous; SL: single-level, ML: multi-level.
Model ARD: association rule discovery, FPM: frequent pattern mining, SPM: sequential pattern mining, NN: nearest neighbour, MC: Markov chain, MF: matrixfactorization, VI: variational inference, HMM: hidden markov model, ME: metric embedding, DR: distributed representation, RNN: recurrent neural network,
CNN: convolution neural network, TCN: temporal convolution network, MLP: multi-layer perceptron, GNN: graph neural network, ATT: attention, MN: memory network, MM: mixture model, GM: generative model, RL: reinforcement learning, ED: encoder-decoder.
1 Most of the works do not target sessions of a specific length, only a few ones are experimented on long sessions and thus marked â€˜Lâ€™.
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
SBRS approaches
Conventional SBRS
approaches
Latent representation
based approaches
Deep neural network
based approaches
Pattern/rule mining
Markov chain
Latent factor model
Distributed representation
Basic deep neural
Advanced models
Recurrent neural networks
Convolutional neural networks
Graph neural networks
Attention model
Memory networks
Mixture model
K nearest neighbour
Generative model
Reinforcement learning
Multilayer perceptron networks
Generative probabilistic model
Fig. 3. The categorization of SBRS approaches
attention models, memory networks, mixture models, generative models and reinforcement learning.
Consequently, the existing approaches for SBRSs are classified into three super-classes, eight classes,
plus nine sub-classes. As a result, 15 atomic classes of SBRS approaches are obtained, i.e., six classes
from conventional SBRS approaches and latent representation approaches, and nine sub-classes
from deep neural network approaches. In addition to approaches based on a single technique/model,
there are some hybrid approaches which combine multiple techniques/models, e.g., an approach for
next-basket recommendations combines Markov chain model and latent factor model . Next,
first, a comparison of different classes of approaches will be presented in Section 5.2, and then each
super-class of approaches will be reviewed in Sections 6, 7 and 8 respectively.
A Comparison of Different Classes of Approaches
Generally speaking, conventional SBRS approaches are relatively simple, straightforward, and easy
to understand and implement. Although simple, they are effective in some cases, especially on those
simple datasets where the dependencies within or between sessions are obvious and easy to model
and capture. Particularly, in a study by Ludewig et al. , KNN-based approaches, e.g., session-KNN,
have achieved superior recommendation accuracies even compared with some deep neural network
based approaches, e.g., GRU4Rec, in much less running time on some e-commerce datasets including
RETAIL, DIGI3. In contrast, deep neural network based approaches are usually relatively complex,
involve complicated and multi-layer network architecture and often require extensive computing.
They are generally believed to be more powerful to comprehensively model and capture the complex
3 
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
dependencies, e.g., long-term or high-order dependencies, embedded in complex datasets, e.g.,
imbalanced or sparse datasets, for more accurate SBR . The superiority of deep neural network
based approaches has been verified by a variety of works in recent years, e.g., . In
general, latent representation based approaches are a bit more complicated than conventional
approaches but less complicated than deep neural network based approaches. Unlike deep neural
network based approaches, they usually do not involve a deep network architectures, leading to
relatively low computation cost. However, benefiting from their efficient and effective representation
learning, they sometimes perform very well. In some studies , latent representation based
approaches can outperform not only some conventional approaches, e.g., Markov chain based
approaches , but also some deep neural network based ones, e.g., RNN-based approaches .
As introduced in Section 3.6, the work mechanism of SBRSs is to learn the comprehensive
dependencies to guide the subsequent recommendations. Therefore, learning dependencies in
session data is the key computation task in an SBRS. In addition, recall that most of the challenges
in SBRSs can be abstracted to learn the various types of dependencies, e.g., high-order dependencies,
embedded in different types of session data, e.g., long sessions, as illustrated in Section 4. Therefore,
in order to have a better understanding of how each class of approaches can benefit completing the
key computation task and addressing the main challenges in the field of SBRSs, Table 5 compares
all the 15 atomic classes of approaches regarding the type of dependencies they can learn. For
example, the fourth row in Table 5 means that Markov chain based approaches mainly capture
sequential, short-term, first-order and pointwise dependencies in session data for recommendations.
First-order dependency and pointwise dependency refer to the dependency between any two
adjacent interactions and that between any pair of interactions, respectively.
In addition, a statistic on the number of publications in each atomic class is presented in Fig.
4. This result was achieved by manually retrieving and counting the publications on SBRS using
Google scholar on 20 March, 2021. We first used the typical keywords "session, recommendation",
"next item/basket/POI/song/news/video recommendation" for searching and then manually counted
those relevant publications only.
Table 5. A comparison of learned dependencies by different classes of approaches
Sequential or nonsequential
collective
Pattern/rule mining
K nearest neighbour
Mainly non-sequential
Mainly first-order
Markov chain
Sequential
Short-term
First-order
Generative probabilistic model
Sequential
Higher-order
Collective
Latent factor model
Sequential
Short-term
First-order
Distributed representation
Mainly non-sequential
Mainly first-order
Collective
Recurrent neural networks
Sequential
High-order
Multilayer perceptron networks
Non-sequential
First-order
Collective
Convolutional neural networks
Mainly sequential
Mainly first-order
Collective
Graph neural networks
High-order
Attention models
Mainly non-sequential
First-order
Mainly pointwise
Memory networks
Non-sequential
First-order
Mixture models
Generative models3
Reinforcement learning
Sequential
High-order
1 Non-sequential and sequential dependencies are learned by frequent pattern mining and sequential pattern mining respectively.
2 Item-KNN and session-KNN mainly models pointwise and collective dependencies respectively.
3 The learned dependencies mainly depend on the employed encoder for encoding the input of the generation model.
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
Reinforcement learning
Generative model
Mixture model
Memory networks
Attention model
Graph neural networks
Convolutional neural networks
Multilayer perceptron networks
Recurrent neural networks
Distributed representation
Latent factor model
Generative probabilistic model
Markov chain
K nearest neighbour
Pattern/rule mining
Number of publications
Fig. 4. Number of publications on each class of SBRS per year
CONVENTIONAL SBRS APPROACHES
Conventional approaches for SBRSs utilize the conventional data mining or machine learning techniques, to capture the dependencies embedded in session data for session-based recommendations.
Next, we introduce each of the four classes of conventional approaches respectively.
Pattern/Rule Mining based SBRSs
Generally speaking, there are two types of pattern/rule mining based approaches for SBRS: (1)
frequent pattern/association rule mining based approaches, which mine the association rules over
different interactions within unordered sessions to guide the subsequent recommendations; and (2)
sequential pattern mining based approaches, which mine the sequential patterns over sequences of
sessions or interactions within ordered sessions to guide the subsequent recommendations. This
class of approaches can handle single-type-action sessions only in which all the actions are the
same in a dataset, so each interaction in a given session is simplified into an item.
Frequent Pattern/Association Rule Mining based Approaches. Frequent pattern/association
rule mining based SBRSs mainly contain three steps: (1) frequent pattern or association rule mining,
(2) session matching, and (3) recommendation generation. To be specific, given an item set ğ‘‰and
the corresponding session set ğ‘†over ğ‘‰, first, a set of frequent patterns ğ¹ğ‘ƒ= {ğ‘1, ğ‘2, ..., ğ‘|ğ¹ğ‘ƒ|} are
mined by using pattern mining algorithms like FP-Tree . Then, given a partial session Ë†ğ‘ (e.g.,
a list of chosen items in one session), if an item Ë†ğ‘£âˆˆğ‘‰\ Ë†ğ‘ exists so that Ë†ğ‘ âˆª{Ë†ğ‘£} âˆˆğ¹ğ‘ƒ, then Ë†ğ‘£is a
candidate item for recommendations. Finally, if the conditional probability ğ‘ƒ(Ë†ğ‘£|Ë†ğ‘ ) is greater than a
predefined confidence threshold, then Ë†ğ‘£is added into the recommendation list .
Besides the aforementioned basic framework, there are many variants. For instance, to consider
the different significance of different web pages and thus to recommend more useful ones, several
methods utilized the page-view duration to weight the significance of each page and then
incorporated such weight into association rule mining to build weighted association rule based SBRSs.
With regard to the application domain, except for the traditional shopping basket based product
recommendations, frequent pattern/association rule based SBRSs are also commonly applied in
web page recommendations , music recommendations , and so on.
Sequential Pattern Mining based Approaches. Following a representative work falling
into this sub-class, here we introduce a typical sequential pattern mining based SBRS built on
session level (cf. Section 3.5) for next session recommendations. For sequential pattern based
mining SBRSs built on the interaction level for next interaction recommendations, please refer
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
to . Similar to frequent pattern/association rule mining based approaches, sequential pattern
mining based SBRSs also contain three steps: (1) sequential pattern mining, (2) sequence matching,
and (3) recommendation generation. Specifically, given a sequence set ğ‘„= {ğ‘1,ğ‘2, ...,ğ‘|ğ‘„|} where
ğ‘= {ğ‘ 1,ğ‘ 2, ...,ğ‘ |ğ‘|} is a sequence of sessions from the same user ordered according to the timestamp,
first, a set of sequential patterns ğ‘†ğ‘ƒ= {ğ‘1, ğ‘2, ..., ğ‘|ğ‘†ğ‘ƒ|} is mined on ğ‘„. Then, given a user ğ‘¢â€™s
sequence ğ‘ğ‘¢= {ğ‘ 1,ğ‘ 2, ...,ğ‘ ğ‘”}, for any sequential pattern ğ‘âˆˆğ‘†ğ‘ƒ, if the last session ğ‘ ğ‘”of ğ‘ğ‘¢belongs
to ğ‘, i.e., ğ‘= {ğ‘ 1,ğ‘ 2, ...,ğ‘ ğ‘”,ğ‘ ğ‘Ÿ...}, then ğ‘is a relevant pattern for this specific recommendation and
the items after ğ‘ ğ‘”in ğ‘, like items in ğ‘ ğ‘Ÿ, are candidate items. For each candidate item Ë†ğ‘£, its support is
the sum of the support of all relevant patterns:
ğ‘ ğ‘¢ğ‘ğ‘(Ë†ğ‘£) =
ğ‘ ğ‘”âˆˆğ‘ğ‘¢,ğ‘ ğ‘”âˆˆğ‘,Ë†ğ‘£âˆˆğ‘ ğ‘Ÿ,ğ‘ ğ‘Ÿâˆˆğ‘,ğ‘âˆˆğ‘†ğ‘ƒ
Finally, those candidate items with the top support values are recommended to user ğ‘¢.
Except for the basic framework described above, there are various extensions for sequential
pattern mining based SBRSs. A typical example is to utilize the user-related weighted sequential
pattern mining for personalized recommendations, where each sequence is assigned a weight based
on its similarity to those past sequences of the target user . Another extension is to build a
hybrid RS by combining sequential pattern mining and collaborative filtering to consider both the
usersâ€™ dynamic individual patterns and their general preference . Regarding the application
domain, shopping basket based product recommendations and web page recommendations
 are two typical applications of sequential pattern based SBRSs.
K Nearest Neighbour based SBRSs
K Nearest Neighbour (KNN) based approaches for SBRS are proven to be simple but effective .
In principle, a KNN-based SBRS first finds out the ğ¾interactions or sessions that are most similar to
the current interaction or session respectively from the session data. Then, it calculates a score for
each candidate interaction based on the similarity to indicate its relevance to the current interaction
as the guidance of recommendations. For the same reason as mentioned in the first paragraph
in Section 6.1, each interaction is simplified as an item in this class of approaches. According to
whether the similarity is actually calculated between items or sessions, KNN-based approaches for
SBRSs can be divided into item-KNN and session-KNN.
Item-KNN. Given the current session context, an item-KNN based SBRS recommends
those ğ¾items most similar to the current item in terms of their co-occurrence in other sessions
as the next choice. Technically, each item is encoded into a binary vector where each element
indicates whether the item occurs (set to "1") in a specific session or not (set to "0"). Consequently,
the similarity between items can be calculated on their vectors with a certain similarity measure,
like cosine similarity .
Session-KNN. Given the current session context ğ‘, a session-KNN based SBRS first calculates the similarity between ğ‘and all other sessions to find the set ğ‘(ğ‘) of its ğ¾neighbour sessions,
and then calculates the score of each candidate item Ë†ğ‘£w.r.t. ğ‘based on the similarity:
ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(Ë†ğ‘£) =
ğ‘ ğ‘–ğ‘š(ğ‘,ğ‘ ğ‘›ğ‘) Â· 1ğ‘ ğ‘›ğ‘(Ë†ğ‘£),
where ğ‘ ğ‘–ğ‘šis a kind of similarity measures and 1ğ‘ ğ‘›ğ‘(Ë†ğ‘£) is an indicator function which returns 1 if Ë†ğ‘£
occurs in ğ‘ ğ‘›ğ‘and 0 otherwise.
Compared with item-KNN, session-KNN considers the whole session context rather than just
the current item in the session context, and thus can capture more information for more accurate
recommendations. Other similar works include an improved session-KNN which takes into account
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
the readily available sequential and temporal information from sessions , and a hybrid approach
that combines session-KNN and GRU4Rec (i.e., an RNN-based SBRS) using a weighted combination
scheme . In addition, a user-KNN approach built on usersâ€™ session information was also proposed
for next-basket recommendation .
Markov Chain based SBRSs
Markov chain based SBRSs adopt Markov chains to model the transitions over interactions within or
between sessions to predict the probable next interaction(s) or session given a session context .
According to whether the transition probabilities are calculated based on explicit observations or
latent space, Markov chain based approaches can be roughly divided into basic Markov chain based
approaches and latent Markov embedding based approaches.
Basic Markov Chain based Approaches. A basic Markov chain based SBRS usually contains
four steps: (1) calculating the transition probabilities over a sequence of interactions, (2) predicting
the transition paths over interactions, (3) matching the session context to the predicted paths,
and (4) making recommendations based on the matching result . Note that, in most cases, the
interactions here are simplified to items.
To be specific, a Markov chain model is defined as a set of tuples {ğ‘†ğ‘‡, ğ‘·ğ’•, ğ‘ƒ0}, where ğ‘†ğ‘‡is the
state space including all the distinct interactions, ğ‘·ğ’•is the ğ‘šâˆ—ğ‘šone-step transition probability
matrix between ğ‘šdistinct interactions, and ğ‘ƒ0 is the initial probability of each state in ğ‘†ğ‘‡. First,
the first-order transitional probability from interaction ğ‘œğ‘–to ğ‘œğ‘—is defined as:
ğ‘ƒğ‘¡(ğ‘–, ğ‘—) = ğ‘ƒ(ğ‘œğ‘–â†’ğ‘œğ‘—) =
ğ‘“ğ‘Ÿğ‘’ğ‘(ğ‘œğ‘–â†’ğ‘œğ‘—)
ğ‘œğ‘¡ğ‘“ğ‘Ÿğ‘’ğ‘(ğ‘œğ‘–â†’ğ‘œğ‘¡) .
Second, a transition path, e.g., {ğ‘œ1 â†’ğ‘œ2 â†’ğ‘œ3}, is predicted by estimating its probability by using
the first-order Markov chain model:
ğ‘ƒ(ğ‘œ1 â†’ğ‘œ2 â†’ğ‘œ3) = ğ‘ƒ(ğ‘œ1) âˆ—ğ‘ƒ(ğ‘œ2|ğ‘œ1) âˆ—ğ‘ƒ(ğ‘œ3|ğ‘œ2).
Then, given a session context consisting of a sequence of interactions, the paths with high probabilities are chosen as the reference paths. Finally, if the session context occurs in a reference path,
those items occurring after it in this path are put into the recommendation list.
Except for the basic Markov chain based SBRS introduced above, there are many variants. For
example, Zhang et al. combined first- and second-order Markov model together to make
more accurate web page recommendations. Le et al. developed a hidden Markov model based
probabilistic model for next item recommendations. Rendle et al. factorized the transition
probability matrix to estimate those unobserved transitions among interactions.
Latent Markov Embedding based Approaches. Different from the basic Markov chain based
SBRSs which calculate the transition probabilities based on the explicit observations directly, Latent
Markov Embedding (LME) based SBRSs first embed the Markov chains into an Euclidean space and
then calculate the transition probabilities between interactions based on their Euclidean distance
 . In this way, they can derive the unobserved transitions and thus solve the data sparsity issue
in limited observed data. Formally, each interaction ğ‘œis represented as a vector ğ’in a ğ‘‘-dimensional
Euclidean space, and the transition probability ğ‘ƒ(ğ‘œğ‘–â†’ğ‘œğ‘—) is assumed to be negatively related to
the Euclidean distance ||ğ’ğ‘–âˆ’ğ’ğ‘—||2 between ğ‘œğ‘–and ğ‘œğ‘—. Accordingly, the probability of a transition
path ğ‘ğ‘= {ğ‘œ1 â†’ğ‘œ2 â†’, ..., â†’ğ‘œ|ğ‘ğ‘|} can be defined based on Markov model:
ğ‘ƒ({ğ‘œ1 â†’ğ‘œ2 â†’, ..., â†’ğ‘œ|ğ‘ğ‘|}) =
ğ‘ƒ(ğ‘œğ‘–âˆ’1 â†’ğ‘œğ‘–) =
ğ‘’âˆ’||ğ’ğ‘–âˆ’ğ’ğ‘–âˆ’1 ||2
ğ‘œğ‘¡ğ‘’âˆ’||ğ’ğ‘¡âˆ’ğ’ğ‘–âˆ’1 ||2
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
To generate personalized recommendations, Wu et al. proposed a Personalized Markov
Embedding (PME) model which maps both users and items into an Euclidean space where the
user-item distance and item-item distance reflect the corresponding pairwise relationship. Further,
Personalized Ranking Metric Embedding (PRME) was proposed to first project each item into a low
dimensional Euclidean latent space, and then use the Metric Embedding algorithm to effectively
compute transitions between items in a Markov chain model. Intuitively, the Euclidean distances
measure the probabilities of transitions .
Generative Probabilistic Model based SBRSs
Generative probabilistic model based approaches generally first infer the latent taxonomy (e.g.,
topics or genres) of items (e.g., songs) in sessions and then learn the transitions among these latent
taxonomies within or between sessions. Afterwards, they predict the next latent taxonomy using
the learned transitions. Finally, they further predict specific items as the next item conditional on
the predicted latent taxonomy of items. Usually, the latent topic model is utilized to infer the latent
taxonomies and the transitions among them. Representative studies include music recommendation
based on latent topic sequential patterns , and playlist generation with statistical models on
music-listening sessions .
Comparison of Conventional SBRS Approaches
After providing the main idea and key technical details of each class of conventional approaches for
SBRSs, we present a comparison and summary of those approaches in this subsection. Specifically,
in Table 6, we compare these three classes of approaches in terms of their applicable scenarios,
i.e., for which type of session data that an approach is suitable, pros, cons and the typical works.
An empirical comparison on prediction accuracy of the first three classes of conventional SBRS
approaches was conducted on seven datasets from domains including retail, music and news. The
result shows KNN-based approaches especially the session-KNN achieve superior performance .
Table 6. A comparison of different classes of conventional approaches for SBRSs
Applicable scenario
Typical work
Pattern/rule
mining based
unordered sessions
Intuitive, simple and effective on session data
dependencies
are easy to learn
Information loss, cannot handle complex data (e.g., imbalanced or sparse data)
 , , ,
 , , 
Simple, ordered or unordered sessions
Intuitive, simple and effective, quick response
Information loss, hard to select
ğ¾, limited ability for complex
sessions (e.g., noisy sessions)
 , , ,
chain based
Short and ordered sessions with short-term
and low-order dependencies
short-term and loworder
sequential
dependencies
Usually ignore long-term and
higher-order
dependencies,
the rigid order assumption is
too strong
 , , ,
 , , ,
Generative
probabilistic
Ordered sessions with
high-order dependencies
high-order and collective dependencies
Computation cost is relatively
 , 
LATENT REPRESENTATION APPROACHES FOR SBRSs
Latent representation approaches for SBRSs first build a low-dimensional latent representation for
each interaction within sessions with shallow models. The learned informative representations
encode the dependencies between these interactions, and then will be utilized for the subsequent
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
session-based recommendations. According to the utilized techniques, latent representation approaches can be roughly classified into latent factor model based approaches and distributed
representation based approaches.
Latent Factor Model based SBRSs
Latent factor model based SBRSs first adopt factorization models, e.g., matrix factorization, to
factorize the observed transition matrix over interactions (items) into their latent representations,
and then utilize the resultant latent representations to estimate the unobserved transitions for the
subsequent session-based recommendations. To be specific, first, a transition tensor B |ğ‘ˆ|Ã—|ğ‘‚|Ã—|ğ‘‚| can
be built using the observed session data, where each entry ğ‘ğ‘˜,ğ‘–,ğ‘—indicates the transition probability
from interaction ğ‘œğ‘–to ğ‘œğ‘—under user ğ‘¢ğ‘˜. Then, a general linear factorization model, e.g., Tucker
Decomposition, is used to factorize B:
Ë†B = Cğ‘œÃ— ğ‘¼Ã— ğ‘¶ğ‘–Ã— ğ‘¶ğ‘—,
where Cğ‘œis a core tensor, ğ‘¼is the latent representation matrix for users while ğ‘¶ğ‘—and ğ‘¶ğ‘˜are the
latent representation matrix for the last interactions and the current interactions respectively.
To alleviate the negative effect of the sparse transitions observed for B, a special case of Canonical
Decomposition is used to transfer Eq (7) into the modelling of pairwise interactions:
Ë†ğ‘ğ‘˜,ğ‘–,ğ‘—=< ğ’–ğ‘˜, ğ’ğ‘–> + < ğ’ğ‘–, ğ’ğ‘—> + < ğ’–ğ‘˜, ğ’ğ‘—>,
where ğ’–ğ‘˜, ğ’ğ‘–and ğ’ğ‘—are the latent representation vector of user ğ‘¢ğ‘˜, the last interaction ğ‘œğ‘–and the
current interaction ğ‘œğ‘—respectively . Here, interactions are usually simplified to items.
In addition to the above defined latent factor model based SBRS, i.e., Factorized Personalized
Markov Chain (FPMC) model, there are many other variants. For instance, Cheng et al. extended
FPMC into FPMC-LR by adding a constraint to limit user movements into a localized region to
make it more consistent with the real-world tourism cases for next POI recommendations. A
co-factorization model, CoFactor, was proposed to jointly decompose the user-item interaction
matrix and the item-item co-occurrence matrix with shared latent factors for items to capture
both the usersâ€™ individual preference and the item transition patterns . Some other similar
works utilize the matrix factorization model to learn the transitions of preferences from
one location category to another to provide location recommendations.
Distributed Representation based SBRSs
Distributed representation based SBRSs generally learn the distributed representations of interactions (usually specified to items, sometimes users are also incorporated) with a shallow neural
network structure to map each interaction into a low-dimensional latent space. In most cases, the
shallow neural network structure is similar to Skip-gram model or CBOW model in the natural language processing domain. As a result, the intra- or inter-session dependencies are encoded
into the distributed representations, which are then used for session-based recommendations.
Specifically, a shallow neural network embeds a user ğ‘¢ğ‘˜and an item ğ‘£ğ‘–into a latent distributional
vector respectively using the logistic function ğ›¿(Â·) for nonlinear transformation :
where ğ‘¾ğ‘¢âˆˆRğ‘‘Ã—|ğ‘ˆ| and ğ‘¾ğ‘£âˆˆRğ‘‘Ã—|ğ‘‰| are the user and item embedding matrices respectively, and
the ğ‘˜ğ‘¡â„column of ğ‘¾ğ‘¢corresponds to user ğ‘¢ğ‘˜.
In addition to the basic latent representation based SBRS introduced above, there are a number of
variants. Wang et al. designed a shallow network to embed the ID and features of each item
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
simultaneously to build a compound item representation to tackle the cold-start item issues; some
similar works include . To attentively learn the relevance scales of different interactions
in the session context w.r.t. the next choice, attention mechanism is incorporated into the representation learning process . In other related works , a hierarchical representation of
each basket is learned for next-basket recommendations.
Comparison of Latent Representation based SBRS Approaches
After providing the main idea and the basic technical details of each class of latent representation
approaches for SBRSs, we present a comparison and summary of these approaches. Specifically, in
Table 7, we compare the two classes of approaches in terms of their applicable scenarios, i.e., for
which kind of session data that an approach is suitable, pros, cons and the typical works.
Table 7. A comparison of different classes of latent representation approaches for SBRSs
Applicable scenario
Typical work
Latent factor
Dense, ordered session
Relatively
and effective
Suffer from data sparsity, cannot capture higher-order and
long-term dependencies
 , , ,
 , , 
Distributed
representation
Unordered session data
efficient,
encoding capability
Hard to model ordered or
heterogeneous sessions (e.g.,
noisy sessions)
 , , , ,
 , , 
DEEP NEURAL NETWORK APPROACHES FOR SBRSs
Deep neural network approaches for SBRSs mainly take advantage of the powerful capabilities
of deep neural networks in modelling the complex intra- and inter-session dependencies for
recommendations. According to the utilized basic framework, deep neural network approaches can
be roughly divided into basic deep neural network approaches, each of which involves one type of
a basic neural network architecture, e.g., Recurrent Neural Networks (RNN), and advanced models,
each of which involves a certain advanced mechanism or model, e.g., attention model.
Basic Deep Neural Network based SBRSs
According to the utilized network architecture, basic deep neural network approaches can be divided
into RNN-based approaches, Multi-Layer Perceptron (MLP) based approaches, Convolutional Neural
Networks (CNN) based approaches and Graph Neural Networks (GNN) based approaches.
Recurrent Neural Networks (RNN). Benefiting from their intrinsic advantages for modeling
sequential dependencies, RNN-based approaches dominate deep neural network approaches for
SBRSs. This is because the order assumption has been applied to the interactions in a majority
of session datasets in the literature. Particularly, an RNN-based SBRS first models each ordered
session context as a sequence of interactions within the context. In such a way, it takes the last
hidden state of the RNN modeling the context as the context representation. Then, the RNN-based
SBRS takes the context representation as the input to predict the next interaction to complete
the recommendation task. In those RNN-based SBRSs where the inter-session dependencies are
considered, the representation of a sequence of historical sessions is first learned in a similar way
and then incorporated for recommendations.
We introduce a representative RNN-based SBRS called GRU4Rec which is built on Gated Recurrent
Units (GRU) , as an example to illustrate the work mechanism of RNN-based SBRSs. To be
specific, an RNN is built to model the session context consisting of a sequence of interactions. First,
the embedding ğ’ğ‘¡of the ğ‘¡ğ‘¡â„interaction ğ‘œğ‘¡in the context is taken as the input of the ğ‘¡ğ‘¡â„time step of
the RNN. Then, an RNN unit, i.e., GRU, is used to update the hidden state ğ’‰ğ‘¡at the ğ‘¡ğ‘¡â„time step by
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
absorbing information from both the last hidden state ğ’‰ğ‘¡âˆ’1 and the current candidate state Ë†ğ’‰ğ‘¡by
using an update gate ğ’›ğ‘¡.
ğ’‰ğ‘¡= (1 âˆ’ğ’›ğ‘¡)ğ’‰ğ‘¡âˆ’1 + ğ‘§ğ‘¡Ë†ğ’‰ğ‘¡,
where ğ‘§ğ‘¡and Ë†ğ’‰ğ‘¡are computed by Eqs (12) and (13) given below respectively.
ğ’›ğ‘¡= ğœ(ğ‘¾ğ‘§ğ’ğ‘¡+ ğ‘¿ğ‘§ğ’‰ğ‘¡âˆ’1),
Ë†ğ’‰ğ‘¡= ğ‘¡ğ‘ğ‘›â„(ğ‘¾â„ğ’ğ‘¡+ ğ‘¿â„(ğ’“ğ‘¡âŠ™ğ’‰ğ‘¡âˆ’1)),
where âŠ™denotes Hadamard product and the reset gate ğ’“ğ‘¡is given below:
ğ’“ğ‘¡= ğœ(ğ‘¾ğ‘Ÿğ’ğ‘¡+ ğ‘¿ğ‘Ÿğ’‰ğ‘¡âˆ’1),
where ğœis the activation function which can be specified to be sigmoid function. ğ‘¾and ğ‘¿are the
corresponding weighting matrices.
In this way, a session context ğ‘composed of |ğ‘| interactions can be modeled by an RNN with |ğ‘|
units. Finally, the hidden state ğ’‰|ğ‘| from the last time step is used as the representation ğ’†ğ‘of ğ‘for
the prediction of the next interaction .
In addition to the basic GRU4Rec, there are also many variants. To improve GRU4Rec, Tan
et al. adopted data augmentation via sequence preprocessing and embedding dropout to
enhance the training process and reduce overfitting respectively. Quadrana et al. further
improved GRU4Rec by proposing a hierarchical RNN model to capture both intra- and inter-session
dependencies for more reliable next item(s) recommendations. Specifically, a two-level GRU-based
RNN is designed: the session-level GRU models the sequence of items purchased within each
session and generates recommendations for next item(s), while the user-level GRU models the
cross-session information transfer and then provides personalized information to the session-level
GRU by initializing its hidden state. Another similar work is Inter-Intra RNN (II-RNN) proposed by
Ruocco et al. . In , the authors designed a unique user-based GRU model which incorporates
user characteristic to generalize personalized next item recommendations. Furthermore, there are
also RNN-based SBRSs built on basic RNN units, for example, the Dynamic REcurrent bAsket Model
(DREAM) learns a dynamic representation of a user at each time step using an RNN built on
basic RNN units for next basket recommendations.
There are also other variants which incorporate (1) variational inference into RNN to handle the
uncertainty in sparse session data and simultaneously enhance the modelâ€™s scalability on large realworld datasets for recommendations ; (2) side information like item features and contextual
factors like time and location into RNN to improve the recommendation performance ; (3)
time decay or attention mechanism into RNN to discriminate the intra-session dependencies and
thus achieve more precise recommendations ; and (4) traditional models like factorization
machines or neighbourhood models to make up the drawbacks of RNN-only models .
There are other similar RNN-based SBRSs .
MultiLayer Perceptron (MLP) networks. MLP-based approaches are usually applied to
learn an optimized combination of different representations to form a compound representation of
session context for the subsequent recommendations. Different from RNN, MLP is mainly suitable
for unordered session data due to the lack of capability to model sequence data. Specifically, in the
work of Wu et al. , an MLP layer is utilized to connect the representations of different parts of
a session context to export a unified and compound representation ğ’†ğ‘for context ğ‘:
ğ’†ğ‘= ğœ(ğ‘¾ğ‘ğ’†ğ‘ğ‘+ ğ‘¾ğ‘£ğ’†ğ‘ğ‘£),
where ğ’†ğ‘ğ‘, ğ’†ğ‘ğ‘£are the representation of the sub session context containing "click" actions and the
sub session context containing "view" actions respectively. ğ‘¾ğ‘and ğ‘¾ğ‘£are the corresponding weight
matrices to fully connect each of the representations to the hidden layer of MLP.
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
In addition, Jannach et al. applied MLP to learn an optimized combination of different factors
like "reminders", "item popularity" and "discount" as a compound session-based feature for next-item
recommendations. Song et al. employed an MLP layer to combine both a userâ€™s long-term
static and short-term temporal preferences for making more accurate next-item recommendations.
Convolutional Neural Networks (CNN). CNN are another good choice for SBRSs for two
reasons: (1) they relax the rigid order assumption over interactions within sessions, which makes
the model more robust; and (2) they have high capabilities in learning local features from a certain
area and relationships between different areas in a session to effectively capture the union-level
collective dependencies embedded in session data. In principle, a CNN-based SBRS first utilizes
the filtering and pooling operations to better learn an informative representation for each session
context and then uses the learned representation for the subsequent recommendations . To be
specific, given a session context ğ‘consisting of |ğ‘| interactions, an embedding matrix ğ‘¬âˆˆRğ‘‘Ã—|ğ‘| of
ğ‘can be constructed by first mapping each interaction in ğ‘into a ğ‘‘-dimensional latent vector and
then puting all the vectors together into a matrix. Afterwards, in a horizontal convolutional layer,
the ğ‘šğ‘¡â„convolution value ğ›¼ğ‘¥
ğ‘šis achieved by sliding the ğ‘¥ğ‘¡â„filter ğ‘­ğ‘¥from the top to the bottom on
ğ‘¬to interact with its horizontal dimensions:
ğ‘š= ğœ™ğ›¼(ğ‘¬ğ‘š:ğ‘š+â„âˆ’1 âŠ™ğ‘­ğ‘¥),
where ğœ™ğ›¼is the activation function for the convolutional layer.
Then the final output ğ’†ğ‘âˆˆRğ‘§from the ğ‘§filters is obtained by performing the max pooling
operation on the convolution result ğœ¶ğ‘¥= [ğ›¼ğ‘¥
2, ..., ğ›¼ğ‘¥
|ğ‘|âˆ’â„+1] to capture the most significant
features in the session context:
ğ’†ğ‘= ğ‘šğ‘ğ‘¥{ğ‘šğ‘ğ‘¥(ğœ¶1),ğ‘šğ‘ğ‘¥(ğœ¶2), ...,ğ‘šğ‘ğ‘¥(ğœ¶ğ‘§)}.
Finally, ğ’†ğ‘is treated as the representation of the session context ğ‘and is used for subsequent
recommendations .
Some variants include a 3D CNN model built for SBRS, which jointly models the sequential
patterns in click session data and the item characteristics from item content features, and a CNN
model to accumulate long-term user preferences for generating personalized recommendations.
Furthermore, Temporal Convolutional Networks (TCN) were utilized to model the interactions
within sessions to predict the next interaction .
Graph Neural Networks (GNN) . In recent years, GNN have shown great expressive power
in modeling the complex relations embedded in graph structured data by introducing deep neural
networks into graph data . To benefit from this power, some researchers have introduced
GNN to model the complex transitions within or between sessions to build better-performing
SBRSs. First, given a dataset containing multiple sessions, it is transferred to a graph G by mapping
each session into a chain on the graph. Each interaction ğ‘œin a session serves as a node ğ‘›in the
corresponding chain where an edge ğ‘’is created to connect each pair of the adjacent interactions in
the session. Then, the constructed graph is imported into GNN to learn an informative embedding
for each node (interaction) by encoding the complex transitions over the graph into the embeddings.
Finally, these learned embeddings are imported into the prediction module for session-based
recommendations. According to the specific model architecture of GNN, GNN approaches for
SBRSs can be generally divided into three classes: Gated Graph Neural Networks (GGNN), Graph
Convolutional Networks (GCN) and Graph ATtention networks (GAT).
Gated Graph Neural Networks (GGNN) for SBRSs. In GGNN-based SBRSs, first, a directed graph is
constructed based on all the historical ordered sessions, where the direction of each edge indicates
the order of adjacent interactions within sessions. Then, each session graph, i.e., a chain (sub-graph)
for each session, is processed successively by GGNN to obtain the embedding ğ’ğ‘–of node ğ‘›ğ‘–, namely
the embedding of the corresponding interaction ğ‘œğ‘–. Finally, after all the session graphs are processed,
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
the embeddings of all the interactions are obtained, which are then used to construct the embedding
of the session context for recommendations. Particularly, in GGNN, a Gated Recurrent Unit (GRU) is
used to learn the embedding of each node in a session graph by updating the embedding recurrently.
Specifically, the embedding (also called hidden state) ğ’‰ğ‘¡
ğ‘–of node ğ‘›ğ‘–at step ğ‘¡is updated by the
previous hidden state of itself and its neighbourhood nodes, i.e., ğ’‰(ğ‘¡âˆ’1)
and ğ’‰(ğ‘¡âˆ’1)
ğ‘–= ğºğ‘…ğ‘ˆ(ğ’‰(ğ‘¡âˆ’1)
where ğ‘(ğ‘›ğ‘–) is the set of neighbourhood nodes of ğ‘›ğ‘–in the session graph, and ğ‘¨is the adjacency
matrix built on the session graph. After multiple iterations until a stable equilibrium is reached,
the hidden state at the final step of node ğ‘›ğ‘–is taken as its embedding ğ’ğ‘–. Session-based Recommendation with Graph Neural Networks (SR-GNN) is the pioneering work which introduced
GNN into SBRSs and is claimed to have achieved superior performance, compared with non-GNN
approaches including Short-Term Attention/Memory Priority Model (STAMP) , Neural Attentive Recommendation Machine (NARM) and an RNN-based approach built on GRU, named
GRU4Rec . But it may not always outperform conventional methods, as discussed in . Other
representative approaches falling into this stream include (1) Graph Contextualized Self-Attention
Network (GC-SAN) , which utilizes both GNN and self-attention mechanism to learn local
dependencies and long-range dependencies respectively, for session-based recommendations, and
(2) Target Attentive GNN (TAGNN) which first learns item embedding with GNN and then
attentively activates different user interests with respect to varied target items, for session-based
recommendations.
Graph Convolutional Networks (GCN) for SBRSs. Different from GGNN-based SBRSs, GCN-based
SBRSs mainly utilize the pooling operation to integrate information from node ğ‘›ğ‘–â€™s neighbourhood
node ğ‘›ğ‘—in the graph to help with the update of the hidden state of ğ‘›ğ‘–as shown below:
ğ‘–= ğ‘ğ‘œğ‘œğ‘™ğ‘–ğ‘›ğ‘”({ğ’‰(ğ‘¡âˆ’1)
,ğ‘›ğ‘—âˆˆğ‘(ğ‘›ğ‘–)}),
where ğ‘(ğ‘›ğ‘–) is the set of neighbourhood nodes of node ğ‘›ğ‘–. Different specific pooling operations
including mean pooling and max pooling can be utilized, depending on the specific scenarios.
Afterwards, the integrated neighbourhood information can be incorporated into the iterative
update of the hidden state of node ğ‘›ğ‘– :
Finally, when a stable equilibrium is reached, the last hidden state of node ğ‘›ğ‘–is taken as its
embedding ğ’ğ‘–.
Graph ATtention networks (GAT) for SBRSs. GAT-based SBRSs mainly utilize attention mechanism
to attentively integrate the information from the neighbourhood nodes of node ğ‘›ğ‘–in a session
graph to update its hidden state in each attention layer :
ğ‘–= ğ‘ğ‘¡ğ‘¡ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘œğ‘›({ğ’‰(ğ‘¡âˆ’1)
,ğ‘›ğ‘—âˆˆğ‘(ğ‘›ğ‘–)}),
ğ‘–is the hidden state of node ğ‘›ğ‘–in the ğ‘¡ğ‘¡â„attention layer. Here ğ‘ğ‘¡ğ‘¡ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘œğ‘›is a general attention
module and can be specified to different operations including self attention, multi-head attention,
etc. In principal, the operations in ğ‘ğ‘¡ğ‘¡ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘œğ‘›can be divided into two steps (cf. Section 8.2.1): (1)
calculating the importance weights of each neighbourhood node, and (2) aggregating the hidden
states of neighbourhood nodes according to their importance weights. Finally, once the forward
propagation of multiple attention layers is completed, the hidden state of each node ğ‘›ğ‘–in a session
graph at the final layer is taken as its embedding ğ’ğ‘–.
Typical works falling into this class include Full Graph Neural Network (FGNN), which learns the
inherent order of the item transition patterns in sessions with a multiple Weighted Graph ATtention
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
(WGAT) network , another FGNN based on Broadly Connected Session graph to attentively
exploit information both within and between sessions , and Shortcut Graph ATention (SGAT)
to effectively propagate information along shortcut connections with attention mechanism .
Advanced Model based SBRSs
In addition to the aforementioned four classes of basic deep neural network approaches for SBRSs,
there are also advanced approaches that are built on some advanced models or algorithms, including
attention models, memory networks, mixture models, generative models and reinforcement learning.
Usually, these advanced models or algorithms are combined with some basic approaches like
distributed representation learning or RNN to construct more powerful SBRSs.
Attention Models. Attention-based SBRSs introduce the attention mechanism to
discriminatively exploit different elements, i.e., interactions or/and sessions, in a session context
to build an informative session context representation for accurate recommendations. With the
incorporation of attention mechanism, an SBRS is able to emphasize those elements that are more
relevant to the next interaction or session and reduce the interference of the irrelevant ones in a
session context. Generally, an attention model mainly contains two steps: attention weight calculation and aggregation. Next we introduce how an attention model learns a context representation
for next interaction recommendations when the context includes the known part of the current
session only (cf. Section 2.2). For contexts including historical sessions, their representations can
be learned in a similar way.
Step 1: given the embedding ğ’ğ‘–of interaction ğ‘œğ‘–in session context ğ‘of next interaction ğ‘œğ‘¡ğ‘”,
attention model calculates the weight ğ›½ğ‘¡ğ‘”,ğ‘–of ğ‘œğ‘–to indicate its relevance scale w.r.t ğ‘œğ‘¡ğ‘”, which is
usually performed by a softmax function :
ğ‘’ğ‘¥ğ‘(ğ‘’(ğ’ğ‘–))
ğ‘œğ‘—âˆˆğ‘ğ‘’ğ‘¥ğ‘(ğ‘’(ğ’ğ‘—)) ,
where ğ‘’(ğ’ğ‘–) is a utility function, which can be specified as the inner product between a learnable
weight vector ğ’˜and ğ’ğ‘–. Sometimes, ğ’ğ‘¡ğ‘”is also taken as an input of the utility function to make the
learned weight more sensitive to the target interaction ğ‘œğ‘¡ğ‘”.
Step 2: the embeddings of all interactions in the session context ğ‘are aggregated with the learned
weights to construct the embeddeding eğ‘for ğ‘:
eğ‘= ğ‘ğ‘”ğ‘”ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘¡ğ‘’({ğ’ğ‘–, ğ›½ğ‘¡ğ‘”,ğ‘–, ğ‘œğ‘–âˆˆğ‘}),
where ğ‘ğ‘”ğ‘”ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘¡ğ‘’is an aggregation function which is often specified as a weighted sum. The context
embedding is then fed into the prediction module for generating recommendations.
In addition to the aforementioned basic attention model, a series of variants have been proposed
for improving the performance of session-based recommendations. For example, a hierarchical attention model was proposed to attentively integrate both a userâ€™s historical sessions and the current
session to capture her long- and short-term preferences for accurate session-based recommendations . Similarly, a co-attention network was designed to better explore the correlations
between a userâ€™s current interaction and the interactions from historical sessions, for more accurate
session-based recommendations . It should be noted that attention models are usually integrated
into other basic approaches, including encoder-decoder , distributed representation learning
 , RNN and GNN , to enhance their capabilities for recommendations. In particular,
the attention-enhanced GNN, i.e., GAT, has been introduced in Section 8.1.4. Other representative
approaches for SBRSs that utilize attention models include the Short-Term Attention/Memory
Priority (STAMP) model , the self attention model and the soft attention model .
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
Memory Networks. A memory network based SBRS introduces a memory network to
capture the dependency between any interaction in the session context and the next interaction
directly by introducing an external memory matrix. Such matrix stores and updates the information
of each interaction in a secession context more explicitly and dynamically to keep the most relevant
and important information for the recommendation task.
To be specific, a memory network based SBRS mainly consists of two major components: a
memory matrix that maintains the embeddings of interactions in a session context ğ‘, and a controller
that performs operations (including reading and writing) on the matrix . Suppose Mğ‘is the
memory matrix to store the embeddedings of the recent interactions in ğ‘, where each column
corresponds to the embedding of one interaction. After an interaction ğ‘œğ‘–happens in a session and is
added into ğ‘, Mğ‘will be updated accordingly to maintain the information of the recent interactions
by writing the embedding oğ‘–of ğ‘œğ‘–into it:
Mğ‘â†ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(Mğ‘, oğ‘–),
where ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’stands for the write operation, and it can be specified as one of various writing
processes, including the Least Recently Used Access (LRUA) .
During the prediction, the relevant information is carefully read from the maintained memory
matrix to build the embedding eğ‘of the session context ğ‘:
eğ‘= ğ‘Ÿğ‘’ğ‘ğ‘‘(Mğ‘, oğ‘¡ğ‘”),
where oğ‘¡ğ‘”is the embedding of the next interaction ğ‘œğ‘¡ğ‘”to be predicted, and it is considered during
the reading process to read the information more relevant to ğ‘œğ‘¡ğ‘”. The read operation can be specified
to multiple forms, and a typical one is to use the aforementioned attention mechanism (cf. Section
8.2.1) to attentively read the information from the memory matrix.
In addition to the basic memory network based SBRS introduced above, some advanced variants
have been proposed for better modeling sessions and making recommendations. For instance, two
parallel memory modules, i.e., an Inner Memory Encoder (IME) and an Outer Memory Encoder
(OME), were proposed by Wang et al. to model the current session and neighbourhood sessions
respectively to build more informative embedding for a session context. Song et al. proposed
hierarchical memory networks to model a userâ€™s item-level and feature-level preferences simultaneously for better preforming SBR. Other typical works include the short-term attention/memory
priority model for SBR , and the memory augmented neural model for incremental SBR .
Mixture Models. A mixture model based SBRS mainly builds a compound model containing
multiple sub-models to take the advantage of each one to comprehensively model the various
complex dependencies embedded in session data. Usually, each sub-model excels at modeling a
certain type of dependencies, e.g., low-order or higher-order dependencies. In principle, a mixture
model based SBRS performs two main steps: (1) learn different types of dependencies using different
sub-models, and (2) carefully integrate the learned dependencies for accurate SBR.
Representative mixture model based SBRSs include neural Multi-temporal range Mixture Model
(M3), which combines different kinds of encoders to capture short- and long-term dependencies in
a session respectively for accurate recommendations , and Mixture-channel Purpose Routing Networks (MCPRN), which employs multiple recurrent networks to model the intra-session
dependencies under a userâ€™s different shopping purposes .
Generative Models. Generally speaking, approaches based on generative models for SBRSs
make recommendations by generating the next interaction(s) or the next session via a carefully
designed generation strategy. In this way, the recommendation procedure better approaches a
userâ€™s online shopping behaviours in the real word, where items are often picked up step by step to
form a shopping basket . To be specific, given a session context ğ‘as the prior information, a
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
list of interactions (items) ğ‘™is generated to serve as the recommendation list:
ğ‘™= ğ‘”ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘’(ğ‘),
where ğ‘”ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘’stands for a generation process, which can be specified as one of the various forms
including probabilistic generative models .
Representative generative model based SBRSs include NextItNet where a probabilistic
generative model was devised to generate a probability distribution over the candidate items;
Intention2Basket model where a utility-based generator was designed to generate a candidate
session with the maximum utility to best fulfill a userâ€™s shopping intentions; the Variational
Recurrent Model (VRM) where a stochastic generative process of sessions was specified ; and
VAriational SEssion-based Recommendation (VASER) which utilized a non-linear probabilistic method
for Bayesian inference to perform SBR .
Reinforcement Learning (RL). Reinforcement learning approaches for SBRSs generally
model the interactions between a user and an RS in a session as a Markov Decision Process (MDP).
Note that here the interaction particularly refers to the conversation between a user and an RS. For
instance, first, an RS recommends an item to a user who provides some feedback on it, and then the
RS recommends the subsequent item according to the userâ€™s feedback to better fit her preference.
An RL-based SBRS aims to learn the optimal recommendation strategies via recommending trialand-error items and receive reinforcements for these items from usersâ€™ feedback . In this way,
an RL-based SBRS is able to continuously update its strategies during the interactions with users
until reaching the optimal one that best fits the usersâ€™ dynamic preferences. Moreover, the expected
long-term cumulative reward from users is considered during the optimization of the strategies.
Following the work of Zhao et al. , we formalize a basic RL-based SBRS. First, the following
five key concepts are defined in an RL-based SBRS. State space ğ‘†ğ‘, where a stateğ‘ ğ‘ğ‘¡= {ğ‘ ğ‘1
ğ‘¡, ...,ğ‘ ğ‘ğ‘šâ€²
ğ‘†ğ‘is defined as the previous ğ‘šâ€² items with which a user interacted before time ğ‘¡. Action space ğ´ğ‘,
where an action ğ‘ğ‘ğ‘¡= {ğ‘ğ‘1
ğ‘¡, ...,ğ‘ğ‘ğ‘›â€²
ğ‘¡} âˆˆğ´ğ‘is to recommend a list of ğ‘›â€² items to a user at time ğ‘¡based
on the current state ğ‘ ğ‘ğ‘¡. Reward ğ‘…ğ‘’: after the RS takes an action ğ‘ğ‘ğ‘¡at the state ğ‘ ğ‘ğ‘¡, it receives
immediate reward ğ‘…ğ‘’ğ‘¡according to the userâ€™s feedback. Transition probability ğ‘‡ğ‘(ğ‘ ğ‘ğ‘¡+1|ğ‘ ğ‘ğ‘¡,ğ‘ğ‘ğ‘¡)
defines the probability of the state transition from ğ‘ ğ‘ğ‘¡to ğ‘ ğ‘ğ‘¡+1 when the RS takes an action ğ‘ğ‘ğ‘¡.
Discount factor ğ‘‘ğ‘“: ğ‘‘ğ‘“âˆˆ defines the discount factor when we measure the present value of
the future reward. Therefore, SBR can be formalized to find a recommendation policy ğœ‹: ğ‘†ğ‘â†’ğ´ğ‘
to maximize the cumulative reward for an RS given the historical MDP, i.e., (ğ‘†ğ‘,ğ´ğ‘, ğ‘…ğ‘’,ğ‘‡ğ‘,ğ‘‘ğ‘“).
There are three main steps in an RL-based SBRS. The first step is to calculate the state-specific
weight parameters by mapping state ğ‘ ğ‘ğ‘¡to a weight matrix ğ‘¾ğ‘¡:
ğ‘“ğ‘¡: ğ‘ ğ‘ğ‘¡â†’ğ‘¾ğ‘¡.
The second step is to calculate the score of each candidate item using the score function ğ‘“ğ‘ and
then select items with the highest score for recommendations:
ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘£ğ‘–) = ğ‘“ğ‘ (ğ’—ğ‘–,ğ‘¾ğ‘¡).
The final step is to calculate the action value ğ¸(ğ‘ ğ‘ğ‘¡,ğ‘ğ‘ğ‘¡) of the potential action ğ‘ğ‘ğ‘¡, i.e., to recommend the selected item, to judge whether ğ‘ğ‘ğ‘¡matches the current state ğ‘ ğ‘ğ‘¡or not . Usually,
the following optimal action-value function ğ¸âˆ—(ğ‘ ğ‘ğ‘¡,ğ‘ğ‘ğ‘¡), namely the maximum expected return
achievable by the optimal policy , is used:
ğ¸âˆ—(ğ‘ ğ‘ğ‘¡,ğ‘ğ‘ğ‘¡) = Eğ‘ ğ‘ğ‘¡+1 [ğ‘…ğ‘’ğ‘¡+ ğ‘‘ğ‘“ğ‘šğ‘ğ‘¥ğ‘ğ‘ğ‘¡+1ğ¸âˆ—(ğ‘ ğ‘ğ‘¡+1,ğ‘ğ‘ğ‘¡+1)|ğ‘ ğ‘ğ‘¡,ğ‘ğ‘ğ‘¡].
Subsequently, the recommendation strategies are optimized by minimizing the error between the
action value of the ground truth action and that of trialed actions.
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
Table 8. A comparison of different classes of deep neural network approaches for SBRSs
Applicable scenario
Typical work
Long and rigidly ordered
Model long-term and highorder sequential dependencies
The rigid order assumption is too strong for session data
 , , ,
 , , ,
 , , 
Unordered sessions, sessions with multi-aspects
(e.g., static and dynamic
features) to be combined
A simple structure, project
sparse features to dense
ones, learn the combination
of different parts
Cannot model complex
sessions, e.g., ordered,
heterogeneous sessions
 , , ,
Flexible-ordered, heterogeneous or noisy sessions
Robust, no rigid order assumption, capture the unionlevel collective dependency
Relatively high complexity
 , , ,
 , 
Complex sessions with
complex transitions, e.g.,
repeat interactions
Model the complex transitions among interactions
Complex and costly
 , , ,
 , , 
Heterogeneous, noisy, or
long sessions
Identify and highlight important information
Cannot capture sequential information
 , , ,
 , , ,
 , 
incremental
noisy sessions
Dynamically store the latest
information
Cannot capture sequential information
 , , ,
 , 
Heterogeneous,
Model different types of dependencies, e.g., long and
short term dependencies
Relatively complex and
 , 
Generative
incremental
Close to the practical session
 , , 
incremental
Interactive process, consider
the future effect of actions
Hard to simulate the interactive environment
 , , 
Typical works on RL-based SBRSs include LIst-wise Recommendation framework based on
Deep reinforcement learning (LIRD) which learns recommendation strategies for list-wise
recommendations; a similar work called DeepPage for page-wise recommendations ; and Reinforcement Learning with Window for Recommendation (RLWRec) where a state compression
method was proposed to capture an enormous state space for play-list recommendations.
Comparison of Deep Neural Network based SBRS Approaches
After introducing the main ideas and the key technical details of deep neural network approaches
for SBRSs, we present a comparison and summary of these approaches. In particular, in Table 8, we
compare the two classes of deep neural network approaches, including nine sub-classes, in terms
of their applicable scenarios, the typical example of pros and cons, and the typical works.
SBRS APPLICATIONS, ALGORITHMS AND DATASETS
SBRS Applications
SBRSs are widely applied in a variety of real-word domains and scenarios to benefit both customers
and businesses. A summary of SBRS applications is presented in Table 9. Generally speaking, these
applications can be grouped into (1) conventional applications, e.g., next-item recommendation in
E-commerce, and (2) emerging applications, e.g., next-treatment recommendation in healthcare.
According to whether to recommend a product, a content or a service, we can organize SBR into
product recommendation, content recommendation and service recommendation. The conventional
applications involve all these three classes while the emerging applications mainly involve service
recommendation (cf. Table 9). From our observation, most of the existing works on SBRS focus
on the conventional applications, especially the E-commerce domain, e.g., to recommend the next
item or next basket of items on an online shopping platform (e.g., amazon.com). In
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
Table 9. A summary of SBRS applications
Application domain
Application scenario
Typical work
Conventional
application
Product recommendation
E-commerce
Next-item/basket recommendation
 , , , ,
 , , , 
Content recommendation
Media, entertainment
Next news/web-page/song/movie
/video recommendation
 , , , ,
 , , , 
Service recommendation
Next-POI recommendation
application
recommendation
Next-trading recommendation
 , 
Healthcare
Next-treatment recommendation
addition, it is not uncommon that SBRSs are applied to other conventional domains, e.g., next
news/web-page recommendation in media domain , next song/movie/video recommendation
in entertainment domain , and next-POI recommendation in tourism domain .
Compared with the prosper of conventional applications of SBRS, the emerging applications of
SBRS are just in their early stage. However, the applications of SBRS in emerging domains including
finance and healthcare are promising and deserve to be further explored. For example, SBRS is of
great potential to recommend next trading strategies or portfolios to an investor per her investment
goals and context in a financial market and to suggest personalized treatments on a patient
according to her health conditions, past treatments and medical treatment protocols .
Algorithms and Datasets for SBRSs
The source code of most of the representative SBRS algorithms is publicly accessible. We summarize
the open-source code of algorithms for SBRSs built on different models for various tasks in Table 10
to facilitate the access for empirical analysis.
Table 10. A list of representative open-source SBRS algorithms
Utilized model
Next basket
Pattern mining
 
UP-CF 
Next basket
 
Next basket
Markov chain
 
Next basket
Distributed representation
SIGIR 2015
 
Recommendation
DERAM 
Next basket
SIGIR 2016
 
Beacon 
Next basket
IJCAI 2019
 
TIFUKNN 
Next basket
SIGIR 2020
 
Association rule
UMUAI 2018
 
BPR-MF 
Latent factor
 
RecSys 2017
 
RecSys 2017
 
FOSSIL 
Latent factor
 
Latent factor
UMUAI 2018
 
GRU4Rec 
 
STAMP 
 
Attention, RNN
 
SR-GNN 
 
CSRM 
Memory network
SIGIR 2019
 
RepeatNet 
RNN, Attention
 
DGRec 
 
RecommenderSystems/tree/master/socialRec
 
TAGNN 
SIGIR 2020
 
LESSR 
 
MKM-SR 
SIGIR 2020
 
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
Table 11. Commonly used and publicly accessible real-world datasets for SBRSs
# sessions
# interactions
Avg. session length
 , , 
13,418,695
 , 
 , 
Diginetica4
RetailRocket5
CLEF 20176
Adressa 16G8
31,351,954
 , 
NowPlaying11
Foursquare13
0Raw POI data does not have a session structure, researchers often manually build sessions by treating a userâ€™s check-ins
in a single day as a session .
Datasets are necessary for evaluating SBRS algorithms. We summarize a collection of 13 publicly
accessible real-world datasets that are commonly used for SBRS evaluations in Table 11 in the
supplemental material. These datasets cover a wide range of application domains from e-commerce
to POI and are with various characteristics. They can provide challenging test-beds for SBRS
algorithms. The collection of algorithms and datasets will be updated on the associated github
PROSPECTS AND FUTURE DIRECTIONS
Our comprehensive review of the literature has revealed the significant challenges facing SBRS
research and the enormous opportunities SBRS presents. In this section, we outline several promising
prospective research directions, which we believe are critical to the further development of the
Session-based Recommendations with General User Preference
ğ‘†ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘ğ‘’. SBRSs usually ignore usersâ€™ long-term general preferences which can be well captured
by conventional RSs like collaborative-filtering based RSs. This may lead to unreliable recommendations since users with different general preferences and consumption habits may chose different
items even under the same session context. In this case, how to effectively incorporate usersâ€™ general
preferences into an SBRS is critical yet challenging.
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
4 
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
ğ‘‚ğ‘ğ‘’ğ‘›ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ‘ . Here, we discuss two major issues w.r.t. the general preference learning as well as
its incorporation into SBRSs and sketch several critical future research directions.
- How to incorporate usersâ€™ explicit general preference into an SBRS? In this case, it is assumed
that the explicit user-item preference data, e.g., a user-item rating matrix, is available. An intuitive
way is to first learn usersâ€™ general preferences from the explicit preference data using conventional
RS approaches, e.g., Matrix Factorization (MF), and then take the learned preference as an indicator
to fine-tune the ranking of candidate items in an SBRS, e.g., to put those items more preferred by
a user to the front of the recommendation list. Another way is to combine both usersâ€™ long-term
general preferences and short-term preferences together when ranking the candidate items. For
instance, a Generative Adversarial Network (GAN) framework was proposed by Zhao et al. 
to build a hybrid model for movie recommendations. In this model, MF and RNN are utilized to
learn usersâ€™ long-term preference and short-term preference respectively. However, the efforts to
address this issue are still limited and more efforts are needed.
- How to incorporate a userâ€™s implicit general preference into an SBRS? In the real word, the
explicit preference data may not be always available since users may or may not provide explicit
feedback, e.g., ratings, on everything they bought. In such a case, the implicit preference data, i.e.,
usersâ€™ transaction behaviour data including view, click, add to cart and purchase, can be leveraged
to learn usersâ€™ implicit general preference . In practice, such implicit preference data is
often available in the session-based recommdation scenario . Although a variety of works
 have explored how to learn a usersâ€™ general preference from such implicit preference data
in conventional RSs, e.g., collaborative filtering, the efforts in SBRS field are still limited. Therefore,
how to simultaneously learn a userâ€™s implicit general preference and her short-term preference
and effecetively integrate them for accurate SBR is a challenging issue which requires more efforts.
Session-based Recommendations Considering More Contextual Factors
ğ‘†ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘ğ‘’. A context refers to the specific internal and external environment when a user makes
choices on items . Accordingly, contextual factors refer to context-related aspects that may affect
a userâ€™s choices, such as weather, season, location, time and recent popularity trend. Taking these
contextual factors into account may make a huge difference on recommendation performance ,
as demonstrated by researchers including Adomavicius et al. and Pagano et al. . In practice,
an SBRS can be seen as a simplified context-aware RS whose context is simplified to a session
context . Although contextual information has been incorporated into other types of RSs
including context-aware RSs , most of the contextual factors are rarely exploited in SBRSs.
ğ‘‚ğ‘ğ‘’ğ‘›ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ‘ . How to incorporate more contextual factors into SBRSs? A few works have provided
some initial solutions to this issue. A Contextual RNN for Recommendation (CRNN) was proposed
to incorporate contextual factors including the time gap between different interactions and the time
of a day when an interaction happens, into an RNN-based SBRS . In several works ,
the recent popularity trend, a userâ€™s recently viewed items, and items with discount in shopping
mall are taken as contextual factors for SBR. However, these solutions are just a starting point,
and more explorations are still necessary to address issues such as how to collect more contextual
information and how to more effectively incorporate it for more accurate SBR.
Session-based Recommendations with Cross-domain Information
ğ‘†ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘ğ‘’. Cross domains mean different but relevant domains , e.g., movie domain and
song domain. Usually, a userâ€™s purchased items come from multiple domains rather than a single
one to meet her demand . In addition, a userâ€™s choices on items from different domains are
often dependent. For example, after Alice watches the movie â€œTitanic", she may listen to the movieâ€™s
theme song â€œMy heart will go onâ€. Such an example shows that items from different domains may
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
not only be dependent but can even form a sequential session, such as {â€œTitanic", â€œMy heart will go
onâ€}. The recommendations based on such type of session data are interesting but quite challenging.
Such recommendations not only cover more aspects of our daily lives but also provide a solution to
the data sparsity issue when only one domain is considered. On the other hand, it is hard to collect
a userâ€™s consumed items from various domains together, and also the relations between items from
different domains are much more complex than that from a single domain.
ğ‘‚ğ‘ğ‘’ğ‘›ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ‘ . According to whether the items from different domains can form a session or not,
there are two main open issues to be explored.
- How to borrow knowledge from other domains to benefit the SBR in the target domain? When
no sessions can be built across different domains, a target-auxiliary framework can be employed
to benefit SBR from other domains. To be specific, the framework takes the target domain where
the recommendations are made as the main information source while taking other domains as a
supplementary one. An intuitive instance of the framework could utilize transfer learning 
which transfers knowledge from source domains to help with the tasks in the target one. Although
transfer learning has been well explored in conventional RSs like collaborative filtering , it
is rarely explored in SBRSs.
- How to perform SBR on multiple domains? This case happens when sessions can be built from
different domains. Different from the aforementioned target-auxiliary framework, in this case, RSs
treat items from different domains equally and each domain can serve as the target domain to make
recommendations. This is much more interesting yet challenging than the first case. Consequently,
how to develop advanced models to effectively capture the complex and heterogeneous dependencies
 among different domains for accurate SBR requires more explorations.
Session-based Recommendations by Considering More User Behaviour Patterns
ğ‘†ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘ğ‘’. In addition to the basic co-occurrence or sequential behaviour patterns hidden in
session data, there are actually more types of user behaviour patterns that can be leveraged to benefit
SBR, such as repeat consumption and periodic consumption . Such kinds of behaviour
patterns are not uncommon in the real world, but are usually ignored by existing works on SBRSs.
ğ‘‚ğ‘ğ‘’ğ‘›ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ‘ . How to effectively discover and leverage more types of user behaviour patterns
to improve SBR? On one hand, the other types of patterns are less frequent and obvious than the
basic co-occurrence or sequential patterns which are thus more difficult to be precisely identified.
On the other hand, how these patterns can influence the usersâ€™ final choices on items is not very
clear. Hence, it is difficult to effectively incorporate the useful information from these patterns
while reducing noise to benefit the recommendations. Such issues are of practical significance in
real-world applications, especially in the e-commence industry, and thus require more efforts.
Session-based Recommendations with Constraints
ğ‘†ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘ğ‘’. In reality, it is not uncommon that there are some types of underlying constraints
over the items in one session. For example, in some cases, the items purchased in one session may
not be identical or similar, instead, they may complement each other , e.g., milk and bread, to
form a coherent package to satisfy a userâ€™s certain goal, e.g., breakfast. In other cases, there may be
duplicated items within a session, since a user may buy multiple copies of items in one session.
Such kinds of constraints are often ignored by existing works on SBRSs.
ğ‘‚ğ‘ğ‘’ğ‘›ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ‘ . How to generate a session with some constraints on it to better satisfy a userâ€™s purchase goal? On one hand, different users may have different interaction patterns and requirements
to be satisfied with different constraints. Therefore, it is difficult to determine which constraints
should be added to a specific user to best accomplish her goal. On the other hand, it is also challenging to jointly optimize both the added constraints and the prediction accuracy. This open issue
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
A Survey on Session-based Recommender Systems
is challenging but of practical concern, with only limited attention from the community . A
straightforward solution is to incorporate some semantic relations between items by employing a
knowledge graph into SBRSs.
Interactive Session-based Recommendations
ğ‘†ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘ğ‘’. In the real-word cases, particularly in the online shopping scenario, a session is often
generated from a continuous interactive process between a user and the shopping platform. For
example, a user may first click an item to start a session, followed by different actions on this item,
e.g., view it, add it to cart, or just skip it. By taking these different actions as different feedback from
the user, the platform can then accordingly adjust recommendation strategies for the subsequent
items. Such interactive process proceeds till to the end of the session. Though such intrinsic nature
embedded in session generation process is quite important for precisely learning the userâ€™s dynamic
preference for accurate SBR, it has been overlooked by most of the existing works on SBRSs.
ğ‘‚ğ‘ğ‘’ğ‘›ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ‘ . How to effectively model the continuous interactive process between users and the
platform for interactive SBR? This issue is critical but challenging in the area of SBRSs. In such a
case, a userâ€™s preference is revealed by her limited real-time interactions with the platforms and
usually changes over time. So, it is difficult to precisely capture the userâ€™s dynamic preferences from
limited interactions in a timely manner. Although, some researchers have proposed approaches
based on reinforcement learning to address it, the studies are still in early stage while more
and deeper explorations are needed.
Online or Streaming Session-based Recommendations
ğ‘†ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘ğ‘’. On a real-word online shopping platform, session data usually comes incrementally
in a streaming scenario. This leads to the continuous, large-volume, high-velocity nature of session
data . However, most of the existing studies on SBRSs work on the offline and static data,
which may be inconsistent with the real-world application scenario.
ğ‘‚ğ‘ğ‘’ğ‘›ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ‘ . How to effectively learn usersâ€™ dynamic preferences in an online and streaming
scenario for better SBR? This is much more challenging than the SBRSs based on offline data,
but of greater significance from the practical perspective. Specifically, it is quite challenging
to develop accurate and highly-efficient recommendation algorithms to effectively model largevolume streaming data and generate timely recommendations. Researchers tried to address this
issue with adaptively distilled exemplar replay strategy , a continuously queried and updated
non-parametric memory mechanism or a reservoir-based streaming model . More
efforts are still required for this open issue.
CONCLUSIONS
In this paper, we have conducted a systematic and extensive review of the most notable works
to date on session-based recommender systems (SBRSs). We have proposed a unified framework
to organise the existing works in this area into three sub-areas and provided a unified problem
statement for SBRS to reduce some confusions and inconsistencies in the field. We have thoroughly
analyzed the characteristics of session data and the corresponding challenges they bring for SBRSs.
We have also proposed a classification scheme for the organization and clustering of existing
approaches for SBRSs, and highlighted some critical technical details for each class of approaches.
In addition, we have discussed some of the most pressing open issues and promising directions. The
research in SBRS field is flourishing and a number of newly developed techniques and emerging
approaches keep coming. It is our hope that this survey can provide readers with a comprehensive
understanding of the key aspects, main challenges, notable progress in this area, and shed some
light on future studies.
ACM Comput. Surv., Vol. 9, No. 4, Article 39. Publication date: May 2021.
S. Wang et al.
ACKNOWLEDGMENTS
The authors would like to thank Dr. Liang Hu and Mr. Yan Zhao for their constructive suggestions on
this work. This work was supported by Australian Research Council Discovery Grants (DP180102378,
DP190101079 and FT190100734).