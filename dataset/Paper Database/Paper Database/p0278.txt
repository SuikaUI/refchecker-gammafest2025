HAL Id: hal-01267345
 
Submitted on 11 Oct 2017
HAL is a multi-disciplinary open access
archive for the deposit and dissemination of scientific research documents, whether they are published or not.
The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.
L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.
An eﬀicient acyclic contact planner for multiped robots
Steve Tonneau, Andrea del Prete, Julien Pettré, Chonhyon Park, Dinesh
Manocha, Nicolas Mansard
To cite this version:
Steve Tonneau, Andrea del Prete, Julien Pettré, Chonhyon Park, Dinesh Manocha, et al.. An eﬀicient
acyclic contact planner for multiped robots. IEEE Transactions on Robotics, 2018, 34 (3), pp.586-601.
￿10.1109/TRO.2018.2819658￿. ￿hal-01267345v3￿
An efﬁcient acyclic contact planner for multiped
Steve Tonneau, Andrea Del Prete, Member, IEEE, Julien Pettr´e, Member, IEEE, Chonhyon Park, Student
Member, IEEE, Dinesh Manocha, Member, IEEE, and Nicolas Mansard, Member, IEEE,
Abstract—We present a contact planner for complex legged
locomotion tasks: standing up, climbing stairs using a handrail,
crossing rubble and getting out of a car. The need for such a
planner was shown at the Darpa Robotics Challenge, where such
behaviors could not be demonstrated (except for egress).
Current planners suffer from their prohibitive algorithmic
complexity, because they deploy a tree of robot conﬁgurations
projected in contact with the environment.
We tackle this issue by introducing a reduction property:
the reachability condition. This condition deﬁnes a geometric
approximation of the contact manifold, which is of low dimension,
presents a Cartesian topology, and can be efﬁciently sampled
and explored. The hard contact planning problem can then be
decomposed into two sub-problems: ﬁrst, we plan a path for the
root without considering the whole-body conﬁguration, using a
sampling-based algorithm; then, we generate a discrete sequence
of whole-body conﬁgurations in static equilibrium along this path,
using a deterministic contact-selection algorithm.
The reduction breaks the algorithm complexity encountered in
previous works, resulting in the ﬁrst interactive implementation
of a contact planner (open source). While no contact planner has
yet been proposed with theoretical completeness, we empirically
show the interest of our framework: in a few seconds, with high
success rates, we generate complex contact plans for various
scenarios and two robots, HRP-2 and HyQ. These plans are
validated either in dynamic simulations, or on the real HRP-
Index Terms—Multi contact locomotion, centroidal dynamics,
Humanoid robots, legged robots, motion planning
I. INTRODUCTION
EGGED robots move by sequentially creating contacts
with the environment. After years of research, such robots
can autonomously walk on ﬂat ground, but struggle to navigate
more complex environments. Deciding where to create a
contact with its feet and possibly its hands is nontrivial, e.g.
to climb stairs using a handrail.
Most of the complexity of this problem lies in the contact
planning, i.e. the underlying decomposition of the trajectory
into contact phases where speciﬁc points of the robot body
are exerting forces on speciﬁc locations of the environment.
Tackling this complexity is the main objective of this paper.
Once the contact plan is known, efﬁcient approaches exist
to generate a dynamically feasible motion . In the speciﬁc
(and simple) case of gaited biped locomotion on ﬂat ground,
choosing the effector with which to create a contact is trivial
because walking follows a cyclic pattern (the left foot always
S. Tonneau, A. Del Prete and N. Mansard are with LAAS-CNRS /
Universit´e de Toulouse, France e-mail: ( )
J. Pettr´e is with Inria, Rennes, France
C. Park and D. Manocha are with UNC, Chapel Hill, USA
follows the right foot). Efﬁcient tools such as the capture
point can be used to compute the next contact location.
In the general case planning complex contact interactions is
extremely challenging: At any given time a contact must be
chosen between inﬁnitely many possibilities (often a combinatorial discrete choice for the effector and contact surface, and
a continuous choice for the contact location). Furthermore, a
contact choice constrains kinematically and dynamically the
possible motions, and there is no analytical way to verify
whether this choice brings the robot one step closer to the
desired goal or to a dead end, especially in the presence of
obstacles; we say that the contact manifold is foliated . The
foliation prevents the use of efﬁcient sampling-based planners
for two reasons. (i) First, each sub-manifold of the foliation
has a zero measure and cannot be directly sampled. A sample
is rather obtained by sampling a free ﬂying conﬁguration and
explicitly projecting it in contact (which is a costly numerical
operation). (ii) Second, the foliated topology turns the exploration by spreading a graph of conﬁgurations (probabilistic
road-map, rapidly exploring random trees) into an inefﬁcient
random process, where many useless nodes are sampled on
parallel sub-manifolds. The total algorithmic complexity of
classical contact planners comes from both the number of
graph nodes sampled during exploration (ii) and the cost of
the projection when sampling new conﬁgurations (i).
For this reason previous contributions having demonstrated
acyclic contact locomotion on a real robot are too computationally expensive . As a result at the DARPA Robotics
Challenge, the participants stated that except for egress, the
robots did not use multi contact strategies: they relied on
unsafe bipedal walking to climb stairs, instead of using the
provided handrails to facilitate the motion .
Our work aims at breaking the complexity of the acyclic
contact planning problem. To do so we deal sequentially
with the two main issues associated to our problem: the
null measure of the contact manifold, and the combinatorics
of the contact selection problem. First we introduce a lowdimensional space, called the contact reachable space, that
can be sampled and mapped efﬁciently to the contact manifold.
Then, given a path computed in the contact reachable space,
we propose a deterministic algorithm to generate a contact
sequence along the path. This decoupling presents pros and
cons discussed in previous related literature, summarized in
the following.
Overview of our two-stage framework. Given a path request between start and goal positions (left image), P1 is the problem of computing a guide
path in the space of equilibrium feasible root conﬁgurations. We achieve this by deﬁning a geometric condition, the reachability condition (abstracted with the
transparent cylinders on the middle image). P2 is then the problem of extending the path into a discrete sequence of contact conﬁgurations using an iterative
algorithm (right image).
A. State of the art
Additionally to robotics, acyclic motion planning is also
a problem of interest in neurosciences, biomechanics, and
virtual character animation. Early contributions in the latter
ﬁeld rely on local adaptation of motion graphs , or ad-hoc
construction of locomotion controllers . These approaches
are by deﬁnition not able to discover complex behaviors in
unforeseen contexts.
The issue of planning acyclic contacts was ﬁrst completely
described by Bretl . The issue requires the simultaneous
handling of two sub-problems, P1: planning a guide path for
the root of the robot in SE(3); and P2: planning a discrete
sequence of equilibrium conﬁgurations along the path. A third
nontrivial problem, P3, then consists in interpolating a complete motion between two postures of the contact sequence. A
key issue is to avoid combinatorial explosion when considering
at the same time the possible contacts and the potential paths.
Bretl’s seminal paper proposes a ﬁrst effective algorithm,
able to handle simple situations (such as climbing scenarios),
but not applicable to arbitrary environments. Following it,
several papers have applied this approach in speciﬁc situations,
limiting the combinatorial by imposing a ﬁxed set of possible
contacts , .
Most of the papers that followed the work of Bretl have
explored alternative formulations to handle the combinatorics.
Two main directions have been explored. On the one hand,
local optimization of both the root trajectory P1 and the
contact positions P2 has been used, to trade the combinatorial
aspect of the complete problem for a differential complexity,
at the cost of local convergence . A complete example of
the potential offered by such approaches was proposed by 
and successfully applied to a real robot . To get reasonable
computation times, the method uses a simpliﬁed dynamic
model for the avatar. Still, the method is far from real-time
(about 1 minute of computation for 20 contacts). A similar
approach has been considered for manipulation by . Deits
and Tedrake proposed to solve contact planning globally as
a mixed-integer problem, but only cyclic, bipedal locomotion
is considered, and equilibrium is not considered . Dai et
al. extended the work of Posa et al. to discover
the contact sequence for landing motions, but need to specify
the contacts manually for complex interactions. In addition to
the limits of the current implementations, optimization-based
approaches only converge locally.
On the other hand, the two problems P1 and P2 might
be decoupled to reduce the complexity. The feasibility and
interest of the decoupling has been shown by Escande et
al. who manually set up a rough root guide path (i.e.
an ad-hoc solution to P1), and then addressed P2 as the
combinatorial computation of a feasible contact sequence in
the neighborhood of the guide. A solution could then be
found, but at the cost of prohibitive computation times (up
to several hours) for constraining scenarios. This approach
is suboptimal because the quality of the motion depends
on the quality of the guide path. Bouyarmane et al.
precisely focused on automatically computing a guide path
with guarantees of equilibrium feasibility, by extending key
frames of the path into whole-body conﬁgurations in static
equilibrium. Randomly-sampled conﬁgurations are projected
to the contact manifold using an inverse-kinematics solver, a
computationally-expensive process (about 15 minutes to compute a guide path in the examples presented). Moreover this
explicit projection is insufﬁcient to guarantee the feasibility
between two key postures in the path. Chung and Khatib 
also proposed a decoupled approach, with a planning phase
based on the reachable workspace of the robot limbs, used
to judge the ability to make contact with a discretized environment. This planning phase does not account for collisions,
implying that re-planning is required in case of failure. In
highly-constraining cases such as the car egress scenario we
address, we believe that including collision constraints in the
planning is a requirement , . A limitation with these
approaches (including our method) is that the existing planners
only address a subset of the problem, because their ability
to ﬁnd a solution depends on the existence of quasi-static
equilibrium conﬁgurations along a feasible path, which is too
restrictive in the general case. Other contributions to legged
locomotion, not directly related to multi-contact motion, are
worth mentioning, as they rely on a similar decomposition
of the problem. First a discrete sequence of contact sets is
planned (at the so-called footstep planning phase), using a
low-dimensional abstraction of the robot to account for its
kinematic constraints , . In , a “pose certiﬁcate”
is obtained by generating a whole-body conﬁguration for each
set through inverse kinematics, as done in P2. Then a motion is
generated along the sequence through the use of optimization
techniques. The solutions proposed are designed for cyclic
locomotion in quasi-ﬂat scenarios, where the support polygon
is a relevant method for equilibrium checks. They thus cannot
be generalized to multi contact locomotion. However, some
contributions on speciﬁc parts of the problem could be applied
directly in our case. For instance, learning “terrain costs”,
based on expert knowledge as proposed in , could deﬁne
good heuristics to compute the next contact location for an
effector. Although we did not try to include such formulation
in this paper, it would be straightforward to integrate such
heuristic in our planner.
As far as robotics applications are concerned, none of
the existing multi-contact planners is interactive1. However,
recent contributions to the interpolation between contact poses
(problem P3) have brought promising preliminary solutions
 , , , . In particular, our algorithm proposed in
 is interactive. Therefore, a planner capable of efﬁciently
solving P1 and P2 could outperform all existing planners if
coupled with an interpolation method solving P3. The main
contribution of this paper is exactly this planner.
B. Contributions
Our solution belongs to the class of decoupled approaches,
i.e. we propose speciﬁc algorithms to efﬁciently solve both
P1 and P2 while relying on state-of-the-art solution to P3
to obtain the whole movement. Our main contribution is the
deﬁnition of a reduction property, the reachability condition.
Compared to previous approaches, our solution has two
main novelties:
Regarding P1, we propose a fast guide path planning algorithm. The key to its efﬁciency is that it does not sample
directly the contact manifold, but an approximation of the
contact reachable space. The contact reachable space is a
low-dimensional space for which there exists a mapping to
the contact manifold.
Regarding P2, we propose a fast method to extend a contact
reachable path into a sequence of whole-body conﬁgurations
in static equilibrium. This requires the explicit computation of
contact conﬁgurations. It is guided by dedicated heuristics that
quickly synthesize feasible conﬁgurations.
The reachability condition is the key to the strict separation between P1 and P2, hence to the low complexity of
our planner. However the reduction can result in failures.
We demonstrate empirically its interest, through an extensive
experimental validation with real robot models on a dynamic
simulator. The high success rate and low computation times
we obtain allow us to plan (and re-plan upon failure) multicontact sequences at interactive rates.
To further demonstrate the validity of our approach, we
show that the generated contact plans can be successfully
executed (problem P3), either in simulation or on the real
HRP-2 robot. For HRP-2, we detail the complete computation
times to address sequentially the three problems, and compare
them to related work, demonstrating that our method is orders
of magnitude faster.
discussion
consequences of our approach in terms of efﬁciency and
1We deﬁne an interactive planner as one for which the time to plan a motion
is in the same order of magnitude as the time to execute it. For instance,
computing one contact change should take about one or two seconds.
completeness regarding the contact planning problem.
Comparison with our previous work: The present paper is
an extension of our ISRR conference paper . As such, our
solution to address P1 and P2 is the same motion planner
as the one presented at ISRR (reformulated in Section IV
and V). However three important novelties have been added to
the planner: the pseudo-code of the algorithm (Section V-B2),
a novel criterion for static equilibrium (Section VI), and the
release of the source code of the planner (Section VII).
The other novelty of the paper is a rigorous experimental
validation of the approach on actual robot models (Section VIII). To validate our contact plans we introduced a
complete framework for multi-contact motion synthesis. This
framework additionally comprises an interpolation method
to solve the problem P3, based on a reformulation of our
previous work . Our solution to P3 allows us to verify that
the synthesized motions are physically consistent, using our
implementation of a state-of-the-art simulation algorithm .
These aspects of the framework are presented in details in the
paper, but are not novel per se. The novelty lies in the complete
validation of the contact planner with real robot models, for
which the planning is much harder with respect to the avatars
used in , because of more restrictive kinematic constraints.
II. OVERVIEW
Figure 1 illustrates our work ﬂow. P1 and P2 are addressed
sequentially: From a given problem (a) we ﬁrst plan a root
guide path (b), before extending it into a sequence of static
equilibrium conﬁgurations (c). In the case where step (c)
fails, our framework invalidates the computed guide path, and
restarts the planning from (b).
A. Computation of a guide path — P1 (Section IV)
We ﬁrst consider the problem of planning a root guide path
(Figure 1–P1). The dimension of the path is equal to the
number of degrees of freedom (DoFs) of the root of the robot.
Similarly to previous work the path must be equilibrium
feasible: there must exist a joint conﬁguration that results in
static equilibrium for each root conﬁguration2. Previous works
verify equilibrium feasibility by explicitly computing such
a conﬁguration. We preserve the low dimensionality of the
problem by approximating equilibrium feasibility with contact
reachability, illustrated in the following.
An intuitive description of contact reachable conﬁgurations
is “close, but not too close” to the environment: close, because
a contact surface must be partially included in the reachable
workspace of the robot to allow contact creation; not too close,
because the robot must avoid collision. More precisely, a root
conﬁguration is contact reachable if the root scaled by a userdeﬁned factor s ≥1 is not in collision (Figure 2 - red shape),
while the reachable workspace is in collision (Figure 2 - green
shapes). To plan a root path, we then use an RRT planner
2Enforcing static equilibrium is a classical, conservative approach to reduce
the search space and considering states with non-zero accelerations and
velocities, which can’t be connected trivially. This does not mean that the
ﬁnal motion will necessary be quasi-static.
Fig. 2. The reachability condition is veriﬁed by the right conﬁguration: the
trunk (red) is free of collisions while the limbs reachable workspace (green)
intersect the environment.
where, instead of checking collision to validate a conﬁguration,
we verify the reachability condition.
In the remainder of this paper, we use the terms contact
reachable and equilibrium feasible to qualify either a root or
a whole-body conﬁguration, or a set of such conﬁgurations.
B. Generating a discrete sequence of contact conﬁgurations
— P2 (Section V)
The second stage extends the guide path into a sequence
of contact conﬁgurations (Figure 1–P2). To achieve this the
root path is ﬁrst decomposed into a sequence of discrete
root conﬁgurations, according to a user-deﬁned discretization
step. Each root conﬁguration is then extended into a wholebody conﬁguration in static equilibrium. The algorithm thus
proceeds iteratively, starting from the whole-body initial con-
ﬁguration of the robot. It takes advantage of the fact that
each root conﬁguration is ﬁxed to generate the contact by
considering each limb individually.
III. NOTATION AND DEFINITIONS
A vector x is denoted with a bold lower-case letter. A matrix
A is denoted with a bold upper-case letter. A set C is denoted
with an upper-case italic letter. Scalar variables and functions
are denoted with lower-case italic letters, such as r or f(x).
A robot is a kinematic tree R composed of: a root R0, and
l limbs Rk, 1 ≤k ≤l, attached to the root. The root has
r ≥6 DoFs: for instance, HRP-2 has two extra DoFs in the
torso, such that we have r = 8. Thus R is fully described by
a conﬁguration (a vector of joint values) q ∈Rr+n, with n
the number of joint DoFs. q is decomposed as follows:
• qk is a conﬁguration of the limb Rk;
• qk is a vector of joint values of R not related to Rk. We
deﬁne for convenience q = qk ⊕qk;
• q0 ∈Rr is the world coordinates vector of R0.
We then deﬁne a set of 3d volumes W i, 0 ≤i ≤l, each
attached to one joint of the root, such that W i(q0) describes
the world position of W i for the root conﬁguration q0.
W 0 is a volume encompassing R0 (Figure 3), or equal to it3.
W k is the reachable workspace of a limb Rk:
x ∈R3 : ∃qk ∈Ck
j.lim, pk(qk) = x
3W 0 is typically a low-polygonal bounding shape of R0 for performance.
Reachable workspace and torso bounding box of HyQ. Each green
shape represent a reachable workspace W k of a limb. The red shape is W 0.
where pk denotes the end-effector position (in the root frame)
of Rk (translation only) for q0 = 0 being the null displacement, and Ck
j.lim is the space of admissible limb joint
conﬁgurations. We also deﬁne W = Sl
The environment O is deﬁned as the union of the obstacles
Oi that it contains. O is represented as a polygon soup (or
mesh), where the normal of each surface is known. No further
requirement is needed by our approach. In this work, we
assume the environment is fully known. State uncertainty is
out of the scope of the paper.
Finally we deﬁne some relevant subsets of the conﬁguration
space C. CContact is the set of whole body-conﬁgurations in
contact and collision-free. Ck
Contact ⊂CContact is the set of
whole body-conﬁgurations where at least Rk is in contact.
CEquil ⊂CContact is the set of whole body-conﬁgurations
in static equilibrium and collision-free.
For any set CX, we deﬁne C0
q0, ∃q0 : q0 ⊕q0 ∈CX
IV. ROOT PATH PLANNING IN THE CONTACT REACHABLE
During the root path planning we only consider the root
conﬁguration q0 deﬁned in the previous Section, as well as
the environment O.
Given start and goal conﬁgurations, we aim at computing a
guide path q0(t) : −→Rr verifying:
∀t ∈ , q0(t) ∈C0
This means that any root conﬁguration must be extended into
a whole-body, static equilibrium conﬁguration. C0
Equil cannot
be described analytically.
The main hypothesis of this work is that for a large
variety of locomotion tasks, we can deﬁne a space C0
Contact, such that
∀t ∈ , q0(t) ∈C0
Reach ⇒q0(t) ∈C0
We call C0
Reach the contact reachable workspace, and detail its
construction in the following. The validity of this hypothesis
is discussed in depth in Section IX.
A. Conditions for contact reachability
The contact reachable workspace is deﬁned as a compromise between two necessary and a sufﬁcient condition for
contact creation.
necessary conditions: For a contact to be possible, an obstacle Oi ⊂O necessarily intersects the reachable workspace
W(q0) of the robot. Also the torso of the robot W 0(q0) must
necessarily be collision-free. Therefore we can deﬁne an outer
approximation C0
Contact as:
Nec = {q0 : W(q0) ∩O ̸= ∅and W 0(q0) ∩O = ∅}
sufﬁcient condition: Similarly we can deﬁne an inner
approximation C0
Contact by considering a bounding
volume BSuf encompassing the whole robot in a given pose,
except for the effector surfaces.
Suf = {q0 : W(q0) ∩O ̸= ∅and BSuf(q0) ∩O = ∅}
B. The compromising reachability condition
The ideal shape B∗, W 0 ⊂B∗⊂BSuf would deﬁne
a necessary and sufﬁcient condition for contact creation. It
would guarantee that any root conﬁguration q0 ∈B∗would
result in a contact conﬁguration, while any q0 /∈B∗could not.
To our knowledge B∗has no explicit deﬁnition. Therefore, we
approximate B∗to deﬁne the contact reachable space C0
We deﬁne W 0
s as the volume W 0 subject to a scaling
transformation by a factor s ∈R+. We then consider the
s = {q0 : W(q0) ∩O ̸= ∅and W 0
s (q0) ∩O = ∅}
The parametrization of s deﬁnes a trade-off: If s = 1, then
s = W 0, such that C0
Nec. By increasing s, the condition
can become sufﬁcient, but less and less necessary. Eq. 5 thus
deﬁnes the reachability condition. We ﬁx a value s∗for s and
Reach = C0
s∗. The computation of s∗is detailed in
Section VIII-C1. In Appendix A, we give a generic method to
compute the W volumes appearing in the deﬁnition of C0
C. Computing the guide path in C0
Reach can be sampled efﬁciently thanks to Eq. 5, and can
thus be used with any standard motion planner. Our current
implementation uses the Bi-RRT planner provided by the
HPP software . Our implementation is exactly the same
as the pseudo-code of the original planner (which does not
detail the conﬁguration validation method). With respect to a
“classic” implementation, the only difference is that instead
of validating a conﬁguration using collision detection, we
validate it with the reachability condition.
This Section has presented a guide path planner for the
geometric root of a robot, implemented as a low-dimensional
sampling-based algorithm. Given start and goal conﬁgurations,
it outputs a continuous path for the robot’s root.
V. FROM A GUIDE PATH TO A DISCRETE SEQUENCE OF
CONTACT CONFIGURATIONS (P2)
In the second phase, we compute a discrete sequence
of static equilibrium conﬁgurations Q0 given a root path
q0(t) : −→C0
Reach. This contact planner uses a contact
generator, used to generate static equilibrium conﬁgurations.
We ﬁrst describe the contact planning algorithm, before describing the contact generator.
A. Deﬁnition of a contact sequence
In previous contributions , a contact plan is deﬁned as
a sequence of quasi-static equilibrium conﬁgurations for each
contact phase. For instance, a walk cycle would be described
by three key conﬁgurations: a double-support conﬁguration,
a single-support conﬁguration (a contact is broken), and another double-support conﬁguration (a contact is created). Our
deﬁnition of contact plan differs: between two consecutive
conﬁgurations we allow both a contact break and a contact
creation—if they are on the same effector. In the previous
example, our contact plan would simply consist of the two
double-support conﬁgurations. This representation is sufﬁcient
to describe all the contact phases, because the single support
phase is implicitely described. Furthermore it removes the
need to compute a single-support quasi-static conﬁguration
as in the example. Indeed, there might be a case where
no quasi-static solution exists for the single support phase
(because of the environment), but there exists a dynamic
motion connecting the two double support states. Such motion
will be computed by our framework, because the quasi-static
constraint is only required at the contact planning phase; as
shown in the companion video, and explained in Appendix C,
our framework is able to produce dynamic motions.
B. Contact planning algorithm
Starting from an initial whole-body conﬁguration, we compute a sequence of whole-body conﬁgurations Q0 along the
root path q0(t). We ﬁrst give an intuition of the algorithm,
before providing its complete pseudo-code.
1) Algorithm overview: First, the root path q0(t) is discretized into a sequence of j key conﬁgurations:
i ; ..., q0
j−1 are the start and goal conﬁgurations.
j depends on a user-deﬁned variable, called the discretization
step. It corresponds to the ratio between the length of the path
q0(t)4, and the number of conﬁgurations selected along it to
create the contact conﬁgurations. Each root conﬁguration of
Q0 is then extended into a whole-body conﬁguration such that:
• At most one contact is not maintained (broken) between
two consecutive conﬁgurations.
• At most one contact is added between two consecutive
conﬁgurations.
• Each conﬁguration is in static equilibrium.
• Each conﬁguration is collision-free.
4The length of the path is computed as the weighted 6D Euclidian distance
travelled along the it, with a weight of 0.7 for the translation part, and 0.3
for the orientation part.
Fig. 4. Contacts are maintained if joint limits and collisions constraints are
respected (2). They are broken otherwise(3,4). The green line represents the
root path. The blurred character represents the previous contact conﬁguration.
a) Maintaining a contact in the sequence: If kinematically possible, a limb in contact at step i−1 remains in contact
at step i (Figure 4). Otherwise the contact is broken and a
collision-free conﬁguration is assigned to the limb. If two or
more contacts can’t be maintained between two consecutive
conﬁgurations, one or more intermediate conﬁgurations are
added, to ensure that at most one contact is broken between
two sequential conﬁgurations.
b) Creating contacts: Contacts are created using a FIFO
approach: we try ﬁrst to create a contact with the limb that
has been contact-free the longest. If the contact creation does
not succeeds, the limb is pushed on top of the queue, and
will only be tried again after the others.
2) Pseudo-code of the Algorithm:
First, we deﬁne an
abstract structure State, that describes a contact conﬁguration.
The use of queues allows a FIFO approach regarding the order
in which contacts are tested: we try to replace older contacts
ﬁrst when necessary. Thus the algorithm is deterministic even
though it can handle acyclic motions.
S t r u c t
C o n f i g u r a t i o n
C o n f i g u r a t i o n
E f f e c t o r
p o s i t i o n
c o o r d i n a t e s
v e c t o r 6
S t r u c t
l o c a t i o n
C o n f i g u r a t i o n
c o n t a c t
queue<Limb> freeLimbs ;
c o n t a c t
queue<Limb> contactLimbs ;
From the start conﬁguration, given as an input by the user,
we create the initial state s0. Algorithm 1 is then called with
s0, as well as the discretized path Q0, as input parameters.
At each step, GENFULLBODY is called with the previous
state as a parameter, as well as a new root conﬁguration.
GENFULLBODY returns a new contact conﬁguration, if it
succeeded in computing a conﬁguration with only one contact
Algorithm 1 Discretization of a path
1: function INTERPOLATE(s0,Q0, MAX TRIES)
list <State> states = [s0]
nb fail = 0
i = 1; /*Current index in the list*/
while i < length(Q0) do
State pState = last element(states)
State s = GENFULLBODY(pState, Q0[i])
if s! = NULL then
nb fail = 0
nb fail+ = 1
if nb fail == MAX TRIES then
return FAILURE
s =INTERMEDIATECONTACTSTATE(pState)
push back(states, s)
return states
Algorithm 2 Full body contact generation method
1: function GENFULLBODY(pState,q0)
State newState
newState.q0 = q0
newState.freeLimbs = pState.freeLimbs
/*First try to maintain previous contacts*/
nbContactsBroken = 0
for each Limb k in pState.contactLimbs do
if !MAINTAINCONTACT(pState, q0, k) then
nbContactsBroken+ = 1
if nbContactsBroken > 1 then
return NULL
push(newState.freeLimbs, k)
push(newState.contactLimbs, k)
for each Limb k in pState.freeLimbs do
if GENERATECONTACT(q0, k) then
push(newState.contactLimbs, k)
remove(newState.freeLimbs, k)
return newState
if ISINSTATICEQUILIBRIUM(newState) then
return newState
return NULL
switch occurring. Otherwise, the method INTERMEDIATE-
CONTACTSTATE is called. It repositions one end effector
(either a free limb, or the oldest active contact) towards a
new contact position if possible. This repositioning allows to
increase the odds that the contact can be maintained at the next
step. Algorithm 2 gives the pseudo code for GENFULLBODY.
The method MAINTAINCONTACT(pState, q0, k) performs
inverse kinematics to reach the previous contact position for
the Limb. If it succeeds, the new limb conﬁguration is assigned
to k. If it fails, a random collision free conﬁguration is
assigned to k.
Algorithm 3 Adds or repositions a contact for one limb
1: function INTERMEDIATECONTACTSTATE(state)
while i < length(states.freeLimbs) do
Limb k = pop(states.freeLimbs)
if GENERATECONTACT(state.q0, k) then
push(newState.contactLimbs, k)
push(states.freeLimbs, k)
while i < length(states.contactLimbs) do
Limb k = pop(states.contactLimbs)
Limb copy = k
if GENERATECONTACT(state.q0, k) then
push(newState.contactLimbs, k)
push(newState.contactLimbs, copy)
/*Fails if impossible to relocate any effector*/
return FAILURE
The method ISINSTATICEQUILIBRIUM returns whether a
given state is in static equilibrium.
The pseudo code for the method INTERMEDIATECONTACT-
STATE is given by Algorithm 3.
GENERATECONTACT(q0, k) is a call to the contact generator presented in the following Section V-C. It generates
a contact conﬁguration in static equilibrium, and assigns
the corresponding conﬁguration to k. If it fails, k remains
unchanged if it is collision free, otherwise it is assigned a
random collision free conﬁguration.
C. Contact generator
Given a conﬁguration of the root and the list of effectors
that should be in contact, the contact generator computes the
conﬁguration of the limbs such that contacts are properly
satisﬁed and the robot is in static equilibrium:
qk −→qk, (qk ⊕qk) ∈CEquil and qk ∈Ck
In previous works , , the generation of contact is
typically implemented by randomly sampling conﬁgurations
and projecting the whole robot conﬁguration onto the closest
surfaces with an inverse kinematics solver. In case of failure
of the projection, the process would randomly iterate.
We propose two modiﬁcations of this general algorithm
principle. First our contact generator handles each limb Rk
independently. By handling each limb separately, we reduce
the complexity of the generation of contact conﬁgurations.
This is made possible thanks to the reachability condition
in P1 that produces a root path that we can afford not to
modify in P2, and because we allow both a contact break and
a contact creation between two consecutive conﬁgurations of
the contact sequence. Second, we rely on off-line generation
of conﬁguration candidates.
We deﬁne Cǫ
Contact ⊃CContact as the set of conﬁgurations
such that the minimum 3D distance between an effector and
an obstacle is less than ǫ ∈R. We then apply the following
1) Generate off-line N valid sample limb conﬁgurations
i , 0 ≤i < N (We choose N = 104);
2) Using the end-effector positions p(qk
i ) as indices, store
each sample in an octree data structure;
3) At runtime, when contact creation is required, intersect
the octree and the environment5 to retrieve the list of
samples S ⊂Cǫ
Contact close to contact (Figure 5 (b)
4) Use a user-deﬁned heuristic h to sort S;
5) If S is empty, stop (failure). Else select the ﬁrst con-
ﬁguration of S. Project it onto contact using inverse
kinematics. (Figure 5 (d) and (e));
6) If Eq. 6 is veriﬁed, stop (success). Otherwise remove
the element from S and go to step 5.
Because the distance ǫ does not account for the variation
in orientation, several samples of Cǫ
Contact may turn out to
be unfeasible at the time of projection. One could consider
additionally ﬁltering Cǫ
Contact based on the orientation with
respect to the obstacle normal, but in our experience we did
not notice any signiﬁcant improvement in the computational
performances of the planner, so we do not perform this
additional step.
In all our experiments, the heuristic h is implemented
as a variation of a manipulability-based heuristic . The
manipulability is a real number that quantiﬁes how “good” a
conﬁguration is to perform a given task, based on the analysis
of the Jacobian matrix. With such heuristics, a conﬁguration
can be chosen because it is far from singularities, and thus
allows mobility in all directions. On the contrary, it can be
chosen because it is particularly efﬁcient to exert a force in
a desired direction. In our experiments, the former solution is
usually chosen for computing leg contacts, while the latter is
used for computing hand contacts. We recall the manipulability
measure and its derivatives in Appendix B.
Finally, to verify that a conﬁguration is in static equilibrium,
we use a new robust LP formulation. It replaces the computationally inefﬁcient double description approach used in our
previous work , and presented in the following Section VI.
VI. A CRITERION FOR ROBUST STATIC EQUILIBRIUM
We ﬁrst give a linear program (LP) that veriﬁes whether a
contact conﬁguration allows for static equilibrium. This LP is
the same that was proposed in . From this formulation
we derive a new LP that quantiﬁes the robustness of the
equilibrium to uncertainties in the contact forces. In turn, from
this value we can either choose the most robust candidate, or
set a threshold on the required robustness.
5this operation is achieved natively by the fcl library 
Generation of a contact conﬁguration for the right leg of HRP-2. (a): Selection of reachable obstacles. (b): Entries of the limb samples database
(with N = 4). (c): With a proximity query between the octree database and the obstacles, conﬁgurations too far from obstacles are discarded. (d): The best
candidate according to a user-deﬁned heuristic h is chosen. (e): The ﬁnal contact is achieved using inverse kinematics.
1) Conditions for static equilibrium: We ﬁrst deﬁne the
variables of the problem, for e contact points, expressed in
world coordinates:
• c ∈R3 is the robot center of mass (COM);
• m ∈R is the robot mass;
• g = [0, 0, −9.81]T is the gravity acceleration;
• µ is the friction coefﬁcient;
• for the i-th contact point 1 ≤i ≤e:
– pi is the contact position;
– fi is the force applied at pi;
– ni, γi1, γi2 form a local Cartesian coordinate system
centered at pi. ni is aligned with the contact surface
normal, and the γis are tangent vectors.
According to Coulomb’s law, the non-slipping condition is
veriﬁed if all the contact forces lie in the friction cone deﬁned
by the surface. As classically done, we linearize the friction
cone in a conservative fashion with a pyramid included in it,
described by four generating rays of unit length. We choose
for instance:
ni + µγi1
Any force belonging to the linearized cone can thus be
expressed as a positive combination of its four generating rays.
∃βi ∈R4 : βi ≥0 and fi = Viβi,
where βi contains the coefﬁcients of the cone generators. We
can then stack all the constraints to obtain:
∃β ∈R4e, β ≥0 and f = Vβ,
where V = diag({V1, . . . , Ve}), and f = (f0, ..., fe).
From the Newton-Euler equations, to be in static equilibrium the contact forces have to compensate the gravitational
where ˆx ∈R3×3 is the cross-product matrix associated to x.
If there exists a β∗satisfying (7) and (8), it means that the
conﬁguration is in static equilibrium. The problem can then
be formulated as an LP:
subject to
Gβ = Dc + d
2) Formulation of a robust LP: Let b0 ∈R be a scalar
value. We now deﬁne the following LP:
β ∈R4e, b0 ∈R
subject to
Gβ = Dc + d
We observe that if b0 is positive then (9) admits a solution,
and b0 is proportional to the minimum distance of the contact
forces to the boundaries of the friction cones. If b0 is negative,
the conﬁguration is not in static equilibrium, and b0 indicates
“how far” from equilibrium the conﬁguration is. We thus use
b0 as a measure of robustness. A simple approach to robustness
consists in choosing a smaller friction coefﬁcient, to constrain
the forces to lie away from the boundaries of the real cone.
However, this would result in a small safety margin for forces
of low magnitude, and an excessively large safety margin for
large forces as the boundaries grow more and more apart.
In comparison, our margin b0 is constant, and provides a
helpful mean to compare the robustness of different contact
conﬁgurations.
In our implementation, rather than solving directly (10),
we solve an equivalent problem of smaller dimension that we
get by taking the dual of (10) and eliminating the Lagrange
multipliers associated to the inequality constraints:
−(Dc + d)T ν
subject to
1T GT ν = 1
Indeed, from Slater’s conditions , we know that the
optimal values of an LP and its dual are equal. Therefore
the optimal value ν∗gives the optimal value b∗
0 through the
equality b∗
0 = (Dc + d)T ν∗.
VII. SOURCE CODE OF OUR PLANNER
Our planner is implemented using the Humanoid Path
Planner (HPP) software, introduced in . HPP is an open
source motion planning framework developed by the Gepetto
team at LAAS-CNRS. HPP implements the standard tools
and algorithms used in motion planning, such as the Bi-RRT
planner from which RB-RRT is derived.
The robot models used in our experiments are described
using the standard urdf ﬁle format, compatible with HPP.
implementation
downloaded and compiled by following the instructions on
 
html?branch=rbprm.
VIII. RESULTS
In this section we present some of the results obtained
with our planner. The complete sequences are shown in the
companion video. Speciﬁcally, we demonstrate the planner for
two legged robots, in a large variety of environments: the
humanoid HRP-2 and the quadruped HyQ.
Our contact plans are then interpolated with a dedicated
solution to the interpolation problem P3. This allows us to
validate the obtained motions in a dynamic simulator. This
validation is an important contribution as it increases the
conﬁdence that the contact plans we compute can effectively
result in feasible motions on the real robot. One motion is
demonstrated on the real HRP-2 robot.
At the end of this section, we discuss the role of the
parameters of our framework. We then provide the interactive
computation times obtained in each case. We also compare the
times obtained with HRP-2 with respect to previous works.
A. Experimental validation of the contact plans
To generate continuous movements from our contact plans
we used either the framework proposed in , or our own
implementation of a P3 solver (Appendix C). The resulting
movements have been validated either on the real HRP-2
robot (details can be found in ), or with our dynamic
simulator, based on a state-of-the-art algorithm . In the
simulations we controlled the robot with a standard inversedynamics controller . The code source of the simulator is
available at inv
dyn/releases/tag/rbprm. This controller tries to follow the given
whole-body trajectories, giving higher priority to the centerof-mass and end-effectors tracking with respect to the joint
tracking. The controller also makes sure that the resulting
contact forces lie inside the speciﬁed friction cones (we used a
friction coefﬁcient of 0.3), and that the joint position, velocity
and torque limits are satisﬁed. The companion video shows
the obtained motions.
B. Description of the scenarios
In all the scenarios considered, the formulation of the
problem is always the same: a start and goal root conﬁguration are provided as input (except in the stair climbing
scenario where the start whole body conﬁguration is given).
The framework computes the initial contact conﬁguration, and
outputs a sequence of contact conﬁgurations connecting it to
HRP-2 in the standing scenario.
Selected frames from the car egress scenario.
the goal. In each scenario we detail the contacts involved and
the heuristics chosen (either hEFORT, hvel or hw, all of which
are deﬁned in the Appendix B).
1) HRP-2 – Standing up (Figure 6): From a bent conﬁguration, the robot has to stand up using a wall as support, and
climbing a 25-cm high step.
Contacts involved: All (both feet and hands).
Heuristics: hw for the feet, hEFORT for the hands.
2) HRP-2 – Car egress (Figure 7): In this scenario inspired
from the DRC car egress HRP-2 has to step out of a car.
Contacts involved: All (both feet and hands).
Heuristics: hw.
3) HRP-2 – Staircase with high steps (Figure 8): The goal
is to climb three 15-cm high steps.
Contacts involved: Feet and right arm.
Heuristics: The manipulability hw is chosen for the feet;
hEFORT is chosen for the right arm.
4) HyQ – DRC-style rubble (Figure 9): The quadruped
robot must cross a rubble composed of bricks rotated at
different angles and directions.
Contacts involved: All (the 4 legs).
Heuristics: hw for all legs. The robustness threshold b0 is set
HRP-2 in the stair climbing scenario.
Robust crossing of rubbles by HyQ.
HyQ crossing a narrow bridge.
5) HyQ – Obstacle race (Figure 10 and 11): In this long
scene, HyQ has to cross a 55-cm large hole, followed by a
narrow “bridge”, only 25-cm large.
Contacts involved: All (the 4 legs).
Heuristics: hw for all legs. The robustness threshold b0 is set
6) HRP-2 – Path re-planning (Figure 12): In this long
scene, HRP-2 plans a path through several obstacles. The
scene is edited during the execution of the motion: a stair
is added, some stepping stones are removed, and part of the
ﬁnal staircase is deleted. All these modiﬁcations require replanning.
Contacts involved: Feet and the right arm.
Heuristics: hw for all legs. hEFORT for the right arm. The
robustness threshold is set to 2.
Crossing a hole contact sequence for HyQ.
HRP-2 in the re-planning scenario. After the red step stones are
removed, a new sequence of contacts is re-planned. Hand contacts are not
presented here for readability.
Value of s
Sensitivity
Speciﬁcity
SENSITIVITY AND SPECIFICITY VALUES OF THE REACHABILITY
CONDITION, DEPENDING ON THE SCALING VALUE s OF W 0.
C. Role of the main parameters
We discuss the factors that inﬂuence the outcome of our
planner: the root scaling factor s (Section IV-B), the heuristics
for contact generation (Appendix B), and lastly, the discretization step for the guide path. The appropriate value for these
parameters is computed empirically based on use-case analysis
or trials and errors.
1) Choosing the scaling factor s: For several values of
s, we generated 10000 conﬁgurations. We then computed
the sensitivity and speciﬁcity of the reachability condition.
In this context, the sensitivity refers to the percentage of
conﬁgurations in C0
Reach, effectively belonging to C0
If a sampled conﬁguration is in C0
Reach, but our method is
unable to generate a contact conﬁguration from it, as a result
the sensitivity decreases. The sensitivity thus illustrates the
conﬁdence we have that any conﬁguration in C0
Reach will
effectively lead to a contact conﬁguration. Conversely, the
speciﬁcity refers to the percentage of conﬁgurations not in
Reach, effectively not belonging to C0
Contact. If a sampled
conﬁguration is not in C0
Reach, but our method is able to
generate a contact conﬁguration from it, as a result the speci-
ﬁcity decreases. The speciﬁcity thus illustrates the conﬁdence
we have that all conﬁgurations that allow contact creation
belong to C0
Reach (or informally, the conﬁdence that we are
not missing valid solutions). We thus look for a compromise
between sensitivity and speciﬁcity.
The obtained results for HRP-2 are shown in Table I,
averaged over all scenes (except for the car egress: in this
scenario, statistical tests are not really conclusive since we
are only interested in a small area of the environment).
As it can be expected, the scaling results in a high increase
of the sensitivity, with a decrease of the speciﬁcity. For HRP-2
we decided to set s∗= 1.2.
2) Choosing the heuristics: In our conference paper ,
the computed motions were generated using the EFORT
heuristic. EFORT is designed for tasks requiring large magnitude contact forces (such as pushing / pulling / climbing). In
locomotion tasks, such as the stair scenario, one issue with
EFORT is that it tends to generate conﬁgurations close to
singularities (and joint limits). While this did not signiﬁcantly
impact the generation of the plan, the resulting interpolation
turned out to be harder. For this reason, we prefer to use our
manipulability-based heuristic for the legs of the robot, but we
still use EFORT for the arms, which results in fewer contact
repositionings.
3) Discretization of the guide path: The discretization step
is a user-deﬁned, ﬁxed parameter. The step has an inﬂuence
Path planning success rate
PERCENTAGE OF SUCCESSFUL COMPLETE CONTACT PLANNING RATES FOR
EACH SCENARIO, ROUNDED TO THE FIRST DECIMAL.
Equilibrium
success rate
Equilibrium
High stairs
Standing up
Car egress
Obstacle race
SUCCESS RATES OBTAINED FOR THE GENERATION OF STATIC
EQUILIBRIUM CONTACT CONFIGURATIONS FOR EACH SCENARIO,
ROUNDED TO THE FIRST DECIMAL. COLUMN 1 INDICATES INDICATES THE
RATE OF CONTACT GENERATION THAT SUCCEEDED. IN THE CASES WHERE
THE GENERATION FAILS, IT CAN BE EITHER A KINEMATIC ISSUE (COLUMN
2), OR BECAUSE NO CONTACT CONFIGURATION LED TO A STATIC
EQUILIBRIUM CONFIGURATION (COLUMN 3). NOTE THAT A FAILURE IN
THE CONTACT GENERATION IS NOT EQUIVALENT TO A FAILURE OF THE
CONTACT PLANNING ALGORITHM.
on the output of the planner: if too large steps are taken, the
planner may fail since we impose the constraint that only one
contact change might occur between two consecutive steps. On
the other hand, a small step will not impact the success rate
of the planner, but may generate unnecessary states. In most
scenarios the torso of HRP-2 moves about 15 cm between two
postures, but only 3 cm for the car egress scenario to handle
the geometry of the car. For future work, we would like to
automatically adapt the size of the discretization step to the
complexity of the environment.
D. Performance analysis
To analyze performance, we ran the planner 1000 times for
each scenario. We measured the computation time spent in
each part of the algorithm, and analyzed success rate.
1) Success rates (Table II): Despite the complexity of the
scenarios and the approximations made in our formulation, our
planner succeeded in the large majority of cases.
Table III presents the rate of successful contact generation.
Note that a failure in contact generation for a root conﬁguration is not equivalent to a failure in the contact plan. It simply
means that another limb was tested for contact generation for
the same root conﬁguration. As expected, a more constrained
scenario such as the car egress provides less satisfying results,
despite the high success rate of the planner.
2) Computation times (Table IV): For HRP-2, most of the
time was spent performing inverse kinematics. This is not
surprising considering the number of calls to the methods: IK
projection is used intensively to maintain contact continuity
between two postures; it is also applied every time a new
candidate needs to be evaluated. In particular for the car
egress scenario, the kinematic constraints are very demanding
to avoid collisions.
(nb steps)
Complete guide
generation (ms)
Static equilibrium
Collision (ms)
Inverse Kinematics
Total generation time
Stairs (18)
5 – 6 – 18
13 – 32 – 329
1 – 4 – 38
26 – 127 – 1345
92 – 261 – 2174
65 – 1086 –
27 – 144 – 338
2 – 12 – 37
144 – 1046 – 2374
371 – 2257 – 7671
320 – 6971 –
409 – 1766 –
297 – 1187 – 8483
3154 – 15323 –
5834 – 31391 – 281000
37 – 573 – 1685
583 – 2714 – 9459
491 – 1971 – 6273
269 – 706 – 3118
1811 – 7195 – 23241
Race (134)
14 – 51 – 125
455 – 1359 –
397 – 923 – 9924
228 – 471 – 5415
1436 – 3343 – 41446
MINIMUM, AVERAGE AND WORST TIME (IN MS) SPENT IN THE GENERATION PROCESS FOR EACH SCENARIO AND EACH CRITICAL PART OF THE
GENERATION PROCESS (NOT ALL PARTS ARE TIMED, THUS THE AVERAGE TOTAL COMPUTATION TIME IS HIGHER THAN THE SUM OF EACH PART). THE
LAST COLUMN INDICATES THE AVERAGE TIME NECESSARY TO COMPUTE ONE CONTACT TRANSITION. THE COLLISION COLUMN TIMES INCLUDES THE
(NEGLIGEABLE) OCTREE INTERSECTION OPERATION NECESSARY TO RETRIEVE THE CANDIDATE SAMPLES.
Computation time
Stair 20 cm
Hauser 
Mordatch et al. 
2 to 10 min
Ours + 
Stair 30 cm
Hauser 
Mordatch et al. 
2 to 10 min
Stair 40 cm
Hauser 
Mordatch et al. 
2 to 10 min
Table (car) egress
Bouyarmane et al. , 
COMPARISON BETWEEN THE COMPUTATION TIMES OBTAINED BY OUR
METHOD AND PREVIOUS ONES FOR ADDRESSING THE WHOLE PROBLEM.
On the other hand for HyQ most of the time is spent testing
the static equilibrium of the candidate conﬁgurations.
In all scenarios, one can observe that the average computation time for one single step is largely below one second,
thus enabling interactive applications and online autonomous
planning of the robot motion.
Conclusion: These results conﬁrm that our approach provides a satisfying compromise between completeness and
efﬁciency, thus enabling online planning while controlling the
robot. Indeed, when the contact planning fails, it fails rapidly.
This allows us to rapidly re-plan with a reasonable chance
of success. The most efﬁcient (and immediate) approach to
obtain a valid contact plan as fast as possible would be to
launch in parallel several instances of the planner (our current
implementation is single-threaded) and to use any successful
result as a plan for solver P3.
E. Comparison with previous work
We did our best to provide a fair comparison of the
computation complexity of our method with the state of the
art. However existing benchmarks for motion planning algorithms do not yet encompass contact planning. Moreover,
the source code of the previous methods of the state of the
art is often not available. Providing a fair comparison with
the algorithms performing on the same computer and on the
same scenarios is yet out of reach. A step in this direction is
the open-source release of our source code (see Section VII)
that allows any reader to reproduce our results. Furthermore,
P3 remains challenging in the presence of obstacles. The only
valid scenarios addressed completely in previous works are
thus the stair-climbing scenarios of different heights proposed
by Hauser in , and the table-egress scenario by Escande
et al. in , which we consider to be of similar complexity
with respect to the car-egress scenario (we did not consider
the stairs in the scene). Both scenarios are tested with HRP-2.
Table V presents the computation times for these scenarios,
clearly demonstrating that our approach is order of magnitude
faster than previous works.
IX. DISCUSSION: VALIDITY AND PURPOSE OF OUR
CONTACT PLANNER
As demonstrated in the results section, the main purpose
of our method is the reduction of the algorithmic complexity
of the problem, which leads to an interactive application.
This property is critical for online applications with the robot
and was not proposed by any of the previous contributions.
Our method addresses highly constrained environments while
improving the search time by orders of magnitude. This high
performance is reached at the cost of some approximations
that we discuss here.
The ﬁrst approximation is the veriﬁcation of contact reachability (q0 ∈C0
Contact). Our reachability condition (q0 ∈
Reach) is computationally efﬁcient and provides an accurate
approximation of C0
Contact (Section IV-B). This is demonstrated by the second column of Table III, and illustrated
by Figure 13. Indeed, in the large majority of cases, (84%
in the worst car egress case), we are able to ﬁnd a contact
conﬁguration for any conﬁguration in C0
Another source of computational cost identiﬁed in previous
works is the veriﬁcation of equilibrium feasibility. The main
assumption of our work is that for the class of problems we
consider contact reachability implies equilibrium feasibility.
Our scenarios show that the assumption is veriﬁed in the
majority of cases when at least one contact surface is quasi
ﬂat , that is when the friction cone of the contact surface
contains the direction opposite to the gravity. Figure 13
illustrates this observation, demonstrated empirically by the
third column of Table III. In the worst case, in our experiment
Illustration of several root conﬁgurations sets used in this paper
in a 2D scene. Obstacles are violet, and units are in meters. To show the
sets in a 2D representation, all the rotational joints of HRP-2 are locked in
the shown conﬁguration, such that a torso conﬁguration is only described
by two positional parameters (x and y). The root of the robot is indicated
with a black cross. To compute the reachable workspace, the point on the
ankle indicated by a green cross was used. C0
Equil is included in C0
Reach approximates C0
Contact. Depending on a parametrization, we can
Contact ⊂C0
Reach. Considering the conﬁgurations around the top
obstacle, we can observe a similarity between C0
Equil and C0
Contact when
the reachable workspace of the legs includes quasi-ﬂat surfaces.
the assumption was veriﬁed for 82% of the total amount
of trials that veriﬁed contact reachability. In the example
of , the veriﬁcation of equilibrium feasibility implies a
constructive demonstration by exhibiting a valid q0, requiring
several minutes of planning. Our method, in comparison, takes
from a few milliseconds to several seconds.
These results clearly justify our pragmatic approach.
X. CONCLUSION
In this paper we consider the multi-contact planning problem, formulated as three sub-problems P1, P2, P3, addressed
sequentially. While we propose a global framework that handles all these problems, our contribution focuses on P1 and
P2. The ﬁrst problem P1 consists in computing an equilibrium
feasible guide path for the root of the robot; the second
problem P2 is the computation of a discrete sequence of
whole-body conﬁgurations along the root path. We believe that
this decomposition is currently the most promising approach
towards a global resolution of the problem. We also claim to
have achieved a signiﬁcant step towards this objective thanks
to the dimensionality reduction provided by the reachability
condition. With our results and the release of our source code,
we hope to inspire further research in this direction.
Our contribution to P1 is the introduction of a lowdimensional space C0
reach, an approximation of the space
of equilibrium feasible root conﬁgurations. C0
reach can be
efﬁciently sampled and has a low-dimension. For these reasons
we are able to solve P1 much faster than previous approaches.
Our contribution to P2 is a fast contact generation scheme
that can optimize user-deﬁned criteria.
Our results demonstrate that our method allows a pragmatic
compromise between three criteria that are hard to reconcile:
generality, performance, and quality of the solution, making
it the ﬁrst acyclic contact planner compatible with interactive
applications.
Regarding generality, the reachability condition, coupled
with an approach based on limb decomposition, allows the
method to address automatically arbitrary legged robots. Regarding performance, our framework is efﬁcient in addressing both P1 and P2. This results in interactive computation
times. Regarding the quality of the paths, we are able
to compute equilibrium feasible paths in all the presented
scenarios, with high success rates. As for , failures can
still occur, due to the approximate condition used to compute
the guide path. The low computational burden of our framework however allows for fast re-planning in case of failure.
Furthermore, because of this approximation, the guide search
is not complete. The choice is deliberate, because we believe
that it is necessary to trade completeness for efﬁciency at all
stages of the planner. However, one direction for future work is
to focus on a more accurate formulation of C0
reach to improve
the approximation.
Our method applies to any scenario where at least one
contact friction cone contains the direction opposed to the
gravity (i.e. quasi-ﬂat). This class of scenarios include all
the problems proposed at the DARPA Robotics Challenge.
One way to further extend its range of application, which
we consider for future work, is to include the equilibrium
criterion when solving P1. Considering the set of obstacles
intersecting with the reachable workspace for a given root
conﬁguration as candidate surfaces, we can use them to verify
the equilibrium criterion. This would give us a necessary
condition for equilibrium feasibility.
While we have exhibited complete multi-contact locomotion
obtained with our contact planner, our main concern for future
work is to address the interpolation between contact sequences
(P3), which remains an open issue in highly-constrained scenarios. Solving P3 requires addressing efﬁciently the collision
avoidance problem in the interpolation phase, an issue not
addressed by existing frameworks. We aim at providing our
plans with transition certiﬁcates, that would deﬁne constraints
on P3, under which the transition between two contact con-
ﬁgurations is feasible and collision-free. Finally, we aim at
performing kinodynamic planning to remove the constraint
that conﬁgurations be in static equilibrium. We believe that
the most promising direction in this regard is to integrate the
notion of Admissible Velocity Propagation . Addressing
these two issues is essential to bridge the gap between the
planning and control aspects of legged locomotion.
APPENDIX A
GENERATING THE W VOLUMES FOR HRP-2
We detail our method to generate the volumes W used
in RB-RRT, with the example of HRP-2. The kinematic tree
is split into four limbs Rk. The arms are connected to the
Fig. 14. The W volumes computed for HRP-2. The red shapes are W 0. The
green shapes represent the W k.
Fig. 15. Different approximations of the range of motion of the right arm of
HRP-2. Left: non convex-hull, computed with the powercrust algorithm .
Middle: convex hull of the reachable workspace. Right: Simpliﬁed hull used
in our experiments.
shoulders, and the legs to the root. The obtained volumes W
are shown in Figure 14.
A. Step 1: computing the reachable workspace W k of a limb
To generate a volume W k, we proceed as follows:
1) Generate randomly N valid limb conﬁgurations for Rk,
for N really large (say 100000);
2) For each conﬁguration, store the 3D position of the end
effector joint relatively to the root of Rk; then compute
the convex hull of the resulting point cloud;
3) The resulting polytope can contain a very large number
of faces. A last step is thus to simplify it with the blender
decimate tool ( 
4/Manual/Modiﬁers/Generate/Decimate). This tool removes a user-deﬁned amount of vertices (and faces) of
the polytope, thus resulting in a convervative approximation of the original shape. For HRP-2 we apply the
operator with a ratio of 0.06, resulting in a polytope of
38 faces for the arms and the legs.
Figure 15 illustrate the obtained W k for HRP-2. Regarding
the procedure, we can see that step 2 is conservative (Figure 15–right), which is acceptable, especially because the lost
set essentially relates to conﬁgurations close to singularity
(they are close to the boundaries of the reachable workspace,
Velocity ellipsoid
Force ellipsoid (scale 0.5)
Fig. 16. Examples of velocity and force ellipsoids for a manipulator composed
of 2 DoFs and 2 segments. Only the horizontal and vertical speeds are shown
(not the rotation speeds).
and often not contact reachable, as illustrated in Figure 13,
where the exterior boundaries of the reachable workspace
appear red, thus not belonging to C0
Contact). We choose again
to be less complete but more efﬁcient, regarding the number
of collision tests to be performed by RB-RRT. In step 1 on
the other hand, selecting the convex hull (Figure 15–middle)
instead of a minimum encompassing shape (Figure 15–left)
may introduce false positives. Concretely, because the false
positive set intersects with W 0, the scaling volume of the
robot torso, the induced error is compensated, as veriﬁed by
the results shown by Table III.
B. Step 2: computing the torso scaling workspace W 0 of the
To deﬁne the volume W 0 of HRP-2, we proceed in an
empirical manner. First, we compute the bounding boxes of
the robot torso, head, and upper legs (Figure 14 – red shapes).
Then, we perform a scaling of these boxes by a factor s.
The higher s is, the more likely sampled conﬁgurations are
to be feasible, but the less complete is the approach. To
compute the appropriate value of s, we proceed as described
in Section VIII-C1, and choose empirically s∗= 1.2 as the
appropriate value for HRP-2.
APPENDIX B
MANIPULABILITY-BASED HEURISTICS FOR CONTACT
This Section proposes two heuristics to select a contact
that optimizes desired capabilities. For instance, one can be
interested in conﬁgurations that allow to efﬁciently exert a
force in the global direction of motion, or to stay away from
singular conﬁgurations. We derive these heuristics from the
work by , recalled here.
1) The force and velocity ellipsoids: We consider: a limb
conﬁguration qk; its end effector position pk; its Jacobian
matrix Jk(qk); a force f exerted by the end effector. For clarity
in the rest of the section we omit the k indices and write
Jk(qk) as J. Yoshikawa deﬁnes the velocity( 12) and
force (13) ellipsoids:
˙pT (JJT )−1 ˙p ≤1
f T (JJT )f ≤1
They describe the set of end-effector velocities (respectively
forces) that can be reached under the constraint || ˙q||2 ≤1 for
the current conﬁguration. The longer the axis of the ellipsoid
is, the more important the velocity (resp. force) of the endeffector the direction of the axis can be (Figure 16).
2) Manipulability-based heuristics: From these deﬁnitions,
we can derive two useful heuristics, that all account for the
environment and the task being performed. The ﬁrst one,
EFORT, was introduced by ; the second one derives the
manipulability measure proposed by Yoshikawa .
With EFORT, we deﬁne the efﬁciency of a conﬁguration as
the ability of a limb to exert a force in a given direction. We
thus consider the force ellipsoid as a basis for our heuristic.
In a given direction ρ, the length of the ellipsoid is given by
the force-transmission ratio :
fT(q, ρ) = [ρT (JJT )ρ]−1
In our problem, to compare candidate conﬁgurations, we
include the quality of the contact surface, and choose ρ as the
direction opposite to the local motion (given by the difference
between two consecutive root positions):
hEFORT(q, ρ) = [ρT (JJT )ρ]−1
where µ and n are respectively the friction coefﬁcient and the
normal vector of the contact surface.
hEFORT will favor contacts that allow large efforts. EFORT
in particular is useful for tasks such as standing up, pushing /
pulling. In other less demanding cases, manipulability can also
be considered to avoid singularities. To do so, we can consider
the manipulability measure hw, also given by Yoshikawa :
hw measures the “distance” of a given conﬁguration to singularity. When hw is equal to 0, the conﬁguration is singular;
the greater hw is, the further away the conﬁguration is from
singularity.
APPENDIX C
ADDRESSING P3
The stair climbing and the standing up scenarios were
validated with the trajectory optimization scheme provided in
 . To address the other scenarios, we propose a new implementation, entirely open source ( 
python sandbox/releases/tag/tro paper ), which can be integrated directly in our motion planner software. This formulation uses the center of mass acceleration and angular
momentum as input variables, while previously the contact
forces were used. The center-of-mass trajectory resulting from
the optimization is then turned into a collision-free whole-body
trajectory.
We rewrite Eq. 8 in the general case:
mc × (¨c −g) + ˙L
where ˙L is the angular momentum expressed at the com.
Eq. 16 deﬁnes a 6-dimensional cone K
 , . For a
given set of contacts, this cone determines all the admissible
wrenches w that can be generated by contact forces inside
their friction cones. The face form of K can be computed using
the double description method , resulting in the following
linear inequalities:
K = {w, Aw ≤b}
The objective is then to plan a trajectory for the center of
mass such that the generated w always veriﬁes Eq. 17. We
now consider two contact conﬁgurations q0 and q1 computed
by our planner: in the general case one contact is broken and
one created to get from q0 to q1. We manually deﬁne the
duration of each of the three contact phases. In each phase
s the centroidal wrench w is constrained to lie inside a cone
Ku, u = 0 . . . 2. We call the total duration of the motion T,
and formulate the following optimization problem:
¨c(t), ˙L(t)
ℓ(¨c(t), ˙L(t))dt
subject to
Auw(t) ≤bu, ∀t ∈[tu, tu + ∆tu[ , ∀u
Yuc(t) ≤yu, ∀t ∈[tu, tu + ∆tu[ , ∀u
c(0) = cq0
c(T) = cq1
c(0) = ˙c(0) = ¨c(0) = 0
c(T) = ˙c(T) = ¨c(T) = 0
The cost function ℓis a weighted sum of the angular momentum and center-of-mass acceleration variation over the
whole trajectory. The center-of-mass positions and velocities
c(t), ˙c(t) are internal variables, obtained through the double
integration of ¨c(t). Then w(t) is obtained directly from these
variables. cq0 and cq1 are the center-of-mass positions for
conﬁgurations q0 and q1 respectively. Yu and yu denote
stacked kinematic constraints on the center of mass position,
determined by the active contact locations. The inequalities
for each contact are determined in the same way that the
reachable workspace is computed in Appendix A, with the
effector serving as root.
This formulation can trivially be extended over the whole
contact sequence. In our implementation, the problem is
discretized using time steps of 100 ms.
The output of this optimization problem is an admissible
center-of-mass trajectory. To compute the whole body motion,
we use a two-step approach.
First, we plan a kinematic motion for the robot, subject to
the contact constraints. We also constrain the center of mass
to follow the computed trajectory. This is achieved using a
constraint-based RRT planner . As a result we obtain a
collision-free whole-body motion.
The entire resolution takes approximatively 1.5 seconds for
a complete contact transition.
ACKNOWLEDGEMENTS
This research is supported by Euroc (project under FP7
Grant Agreement 608849); Entracte (ANR grant agreement
13-CORD-002-01); the ARO Contract W911NF-14-1-0437;
and the NSF award 1305286.