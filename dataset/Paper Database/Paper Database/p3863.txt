Deep Multi-scale Convolutional Neural Network for Dynamic Scene Deblurring
Seungjun Nah
Tae Hyun Kim
Kyoung Mu Lee
Department of ECE, ASRI, Seoul National University, 08826, Seoul, Korea
{seungjun.nah, lliger9}@gmail.com, 
Non-uniform blind deblurring for general dynamic
scenes is a challenging computer vision problem as blurs
arise not only from multiple object motions but also from
camera shake, scene depth variation.
To remove these
complicated motion blurs, conventional energy optimization based methods rely on simple assumptions such that
blur kernel is partially uniform or locally linear. Moreover, recent machine learning based methods also depend
on synthetic blur datasets generated under these assumptions. This makes conventional deblurring methods fail to
remove blurs where blur kernel is difﬁcult to approximate or
parameterize (e.g. object motion boundaries). In this work,
we propose a multi-scale convolutional neural network that
restores sharp images in an end-to-end manner where blur
is caused by various sources. Together, we present multiscale loss function that mimics conventional coarse-to-ﬁne
approaches. Furthermore, we propose a new large-scale
dataset that provides pairs of realistic blurry image and the
corresponding ground truth sharp image that are obtained
by a high-speed camera. With the proposed model trained
on this dataset, we demonstrate empirically that our method
achieves the state-of-the-art performance in dynamic scene
deblurring not only qualitatively, but also quantitatively.
1. Introduction
Motion blur is one of the most commonly arising types
of artifacts when taking photos. Shakes of camera and fast
object motions degrade image quality to undesired blurry
images. Furthermore, various causes such as depth variation, occlusion in motion boundaries make blurs even more
complex. Single image deblurring problem is to estimate
the unknown sharp image given a blurry image. Earlier
studies focused on removing blurs caused by simple translational or rotational camera motions. More recent works try
to handle general non-uniform blurs caused by depth variation, camera shakes and object motions in dynamic environments. Most of these approaches are based on following
blur model .
B = KS + n,
where B, S and n are vectorized blurry image, latent
sharp image, and noise, respectively. K is a large sparse
matrix whose rows each contain a local blur kernel acting
on S to generate a blurry pixel. In practice, blur kernel is
unknown. Thus, blind deblurring methods try to estimate
latent sharp image S and blur kernel K simultaneously.
Finding blur kernel for every pixel is a severely ill-posed
problem. Thus, some approaches tried to parametrize blur
models with simple assumptions on the sources of blurs. In
 , they assumed that blur is caused by 3D camera
motion only. However, in dynamic scenes, the kernel estimation is more challenging as there are multiple moving
objects as well as camera motion. Thus, Kim et al. proposed a dynamic scene deblurring method that jointly segments and deblurs a non-uniformly blurred image, allowing
the estimation of complex (non-linear) kernel within a segment. In addition, Kim and Lee approximated the blur
kernel to be locally linear and proposed an approach that estimates both the latent image and the locally linear motions
jointly. However, these blur kernel approximations are still
inaccurate, especially in the cases of abrupt motion discontinuities and occlusions. Note that such erroneous kernel
estimation directly affects the quality of the latent image,
resulting in undesired ringing artifacts.
Recently, CNNs (Convolutional Neural Networks) have
been applied in numerous computer vision problems including deblurring problem and showed promising results
 . Since no pairs of real blurry image and
ground truth sharp image are available for supervised learning, they commonly used blurry images generated by convolving synthetic blur kernels. In , synthesized
blur images with uniform blur kernel are used for training.
And, in , classiﬁcation CNN is trained to estimate locally linear blur kernels. Thus, CNN-based models are still
suited only to some speciﬁc types of blurs, and there are
restrictions on more common spatially varying blurs.
Figure 1. (a) Input blurry image. (b) Result of Sun et al. . (c) Our deblurring result. Our results show clear object boundaries without
artifacts.
Therefore, all the existing methods still have many problems before they could be generalized and used in practice.
These are mainly due to the use of simple and unrealistic blur kernel models. Thus, to solve those problems, in
this work, we propose a novel end-to-end deep learning approach for dynamic scene deblurring.
First, we propose a multi-scale CNN that directly restores latent images without assuming any restricted blur
kernel model.
Especially, the multi-scale architecture is
designed to mimic conventional coarse-to-ﬁne optimization
methods. Unlike other approaches, our method does not estimate explicit blur kernels. Accordingly, our method is free
from artifacts that arise from kernel estimation errors. Second, we train the proposed model with a multi-scale loss
that is appropriate for coarse-to-ﬁne architecture that enhances convergencegreatly. In addition, we further improve
the results by employing adversarial loss . Third, we propose a new realistic blurry image dataset with ground truth
sharp images. To obtain kernel model-free dataset for training, we employ the dataset acquisition method introduced
in . As the blurring process can be modeled by the integration of sharp images during shutter time ,
we captured a sequence of sharp frames of a dynamic scene
with a high-speed camera and averaged them to generate a
blurry image by considering gamma correction.
By training with the proposed dataset and adding proper
augmentation, our model can handle general local blur kernel implicitly.
As the loss term optimizes the result to
resemble the ground truth, it even restores occluded regions where blur kernel is extremely complex as shown in
Fig. 1. We trained our model with millions of pairs of image
patches and achieved signiﬁcant improvements in dynamic
scene deblurring. Extensive experimental results demonstrate that the performance of the proposed method is far
superior to those of the state-of-the-art dynamic scene deblurring methods in both qualitative and quantitative evaluations.
1.1. Related Works
There are several approaches that employed CNNs for
deblurring .
Xu et al. proposed an image deconvolution CNN to
deblur a blurry image in a non-blind setting. They built a
network based on the separable kernel property that the (inverse) blur kernel can be decomposed into a small number
of signiﬁcant ﬁlters. Additionally, they incorporated the denoising network to reduce visual artifacts such as noise
and color saturation by concatenating the module at the end
of their proposed network.
On the other hand, Schuler et al. proposed a blind
deblurring method with CNN. Their proposed network
mimics conventional optimization-based deblurring methods and iterates the feature extraction, kernel estimation,
and the latent image estimation steps in a coarse-to-ﬁne
manner. To obtain pairs of sharp and blurry images for network training, they generated uniform blur kernels using a
Gaussian process and synthesized lots of blurry images by
convolving them to the sharp images collected from the ImageNet dataset . However, they reported performance
limits for large blurs due to their suboptimal architecture.
Similarly to the work of Couzinie-Devy et al. , Sun
et al. proposed a sequential deblurring approach. First,
they generated pairs of blurry and sharp patches with 73
candidate blur kernels.
Next, they trained classiﬁcation
CNN to measure the likelihood of a speciﬁc blur kernel of
a local patch. And then smoothly varying blur kernel is obtained by optimizing an energy model that is composed of
the CNN likelihoods and smoothness priors. Final latent
image estimation is performed with conventional optimization method .
Note that all these methods require an accurate kernel
estimation step for restoring the latent sharp image. In contrast, our proposed model is learned to produce the latent
image directly without estimating blur kernels.
In other computer vision tasks, several forms of coarseto-ﬁne architecture or multi-scale architecture were applied . However, not all multi-scale CNNs
are designed to produce optimal results, similarly to .
In depth estimation, optical ﬂow estimation, etc., networks
usually produce outputs having smaller resolution compared to input image resolution . These methods
have difﬁculties in handling long-range dependency even if
multi-scale architecture is used.
Therefore, we make a multi-scale architecture that preserves ﬁne-grained detail information as well as long-range
dependency from coarser scales.
Furthermore, we make
sure intermediate level networks help the ﬁnal stage in an
explicit way by training network with multi-scale losses.
1.2. Kernel-Free Learning for Dynamic Scene Deblurring
Conventionally, it was essential to ﬁnd blur kernel before
estimating latent image. CNN based methods were no exception . However, estimating kernel involves several problems. First, assuming simple kernel convolution
cannot model several challenging cases such as occluded regions or depth variations. Second, kernel estimation process
is subtle and sensitive to noise and saturation, unless blur
model is carefully designed. Furthermore, incorrectly estimated kernels give rise to artifacts in latent images. Third,
ﬁnding spatially varying kernel for every pixel in dynamic
scene requires a huge amount of memory and computation.
Therefore, we adopt kernel-free methods in both blur
dataset generation and latent image estimation. In blurry
image generation, we follow to approximate camera imaging process, rather than assuming speciﬁc motions, instead
of ﬁnding or designing complex blur kernel. We capture
successive sharp frames and integrate to simulate blurring
process. The detailed procedure is described in section 2.
Note that our dataset is composed of blurry and sharp image
pairs only, and that the local kernel information is implicitly embedded in it. In Fig. 2, our kernel-free blurry image is
compared with a conventional synthesized image with uniform blur kernel. Notably, the blur image generated by our
method exhibits realistic and spatially varying blurs caused
by the moving person and the static background, while the
blur image synthesized by conventional method does not.
For latent image estimation, we do not assume blur sources
and train the model solely on our blurry and sharp image
Thus, our proposed method does not suffer from
kernel-related problems in deblurring.
2. Blur Dataset
Instead of modeling a kernel to convolve on a sharp image, we choose to record the sharp information to be integrated over time for blur image generation. As camera sensor receives light during the exposure, sharp image stimulation at every time is accumulated, generating blurry image . The integrated signal is then transformed into
pixel value by nonlinear CRF (Camera Response Function).
Thus, the process could be approximated by accumulating
signals from high-speed video frames.
Blur accumulation process can be modeled as follows.
where T and S(t) denote the exposure time and the sensor signal of a sharp image at time t, respectively. Similarly, M, S[i] are the number of sampled frames and the
i-th sharp frame signal captured during the exposure time,
respectively. g is the CRF that maps a sharp latent signal
S(t) into an observed image ˆS(t) such that ˆS(t) = g(S(t)),
or ˆS[i] = g(S[i]). In practice, we only have observed video
frames while the original signal and the CRF is unknown.
It is known that non-uniform deblurring becomes significantly difﬁcult when nonlinear CRF is involved, and nonlinearity should be taken into account. However, currently,
there are no CRF estimation techniques available for an image with spatially varying blur . When the ground truth
CRF is not given, a common practical method is to approximate CRF as a gamma curve with γ = 2.2 as follows, since
it is known as an aproximated average of known CRFs .
g(x) = x1/γ.
Thus, by correcting the gamma function, we obtain the
latent frame signal S[i] from the observed image ˆS[i] by
S[i] = g−1( ˆS[i]), and then synthesize the corresponding
blur image B by using (2).
We used GOPRO4 Hero Black camera to generate our
dataset. We took 240 fps videos with GOPRO camera and
then averaged varying number (7 - 13) of successive latent
frames to produce blurs of different strengths. For example,
averaging 15 frames simulates a photo taken at 1/16 shutter speed, while corresponding sharp image shutter speed
is 1/240. Notably, the sharp latent image corresponding to
each blurry one is deﬁned as the mid-frame among the sharp
frames that are used to make the blurry image. Finally, our
dataset is composed of 3214 pairs of blurry and sharp images at 1280x720 resolution. The proposed GOPRO dataset
is publicly available on our website 1.
1 
Figure 2. (a) Ground truth sharp image. (b) Blurry image generated by convolving a uniform blur kernel. (c) Blurry image by averaging
sharp frames. In this case, blur is mostly caused by person motion, leaving the background as it is. The blur kernel is non-uniform, complex
shaped. However, when the blurry image is synthesized by convolution with a uniform kernel, the background also gets blurred as if blur
was caused by camera shake. To model dynamic scene blur, our kernel-free method is required.
3. Proposed Method
In our model, ﬁner scale image deblurring is aided by
coarser scale features. To exploit coarse and middle level
information while preserving ﬁne level information at the
same time, input and output to our network take the form of
Gaussian pyramids. Note that most of other coarse-to-ﬁne
networks take a single image as input and output.
3.1. Model Architecture
In addition to the multi-scale architecture, we employ a
slightly modiﬁed version of residual network structure 
as a building block of our model. Using residual network
structure enables deeper architecture compared to a plain
CNN. Also, as blurry and sharp image pairs are similar in
values, it is efﬁcient to let parameters learn the difference
only. We found that removing the rectiﬁed linear unit after the shortcut connection of the original residual building
block boosts the convergence speed at training time. We denote the modiﬁed building block as ResBlock. The original
and our modiﬁed building block are compared in Fig. 3.
By stacking enough number of convolution layers with
ResBlocks, the receptive ﬁeld at each scale is expanded.
Details are described in the following paragraphs. For sake
of consistency, we deﬁne scale levels in the order of decreasing resolution (i.e. level 1 for ﬁnest scale). Unless
denoted otherwise, we use total K = 3 scales. At training
time, we set the resolution of the input and output Gaussian
pyramid patches to be {256 × 256, 128 × 128, 64 × 64}.
The scale ratio between consecutive scales is 0.5. For all
convolution layers, we set the ﬁlter size to be 5 × 5. As our
model is fully convolutional, at test time, the patch size may
vary as the GPU memory allows. The overall architecture
is shown in Fig. 4.
Figure 3. (a) Original residual network building block. (b) Modiﬁed building block of our network. We did not use batch normalization layers since we trained model with mini-batch of size
2, which is smaller than usual for batch normalization. We found
removing rectiﬁed linear unit just before the block output is bene-
ﬁcial in terms of performance empirically.
Figure 4. Multi-scale network architecture. Bk, Lk, Sk denote blurry and latent, and ground truth sharp images, respectively. Subscript
k denotes k-th scale level in the Gaussian pyramid, which is downsampled to 1/2k scale. Our model takes a blurry image pyramid as the
input and outputs an estimated latent image pyramid. Every intermediate scale output is trained to be sharp. At test time, original scale
image is chosen as the ﬁnal result.
Coarsest level network
At the front of the network locates the coarsest level network. The ﬁrst convolution layer transforms 1/4 resolution, 64 × 64 size image into 64 feature maps. Then, 19
ResBlocks are stacked followed by last convolution layer
that transforms the feature map into input dimension. Every
convolution layer preserves resolution with zero padding. In
total, there are 40 convolution layers. The number of convolution layers at each scale level is determined so that total
model should have 120 convolution layers. Thus, the coarsest level network has receptive ﬁeld large enough to cover
the whole patch. At the end of the stage, the coarsest level
latent sharp image is generated.
Moreover, information
from the coarsest level output is delivered to the next stage
where ﬁner scale network is. To convert a coarsest output
to ﬁt the input size of the next ﬁner scale, the output patch
passes an upconvolution layer, while other multi-scale
methods use reshaping or upsampling . Since
the sharp and blurry patches share low-frequency information, learning suitable feature with upconvolution helps to
remove redundancy. In our experiment, using upconvolution showed better performance than upsampling. Then, the
upconvolution feature is concatenated with the ﬁner scale
blurry patch as an input.
Finer level network
Finer level networks basically have the same structure as in
the coarsest level network. However, the ﬁrst convolution
layer takes the sharp feature from the previous stage as well
as its own blurry input image, in a concatenated form. Every
convolution ﬁlter size is 5 × 5 with the same number of
feature maps as in the coarsest level. Except for the last
ﬁnest scale, there is an upconvolution layer before the next
stage. At the ﬁnest scale, the original resolution sharp image
is restored.
3.2. Training
Our model is trained on the proposed GOPRO dataset.
Among 3214 pairs, 2103 pairs were used for training and
remainings were used for the test. To prevent our network
from overﬁtting, several data augmentation techniques are
involved. In terms of geometric transformations, patches
are randomly ﬂipped horizontally and vertically, rotated by
90 degrees. For color, RGB channels are randomly permuted. To take image degradations into account, saturation in HSV colorspace is multiplied by a random number within [0.5, 1.5].
Also, Gaussian random noise is
added to blurry images. To make our network be robust
against different strengths of noise, standard deviation of
noise is also randomly sampled from Gaussian distribution,
N(0, (2/255)2). Then, value outside is clipped. Finally, 0.5 is subtracted to set input and output value range
zero-centered, having range [-0.5, 0.5].
In optimizing the network parameters, we trained the
model in a combination of two losses, multi-scale content
loss and adversarial loss.
Multi-scale content loss
Basically, the coarse-to-ﬁne approach desires that every intermediate output becomes the sharp image of the corresponding scale. Thus, we train our network so that intermediate outputs should form a Gaussian pyramid of sharp
images. MSE criterion is applied to every level of pyramids.
Hence, the loss function is deﬁned as follows:
∥Lk −Sk∥2,
where Lk, Sk denote the model output and ground truth image at scale level k, respectively. The loss at each scale is
normalized by the number of channels ck, width wk, and
the height hk (i.e. the total number of elements).
Adversarial loss
Recently, adversarial networks are reported to generate
sharp realistic images . Following the architecture introduced in , we build discriminator as in Table 1. Discriminator takes the output of the ﬁnest scale or
the ground truth sharp image as input and classiﬁes if it is
deblurred image or sharp image.
The adversarial loss is deﬁned as follows.
S∼psharp(S)[log D(S)]+
B∼pblurry(B)[log(1 −D(G(B)))],
where G and D denote the generator, that is our multiscale deblurring network in Fig. 4 and the discriminator
(classiﬁer), respectively. When training, G tries to minimize
the adversarial loss while D tries to maximize it.
Finally, by combining the multi-scale content loss and
adversarial loss, the generator network and discriminator
network is jointly trained. Thus, our ﬁnal loss term is
Ltotal = Lcont + λ × Ladv,
where the weight constant λ = 1 × 10−4.
We used ADAM optimizer with a mini-batch size
2 for training. The learning rate is adaptively tuned beginning from 5 × 10−5. After 3 × 105 iterations, the learning
Weight dimension
32 × 3 × 5 × 5
64 × 32 × 5 × 5
64 × 64 × 5 × 5
128 × 64 × 5 × 5
128 × 128 × 5 × 5
256 × 128 × 5 × 5
256 × 256 × 5 × 5
512 × 256 × 5 × 5
512 × 512 × 4 × 4
512 × 1 × 1 × 1
Table 1. Model parameters of the discriminator. Every convolution
layers are activated with LeakyReLU layer.
rate is decreased to 1/10 of the previous learning rate. Total
training takes 9 × 105 iterations to converge.
4. Experimental Results
We implemented our model with torch7 library. All the
following experiments were performed in a desktop with i7-
6700K CPU and NVIDIA GTX Titan X (Maxwell) GPU.
4.1. GOPRO Dataset
We evaluate the performance of our model in the proposed GOPRO dataset. Our test dataset consists of 1111
pairs, which is approximately 1/3 of the total dataset. We
compare the results with those of the state-of-the-art methods in both qualitative and quantitative ways. Our
results show signiﬁcant improvement in terms of image
quality. Some deblurring results are shown in Fig. 5. We notice from the results of Sun et al. , deblurring is not successful on the regions where blurs are nonlinearly shaped or
located at the boundary of motion. Kim and Lee ’s results also fail in cases where strong edges are not found. In
contrast, our results are free from those kernel-estimation
related problems. Table 2, shows the quantitative evaluation results of the competing methods and ours with different scale level k in terms of PSNR, SSIM over the test data.
Also, the runtime is compared. We observe that our system
with K = 2 produces the best results in terms of both PSNR
and SSIM, while K = 3 is the fastest.
4.2. K¨ohler Dataset
K¨ohler dataset consists of 4 latent images and 12
differently blurred images for each of them. The blurs are
caused by replaying recorded 6D camera motion, assuming linear CRF. We report the quantitative results on this
Figure 5. Test results on the GOPRO dataset. From top to bottom: Blurry images, results of Sun et al. , results of Kim and Lee ,
and results of the proposed method.
Figure 6. Deblurring results on the dataset . The top row shows results of results of Sun et al. and the bottom row shows our
Table 2. Quantitative deblurring performance comparison on the
GOPRO dataset. K denotes the scale level.
dataset in Table 3. Our model is trained by setting g as identity function in (2). We note that our system with K = 3
produces the best results in PSNR, and the system K = 2
exhibits the best MSSIM result.
Table 3. Quantitative comparison on the K¨ohler dataset.
dataset has its own evaluation code, thus we report multi-scale
SSIM instead of SSIM.
4.3. Dataset of Lai et al.
Lai et al.
 generated synthetic dataset by convolving nonuniform blur kernels and imposing several common
degradations. They also recorded 6D camera trajectories
to generate blur kernels. However, their blurry images and
sharp images are not aligned in the way of our dataset, making simple image quality measures such as PSNR and SSIM
less correlated with perceptual quality. Thus, we show qualitative comparisons in Fig. 6. Clearly, our results avoid ringing artifacts while preserving details such as wave ripple.
5. Conclusion
In this paper, we proposed a blind deblurring neural network for sharp image estimation.
Unlike previous studies, our model avoids problems related to kernel estimation.
The proposed model follows a coarse-to-ﬁne approach and
is trained in multi-scale space. We also constructed a realistic ground-truth blur dataset, enabling efﬁcient supervised learning and rigorous evaluation. Experimental results show that our approach outperforms the state-of-theart methods in both qualitative and quantitative ways while
being much faster.
Acknowledgement
This project is partially funded by Microsoft Research