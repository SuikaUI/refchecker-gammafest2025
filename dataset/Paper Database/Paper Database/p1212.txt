Communicated by Lehel Csato
Incremental Online Learning in High Dimensions
Sethu Vijayakumar
 
School of Informatics, University of Edinburgh,
Edinburgh EH9 3JZ, U.K.
Aaron D’Souza
 
Stefan Schaal
 
Department of Computer Science, University of Southern California,
Los Angeles, CA 90089-2520, U.S.A.
Locally weighted projection regression (LWPR) is a new algorithm for incremental nonlinear function approximation in high-dimensional spaces
with redundant and irrelevant input dimensions. At its core, it employs
nonparametric regression with locally linear models. In order to stay
computationally efﬁcient and numerically robust, each local model performs the regression analysis with a small number of univariate regressions in selected directions in input space in the spirit of partial least
squares regression. We discuss when and how local learning techniques
can successfully work in high-dimensional spaces and review the various
techniques for local dimensionality reduction before ﬁnally deriving the
LWPR algorithm. The properties of LWPR are that it (1) learns rapidly
with second-order learning methods based on incremental training,
(2) uses statistically sound stochastic leave-one-out cross validation for
learning without the need to memorize training data, (3) adjusts its
weighting kernels based on only local information in order to minimize
the danger of negative interference of incremental learning, (4) has a computational complexity that is linear in the number of inputs, and (5) can
deal with a large number of—possibly redundant—inputs, as shown in
various empirical evaluations with up to 90 dimensional data sets. For
a probabilistic interpretation, predictive variance and conﬁdence intervals are derived. To our knowledge, LWPR is the ﬁrst truly incremental
spatially localized learning method that can successfully and efﬁciently
operate in very high-dimensional spaces.
Neural Computation 17, 2602–2634 
© 2005 Massachusetts Institute of Technology
Incremental Online Learning in High Dimensions
1 Introduction
Despite the recent progress in statistical learning, nonlinear function approximation with high-dimensional input data remains a nontrivial problem,especiallyinincrementalandreal-timeformulations.Thereis,however,
an increasing number of problem domains where both of these properties
are important. Examples include the online modeling of dynamic processes
observed by visual surveillance, user modeling for advanced computer interfaces and game playing, and the learning of value functions, policies, and
models for learning control, particularly in the context of high-dimensional
movement systems like humans or humanoid robots. An ideal algorithm for
such tasks needs to avoid potential numerical problems from redundancy
in the input data, eliminate irrelevant input dimensions, keep the computational complexity of learning updates low while remaining data efﬁcient,
allow online incremental learning, and, of course, achieve accurate function
approximation and adequate generalization.
When looking for a learning framework to address these goals, one can
identify two broad classes of function approximation methods: (1) methods
that ﬁt nonlinear functions globally, typically by input space expansions
with predeﬁned or parameterized basis functions and subsequent linear
combinations of the expanded inputs; and (2) methods that ﬁt nonlinear
functions locally, usually by using spatially localized simple (e.g., loworder polynomial) models in the original input space and automatically
adjusting the complexity (e.g., number of local models and their locality)
to accurately account for the nonlinearities and distributions of the target
function. Interestingly, the current trends in statistical learning have concentrated on methods that fall primarily in the ﬁrst class of global nonlinear
function approximators, for example, gaussian process regression , support vector machine regression , and variational Bayes for mixture models .1 In spite of the solid theoretical foundations that
these approaches possess in terms of generalization and convergence, they
are not necessarily the most suitable for online learning in high-dimensional
spaces. First, they require an a priori determination of the right modeling
biases. For instance, in the case of GPR and SVMR, these biases involve
selecting the right function space in terms of the choice of basis or kernel
functions , and in VBM the biases are concerned with the right number of latent variables and proper initialization.2
Second, all of these recent function approximator methods were developed
1 Mixture models are actually in between global and local function approximators since
they use local model ﬁtting but employ a global optimization criterion.
2 It must be noted that some recent work has
started to look at model selection for SVMs and GPRs and automatic determination of
number of latent models for VBM .
S. Vijayakumar, A. D’Souza, and S. Schaal
primarily for batch data analysis and are not easily or efﬁciently adjusted
for incrementally arriving data. For instance, in SVMR, adding a new data
point can drastically change the outcome of the global optimization problem in terms of which data points actually become support vectors, such
that all (or a carefully selected subset of) data have to be kept in memory for
reevaluation. Thus, adding a new data point in SVMR is computationally
rather expensive, a property that is also shared by GPR. VBM suffers from
similar problems due to the need for storing and reevaluating data when
adding new mixture components . In general, it seems that most suggested Bayesian learning algorithms
are computationally too expensive for real-time learning because they tend
to represent the complete joint distribution of the data, albeit as a conditionally independent factored representation. As a last point, incremental
approximation of functions with global methods is prone to lead to negative interference when input distributions change .
Such changes are, however, typical in many online learning tasks.
In contrast to the global learning methods described above, function
approximation with spatially localized models is rather well suited for incremental and real-time learning, particularly in the framework of locally
weighted learning . LWL methods
are very useful when there is limited knowledge about the model complexity such that the model resources can be increased in a purely incremental and data-driven fashion, as demonstrated in previous work . However, since these techniques allocate resources to cover
the input space in a localized fashion, in general, with an increasing number
of input dimensions, they encounter an exponential explosion in the number of local models required for accurate approximation—often referred
to as the “curse of dimensionality” . Hence, at the outset, highdimensionalfunctionapproximationseemstobecomputationallyinfeasible
for spatially localized learning.
Some efﬁcient global learning methods with automatic resource allocation in high-dimensional spaces, however, have been employed successfully by using techniques of projection regression (PR). PR copes with
high-dimensional inputs by decomposing multivariate regressions into a
superposition of single-variate regressions along a few selected projections
in input space. The major difﬁculty of PR lies in the selection of efﬁcient projections, that is, how to achieve the best-ﬁtting result with as few univariate
regressionsaspossible.Amongthebest-knownPRalgorithmsareprojection
pursuit regression and its generalization in the
form of generalized additive models . Sigmoidal
neural networks can equally be conceived of as a method of projection regression, in particular when new projections are added sequentially, as in
cascade correlation .
In this letter, we suggest a method of extending the beneﬁcial properties
of spatially localized learning to high-dimensional function approximation
Incremental Online Learning in High Dimensions
problems. The prerequisite of our approach is that the high-dimensional
learning problems we address have locally low-dimensional distributions,
an assumption that holds for a large class of real-world data . If distributions are locally low dimensional, the allocation of local models can be restricted to
these thin distributions, and only a tiny part of the entire high-dimensional
space needs to be ﬁlled with local models. Thus, the curse of dimensionality of spatially localized model ﬁtting can be avoided. Under these circumstances, an alternative method of projection regression can be derived,
focusing on ﬁnding efﬁcient local projections. Local projections can be used
to accomplish local function approximation in the neighborhood of a given
query point with traditional LWL approaches, thus inheriting most of the
statistical properties from well-established methods . As this letter will demonstrate, the resulting learning
algorithm combines the fast, efﬁcient, and incremental capabilities of LWL
techniques while alleviating the problems faced due to high-dimensional
input domains through local projections.
In the following sections, we ﬁrst review approaches of how to ﬁnd good
localprojectionsbylookingintovariousschemesforperformingdimensionality reduction for regression, including principal component regression,
factor analysis, and partial least squares regression. Afterward, we embed
the most efﬁcient and robust of these projection algorithms in an incremental nonlinear function approximator capable
of automatically adjusting the model complexity in a purely data-driven
fashion. In several evaluations, on both synthetic and real-world data, the
resulting incremental learning system demonstrates high accuracy for function ﬁtting in very high-dimensional spaces, robustness toward irrelevant
and redundant inputs, as well as low computational complexity. Comparisons will prove the competitiveness with other state-of-the-art learning
2 Local Dimensionality Reduction for Locally Weighted Learning
Assuming that data are characterized by locally low-dimensional distributions, efﬁcient algorithms are needed to exploit this property. We will focus
on locally weighted learning (LWL) methods because
they allow us to adapt a variety of linear dimensionality-reduction techniques for the purpose of nonlinear function approximation (see section
3) and because they are easily modiﬁed for incremental learning. LWLrelated methods have also found widespread application in mixture models such that the results of this section can contribute to this ﬁeld
S. Vijayakumar, A. D’Souza, and S. Schaal
The learning problems considered here assume the standard regression
y = f (x) + ϵ,
where x denotes the N-dimensional input vector, y the (for simplicity) scalar
output, and ϵ a mean-zero random noise term. When only a local subset of
data in the vicinity of a point xc is considered and the locality is chosen
appropriately, a low-order polynomial can be employed to model this local
subset. Due to a favorable compromise between computational complexity
and quality of function approximation , we choose
linear models
y = βTx + ϵ.
A measure of locality for each data point, the weight wi, is computed from
a gaussian kernel,
wi = exp(−0.5(xi −xc)TD(xi −xc)),
and W ≡diag{w1, . . . , wM},
where D is a positive semideﬁnite distance metric that determines the size
and shape of the neighborhood contributing to the local model . The weights wi will enter all following algorithms to ensure
spatial localization in input space. Without loss of generality, we assume
zero mean of all inputs and outputs in our algorithms, which is ensured by
subtracting the weighted mean x or y from the data, where
and Mdenotes the number of data points. The input data are summarized in
the rows of the matrix X = [x1 x2, . . . , xM]T, the corresponding outputs are
the coefﬁcients of the vector y, and the corresponding weights, determined
from equation 2.2, are in the diagonal matrix W.
As candidate algorithms for local dimensionality reduction, we consider
two techniques, factor analysis and partial least squares regression. Factor analysis is a density estimation technique that assumes
that the observed data were generated from a lower-dimensional process,
characterized by k latent or hidden variables v that are all independently
distributed with mean zero and unit variance. The observed variables are
generated from the latent variables through the transformation matrix U
Incremental Online Learning in High Dimensions
and additive mean zero independent noise ϵ with diagonal covariance matrix Ω:
z = Uv + ϵ,
where E{ϵϵT} = Ωand E denotes the expectation operator. If both v and ϵ
are normally distributed, the parameters Ωand U can be obtained iteratively
by the expectation-maximization algorithm (EM) .
Factor analysis is superset for several dimensionality-reduction algorithms. For z = x and E{ϵϵT} = σ 2I, we obtain principal component analysis in input space . For the purpose of regression, the lower-dimensional representation v would serve as a new input
to the regression problem—an algorithm called principal component regression (PCR). However, it is well documented that PCR has the huge
danger of eliminating low-variance input dimensions that are nevertheless
crucial for the regression problem, thus leading to inferior function approximation results , the most powerful factor analysis algorithm for dimensionality reduction is obtained and requires an iterative EM solution. In
both joint-space formulations, the regression parameters β (cf. equation 2.1)
can be recovered by computing the expectation of p(y|x), which is obtained
from standard manipulations of the normally distributed joint distribution
p(x, v, y) . While empirical evaluation in Schaal et al.
 veriﬁed that the unconstrained (i.e., non-PCA) version of joint-space
factor analysis performs very well for regression, it also highlighted an important problem. As a density estimation method, factor analysis crucially
depends on representing the complete latent space v of the joint input vector
z; otherwise, performance degrades severely. Hence, even if there are input
dimensions that are irrelevant for the regression, they need to be represented
in the latent variable vector unless they are redundant with combinations
of other inputs. This property is problematic for our goals, as we expect a
large number of irrelevant inputs in high-dimensional learning problems.
The inferior performance of factor analysis when the latent space is underestimated also makes it hard to apply it in constructive algorithms—those
S. Vijayakumar, A. D’Souza, and S. Schaal
Table 1: Locally Weighted Implementation of Partial Least Squares Regression.
1. Initialize: Xres = X, yres = y
2. Repeat for r = 1 to R (No. of projections)
(a) ur = XTresWyres where W ≡diag{w1, . . . , wM} is the matrix of locality weights.
(b) βr = zT
r Wyres/(zT
r Wzr) where zr = Xresur.
(c) yres = yres −zrβr.
(d) Xres = Xres −zrpr T where pr = XTresWzr/ , one
particular algorithm, partial least squares regression (PLS) , achieved equally good and more robust results
than factor analysis for regression without any of the noted problems. PLS, a
technique extensively used in chemometrics, recursively computes orthogonal projections of the input data and performs single-variable regressions
along these projections on the residuals of the previous iteration step. Table 1
provides an outline of the PLS algorithm, derived here for implementing the
locally weighted version (LWPLS). The key ingredient in PLS is to use the
direction of maximal correlation between the residual error and the input
data as the projection direction at every regression step. Additionally, PLS
regresses the inputs of the previous step against the projected inputs z in
order to ensure the orthogonality of all the projections u (step 2d). Actually,
this additional regression could be avoided by replacing p with u in Step 2d,
similar to techniques used in principal component analysis .
However, using this regression step leads to better performance of the algorithm as PLS chooses the most effective projections if the input data have
a spherical distribution: in the spherical case, with only one projection, PLS
will ﬁnd the direction of the gradient and achieve optimal regression results.
The regression step in 2d chooses the reduced input data Xres such that the
resulting data vectors have minimal norms and, hence, push the distribution of Xres to become more spherical. An additional consequence of step 2d
is that all the projections zr become uncorrelated, that is, zT
j zr = 0 ∀j ̸= r, a
property that will be important in the derivations below.
Due to all these consideration, we will choose PLS as the basis for an
incremental nonlinear function approximator, which, in the next sections,
will be demonstrated to have appealing properties for nontrivial function
ﬁtting problems.
Incremental Online Learning in High Dimensions
3 Locally Weighted Projection Regression
For nonlinear function approximation, the core concept of our learning
system, locally weighted projection regression (LWPR), is to ﬁnd approximationsbymeansofpiecewiselinearmodels .Learning
involves automatically determining the appropriate number of local models
K, the parameters βk of the hyperplane in each model, and also the region
of validity, called receptive ﬁeld (RF), parameterized as a distance metric
Dk in a gaussian kernel (cf. equation 2.2):
2(x −ck)TDk(x −ck)
Given a query point x, every linear model calculates a prediction ˆyk(x). The
total output of the learning system is the normalized weighted mean of all
K linear models,
also illustrated in Figure 1. The centers ck of the RFs remain ﬁxed in order
to minimize negative interference during incremental learning that could
occur due to changing input distributions . Local
models are created on an as-needed basis as described in section 3.2. Table 2
provides a reference list of indices and symbols that are used consistently
across the description of the LWPR algorithm.
3.1 Learning with LWPR. Despite its appealing simplicity, the piecewise linear modeling approach becomes numerically brittle and computationally too expensive in high-dimensional input spaces when using ordinary linear regression to determine the local model parameters . Thus, we will use locally weighted partial least squares
regression within each local model to ﬁt the hyperplane. As a signiﬁcant
computational advantage, we expect that far fewer projections than the actual number of input dimensions are needed for accurate learning. The next
sections describe the necessary modiﬁcations of PLS for this implementation, embed the local regression into the LWL framework, explain a method
of automatic distance metric adaptation, and ﬁnish with a complete nonlinear learning scheme, called locally weighted projection regression (LWPR).
3.1.1 Incremental Computation of Projections and Local Regression. For incremental learning, that is, a scheme that does not explicitly store any training
data, the sufﬁcient statistics of the learning algorithm need to be accumulated in appropriate variables. Table 3 provides suitable incremental update
S. Vijayakumar, A. D’Souza, and S. Schaal
Linear Unit
Receptive Field
Correlation
Computation
Figure 1: Information processing unit of LWPR.
rules. The variables azz,r, azres,r, and axz,r are sufﬁcient statistics that enable
us to perform the univariate regressions in step 2c.1.2 and step 2c.2.2, similar
to recursive least squares, that is, a fast Newton-like incremental learning
technique. λ ∈ denotes a forgetting factor that allows exponential forgetting of older data in the sufﬁcient statistics. Forgetting is necessary in
incremental learning since a change of some learning parameters will affect
a change in the sufﬁcient statistics. Such forgetting factors are a standard
technique in recursive system identiﬁcation .
It can be shown that the prediction error of step 2b corresponds to the
leave-one-out cross-validation error of the current point after the regression
parameters were updated with the data point. Hence, it is denoted by ecv.
In Table 3, for R = N, that is, the same number of projections as the input
dimensionality, the entire input space would be spanned by the projections
ur and the regression results would be identical to that of ordinary linear
regression . However, once again, we emphasize the important
properties of the local projection scheme. First, if all the input variables are
statisticallyindependentandhaveequalvariance,3 PLSwillﬁndtheoptimal
3 It should be noted that we could insert one more preprocessing step in Table 3 that
independently scales all inputs to unit variance. Empirically, however, we did not notice
a signiﬁcant improvement of the algorithm, so we omit this step for simplicity.
Incremental Online Learning in High Dimensions
Table 2: Legend of Indexes and Symbols Used for LWPR.
Affectation
Number of training data points
Input dimensionality (i.e., dim. of x)
k = (1 : K)
Number of local models
r = (1 : R)
Number of local projections used by PLS
Training data
Lower-dimensional projection of input data xi(by PLS)
Elements of projected input zi
rth projection direction, i.e., zi,r = xT
Regressed input space to be subtracted to maintain
orthogonality of projection directions
Batch representations of input and projected data
Activation of data (x, y) on a local model centered at c
Weight matrix W ≡diag{w1, . . . , wM} representing
the activation due to all M data points
Sum of weights w seen by the local model after n data points
rth component of slope of the local linear model β ≡[β1 · · · βR]T
Sufﬁcient statistics for incremental computation of
rth dimension of variable var after seeing n data points.
projection direction ur in roughly a single sweep through the training data.
The optimal projection direction corresponds to the gradient of the local linearization parameters of the function to be approximated. Second, choosing
the projection direction from correlating the input and the output data in
step 2b.1 automatically excludes irrelevant input dimensions. And third,
there is no danger of numerical problems due to redundant input dimensions as the univariate regressions can easily be prevented from becoming
3.1.2 Adjusting the Shape and Size of Receptive Field. The distance metric D
and, hence, the locality of the receptive ﬁelds, can be learned for each local
model individually by stochastic gradient descent in a penalized leave-oneout cross-validation cost function ,
wi(yi −ˆyi,−i)2 + γ
where M denotes the number of data points in the training set. The ﬁrst
term of the cost function is the mean leave-one-out cross-validation error
of the local model (indicated by the subscript i, −i) which ensures proper
generalization . The second term, the penalty term,
makes sure that receptive ﬁelds cannot shrink indeﬁnitely in case of large
amounts of training data. Such shrinkage would be statistically correct for
S. Vijayakumar, A. D’Souza, and S. Schaal
Table 3: Incremental Locally Weighted PLS for One RF Centered at c.
1. Initialization: (# data points seen n = 0)
0 = 0, W0 = 0, u0
2. Incorporating new data: Given training point (x, y)
2a. Compute activation and update the means
1. w = exp(−1
2(x −c)TD(x −c));
Wn+1 = λWn + w
0 + wx)/Wn+1;
0 + wy)/Wn+1
2b. Compute the current prediction error
xres,1 = x −xn+1
, ˆy = βn+1
Repeat for r = 1 : R (# projections)
1. zr = xTres,run
2. ˆy ←ˆy + βn
3. xres,r+1 = xres,r −zrpn
r + w (y −ˆy)2
ecv = y −ˆy
2c. Update the local model
res1 = y −βn+1
For r = 1 : R (# projections)
2c.1 Update the local regression and compute residuals
zz,r = λ an
zz,r + w z2
zres,r = λ anzres,r + w zr resr
zres,r/an+1
3. resr+1 = resr −zrβn+1
xz,r = λ an
xz,r + wxres,rzr
2c.2 Update the projection directions
r + wxres,r resr
e = resr+1
3. Predicting with novel data (xq): Initialize: yq = β0, xq = xq −x0
Repeat for r = 1 : R
• yq ←yq + βrsr where sr = uT
• xq ←xq −srpn
Note: The subscript k referring to the kth local model is omitted throughout
this table since we are referring to updates in one local model or RF.
asymptotically unbiased function approximation, but it would require
maintaining an ever increasing number of local models in the learning system, which is computationally too expensive. The trade-off parameter γ can
be determined either empirically or from assessments of the maximal local
curvature of the function to be approximated ; in
general, results are not very sensitive to this parameter , as it primarily affects resource efﬁciency—when input and output
data are preprocessed to have unit variance, γ can be kept constant, for example, at γ = 1e −7 as in all our experiments. It should be noted that due to
Incremental Online Learning in High Dimensions
the local cost function in equation 3.3, learning becomes entirely localized
too; no parameters from other local models are needed for updates as, for instance, in competitive learning with mixture models. Moreover, minimizing
equation 3.3 can be accomplished in an incremental way without keeping
data in memory . This property is due to a reformulation of the leave-one-out cross-validation error as the PRESS residual error
 . As detailed in Schaal and Atkeson the
bias-variance trade-off is thus resolved for every local model individually
such that an increasing number of local models will not lead to overﬁtting.
Indeed, it leads to better approximation results due to model averaging (see
equation 3.2) in the sense of committee machines .
In ordinary weighted linear regression, expanding equation 3.3 with the
PRESS residual error results in
wi(yi −ˆyi)2
wherePcorrespondstotheinvertedweightedcovariancematrixoftheinput
data. Interestingly, we found that the PRESS residuals of equation 3.4 can be
exactly formulated in terms of the PLS projected inputs zi ≡[zi,1 . . . zi,R]T
(cf. Table 3) as
wi(yi −ˆyi)2
where Pz corresponds to the inverse covariance matrix computed from the
projected inputs zi for R = N, that is, the zi’s spans the same full-rank
input space4 as xi’s in equation 3.4 (cf. the proof in appendix A). It can also
been proved, as explained in appendix A, that Pz is diagonal, which greatly
contributestothecomputationalefﬁciencyofourupdaterules.Basedonthis
cost function, the distance metric in LWPR is learned by gradient descent,
Mn+1 = Mn −α ∂J
∂M where D = MTM (for positive deﬁniteness)
where M is an upper triangular matrix resulting from a Cholesky decomposition of D. Following Schaal and Atkeson , a stochastic approximation of the gradient ∂J
∂M of equation 3.5 can be derived by keeping track
4 For rank-deﬁcient input spaces, the equivalence of equations 3.4 and 3.5 holds in the
subspace spanned by X.
S. Vijayakumar, A. D’Souza, and S. Schaal
Table 4: Derivatives for Distance Metric Update.
For the current data point x, its PLS projection z and activation w:
∂M (stochastic update of equation 3.5)
2 w(x −c)T ∂D
(x −c); ∂J2
= Mkjδil + Mkiδjl; where δi j = 1 if i = j else δi j = 0.
Wn+1 q2Tan
H + w ecvz
(1 −h) ; an+1
(1 −h) where h = wzTq
Note: Refer to Table 3 for some of the variables.
of several sufﬁcient statistics, as shown in Table 4. It should be noted that
in these update laws, we treated the PLS projection direction, and hence, z,
as if it were independent of the distance metric, such that chain rules need
not be taken throughout the entire PLS recursions. Empirically, this simpli-
ﬁcation did not seem to have any negative impact and reduced the update
rules signiﬁcantly.
3.2 The Complete LWPR Algorithm. All update rules can be combined in an incremental learning scheme that automatically allocates new
locally linear models as needed. The concept of the ﬁnal learning network is
illustrated in Figure 1, and an outline of the ﬁnal LWPR algorithm is shown
in Table 5.
In this pseudocode, wgen is a threshold that determines when to create
a new receptive ﬁeld, as discussed in Schaal and Atkeson . wgen is a
computational efﬁciency parameter and not a complexity parameter as in
mixture models. The closer wgen is set to 1, the more overlap local models
will have, which is beneﬁcial in the spirit of committee machines but more costly to compute. In
general, the more overlap is permitted, the better the function-ﬁtting results,
without any danger that the increase in overlap can lead to overﬁtting.
Ddef is the initial (usually diagonal) distance metric in equation 3.1. The
initial number of projections is set to R = 2. The algorithm has a simple
Incremental Online Learning in High Dimensions
Table 5: Pseudocode of the Complete LWPR Algorithm.
• Initialize the LWPR with no receptive ﬁeld (RF).
• For every new training sample (x,y):
– For k = 1 to K(number of receptive ﬁelds):
∗Calculate the activation from equation 3.1
∗Update projections and regression (see Table 3) and distance metric (see Table 4)
∗Check if number of projections needs to be increased (cf. section 3.2)
– If no RF was activated by more than wgen;
∗Create a new RF with R = 2, c = x, D = Ddef
mechanism of determining whether R should be increased by recursively
keeping track of the mean-squared error (MSE) as a function of the number
of projections included in a local model—step 2b.4 in Table 3. If the MSE at
the next projection does not decrease more than a certain percentage of the
previous MSE, MSEr+1
> φ, where φ ∈ , the algorithm will stop adding
new projections locally. As MSEr can be interpreted as an approximation
of the leave-one-out cross-validation error of each projection, this threshold
criterion avoids problems due to overﬁtting. Due to the need to compare
the MSE of two successive projections, LWPR needs to be initialized with
at least two projection dimensions. A comparison of these mechanisms of
constructive learning with previous algorithms in the literature can be found in Schaal and Atkeson .
3.2.1 Speed-Up for Learning from Trajectories. If in incremental learning,
training data are generated from trajectories (i.e., data are temporally correlated), it is possible to accelerate lookup and training times by taking advantage of the fact that two consecutively arriving training points are close
neighbors in input space. For such cases, we added a special data structure
to LWPR that allows restricting updates and lookups to only a small fraction
of local models instead of exhaustively sweeping through all of them. For
this purpose, each local model maintains a list of all other local models that
overlap sufﬁciently with it. Sufﬁcient overlap between two models i and j
canbedeterminedfromthecentersanddistancemetrics.Thepointxininput
space that is the closest to both centers in the sense of a Mahalanobis distance is x = (Di + D j)−1(Dici + D jc j). Inserting this point into equation 3.1
of one of the local models gives the activation w due to this point. The two
local models are listed as sufﬁciently overlapping if w ≥wgen (cf. Table 5).
For diagonal distance metrics, the overlap computation is linear in the number of inputs. Whenever a new data point is added to LWPR, one neighborhood relation is checked for the maximally activated RF. An appropriate
counter for each local model ensures that overlap with all other local models
is checked exhaustively. Given this nearest-neighbor data structure, lookup
and learning can be conﬁned to only a few RFs. For every lookup (update), the identiﬁcation number of the maximally activated RF is returned.
S. Vijayakumar, A. D’Souza, and S. Schaal
The next lookup (update) will consider only the neighbors of this RF. It
can be shown that this method is as good as an exhaustive lookup (update) strategy that excludes RFs that are activated below a certain threshold
3.2.2 Pruning of Local Models. As in the RFWR algorithm , it is possible to prune local models depending on the level
of overlap between two local models or the accumulated locally weighted
mean-squared error. The pruning strategy is virtually identical to that in
 . However, due to the numerical robustness of PLS, we have noticed that the need for pruning or merging is almost
nonexistent in the LWPR implementation, such that we do not expand on
this possible feature of the algorithm.
3.2.3 Computational Complexity. For a diagonal distance metric D and
under the assumption that the number of projections R remains small and
bounded, the computational complexity of one incremental update of all
parameters of LWPR is linear in the number of input dimensions N. To
the best of our knowledge, this property makes LWPR one of the computationally most efﬁcient algorithms that have been suggested for highdimensional function approximation. This low-computational complexity
sets LWPR apart from our earlier work on the RFWR algorithm , which was cubic in the number of input dimensions. We
thus accomplished one of our main goals: maintaining the appealing function approximation properties of RFWR while eliminating its problems in
high-dimensional learning problems.
3.2.4 Conﬁdence Intervals. Under the classical probabilistic interpretation
of weighted least squares , that each
local model’s conditional distribution is normal with heteroscedastic variances p(y|x; wk) ∼N(zk Tβk, sk2/wk), it is possible to derive the predictive
variances σ 2
pred,k for a new query point xq for each local model in LWPR.5
The derivation of this measure is in analogy with ordinary linear regression and is also consistent with the
Bayesian formulation of predictive variances . For each
individual local model, σ 2
pred,k can be estimated as (refer to Tables 4 and 3 for
variable deﬁnitions):
pred,k = s2
5 Note that wk is used here as an abbreviated version of w{q,k}—the weight contribution
due to query point q in model k—for simplicity.
Incremental Online Learning in High Dimensions
where zq,k is the projected query point xq under the kth local model, and
2 ≈MSE n=M
k,iqk,i ≈an=M
with incremental update of
The deﬁnition of M′ in terms of the sum of weights reﬂects the effective
number of data points entering the computation of the local variance sk2
 after an update of M training points has been performed. The deﬁnition of p′, also referred to as the local degrees of freedom,
is analogous to the global degrees of freedom of linear smoothers .
In order to obtain a predictive variance measure for the averaging formula (equation 3.2), one could just compute the weighted average of the
predictive variance in equation 3.7. While this approach is viable, it nevertheless ignores important information that can be obtained from variance
across the individual predictions ˆyq,k and is thus potentially too optimistic.
To remedy this issue, we postulate that from the view of combining individual ˆyq,k, each contributing yq,k was generated from the process
yq,k = yq + ϵ1 + ϵ2,k,
where we assume two separate noise processes: (1) one whose variance σ 2 is
independent of the local model, that is, ϵ1 ∼N(0, σ 2/wk) (and accounts for
the differences between the predictions of the local models) and (2) another,
which is the noise process ϵ2,k ∼N(0, σ 2
pred,k/wk) of the individual local models. It can be shown (see appendix B) that equation 3.2 is a consistent way of
combining prediction from multiple models under the noise model we just
described and that the combined predictive variance over all models can be
approximated as
The estimate of σpred,k is given in equation 3.7. The global variance across
models can be approximated as σ 2 = 
k wk( ˆyq −ˆyk,q)2/ 
k wk. Inserting
these values in equation 3.8, we obtain:
( ˆyq −ˆyk,q)2 + s2
S. Vijayakumar, A. D’Souza, and S. Schaal
GP confidence bounds
LWPR confidence bounds
Figure 2: Function approximation with 200 noisy data points along with plots
of conﬁdence intervals for (A) gaussian process regression and (B) LWPR algorithms. Note the absence of data in the range [0.5 1.5].
A one-standard-deviation-based conﬁdence interval would thus be
Ic = ˆyq ± σpred.
The variance estimate in equation 3.8 is consistent with the intuitive requirement that when only one local model contributes to the prediction,
the variance is entirely attributed to the predictive variance of that single
model. Moreover, a query point that does not receive a high weight from any
local model will have a large conﬁdence interval due to the small squared
sum-of-weight value in the denominator. Figure 2 illustrates comparisons of
conﬁdence interval plots on a toy problem with 200 noisy data points. Data
from the range [0.5 1.5] were excluded from the training set. Both gaussian
process regression and LWPR show qualitatively similar conﬁdence interval
bounds and ﬁtting results.
4 Empirical Evaluation
The following sections provide an evaluation of our proposed LWPR learning algorithm over a range of artiﬁcial and real-world data sets. Whenever
useful and feasible, comparisons to state-of-the-art alternative learning algorithms are provided, in particular, support vector regression (SVM) and
gaussian process regression (GP). SVMR and GPR were chosen due to their
generally acknowledged excellent performance in nonlinear regression on
ﬁnite data sets. However, it should be noted that both SVM and GP are batch
learning systems, while LWPR was implemented as a fully incremental algorithm, as described in the previous sections.
Incremental Online Learning in High Dimensions
Figure 3: (A) Target and (B) learned nonlinear cross function.
4.1 Function Approximation with Redundant and Irrelevant Data. We
implemented LWPR algorithm as outlined in section 3. In each local model,
the projection regressions are performed by (locally weighted) PLS, and the
distance metric D is learned by stochastic incremental cross validation; all
learning methods employed second-order learning techniques; incremental PLS uses recursive least squares, and gradient descent in the distance
metric was accelerated as described in Schaal and Atkeson . In all our
evaluations, an initial (diagonal) distance metric of Ddef = 30I was chosen,
the activation threshold for adding local models was wgen = 0.2, and the
threshold for adding new projections was φ = 0.9 (cf. section 3.2).
As a ﬁrst test, we ran LWPR on 500 noisy training data drawn
from the two-dimensional function (Cross 2D) generated from y =
max{exp(−10x2
1), exp(−50x2
2, 1.25exp(−5(x2
2)))} + N(0, 0.01), as shown
in Figure 3A. This function has a mixture of areas of rather high and rather
low curvature and is an interesting test of the learning and generalization
capabilities of a learning algorithm: learning models with low complexity ﬁnd it hard to capture the nonlinearities accurately, while more complex models easily overﬁt, especially in linear regions. A second test added
eight constant (i.e., redundant) dimensions to the inputs and rotated this
new input space by a random 10-dimensional rotation matrix to create a
10-dimensional input space with high-rank deﬁciency (Cross 10D). A third
test added another 10 (irrelevant) input dimensions to the inputs of the second test, each having N(0, 0.052) gaussian noise, thus obtaining a data set
with 20-dimensional input space (Cross 20D). Typical learning curves with
these data sets are illustrated in Figure 4. In all three cases, LWPR reduced
the normalized mean squared error (thick lines) on a noiseless test set (1681
points on a 41 × 41 grid in the unit-square in input space) rapidly in 10
to 20 epochs of training to less than nMSE = 0.05, and it converged to the
S. Vijayakumar, A. D’Souza, and S. Schaal
nMSE on Test Set
#Receptive Fields/Average #Projections
#Training Data Points
Figure 4: Learning curves for 2D, 10D, and 20D data for cross approximation.
excellent function approximation result of nMSE = 0.015 after 100,000 data
presentations or 200 epochs.6 Figure 5 shows the adapted distance metric,
while Figure 3B illustrates the reconstruction of the original function from
the 20-dimensional test data, visualized in 3D, a highly accurate approximation. The rising thin lines in Figure 4 show the number of local models
that LWPR allocated during learning. The very thin lines at the bottom of
the graph indicate the average number of projections that the local models
allocated: the average settled at a value of around two local projections,
as is appropriate for this originally two-dimensional data set. This set of
tests demonstrates that LWPR is able to recover a low-dimensional nonlinear function embedded in high-dimensional space despite irrelevant and
redundant dimensions and that the data efﬁciency of the algorithm does
not degrade in higher-dimensional input spaces. The computational complexity of the algorithm increased only linearly with the number of input
dimensions, as explained in section 3.
The results of this evaluations can be directly compared with our earlier work on the RFWR algorithm , in particular
Figures 4 and 5 of this earlier article. The learning speed and the number
of allocated local models for LWPR is essentially the same as for RFWR
in the 2D test set. Applying RFWR to the 10- and 20-dimensional data set
6 Since LWPR is an incremental algorithm, data presentations in this case refer to
repeated random-order presentations of training data from our noisy data set of size 500.
Incremental Online Learning in High Dimensions
Figure 5: The automatically tuned distance metric for the cross approximation.
of this article, however, is problematic, as it requires a careful selection of
initial ridge regression parameters to stabilize the highly rank-deﬁcient full
covariance matrix of the input data, and it is easy to create too much bias or
too little numerical stabilization initially, which can trap the local distance
metric adaptation in local minima. While the LWPR algorithm just computes
about a factor 10 times longer for the 20D experiment in comparison to the
2D experiment, RFWR requires a 1000-fold increase of computation time,
thus rendering this algorithm unsuitable for high-dimensional regression.
In order to compare LWPR’s results to other popular regression methods,
we evaluated the 2D, 10D, and 20D cross data sets with gaussian process regression (GP) and support vector (SVM) regression in addition to our LWPR
method. It should be noted that neither SVM nor GP methods is an incremental method, although they can be considered state-of-the-art for batch
regression under relatively small numbers of training data and reasonable
input dimensionality. The computational complexity of these methods is
prohibitively high for real-time applications. The GP algorithm used a generic covariance function and optimized over the
hyperparameters. The SVM regression was performed using a standard
available package and optimized for kernel choices.
Figure 6 compares the performance of LWPR and gaussian processes for
the above-mentioned data sets using 100, 300, and 500 training data points.7
As in Figure 3 the test data set consisted of 1681 data points corresponding
to the vertices of a 41 × 41 grid over the unit square; the corresponding
output values were the exact function values. The approximation error was
7 We have not plotted the results for SVM regression since it was found to consistently
perform worse than GP regression for the given number of training data.
S. Vijayakumar, A. D’Souza, and S. Schaal
100 points
300 points
500 points
Cross 2 Dim.
GaussProcess
100 points
300 points
500 points
Cross 10 Dim.
100 points
300 points
500 points
Cross 20 Dim.
Figure 6: Normalized mean squared error comparisons between LWPR and
gaussian processes for 2D, 10D, and 20D Cross data sets.
measured as a normalized weighted mean squared error, nMSE, that is, the
weighted MSE on the test set normalized by the variance of the outputs of
the test set. The weights were chosen as 1/σ 2
pred,i for each test point xi. Using
such a weighted nMSE was useful to allow the algorithms to incorporate
their conﬁdence in the prediction of a query point, which is especially useful
for training data sets with few data points where query points often lie far
away from any training data and require strong extrapolation to form a
prediction. Multiple runs on 10 randomly chosen training data sets were
performed to accumulate the statistics.
As can be seen from Figure 6, the performance differences of LWPR and
GP were largely statistically insigniﬁcant across training data sizes and input dimensionality. LWPR had a tendency to perform slightly better on the
100-point data sets, most likely due to its quickly decreasing conﬁdence
when signiﬁcant extrapolation is required for a test point. For the 300-point
data sets, GP had a minor advantage and less variance in its predictions,
while for 500-point data sets, both algorithms achieved equivalent results.
While GPs used all the input dimensions for predicting the output (deduced from the ﬁnal converged coefﬁcients of the covariance matrix), LWPR
stopped at an average of two local projections, reﬂecting that it exploited
the low-dimensional distribution of the data. Thus, this comparison illustrates that LWPR is a highly competitive learning algorithm in terms of its
generalization capabilities and accuracy of results, in spite of its’ being a
truly incremental, computationally efﬁcient and real-time implementable
algorithm.
4.2 Comparisons on Benchmark Regression Data Sets. While LWPR
is speciﬁcally geared toward real-time incremental learning in high dimensions, it can nevertheless also be employed for traditional batch data analysis. Here we compare its performance on two natural real-world benchmark
data sets, again using gaussian processes and support vector regression as
competitors.
Incremental Online Learning in High Dimensions
Table 6: Comparison of Normalized Mean Squared Errors on Boston and
Abalone Data Sets.
Gaussian Process
Support Vectors
0.0806 ± 0.0195
0.1115 ± 0.09
0.0846 ± 0.0225
0.4440 ± 0.0209
0.4830 ± 0.03
0.4056 ± 0.0131
The data sets we used were the Boston Housing data and the Abalone
data set, both available from the UCI Machine Learning Repository . The Boston Housing data, which had 14 attributes, was split
randomly (10 random splits) into disjoint sets of 404 training and 102 testing
data. The Abalone data set, which had 9 attributes, was downsampled to
yield 10 disjoint sets of 500 training data points and 1177 testing points.8
The GP used hyperparameter estimation for the open parameters of the
covariance matrix, while for SVM regression, the results were obtained
by employing a gaussian kernel of width 3.9 and 10 for the Boston and
Abalone data sets, respectively, based on the optimized values suggested in
Sch¨olkopf, Smola, Williamson, & Bartlett . Table 6 shows the comparisons of the normalized mean squared error (nMSE) achieved by GP, SVM,
and LWPR on both data sets. Once again, LWPR was highly competitive on
these real-world data sets, consistently outperforming SVM regression and
achieving very similar nMSE results as GP regression.
4.3 Sensorimotor Learning in High-Dimensional Space. In this section, we look at the application of LWPR to real-time learning in highdimensional spaces in a data-rich environment, an example of which is
learning for robot control. In such domains, LWPR is (to the best of our
knowledge) one of the only viable and practical options for principled statistical learning. The goal of learning in this evaluation is to estimate the
inverse dynamics model (also referred to as an internal model) of the robotic
system such that it can be used as a component of a feedforward controller
for executing fast, accurate movements. The inverse dynamics model is
a mapping from joint position, joint velocity, and joint acceleration to joint
torques, a function with three times the number of degrees of freedom (DOF)
as input dimensionality.
We implemented LWPR on the real-time operating system (vx-Works)
for the Sarcos humanoid robot in Figure 7A, a 30 DOF system, which used
its right hand to draw a lying ﬁgure 8 pattern. Out of the four parallel
8 The gaussian process algorithm had problems of convergence and numerical stability
for training data sizes above 500 points. However, a more comprehensive computation
can be carried out by using techniques from Williams and Seeger to scale up the
GP results, as pointed out by one of the reviewers.
S. Vijayakumar, A. D’Souza, and S. Schaal
x displacement (in meters)
z displacement (in meters)
Traj_desired
Traj_nouff
Figure 7: (A) The 30-DOF SARCOS humanoid robot. (B) Results of online learning of the inverse dynamics with LWPR on the humanoid robot.
processors of the system, one 366 Mhz PowerPC processor was completely
devoted to lookup and learning with LWPR. In order to accelerate lookup
and training times, the nearest-neighbor data lookup described in section
3.2.1 was used. Learning of the inverse dynamics model required learning in
a 90-dimensional input space and the outputs were the 30 torque commands
for each of the DOFs. Ideally, we would learn one individual LWPR model
for each of the 30 output dimensions. However, as the learning of 30 parallel
LWPR models would have exceeded the computational power of our 366
Mhz real-time processors, we chose to learn one single LWPR model with
a 30-dimensional output vector: each projection of PLS in LWPR regressed
all outputs versus the projected input data. The projection direction was
chosen as the mean projection across all outputs at each projection stage
of PLS. This approach is suboptimal, as it is quite unlikely that all output
dimensions agree on one good projection direction; essentially, one assumes
that the gradients of all outputs point roughly into the same direction. On
the other hand, as D’Souza et al. demonstrated that movement data
of actual physical movement systems lie on locally low-dimensional distributions, one can hope that LWPR with multiple outputs can still work
successfully by simply spanning this locally low-dimensional input space
with all projections.
The LWPR model was trained online while the robot performed a
pseudo–randomly drifting ﬁgure 8 pattern in front of its body. Lookup proceeded at 480 Hz, while updating the learning model was achieved at about
70 Hz. After 10 seconds of training, learning was stopped, and the robot
Incremental Online Learning in High Dimensions
attempted to draw a planar ﬁgure 8 in the x −z plane of the robot endeffector at 2 Hz frequency for the entire pattern. The same test pattern was
also performed after 300 seconds of training. Figure 7B demonstrates the result of learning. In this ﬁgure, Trajdesired denotes the desired ﬁgure 8 pattern;
Traj10 is the LWPR learning result after 10 seconds of training; and Traj300
is the result after 300 seconds of training. The Trajnouff trace demonstrates
the ﬁgure 8 patterns performed without any inverse dynamics model, just
using a low-gain negative feedback (proportional-derivative (PD)) controller. LWPR rapidly improves over a control system with no inverse dynamics controller; within 10 seconds of movement, the most signiﬁcant
inertial and gravity perturbation have been compensated. Convergence to
low error tracking of the ﬁgure 8 takes slightly longer—about 300 seconds
 signiﬁcantly in terms of its
average tracking error of the desired trajectory. This rigid dynamics model
was estimated from about 1 hour of data collection and 30 minutes off-line
processing of the data. These results are the ﬁrst that demonstrate an actual
implementation of real-time inverse dynamics learning on such a robot of
this complexity.
4.3.1 Online Learning for Autonomous Airplane Control. The online learning abilities of LWPR are ideally suited to be incorporated in algorithms
of provably stable adaptive control. The control theoretic development of
such an approach was presented in Nakanishi, Farrell, and Schaal . In
essence, the problem formulation begins with a speciﬁc class of equations
of motion of the form
˙x = f (x) + g(x)u,
where x denotes the state of the control system, the control inputs, and f (x)
and g (x) are nonlinear function to approximated. A suitable control law for
such a system is
u = ˆg (x)−1 (−ˆf (x) + ˙xc + K (xc −x)),
where xc, ˙xc are a desired reference trajectory to be tracked, and the “hat”
notation indicates that these are the approximated version of the unknown
We applied LWPR in this control framework to learn the unknown function f and g for the problem of autonomous airplane control on a high-
ﬁdelity simulator. For simplicity, we considered only a planar version of the
S. Vijayakumar, A. D’Souza, and S. Schaal
airplane, governed by the differential equation :
m (T cos α −D) −g sin γ
mV (L + T sin α) + g cos γ
In these equations, V denotes the forward speed of the airplane, m the mass,
T the thrust, α the angle of attack, g the gravity constant, γ the ﬂight path
anglewithregardtothehorizontalworldcoordinatesystemaxis, Qthepitch
rate, and c an inertial constant. The complexity of these equations is hidden
in D, L, and M, which are the unknown highly nonlinear aerodynamic
lift force, drag force, and pitch moment terms, which are speciﬁc to every
While we will not go into the detail of provably stable adaptive control
with LWPR in this letter and how the control law 4.2 is applied for airplane
control, from the viewpoint of learning, the main components to learn are
the lift and drag forces, and the pitch moment. These can be obtained by
rearranging equation 4.3 to:
D = T cos α −
˙V + g sin γ
= fD (α, Q, V, M, γ, δOFL, δOFR, δMFL, δMFR, δSPL, δSPR)
mV −T sin α
= fL (α, Q, V, M, γ, δOFL, δOFR, δMFL, δMFR, δSPL, δSPR)
c = fM (α, Q, V, M, γ, δOFL, δOFR, δMFL, δMFR, δSPL, δSPR) .
The δ terms denote the control surface angles of the airplane, with indices
Midboard-Flap-Left/Right (MFL, MFR), Outboard-Flap-Left/Right (OFL,
OFR), and left and right spoilers (SPL, SPR). All terms on the right-hand
side of equation 4.4 are known, such that we have to cope with three simultaneous function approximation problems in an 11-dimensional input
space, an ideal application for LWPR.
We implemented LWPR for the three functions above in a high-ﬁdelity
simulink simulation of an autonomous airplane using the adaptive control approach of Nakanishi et al. . The airplane started with no initial knowledge, just the proportional controller term in equation 4.2 (the
term multiplied by K). The task of the controller was to ﬂy doublets—
Incremental Online Learning in High Dimensions
Figure 8: LWPR learning results for adaptive learning control on a simulated
autonomous airplane. (A) Tracking of ﬂight angle: γ . (B) Approximation of
lift force: D. (C) Approximation of drag force: L. (D) Approximation of pitch
moment: M. At 400 seconds into the ﬂight, a failure is simulated that locks one
control surface to a 17 degree angle. Note that for clarity of presentation, an axis
break was inserted after 200 seconds.
up-and-down trajectories that are essentially sinusoidlike variations of the
ﬂight path angle γ .
Figure 8 demonstrates the results of this experiment. Figure 8A shows
the desired trajectory in γ and its realization by the controller. Figures 8B,
8C, and 8D illustrate the online function approximation of D, L, and M. As
can be seen, the control of γ achieves almost perfect tracking after just a few
seconds. The function approximations of D and L are very accurate after a
very short time. The approximation M requires longer for convergence but
S. Vijayakumar, A. D’Souza, and S. Schaal
progresses quickly. About 10 local models were needed for learning fD and
fL, and about 20 local models were allocated for fM.
An interesting element of Figure 8 happens after 400 seconds of ﬂight,
where we simulated a failure of the airplane mechanics by locking the MFR
to a 17 degree deﬂection. As can be seen, the function approximators very
quickly reorganize after this change, and the ﬂight is successfully continued,
although γ tracking has some error for a while until it converges back to
good tracking performance. The strong signal changes in the ﬁrst seconds
after the failure are due to oscillations of the control surfaces, not a problem
in function approximation. Without adaptive control, the airplane would
have crashed.
5 Discussion
Nonlinear regression with spatially localized models remains one of the
most data-efﬁcient and computationally efﬁcient methods for incremental
learning with automatic determination of the model complexity. In order
to overcome the curse of dimensionality of local learning systems, this article investigated methods of linear projection regression and how to employ them in spatially localized nonlinear function approximation for highdimensional input data with redundant and irrelevant components. Due to
its robustness in such a setting, we chose partial least squares regression
at the core of a novel function approximator, locally weighted projection
regression (LWPR). The proposed technique was evaluated on a range of
artiﬁcial and real-world data sets in up to 90-dimensional input spaces. Besides showing fast and robust learning performance due to second-order
learning methods based on stochastic leave-one-out cross validation, LWPR
excelled by its low computational complexity: updating each local model
with a new data point remained linear in its computational cost in the number of inputs since the algorithm accomplishes good approximation results
with only three to four projections irrespective of the number of input dimensions. To our knowledge, this is the ﬁrst spatially localized incremental learning system that can efﬁciently work in high-dimensional spaces
and is thus suited for online and real-time applications. In addition, LWPR
compared favorably in its generalization performance with state-of-the-art
batch regression regression methods like gaussian process regression and
can provide qualitatively similar estimates of conﬁdence bounds and predictive variances.
The major drawback of LWPR in its current form is the need for gradient descent to optimize the local distance metrics in each local model, and
the manual tuning of a forgetting factor as required in almost all recursive
learning algorithms that accumulate sufﬁcient statistics. Future work will
derive a probabilistic version of partial least squares regression that will
allow a complete Bayesian treatment of locally weighted regression with
locally linear models, with, we hope, no remaining open parameters for
Incremental Online Learning in High Dimensions
manual adjustment. Whether a full Bayesian version of LWPR can achieve
the same computational efﬁciency as in the current implementation, however, remains to be seen.
Appendix A: PRESS Residuals for PLS
We prove that under the assumption that x lives in a reduced dimensional
subspace, the PRESS residuals of equation 3.4 can indeed be replaced by the
residual denoted by equation 3.5,
i Pxi = zT
where P = (XTX)†, Pz = (ZTZ)−1 corresponds to the (pseudo)inverse covariance matrices and the symbol † represents the SVD pseudoinverse that generates a solution to the inverse in the embedded lower-dimensional manifold of x with minimum
norm solution in the sense of a Mahalanobis distance.
(Refer to Table 1 for the batch notations.)
Part 1. Let T be the transformation matrix with full rank in row space that
denotes coordinate transformation from the rank-deﬁcient space of x to the
full rank space of z. Then for any z = TTx and the corresponding inverse
covariance matrix Pz, we can show that
i Pzzi = xT
i T((XT)T(XT))−1TTxi = xT
i (XTX)†xi = xT
A linear transformation maintains the norm.
Part 2. In this part, we show that the recursive PLS projections that transform the inputs x to z can be written as a linear transformation matrix, which
completes our proof. Clarifying some of the notation:9
≡[˜z1 . . . ˜zR].
We now look at each of the R PLS projection directions and attempt to show
that zi = TTxi or (in a batch sense) Z = XT by showing (for each individual
projections) r, there exists a tr such that
˜zr = Xtr, where T = [t1 t2 . . . tr].
9 Here, we have used z and ˜z to distinguish between the row vectors and the column
vectors, respectively, of the projected data matrix Z.
S. Vijayakumar, A. D’Souza, and S. Schaal
For r = 1 (cf. Table 1),
˜z1 = XXTy = Xt1, where t1 = XTy.
For r = 2 (cf. Table 1),
˜z2 = XresXT
We also know from the algorithm (cf. Table 1) that
Xres = X −˜z1˜zT
yres = y −˜z1˜zT
y = P˜z1y,
where P˜z1 represents a projection operator. Using results from equations A.7
and A.8 in equation A.6,
s2 = P˜z1X(P˜z1X)T P˜z1y
= P˜z1XXT P˜z1y . . . using property of projection operator: P˜z1 = PT
= P˜z1 P˜z1 = P˜z1Xt′
It can be shown easily by writing out the pseudo-inversion that there exists
an operator R2 = (I −u1ut
1 XTXu1) such that
P˜z1X = XR2.
Using equations A.9 and A.10, we can write
˜z2 = Xt2 where t2 = R2t′
This operation can be carried out recursively to determine all the tk, showing that the PLS projections can be written as a linear transformation.
This completes the proof of the validity of the modiﬁed PRESS residual of
equation A.1 for PLS projections.
Also note that, Pz is diagonal by virtue of the fact that in the PLS algorithm, after every projection iteration, the projected components of input
space X are subtracted before computing the next projection (Table 1d or
Table 3 2b.3), ensuring the next component of Z will always be orthogonal
to the previous ones. This property was discussed in Frank and Friedman
Incremental Online Learning in High Dimensions
Appendix B: Combined Predictive Variances
The noise model for combining prediction from individual local model is
yq,k = yq + ϵ1 + ϵ2,k,
where ϵ1 ∼N(0, σ 2/wk) and ϵ2,k ∼N(0, σ 2
pred,k/wk). The mean prediction due
to multiple local models can be written according to a heteroscedastic average,
k wk ˆyq,k
under the assumption that (σ 2 + σ 2
pred,k) is approximately constant for all
contributing models k and that ˆyq,k is an estimate over multiple noisy instances of yq,k that has averaged out the noise process ϵ2,k—exactly what
happens within each local model. Thus, equation B.1 is consistent with
equation 3.2 under the proposed dual noise model. The combined predictive variance can now be derived as
−(E{yq})2 = E
Using the fact that E{x2} = (E{x})2 + var(x) and noting that ϵ1 and ϵ2,k have
zero mean,
S. Vijayakumar, A. D’Souza, and S. Schaal
which gives the expression for the combined predictive variances.