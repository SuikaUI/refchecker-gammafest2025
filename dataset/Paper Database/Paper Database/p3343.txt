Image Super-Resolution Using Deep
Convolutional Networks
Chao Dong, Chen Change Loy, Member, IEEE, Kaiming He, Member, IEEE,
and Xiaoou Tang, Fellow, IEEE
Abstract—We propose a deep learning method for single image super-resolution (SR). Our method directly learns an end-to-end
mapping between the low/high-resolution images. The mapping is represented as a deep convolutional neural network (CNN) that takes
the low-resolution image as the input and outputs the high-resolution one. We further show that traditional sparse-coding-based SR
methods can also be viewed as a deep convolutional network. But unlike traditional methods that handle each component separately,
our method jointly optimizes all layers. Our deep CNN has a lightweight structure, yet demonstrates state-of-the-art restoration quality,
and achieves fast speed for practical on-line usage. We explore different network structures and parameter settings to achieve tradeoffs between performance and speed. Moreover, we extend our network to cope with three color channels simultaneously, and show
better overall reconstruction quality.
Index Terms—Super-resolution, deep convolutional neural networks, sparse coding
INTRODUCTION
Single image super-resolution (SR) , which aims at
recovering a high-resolution image from a single lowresolution image, is a classical problem in computer
vision. This problem is inherently ill-posed since a multiplicity of solutions exist for any given low-resolution
pixel. In other words, it is an underdetermined inverse problem, of which solution is not unique. Such
a problem is typically mitigated by constraining the
solution space by strong prior information. To learn
the prior, recent state-of-the-art methods mostly adopt
the example-based strategy. These methods either
exploit internal similarities of the same image , ,
 , , , or learn mapping functions from external
low- and high-resolution exemplar pairs , , ,
 , , , , , , , , , . The
external example-based methods can be formulated for
generic image super-resolution, or can be designed to
suit domain speciﬁc tasks, i.e., face hallucination ,
 , according to the training samples provided.
The sparse-coding-based method , is one of the
representative external example-based SR methods. This
method involves several steps in its solution pipeline.
First, overlapping patches are densely cropped from the
input image and pre-processed (e.g.,subtracting mean
and normalization). These patches are then encoded
by a low-resolution dictionary. The sparse coefﬁcients
are passed into a high-resolution dictionary for reconstructing high-resolution patches. The overlapping re-
• C. Dong, C. C. Loy and X. Tang are with the Department of Information
Engineering, The Chinese University of Hong Kong, Hong Kong.
E-mail: {dc012,ccloy,xtang}@ie.cuhk.edu.hk
• K. He is with the Visual Computing Group, Microsoft Research Asia,
Beijing 100080, China.
Email: 
constructed patches are aggregated (e.g., by weighted
averaging) to produce the ﬁnal output. This pipeline is
shared by most external example-based methods, which
pay particular attention to learning and optimizing the
dictionaries , , or building efﬁcient mapping
functions , , , . However, the rest of the
steps in the pipeline have been rarely optimized or
considered in an uniﬁed optimization framework.
In this paper, we show that the aforementioned
pipeline is equivalent to a deep convolutional neural network (more details in Section 3.2). Motivated by this
fact, we consider a convolutional neural network that
directly learns an end-to-end mapping between low- and
high-resolution images. Our method differs fundamentally from existing external example-based approaches,
in that ours does not explicitly learn the dictionaries ,
 , or manifolds , for modeling the patch
space. These are implicitly achieved via hidden layers.
Furthermore, the patch extraction and aggregation are
also formulated as convolutional layers, so are involved
in the optimization. In our method, the entire SR pipeline
is fully obtained through learning, with little pre/postprocessing.
We name the proposed model Super-Resolution Convolutional Neural Network (SRCNN)1. The proposed
SRCNN has several appealing properties. First, its structure is intentionally designed with simplicity in mind,
and yet provides superior accuracy2 compared with
state-of-the-art example-based methods. Figure 1 shows
a comparison on an example. Second, with moderate
1. The implementation is available at 
projects/SRCNN.html.
2. Numerical evaluations by using different metrics such as the Peak
Signal-to-Noise Ratio (PSNR), structure similarity index (SSIM) ,
multi-scale SSIM , information ﬁdelity criterion , when the
ground truth images are available.
 
SC / 25.58 dB
Original / PSNR
Number of backprops
Average test PSNR (dB)
Bicubic / 24.04 dB
SRCNN / 27.95 dB
Number of backprops
Average test PSNR (dB)
The proposed Super-Resolution Convolutional
Neural Network (SRCNN) surpasses the bicubic baseline
with just a few training iterations, and outperforms the
sparse-coding-based method (SC) with moderate
training. The performance may be further improved with
more training iterations. More details are provided in
Section 4.4.1 (the Set5 dataset with an upscaling factor
3). The proposed method provides visually appealing
reconstructed image.
numbers of ﬁlters and layers, our method achieves
fast speed for practical on-line usage even on a CPU.
Our method is faster than a number of example-based
methods, because it is fully feed-forward and does
not need to solve any optimization problem on usage.
Third, experiments show that the restoration quality of
the network can be further improved when (i) larger
and more diverse datasets are available, and/or (ii)
a larger and deeper model is used. On the contrary,
larger datasets/models can present challenges for existing example-based methods. Furthermore, the proposed
network can cope with three channels of color images
simultaneously to achieve improved super-resolution
performance.
Overall, the contributions of this study are mainly in
three aspects:
convolutional
network for image super-resolution. The network directly learns an end-to-end mapping between lowand high-resolution images, with little pre/postprocessing beyond the optimization.
2) We establish a relationship between our deeplearning-based SR method and the traditional
sparse-coding-based SR methods. This relationship
provides a guidance for the design of the network
structure.
3) We demonstrate that deep learning is useful in
the classical computer vision problem of superresolution, and can achieve good quality and
A preliminary version of this work was presented
earlier . The present work adds to the initial version
in signiﬁcant ways. Firstly, we improve the SRCNN by
introducing larger ﬁlter size in the non-linear mapping
layer, and explore deeper structures by adding nonlinear mapping layers. Secondly, we extend the SRCNN
to process three color channels (either in YCbCr or RGB
color space) simultaneously. Experimentally, we demonstrate that performance can be improved in comparison
to the single-channel network. Thirdly, considerable new
analyses and intuitive explanations are added to the
initial results. We also extend the original experiments
from Set5 and Set14 test images to BSD200 
(200 test images). In addition, we compare with a number of recently published methods and conﬁrm that
our model still outperforms existing approaches using
different evaluation metrics.
RELATED WORK
Image Super-Resolution
According to the image priors, single-image super resolution algorithms can be categorized into four types –
prediction models, edge based methods, image statistical
methods and patch based (or example-based) methods.
These methods have been thoroughly investigated and
evaluated in Yang et al.’s work . Among them, the
example-based methods , , , achieve the
state-of-the-art performance.
The internal example-based methods exploit the selfsimilarity property and generate exemplar patches from
the input image. It is ﬁrst proposed in Glasner’s
work , and several improved variants , are
proposed to accelerate the implementation. The external example-based methods , , , , , ,
 , , , learn a mapping between low/highresolution patches from external datasets. These studies
vary on how to learn a compact dictionary or manifold
space to relate low/high-resolution patches, and on how
representation schemes can be conducted in such spaces.
In the pioneer work of Freeman et al. , the dictionaries are directly presented as low/high-resolution
patch pairs, and the nearest neighbour (NN) of the input
patch is found in the low-resolution space, with its corresponding high-resolution patch used for reconstruction.
Chang et al. introduce a manifold embedding technique as an alternative to the NN strategy. In Yang et al.’s
work , , the above NN correspondence advances
to a more sophisticated sparse coding formulation. Other
mapping functions such as kernel regression , simple
function , random forest and anchored neighborhood regression , are proposed to further
improve the mapping accuracy and speed. The sparsecoding-based method and its several improvements ,
 , are among the state-of-the-art SR methods
nowadays. In these methods, the patches are the focus
of the optimization; the patch extraction and aggregation
steps are considered as pre/post-processing and handled
separately.
The majority of SR algorithms , , , , ,
 , , focus on gray-scale or single-channel
image super-resolution. For color images, the aforementioned methods ﬁrst transform the problem to a different color space (YCbCr or YUV), and SR is applied
only on the luminance channel. There are also works
attempting to super-resolve all channels simultaneously.
For example, Kim and Kwon and Dai et al. apply
their model to each RGB channel and combined them to
produce the ﬁnal results. However, none of them has
analyzed the SR performance of different channels, and
the necessity of recovering all three channels.
Convolutional Neural Networks
Convolutional
decades and deep CNNs have recently shown an
explosive popularity partially due to its success in image
classiﬁcation , . They have also been successfully applied to other computer vision ﬁelds, such as
object detection , , , face recognition , and
pedestrian detection . Several factors are of central
importance in this progress: (i) the efﬁcient training
implementation on modern powerful GPUs , (ii) the
proposal of the Rectiﬁed Linear Unit (ReLU) which
makes convergence much faster while still presents good
quality , and (iii) the easy access to an abundance of
data (like ImageNet ) for training larger models. Our
method also beneﬁts from these progresses.
Deep Learning for Image Restoration
There have been a few studies of using deep learning
techniques for image restoration. The multi-layer perceptron (MLP), whose all layers are fully-connected (in
contrast to convolutional), is applied for natural image
denoising and post-deblurring denoising . More
closely related to our work, the convolutional neural network is applied for natural image denoising and removing noisy patterns (dirt/rain) . These restoration
problems are more or less denoising-driven. Cui et al. 
propose to embed auto-encoder networks in their superresolution pipeline under the notion internal examplebased approach . The deep model is not speciﬁcally
designed to be an end-to-end solution, since each layer
of the cascade requires independent optimization of the
self-similarity search process and the auto-encoder. On
the contrary, the proposed SRCNN optimizes an end-toend mapping. Further, the SRCNN is faster at speed. It
is not only a quantitatively superior method, but also a
practically useful one.
CONVOLUTIONAL NEURAL NETWORKS FOR
SUPER-RESOLUTION
Formulation
Consider a single low-resolution image, we ﬁrst upscale
it to the desired size using bicubic interpolation, which
is the only pre-processing we perform3. Let us denote
the interpolated image as Y. Our goal is to recover
from Y an image F(Y) that is as similar as possible
to the ground truth high-resolution image X. For the
ease of presentation, we still call Y a “low-resolution”
image, although it has the same size as X. We wish to
learn a mapping F, which conceptually consists of three
operations:
1) Patch extraction and representation: this operation extracts (overlapping) patches from the lowresolution image Y and represents each patch as a
high-dimensional vector. These vectors comprise a
set of feature maps, of which the number equals to
the dimensionality of the vectors.
2) Non-linear mapping: this operation nonlinearly
maps each high-dimensional vector onto another
high-dimensional vector. Each mapped vector is
conceptually the representation of a high-resolution
patch. These vectors comprise another set of feature
3) Reconstruction:
aggregates
above high-resolution patch-wise representations
to generate the ﬁnal high-resolution image. This
image is expected to be similar to the ground truth
We will show that all these operations form a convolutional neural network. An overview of the network is
depicted in Figure 2. Next we detail our deﬁnition of
each operation.
Patch extraction and representation
A popular strategy in image restoration (e.g., ) is to
densely extract patches and then represent them by a set
of pre-trained bases such as PCA, DCT, Haar, etc. This
is equivalent to convolving the image by a set of ﬁlters,
each of which is a basis. In our formulation, we involve
the optimization of these bases into the optimization of
the network. Formally, our ﬁrst layer is expressed as an
operation F1:
F1(Y) = max (0, W1 ∗Y + B1) ,
where W1 and B1 represent the ﬁlters and biases respectively, and ’∗’ denotes the convolution operation.
Here, W1 corresponds to n1 ﬁlters of support c×f1 ×f1,
where c is the number of channels in the input image,
f1 is the spatial size of a ﬁlter. Intuitively, W1 applies
n1 convolutions on the image, and each convolution has
3. Bicubic interpolation is also a convolutional operation, so it can
be formulated as a convolutional layer. However, the output size of
this layer is larger than the input size, so there is a fractional stride. To
take advantage of the popular well-optimized implementations such
as cuda-convnet , we exclude this “layer” from learning.
feature maps
Patch extraction
and representation
Non-linear mapping
Reconstruction
Low-resolution
image (input)
High-resolution
image (output)
of low-resolution image
of high-resolution image
feature maps
Fig. 2. Given a low-resolution image Y, the ﬁrst convolutional layer of the SRCNN extracts a set of feature maps. The
second layer maps these feature maps nonlinearly to high-resolution patch representations. The last layer combines
the predictions within a spatial neighbourhood to produce the ﬁnal high-resolution image F(Y).
a kernel size c × f1 × f1. The output is composed of
n1 feature maps. B1 is an n1-dimensional vector, whose
each element is associated with a ﬁlter. We apply the
Rectiﬁed Linear Unit (ReLU, max(0, x)) on the ﬁlter
responses4.
Non-linear mapping
The ﬁrst layer extracts an n1-dimensional feature for
each patch. In the second operation, we map each of
these n1-dimensional vectors into an n2-dimensional
one. This is equivalent to applying n2 ﬁlters which have
a trivial spatial support 1 × 1. This interpretation is only
valid for 1×1 ﬁlters. But it is easy to generalize to larger
ﬁlters like 3 × 3 or 5 × 5. In that case, the non-linear
mapping is not on a patch of the input image; instead,
it is on a 3 × 3 or 5 × 5 “patch” of the feature map. The
operation of the second layer is:
F2(Y) = max (0, W2 ∗F1(Y) + B2) .
Here W2 contains n2 ﬁlters of size n1 ×f2 ×f2, and B2 is
n2-dimensional. Each of the output n2-dimensional vectors is conceptually a representation of a high-resolution
patch that will be used for reconstruction.
It is possible to add more convolutional layers to
increase the non-linearity. But this can increase the complexity of the model (n2 × f2 × f2 × n2 parameters for
one layer), and thus demands more training time. We
will explore deeper structures by introducing additional
non-linear mapping layers in Section 4.3.3.
Reconstruction
In the traditional methods, the predicted overlapping
high-resolution patches are often averaged to produce
the ﬁnal full image. The averaging can be considered
as a pre-deﬁned ﬁlter on a set of feature maps (where
each position is the “ﬂattened” vector form of a highresolution patch). Motivated by this, we deﬁne a convolutional layer to produce the ﬁnal high-resolution image:
F(Y) = W3 ∗F2(Y) + B3.
4. The ReLU can be equivalently considered as a part of the second
operation (Non-linear mapping), and the ﬁrst operation (Patch extraction and representation) becomes purely linear convolution.
Here W3 corresponds to c ﬁlters of a size n2 × f3 × f3,
and B3 is a c-dimensional vector.
If the representations of the high-resolution patches
are in the image domain (i.e.,we can simply reshape each
representation to form the patch), we expect that the
ﬁlters act like an averaging ﬁlter; if the representations
of the high-resolution patches are in some other domains
(e.g.,coefﬁcients in terms of some bases), we expect that
W3 behaves like ﬁrst projecting the coefﬁcients onto the
image domain and then averaging. In either way, W3 is
a set of linear ﬁlters.
Interestingly, although the above three operations are
motivated by different intuitions, they all lead to the
same form as a convolutional layer. We put all three
operations together and form a convolutional neural
network (Figure 2). In this model, all the ﬁltering weights
and biases are to be optimized. Despite the succinctness
of the overall structure, our SRCNN model is carefully
developed by drawing extensive experience resulted
from signiﬁcant progresses in super-resolution , .
We detail the relationship in the next section.
Relationship to Sparse-Coding-Based Methods
We show that the sparse-coding-based SR methods ,
 can be viewed as a convolutional neural network.
Figure 3 shows an illustration.
In the sparse-coding-based methods, let us consider
that an f1 × f1 low-resolution patch is extracted from
the input image. Then the sparse coding solver, like
Feature-Sign , will ﬁrst project the patch onto a (lowresolution) dictionary. If the dictionary size is n1, this
is equivalent to applying n1 linear ﬁlters (f1 × f1) on
the input image (the mean subtraction is also a linear
operation so can be absorbed). This is illustrated as the
left part of Figure 3.
The sparse coding solver will then iteratively process
the n1 coefﬁcients. The outputs of this solver are n2
coefﬁcients, and usually n2 = n1 in the case of sparse
coding. These n2 coefﬁcients are the representation of
the high-resolution patch. In this sense, the sparse coding
neighbouring
Patch extraction
and representation
Non-linear
Reconstruction
Fig. 3. An illustration of sparse-coding-based methods in the view of a convolutional neural network.
solver behaves as a special case of a non-linear mapping
operator, whose spatial support is 1 × 1. See the middle
part of Figure 3. However, the sparse coding solver is
not feed-forward, i.e.,it is an iterative algorithm. On the
contrary, our non-linear operator is fully feed-forward
and can be computed efﬁciently. If we set f2 = 1, then
our non-linear operator can be considered as a pixel-wise
fully-connected layer. It is worth noting that “the sparse
coding solver” in SRCNN refers to the ﬁrst two layers,
but not just the second layer or the activation function
(ReLU). Thus the nonlinear operation in SRCNN is also
well optimized through the learning process.
The above n2 coefﬁcients (after sparse coding) are
then projected onto another (high-resolution) dictionary
to produce a high-resolution patch. The overlapping
high-resolution patches are then averaged. As discussed
above, this is equivalent to linear convolutions on the
n2 feature maps. If the high-resolution patches used for
reconstruction are of size f3 × f3, then the linear ﬁlters
have an equivalent spatial support of size f3 × f3. See
the right part of Figure 3.
The above discussion shows that the sparse-codingbased SR method can be viewed as a kind of convolutional neural network (with a different non-linear
mapping). But not all operations have been considered in
the optimization in the sparse-coding-based SR methods.
On the contrary, in our convolutional neural network,
the low-resolution dictionary, high-resolution dictionary,
non-linear mapping, together with mean subtraction and
averaging, are all involved in the ﬁlters to be optimized.
So our method optimizes an end-to-end mapping that
consists of all operations.
The above analogy can also help us to design hyperparameters. For example, we can set the ﬁlter size of
the last layer to be smaller than that of the ﬁrst layer,
and thus we rely more on the central part of the highresolution patch (to the extreme, if f3 = 1, we are
using the center pixel with no averaging). We can also
set n2 < n1 because it is expected to be sparser. A
typical and basic setting is f1 = 9, f2 = 1, f3 = 5,
n1 = 64, and n2 = 32 (we evaluate more settings in
the experiment section). On the whole, the estimation
of a high resolution pixel utilizes the information of
(9 + 5 −1)2
= 169 pixels. Clearly, the information
exploited for reconstruction is comparatively larger than
that used in existing external example-based approaches,
e.g., using (5+5−1)2 = 81 pixels5 , . This is one of
the reasons why the SRCNN gives superior performance.
end-to-end
requires the estimation of network parameters Θ
{W1, W2, W3, B1, B2, B3}. This is achieved through minimizing the loss between the reconstructed images
F(Y; Θ) and the corresponding ground truth highresolution images X. Given a set of high-resolution
images {Xi} and their corresponding low-resolution
images {Yi}, we use Mean Squared Error (MSE) as the
loss function:
||F(Yi; Θ) −Xi||2,
where n is the number of training samples. Using MSE
as the loss function favors a high PSNR. The PSNR
is a widely-used metric for quantitatively evaluating
image restoration quality, and is at least partially related
to the perceptual quality. It is worth noticing that the
convolutional neural networks do not preclude the usage
of other kinds of loss functions, if only the loss functions
are derivable. If a better perceptually motivated metric
is given during training, it is ﬂexible for the network to
adapt to that metric. On the contrary, such a ﬂexibility
is in general difﬁcult to achieve for traditional “handcrafted” methods. Despite that the proposed model is
trained favoring a high PSNR, we still observe satisfactory performance when the model is evaluated using
alternative evaluation metrics, e.g., SSIM, MSSIM (see
Section 4.4.1).
The loss is minimized using stochastic gradient descent with the standard backpropagation . In particular, the weight matrices are updated as
∆i+1 = 0.9 · ∆i −η · ∂L
5. The patches are overlapped with 4 pixels at each direction.
where ℓ∈{1, 2, 3} and i are the indices of layers and iterations, η is the learning rate, and
i is the derivative.
The ﬁlter weights of each layer are initialized by drawing
randomly from a Gaussian distribution with zero mean
and standard deviation 0.001 (and 0 for biases). The
learning rate is 10−4 for the ﬁrst two layers, and 10−5 for
the last layer. We empirically ﬁnd that a smaller learning
rate in the last layer is important for the network to
converge (similar to the denoising case ).
In the training phase, the ground truth images {Xi}
are prepared as fsub×fsub×c-pixel sub-images randomly
cropped from the training images. By “sub-images” we
mean these samples are treated as small “images” rather
than “patches”, in the sense that “patches” are overlapping and require some averaging as post-processing but
“sub-images” need not. To synthesize the low-resolution
samples {Yi}, we blur a sub-image by a Gaussian kernel,
sub-sample it by the upscaling factor, and upscale it by
the same factor via bicubic interpolation.
To avoid border effects during training, all the convolutional layers have no padding, and the network
produces a smaller output ((fsub −f1 −f2 −f3 + 3)2 × c).
The MSE loss function is evaluated only by the difference
between the central pixels of Xi and the network output.
Although we use a ﬁxed image size in training, the
convolutional neural network can be applied on images
of arbitrary sizes during testing.
We implement our model using the cuda-convnet package . We have also tried the Caffe package and
observed similar performance.
EXPERIMENTS
We ﬁrst investigate the impact of using different datasets
on the model performance. Next, we examine the ﬁlters
learned by our approach. We then explore different
architecture designs of the network, and study the relations between super-resolution performance and factors
like depth, number of ﬁlters, and ﬁlter sizes. Subsequently, we compare our method with recent state-ofthe-arts both quantitatively and qualitatively. Following
 , super-resolution is only applied on the luminance
channel (Y channel in YCbCr color space) in Sections 4.1-
4.4, so c = 1 in the ﬁrst/last layer, and performance
(e.g., PSNR and SSIM) is evaluated on the Y channel. At
last, we extend the network to cope with color images
and evaluate the performance on different channels.
Training Data
As shown in the literature, deep learning generally
beneﬁts from big data training. For comparison, we use
a relatively small training set , that consists
of 91 images, and a large training set that consists of
395,909 images from the ILSVRC 2013 ImageNet detection training partition. The size of training sub-images is
fsub = 33. Thus the 91-image dataset can be decomposed
into 24,800 sub-images, which are extracted from original images with a stride of 14. Whereas the ImageNet
provides over 5 million sub-images even using a stride
of 33. We use the basic network settings, i.e., f1 = 9,
f2 = 1, f3 = 5, n1 = 64, and n2 = 32. We use the Set5 
as the validation set. We observe a similar trend even
if we use the larger Set14 set . The upscaling factor
is 3. We use the sparse-coding-based method as our
baseline, which achieves an average PSNR value of 31.42
The test convergence curves of using different training
sets are shown in Figure 4. The training time on ImageNet is about the same as on the 91-image dataset since
the number of backpropagations is the same. As can be
observed, with the same number of backpropagations
(i.e.,8 × 108), the SRCNN+ImageNet achieves 32.52 dB,
higher than 32.39 dB yielded by that trained on 91
images. The results positively indicate that SRCNN performance may be further boosted using a larger training
set, but the effect of big data is not as impressive as
that shown in high-level vision problems . This is
mainly because that the 91 images have already captured sufﬁcient variability of natural images. On the
other hand, our SRCNN is a relatively small network
(8,032 parameters), which could not overﬁt the 91 images
(24,800 samples). Nevertheless, we adopt the ImageNet,
which contains more diverse data, as the default training
set in the following experiments.
Learned Filters for Super-Resolution
Figure 5 shows examples of learned ﬁrst-layer ﬁlters
trained on the ImageNet by an upscaling factor 3. Please
refer to our published implementation for upscaling
factors 2 and 4. Interestingly, each learned ﬁlter has
its speciﬁc functionality. For instance, the ﬁlters g and
h are like Laplacian/Gaussian ﬁlters, the ﬁlters a - e
are like edge detectors at different directions, and the
ﬁlter f is like a texture extractor. Example feature maps
of different layers are shown in ﬁgure 6. Obviously,
feature maps of the ﬁrst layer contain different structures
(e.g., edges at different directions), while that of the
second layer are mainly different on intensities.
Model and Performance Trade-offs
Based on the basic network settings (i.e., f1 = 9, f2 = 1,
f3 = 5, n1 = 64, and n2 = 32), we will progressively
modify some of these parameters to investigate the best
trade-off between performance and speed, and study the
relations between performance and parameters.
NumberSofSbackprops
AverageStestSPSNRSndBI
SRCNNSntrainedSonSImageNetI
SRCNNSntrainedSonS91SimagesI
SCSn31.42SdBI
Fig. 4. Training with the much larger ImageNet dataset
improves the performance over the use of 91 images.
The ﬁgure shows the ﬁrst-layer ﬁlters trained
on ImageNet with an upscaling factor 3. The ﬁlters are
organized based on their respective variances.
Feature maps of the first layer
Feature maps of the second layer
Fig. 6. Example feature maps of different layers.
Filter number
In general, the performance would improve if we increase the network width6, i.e., adding more ﬁlters, at the
cost of running time. Speciﬁcally, based on our network
default settings of n1 = 64 and n2 = 32, we conduct
two experiments: (i) one is with a larger network with
n1 = 128 and n2 = 64, and (ii) the other is with a smaller
network with n1 = 32 and n2 = 16. Similar to Section 4.1,
we also train the two models on ImageNet and test on
Set5 with an upscaling factor 3. The results observed
at 8 × 108 backpropagations are shown in Table 1. It is
clear that superior performance could be achieved by
increasing the width. However, if a fast restoration speed
is desired, a small network width is preferred, which
could still achieve better performance than the sparsecoding-based method (31.42 dB).
The results of using different ﬁlter numbers in SRCNN.
Training is performed on ImageNet whilst the evaluation
is conducted on the Set5 dataset.
Time (sec)
Time (sec)
Time (sec)
Filter size
In this section, we examine the network sensitivity to
different ﬁlter sizes. In previous experiments, we set
ﬁlter size f1 = 9, f2 = 1 and f3 = 5, and the network
could be denoted as 9-1-5. First, to be consistent with
sparse-coding-based methods, we ﬁx the ﬁlter size of the
second layer to be f2 = 1, and enlarge the ﬁlter size of
other layers to f1 = 11 and f3 = 7 (11-1-7). All the other
6. We use ‘width’ to term the number of ﬁlters in a layer, following . The term ‘width’ may have other meanings in the literature.
NumberSofSbackprops
AverageStestSPSNRS(dB)
SRCNNS(9−5−5)
SRCNNS(9−3−5)
SRCNNS(9−1−5)
SCS(31.42SdB)
Fig. 7. A larger ﬁlter size leads to better results.
settings remain the same with Section 4.1. The results
with an upscaling factor 3 on Set5 are 32.57 dB, which is
slightly higher than the 32.52 dB reported in Section 4.1.
This indicates that a reasonably larger ﬁlter size could
grasp richer structural information, which in turn lead
to better results.
Then we further examine networks with a larger ﬁlter
size of the second layer. Speciﬁcally, we ﬁx the ﬁlter size
f1 = 9, f3 = 5, and enlarge the ﬁlter size of the second
layer to be (i) f2 = 3 (9-3-5) and (ii) f2 = 5 (9-5-5).
Convergence curves in Figure 7 show that using a larger
ﬁlter size could signiﬁcantly improve the performance.
Speciﬁcally, the average PSNR values achieved by 9-3-
5 and 9-5-5 on Set5 with 8 × 108 backpropagations are
32.66 dB and 32.75 dB, respectively. The results suggest
that utilizing neighborhood information in the mapping
stage is beneﬁcial.
However, the deployment speed will also decrease
with a larger ﬁlter size. For example, the number of
parameters of 9-1-5, 9-3-5, and 9-5-5 is 8,032, 24,416, and
57,184 respectively. The complexity of 9-5-5 is almost
twice of 9-3-5, but the performance improvement is
marginal. Therefore, the choice of the network scale
should always be a trade-off between performance and
Number of layers
Recent study by He and Sun suggests that CNN
could beneﬁt from increasing the depth of network
moderately. Here, we try deeper structures by adding
another non-linear mapping layer, which has n22 = 16
ﬁlters with size f22 = 1. We conduct three controlled
experiments, i.e., 9-1-1-5, 9-3-1-5, 9-5-1-5, which add an
additional layer on 9-1-5, 9-3-5, and 9-5-5, respectively.
The initialization scheme and learning rate of the additional layer are the same as the second layer. From
Figures 13(a), 13(b) and 8(c), we can observe that the
four-layer networks converge slower than the three-layer
network. Nevertheless, given enough training time, the
deeper networks will ﬁnally catch up and converge to
the three-layer ones.
The effectiveness of deeper structures for super resolution is found not as apparent as that shown in image
classiﬁcation . Furthermore, we ﬁnd that deeper
networks do not always result in better performance.
Speciﬁcally, if we add an additional layer with n22 = 32
ﬁlters on 9-1-5 network, then the performance degrades
and fails to surpass the three-layer network (see Figure 9(a)). If we go deeper by adding two non-linear
Number(of(backprops
Average(test(PSNR((dB)
SRCNN((9−1−5)
SRCNN((9−1−1−5)
SC((31.42(dB)
(a) 9-1-5 vs. 9-1-1-5
NumberSofSbackprops
AverageStestSPSNRS(dB)
SRCNNS(9−3−5)
SRCNNS(9−3−1−5)
SCS(31.42SdB)
(b) 9-3-5 vs. 9-3-1-5
NumberRofRbackprops
AverageRtestRPSNRR(dB)
SRCNNR(9−5−5)
SRCNNR(9−5−1−5)
SCR(31.42RdB)
(c) 9-5-5 vs. 9-5-1-5
Fig. 8. Comparisons between three-layer and four-layer
mapping layers with n22 = 32 and n23 = 16 ﬁlters on
9-1-5, then we have to set a smaller learning rate to
ensure convergence, but we still do not observe superior
performance after a week of training (see Figure 9(a)).
We also tried to enlarge the ﬁlter size of the additional
layer to f22 = 3, and explore two deep structures – 9-3-
3-5 and 9-3-3-3. However, from the convergence curves
shown in Figure 9(b), these two networks do not show
better results than the 9-3-1-5 network.
All these experiments indicate that it is not “the deeper
the better” in this deep model for super-resolution. It
may be caused by the difﬁculty of training. Our CNN
network contains no pooling layer or full-connected
layer, thus it is sensitive to the initialization parameters
and learning rate. When we go deeper (e.g., 4 or 5 layers),
we ﬁnd it hard to set appropriate learning rates that
guarantee convergence. Even it converges, the network
may fall into a bad local minimum, and the learned
ﬁlters are of less diversity even given enough training
time. This phenomenon is also observed in , where
improper increase of depth leads to accuracy saturation
or degradation for image classiﬁcation. Why “deeper is
not better” is still an open question, which requires investigations to better understand gradients and training
dynamics in deep architectures. Therefore, we still adopt
three-layer networks in the following experiments.
Comparisons to State-of-the-Arts
In this section, we show the quantitative and qualitative
results of our method in comparison to state-of-the-art
Number(of(backprops
Average(test(PSNR(=dB)
SRCNN(=9−1−5)
SRCNN(=9−1−1−5,(n22=16)
SRCNN(=9−1−1−5,(n22=32)
SRCNN(=9−1−1−1−5,(n22=32,(n23=16)
SC(=31.42(dB)
(a) 9-1-1-5 (n22 = 32) and 9-1-1-1-5 (n22 = 32, n23 = 16)
NumberSofSbackprops
AverageStestSPSNRS(dB)
SRCNNS(9−3−5)
SRCNNS(9−3−1−5)
SRCNNS(9−3−3−5)
SRCNNS(9−3−3−3)
SCS(31.42SdB)
(b) 9-3-3-5 and 9-3-3-3
Fig. 9. Deeper structure does not always lead to better
methods. We adopt the model with good performancespeed trade-off: a three-layer network with f1 = 9, f2 =
5, f3 = 5, n1 = 64, and n2 = 32 trained on the ImageNet.
For each upscaling factor ∈{2, 3, 4}, we train a speciﬁc
network for that factor7.
Comparisons. We compare our SRCNN with the stateof-the-art SR methods:
• SC - sparse coding-based method of Yang et al. 
• NE+LLE - neighbour embedding + locally linear
embedding method 
Neighbourhood
Regression
method 
• A+ - Adjusted Anchored Neighbourhood Regression method , and
• KK - the method described in , which achieves
the best performance among external examplebased methods, according to the comprehensive
evaluation conducted in Yang et al.’s work 
The implementations are all from the publicly available
codes provided by the authors, and all images are downsampled using the same bicubic kernel.
Test set. The Set5 (5 images), Set14 (14 images)
and BSD200 (200 images)8 are used to evaluate the
performance of upscaling factors 2, 3, and 4.
Evaluation metrics. Apart from the widely used PSNR
and SSIM indices, we also adopt another four
evaluation matrices, namely information ﬁdelity criterion (IFC) , noise quality measure (NQM) ,
weighted peak signal-to-noise ratio (WPSNR) and multiscale structure similarity index (MSSSIM) , which
obtain high correlation with the human perceptual scores
as reported in .
Quantitative and qualitative evaluation
As shown in Tables 2, 3 and 4, the proposed SRCNN
yields the highest scores in most evaluation matrices
7. In the area of denoising , for each noise level a speciﬁc network
is trained.
8. We use the same 200 images as in .
Number(of(backprops
Average(test(PSNR((dB)
ANR - 31.92 dB
A+ - 32.59 dB
SC - 31.42 dB
Bicubic - 30.39 dB
NE+LLE - 31.84 dB
KK - 32.28 dB
The test convergence curve of SRCNN and
results of other methods on the Set5 dataset.
in all experiments9. Note that our SRCNN results are
based on the checkpoint of 8 × 108 backpropagations.
Speciﬁcally, for the upscaling factor 3, the average gains
on PSNR achieved by SRCNN are 0.15 dB, 0.17 dB, and
0.13 dB, higher than the next best approach, A+ ,
on the three datasets. When we take a look at other
evaluation metrics, we observe that SC, to our surprise,
gets even lower scores than the bicubic interpolation
on IFC and NQM. It is clear that the results of SC are
more visually pleasing than that of bicubic interpolation.
This indicates that these two metrics may not truthfully
reveal the image quality. Thus, regardless of these two
metrics, SRCNN achieves the best performance among
all methods and scaling factors.
It is worth pointing out that SRCNN surpasses the
bicubic baseline at the very beginning of the learning
stage (see Figure 1), and with moderate training, SR-
CNN outperforms existing state-of-the-art methods (see
Figure 4). Yet, the performance is far from converge.
We conjecture that better results can be obtained given
longer training time (see Figure 10).
Figures 14, 15 and 16 show the super-resolution results
of different approaches by an upscaling factor 3. As can
be observed, the SRCNN produces much sharper edges
than other approaches without any obvious artifacts
across the image.
In addition, we report to another recent deep learning
method for image super-resolution (DNC) of Cui et
al. . As they employ a different blur kernel (a Gaussian
ﬁlter with a standard deviation of 0.55), we train a speciﬁc network (9-5-5) using the same blur kernel as DNC
for fair quantitative comparison. The upscaling factor
is 3 and the training set is the 91-image dataset. From
the convergence curve shown in Figure 11, we observe
that our SRCNN surpasses DNC with just 2.7 × 107
backprops, and a larger margin can be obtained given
longer training time. This also demonstrates that the
end-to-end learning is superior to DNC, even if that
model is already “deep”.
Running time
Figure 12 shows the running time comparisons of several
state-of-the-art methods, along with their restoration
performance on Set14. All baseline methods are obtained
9. The PSNR value of each image can be found in the supplementary
from the corresponding authors’ MATLAB+MEX implementation, whereas ours are in pure C++. We proﬁle
the running time of all the algorithms using the same
machine (Intel CPU 3.10 GHz and 16 GB memory).
Note that the processing time of our approach is highly
linear to the test image resolution, since all images go
through the same number of convolutions. Our method
is always a trade-off between performance and speed.
To show this, we train three networks for comparison,
which are 9-1-5, 9-3-5, and 9-5-5. It is clear that the 9-
1-5 network is the fastest, while it still achieves better
performance than the next state-of-the-art A+. Other
methods are several times or even orders of magnitude
slower in comparison to 9-1-5 network. Note the speed
gap is not mainly caused by the different MATLAB/C++
implementations; rather, the other methods need to solve
complex optimization problems on usage (e.g., sparse
coding or embedding), whereas our method is completely feed-forward. The 9-5-5 network achieves the
best performance but at the cost of the running time. The
test-time speed of our CNN can be further accelerated
in many ways, e.g., approximating or simplifying the
trained networks , , , with possible slight
degradation in performance.
Experiments on Color Channels
In previous experiments, we follow the conventional
approach to super-resolve color images. Speciﬁcally, we
ﬁrst transform the color images into the YCbCr space.
The SR algorithms are only applied on the Y channel,
while the Cb , Cr channels are upscaled by bicubic interpolation. It is interesting to ﬁnd out if super-resolution
performance can be improved if we jointly consider all
three channels in the process.
Our method is ﬂexible to accept more channels without altering the learning mechanism and network design. In particular, it can readily deal with three channels simultaneously by setting the input channels to
c = 3. In the following experiments, we explore different
training strategies for color image super-resolution, and
subsequently evaluate their performance on different
Implementation details. Training is performed on the
91-image dataset, and testing is conducted on the
Set5 . The network settings are: c = 3, f1 = 9, f2 = 1,
f3 = 5, n1 = 64, and n2 = 32. As we have proved the
NumberBofBbackprops
AverageBtestBPSNRBidBn
SRCNNBi9-5-5BtrainedBonB91Bimagesn
DNCBi32.08BdBn
BicubicBi30.29BdBn
Fig. 11. The test convergence curve of SRCNN and the
result of DNC on the Set5 dataset.
The average results of PSNR (dB), SSIM, IFC, NQM, WPSNR (dB) and MSSIM on the Set5 dataset.
NE+LLE 
The average results of PSNR (dB), SSIM, IFC, NQM, WPSNR (dB) and MSSIM on the Set14 dataset.
NE+LLE 
The average results of PSNR (dB), SSIM, IFC, NQM, WPSNR (dB) and MSSIM on the BSD200 dataset.
NE+LLE 
Running time (sec)
SRCNN(9-1-5)
SRCNN(9-3-5)
SRCNN(9-5-5)
——> Faster
Slower <——
The proposed SRCNN achieves the stateof-the-art super-resolution quality, whilst maintains high
and competitive speed in comparison to existing external
example-based methods. The chart is based on Set14
results summarized in Table 3. The implementation of all
three SRCNN networks are available on our project page.
Average PSNR (dB) of different channels and training
strategies on the Set5 dataset.
PSNR of different channel(s)
Strategies
RGB color image
Y pre-train
CbCr pre-train
effectiveness of SRCNN on different scales, here we only
evaluate the performance of upscaling factor 3.
Comparisons. We compare our method with the stateof-art color SR method – KK . We also try different
learning strategies for comparison:
• Y only: this is our baseline method, which is a
single-channel (c = 1) network trained only on
the luminance channel. The Cb, Cr channels are
upscaled using bicubic interpolation.
• YCbCr: training is performed on the three channels
of the YCbCr space.
• Y pre-train: ﬁrst, to guarantee the performance on
the Y channel, we only use the MSE of the Y channel
as the loss to pre-train the network. Then we employ
the MSE of all channels to ﬁne-tune the parameters.
• CbCr pre-train: we use the MSE of the Cb, Cr
channels as the loss to pre-train the network, then
ﬁne-tune the parameters on all channels.
• RGB: training is performed on the three channels of
the RGB space.
The results are shown in Table 5, where we have the
following observations. (i) If we directly train on the
YCbCr channels, the results are even worse than that of
bicubic interpolation. The training falls into a bad local
minimum, due to the inherently different characteristics
of the Y and Cb, Cr channels. (ii) If we pre-train on the
Y or Cb, Cr channels, the performance ﬁnally improves,
but is still not better than “Y only” on the color image
(see the last column of Table 5, where PSNR is computed
(a) First-layer ﬁlters – Cb channel
(b) First-layer ﬁlters – Cr channel
Chrominance channels of the ﬁrst-layer ﬁlters
using the “Y pre-train” strategy.
in RGB color space). This suggests that the Cb, Cr
channels could decrease the performance of the Y channel when training is performed in a uniﬁed network.
(iii) We observe that the Cb, Cr channels have higher
PSNR values for “Y pre-train” than for “CbCr pre-train”.
The reason lies on the differences between the Cb, Cr
channels and the Y channel. Visually, the Cb, Cr channels
are more blurry than the Y channel, thus are less affected
by the downsampling process. When we pre-train on
the Cb, Cr channels, there are only a few ﬁlters being
activated. Then the training will soon fall into a bad
local minimum during ﬁne-tuning. On the other hand,
if we pre-train on the Y channel, more ﬁlters will be
activated, and the performance on Cb, Cr channels will
be pushed much higher. Figure 13 shows the Cb, Cr
channels of the ﬁrst-layer ﬁlters with “Y pre-train”, of
which the patterns largely differ from that shown in
Figure 5. (iv) Training on the RGB channels achieves
the best result on the color image. Different from the
YCbCr channels, the RGB channels exhibit high crosscorrelation among each other. The proposed SRCNN
is capable of leveraging such natural correspondences
between the channels for reconstruction. Therefore, the
model achieves comparable result on the Y channel as
“Y only”, and better results on Cb, Cr channels than
bicubic interpolation. (v) In KK , super-resolution
is applied on each RGB channel separately. When we
transform its results to YCbCr space, the PSNR value
of Y channel is similar as “Y only”, but that of Cb, Cr
channels are poorer than bicubic interpolation. The result
suggests that the algorithm is biased to the Y channel.
On the whole, our method trained on RGB channels
achieves better performance than KK and the singlechannel network (“Y only”). It is also worth noting that
the improvement compared with the single-channel network is not that signiﬁcant (i.e., 0.07 dB). This indicates
that the Cb, Cr channels barely help in improving the
performance.
CONCLUSION
We have presented a novel deep learning approach
for single image super-resolution (SR). We show that
conventional sparse-coding-based SR methods can be
reformulated into a deep convolutional neural network.
The proposed approach, SRCNN, learns an end-to-end
mapping between low- and high-resolution images, with
little extra pre/post-processing beyond the optimization.
With a lightweight structure, the SRCNN has achieved
superior performance than the state-of-the-art methods.
We conjecture that additional performance can be further
gained by exploring more ﬁlters and different training
strategies. Besides, the proposed structure, with its advantages of simplicity and robustness, could be applied
to other low-level vision problems, such as image deblurring or simultaneous SR+denoising. One could also
investigate a network to cope with different upscaling