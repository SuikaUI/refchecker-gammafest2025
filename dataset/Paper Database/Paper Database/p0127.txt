Swin Transformer: Hierarchical Vision Transformer using Shifted Windows
Yutong Lin†*
Yixuan Wei†
Zheng Zhang
Stephen Lin
Baining Guo
Microsoft Research Asia
{v-zeliu1,v-yutlin,yuecao,hanhu,v-yixwe,zhez,stevelin,bainguo}@microsoft.com
This paper presents a new vision Transformer, called
Swin Transformer, that capably serves as a general-purpose
backbone for computer vision.
Challenges in adapting
Transformer from language to vision arise from differences
between the two domains, such as large variations in the
scale of visual entities and the high resolution of pixels
in images compared to words in text.
To address these
differences, we propose a hierarchical Transformer whose
representation is computed with Shifted windows.
shifted windowing scheme brings greater efﬁciency by limiting self-attention computation to non-overlapping local
windows while also allowing for cross-window connection.
This hierarchical architecture has the ﬂexibility to model
at various scales and has linear computational complexity
with respect to image size. These qualities of Swin Transformer make it compatible with a broad range of vision
tasks, including image classiﬁcation (87.3 top-1 accuracy
on ImageNet-1K) and dense prediction tasks such as object
detection (58.7 box AP and 51.1 mask AP on COCO testdev) and semantic segmentation (53.5 mIoU on ADE20K
val). Its performance surpasses the previous state-of-theart by a large margin of +2.7 box AP and +2.6 mask AP on
COCO, and +3.2 mIoU on ADE20K, demonstrating the potential of Transformer-based models as vision backbones.
The hierarchical design and the shifted window approach
also prove beneﬁcial for all-MLP architectures. The code
and models are publicly available at 
com/microsoft/Swin-Transformer.
1. Introduction
Modeling in computer vision has long been dominated
by convolutional neural networks (CNNs). Beginning with
AlexNet and its revolutionary performance on the
ImageNet image classiﬁcation challenge, CNN architectures have evolved to become increasingly powerful through
*Equal contribution. †Interns at MSRA. ‡Contact person.
Figure 1. (a) The proposed Swin Transformer builds hierarchical
feature maps by merging image patches (shown in gray) in deeper
layers and has linear computation complexity to input image size
due to computation of self-attention only within each local window (shown in red). It can thus serve as a general-purpose backbone for both image classiﬁcation and dense recognition tasks.
(b) In contrast, previous vision Transformers produce feature maps of a single low resolution and have quadratic computation complexity to input image size due to computation of selfattention globally.
greater scale , more extensive connections , and
more sophisticated forms of convolution . With
CNNs serving as backbone networks for a variety of vision
tasks, these architectural advances have led to performance
improvements that have broadly lifted the entire ﬁeld.
On the other hand, the evolution of network architectures
in natural language processing (NLP) has taken a different
path, where the prevalent architecture today is instead the
Transformer .
Designed for sequence modeling and
transduction tasks, the Transformer is notable for its use
of attention to model long-range dependencies in the data.
Its tremendous success in the language domain has led researchers to investigate its adaptation to computer vision,
where it has recently demonstrated promising results on certain tasks, speciﬁcally image classiﬁcation and joint
vision-language modeling .
In this paper, we seek to expand the applicability of
Transformer such that it can serve as a general-purpose
 
backbone for computer vision, as it does for NLP and
as CNNs do in vision. We observe that signiﬁcant challenges in transferring its high performance in the language
domain to the visual domain can be explained by differences between the two modalities.
One of these differences involves scale.
Unlike the word tokens that serve
as the basic elements of processing in language Transformers, visual elements can vary substantially in scale, a
problem that receives attention in tasks such as object detection . In existing Transformer-based models , tokens are all of a ﬁxed scale, a property unsuitable for these vision applications. Another difference
is the much higher resolution of pixels in images compared to words in passages of text. There exist many vision tasks such as semantic segmentation that require dense
prediction at the pixel level, and this would be intractable
for Transformer on high-resolution images, as the computational complexity of its self-attention is quadratic to image size. To overcome these issues, we propose a generalpurpose Transformer backbone, called Swin Transformer,
which constructs hierarchical feature maps and has linear
computational complexity to image size. As illustrated in
Figure 1(a), Swin Transformer constructs a hierarchical representation by starting from small-sized patches (outlined in
gray) and gradually merging neighboring patches in deeper
Transformer layers. With these hierarchical feature maps,
the Swin Transformer model can conveniently leverage advanced techniques for dense prediction such as feature pyramid networks (FPN) or U-Net . The linear computational complexity is achieved by computing self-attention
locally within non-overlapping windows that partition an
image (outlined in red). The number of patches in each
window is ﬁxed, and thus the complexity becomes linear
to image size. These merits make Swin Transformer suitable as a general-purpose backbone for various vision tasks,
in contrast to previous Transformer based architectures 
which produce feature maps of a single resolution and have
quadratic complexity.
A key design element of Swin Transformer is its shift
of the window partition between consecutive self-attention
layers, as illustrated in Figure 2.
The shifted windows
bridge the windows of the preceding layer, providing connections among them that signiﬁcantly enhance modeling
power (see Table 4). This strategy is also efﬁcient in regards to real-world latency: all query patches within a window share the same key set1, which facilitates memory access in hardware. In contrast, earlier sliding window based
self-attention approaches suffer from low latency
on general hardware due to different key sets for different
query pixels2.
Our experiments show that the proposed
1The query and key are projection vectors in a self-attention layer.
2While there are efﬁcient methods to implement a sliding-window
based convolution layer on general hardware, thanks to its shared kernel
Figure 2. An illustration of the shifted window approach for computing self-attention in the proposed Swin Transformer architecture. In layer l (left), a regular window partitioning scheme is
adopted, and self-attention is computed within each window. In
the next layer l + 1 (right), the window partitioning is shifted, resulting in new windows. The self-attention computation in the new
windows crosses the boundaries of the previous windows in layer
l, providing connections among them.
shifted window approach has much lower latency than the
sliding window method, yet is similar in modeling power
(see Tables 5 and 6). The shifted window approach also
proves beneﬁcial for all-MLP architectures .
The proposed Swin Transformer achieves strong performance on the recognition tasks of image classiﬁcation, object detection and semantic segmentation. It outperforms
the ViT / DeiT and ResNe(X)t models signiﬁcantly with similar latency on the three tasks. Its 58.7
box AP and 51.1 mask AP on the COCO test-dev set surpass the previous state-of-the-art results by +2.7 box AP
(Copy-paste without external data) and +2.6 mask AP
(DetectoRS ). On ADE20K semantic segmentation, it
obtains 53.5 mIoU on the val set, an improvement of +3.2
mIoU over the previous state-of-the-art (SETR ). It also
achieves a top-1 accuracy of 87.3% on ImageNet-1K image
classiﬁcation.
It is our belief that a uniﬁed architecture across computer vision and natural language processing could beneﬁt
both ﬁelds, since it would facilitate joint modeling of visual and textual signals and the modeling knowledge from
both domains can be more deeply shared. We hope that
Swin Transformer’s strong performance on various vision
problems can drive this belief deeper in the community and
encourage uniﬁed modeling of vision and language signals.
2. Related Work
CNN and variants
CNNs serve as the standard network
model throughout computer vision. While the CNN has existed for several decades , it was not until the introduction of AlexNet that the CNN took off and became
mainstream. Since then, deeper and more effective convolutional neural architectures have been proposed to further propel the deep learning wave in computer vision, e.g.,
VGG , GoogleNet , ResNet , DenseNet ,
weights across a feature map, it is difﬁcult for a sliding-window based
self-attention layer to have efﬁcient memory access in practice.
HRNet , and EfﬁcientNet .
In addition to these
architectural advances, there has also been much work on
improving individual convolution layers, such as depthwise convolution and deformable convolution .
While the CNN and its variants are still the primary backbone architectures for computer vision applications, we
highlight the strong potential of Transformer-like architectures for uniﬁed modeling between vision and language.
Our work achieves strong performance on several basic visual recognition tasks, and we hope it will contribute to a
modeling shift.
Self-attention based backbone architectures
Also inspired by the success of self-attention layers and Transformer architectures in the NLP ﬁeld, some works employ
self-attention layers to replace some or all of the spatial convolution layers in the popular ResNet . In these
works, the self-attention is computed within a local window
of each pixel to expedite optimization , and they achieve
slightly better accuracy/FLOPs trade-offs than the counterpart ResNet architecture. However, their costly memory
access causes their actual latency to be signiﬁcantly larger
than that of the convolutional networks . Instead of using sliding windows, we propose to shift windows between
consecutive layers, which allows for a more efﬁcient implementation in general hardware.
Self-attention/Transformers to complement CNNs
Another line of work is to augment a standard CNN architecture with self-attention layers or Transformers. The selfattention layers can complement backbones or head networks by providing the capability to encode distant dependencies or heterogeneous
interactions. More recently, the encoder-decoder design in
Transformer has been applied for the object detection and
instance segmentation tasks . Our work explores the adaptation of Transformers for basic visual feature extraction and is complementary to these works.
Transformer based vision backbones
Most related to
our work is the Vision Transformer (ViT) and its
follow-ups . The pioneering work of
ViT directly applies a Transformer architecture on nonoverlapping medium-sized image patches for image classiﬁcation. It achieves an impressive speed-accuracy tradeoff on image classiﬁcation compared to convolutional networks.
While ViT requires large-scale training datasets
(i.e., JFT-300M) to perform well, DeiT introduces several training strategies that allow ViT to also be effective
using the smaller ImageNet-1K dataset. The results of ViT
on image classiﬁcation are encouraging, but its architecture is unsuitable for use as a general-purpose backbone
network on dense vision tasks or when the input image
resolution is high, due to its low-resolution feature maps
and the quadratic increase in complexity with image size.
There are a few works applying ViT models to the dense
vision tasks of object detection and semantic segmentation by direct upsampling or deconvolution but with relatively lower performance . Concurrent to our work
are some that modify the ViT architecture 
for better image classiﬁcation.
Empirically, we ﬁnd our
Swin Transformer architecture to achieve the best speedaccuracy trade-off among these methods on image classi-
ﬁcation, even though our work focuses on general-purpose
performance rather than speciﬁcally on classiﬁcation. Another concurrent work explores a similar line of thinking to build multi-resolution feature maps on Transformers. Its complexity is still quadratic to image size, while
ours is linear and also operates locally which has proven
beneﬁcial in modeling the high correlation in visual signals . Our approach is both efﬁcient and effective, achieving state-of-the-art accuracy on both COCO
object detection and ADE20K semantic segmentation.
3.1. Overall Architecture
An overview of the Swin Transformer architecture is presented in Figure 3, which illustrates the tiny version (Swin-
T). It ﬁrst splits an input RGB image into non-overlapping
patches by a patch splitting module, like ViT. Each patch is
treated as a “token” and its feature is set as a concatenation
of the raw pixel RGB values. In our implementation, we use
a patch size of 4 × 4 and thus the feature dimension of each
patch is 4 × 4 × 3 = 48. A linear embedding layer is applied on this raw-valued feature to project it to an arbitrary
dimension (denoted as C).
Several Transformer blocks with modiﬁed self-attention
computation (Swin Transformer blocks) are applied on these
patch tokens. The Transformer blocks maintain the number
of tokens ( H
4 ), and together with the linear embedding
are referred to as “Stage 1”.
To produce a hierarchical representation, the number of
tokens is reduced by patch merging layers as the network
gets deeper. The ﬁrst patch merging layer concatenates the
features of each group of 2 × 2 neighboring patches, and
applies a linear layer on the 4C-dimensional concatenated
features. This reduces the number of tokens by a multiple
of 2×2 = 4 (2× downsampling of resolution), and the output dimension is set to 2C. Swin Transformer blocks are
applied afterwards for feature transformation, with the resolution kept at H
8 . This ﬁrst block of patch merging
and feature transformation is denoted as “Stage 2”. The procedure is repeated twice, as “Stage 3” and “Stage 4”, with
output resolutions of H
32 , respectively.
These stages jointly produce a hierarchical representation,
(a) Architecture
(b) Two Successive Swin Transformer Blocks
Transformer
Linear Embedding
Transformer
Patch Merging
Transformer
Patch Merging
Transformer
Patch Merging
Patch Partition
Figure 3. (a) The architecture of a Swin Transformer (Swin-T); (b) two successive Swin Transformer Blocks (notation presented with
Eq. (3)). W-MSA and SW-MSA are multi-head self attention modules with regular and shifted windowing conﬁgurations, respectively.
with the same feature map resolutions as those of typical
convolutional networks, e.g., VGG and ResNet .
As a result, the proposed architecture can conveniently replace the backbone networks in existing methods for various vision tasks.
Swin Transformer block
Swin Transformer is built by
replacing the standard multi-head self attention (MSA)
module in a Transformer block by a module based on
shifted windows (described in Section 3.2), with other layers kept the same. As illustrated in Figure 3(b), a Swin
Transformer block consists of a shifted window based MSA
module, followed by a 2-layer MLP with GELU nonlinearity in between. A LayerNorm (LN) layer is applied
before each MSA module and each MLP, and a residual
connection is applied after each module.
3.2. Shifted Window based Self-Attention
The standard Transformer architecture and its adaptation for image classiﬁcation both conduct global selfattention, where the relationships between a token and all
other tokens are computed. The global computation leads to
quadratic complexity with respect to the number of tokens,
making it unsuitable for many vision problems requiring an
immense set of tokens for dense prediction or to represent a
high-resolution image.
Self-attention in non-overlapped windows
For efﬁcient
modeling, we propose to compute self-attention within local windows. The windows are arranged to evenly partition
the image in a non-overlapping manner. Supposing each
window contains M × M patches, the computational complexity of a global MSA module and a window based one
on an image of h × w patches are3:
Ω(MSA) = 4hwC2 + 2(hw)2C,
Ω(W-MSA) = 4hwC2 + 2M 2hwC,
where the former is quadratic to patch number hw, and the
latter is linear when M is ﬁxed (set to 7 by default). Global
self-attention computation is generally unaffordable for a
large hw, while the window based self-attention is scalable.
Shifted window partitioning in successive blocks
window-based self-attention module lacks connections
across windows, which limits its modeling power. To introduce cross-window connections while maintaining the efﬁcient computation of non-overlapping windows, we propose
a shifted window partitioning approach which alternates between two partitioning conﬁgurations in consecutive Swin
Transformer blocks.
As illustrated in Figure 2, the ﬁrst module uses a regular
window partitioning strategy which starts from the top-left
pixel, and the 8 × 8 feature map is evenly partitioned into
2 × 2 windows of size 4 × 4 (M = 4). Then, the next module adopts a windowing conﬁguration that is shifted from
that of the preceding layer, by displacing the windows by
2 ⌋) pixels from the regularly partitioned windows.
With the shifted window partitioning approach, consecutive Swin Transformer blocks are computed as
ˆzl = W-MSA
ˆzl+1 = SW-MSA
zl+1 = MLP
where ˆzl and zl denote the output features of the (S)W-
MSA module and the MLP module for block l, respectively;
3We omit SoftMax computation in determining complexity.
cyclic shift
window partition
reverse cyclic shift
Figure 4. Illustration of an efﬁcient batch computation approach
for self-attention in shifted window partitioning.
W-MSA and SW-MSA denote window based multi-head
self-attention using regular and shifted window partitioning
conﬁgurations, respectively.
The shifted window partitioning approach introduces
connections between neighboring non-overlapping windows in the previous layer and is found to be effective in image classiﬁcation, object detection, and semantic segmentation, as shown in Table 4.
Efﬁcient batch computation for shifted conﬁguration
An issue with shifted window partitioning is that it will result in more windows, from ⌈h
M ⌉+1) in the shifted conﬁguration, and some of the windows will be smaller than M × M 4. A naive solution is to
pad the smaller windows to a size of M × M and mask
out the padded values when computing attention. When
the number of windows in regular partitioning is small, e.g.
2 × 2, the increased computation with this naive solution is
considerable (2 × 2 →3 × 3, which is 2.25 times greater).
Here, we propose a more efﬁcient batch computation approach by cyclic-shifting toward the top-left direction, as illustrated in Figure 4. After this shift, a batched window may
be composed of several sub-windows that are not adjacent
in the feature map, so a masking mechanism is employed to
limit self-attention computation to within each sub-window.
With the cyclic-shift, the number of batched windows remains the same as that of regular window partitioning, and
thus is also efﬁcient. The low latency of this approach is
shown in Table 5.
Relative position bias
In computing self-attention, we
follow by including a relative position bias
B ∈RM 2×M 2 to each head in computing similarity:
Attention(Q, K, V ) = SoftMax(QKT /
where Q, K, V ∈RM 2×d are the query, key and value matrices; d is the query/key dimension, and M 2 is the number
of patches in a window. Since the relative position along
each axis lies in the range [−M +1, M −1], we parameterize a smaller-sized bias matrix ˆB ∈R(2M−1)×(2M−1), and
values in B are taken from ˆB.
4To make the window size (M, M) divisible by the feature map size of
(h, w), bottom-right padding is employed on the feature map if needed.
We observe signiﬁcant improvements over counterparts
without this bias term or that use absolute position embedding, as shown in Table 4. Further adding absolute position embedding to the input as in drops performance
slightly, thus it is not adopted in our implementation.
The learnt relative position bias in pre-training can be
also used to initialize a model for ﬁne-tuning with a different window size through bi-cubic interpolation .
3.3. Architecture Variants
We build our base model, called Swin-B, to have of
model size and computation complexity similar to ViT-
B/DeiT-B. We also introduce Swin-T, Swin-S and Swin-L,
which are versions of about 0.25×, 0.5× and 2× the model
size and computational complexity, respectively. Note that
the complexity of Swin-T and Swin-S are similar to those
of ResNet-50 (DeiT-S) and ResNet-101, respectively. The
window size is set to M = 7 by default. The query dimension of each head is d = 32, and the expansion layer of
each MLP is α = 4, for all experiments. The architecture
hyper-parameters of these model variants are:
• Swin-T: C = 96, layer numbers = {2, 2, 6, 2}
• Swin-S: C = 96, layer numbers ={2, 2, 18, 2}
• Swin-B: C = 128, layer numbers ={2, 2, 18, 2}
• Swin-L: C = 192, layer numbers ={2, 2, 18, 2}
where C is the channel number of the hidden layers in the
ﬁrst stage. The model size, theoretical computational complexity (FLOPs), and throughput of the model variants for
ImageNet image classiﬁcation are listed in Table 1.
4. Experiments
We conduct experiments on ImageNet-1K image classi-
ﬁcation , COCO object detection , and ADE20K
semantic segmentation . In the following, we ﬁrst compare the proposed Swin Transformer architecture with the
previous state-of-the-arts on the three tasks. Then, we ablate the important design elements of Swin Transformer.
4.1. Image Classiﬁcation on ImageNet-1K
For image classiﬁcation, we benchmark the proposed Swin Transformer on ImageNet-1K , which contains 1.28M training images and 50K validation images
from 1,000 classes. The top-1 accuracy on a single crop
is reported. We consider two training settings:
• Regular ImageNet-1K training.
This setting mostly
follows . We employ an AdamW optimizer
for 300 epochs using a cosine decay learning rate
scheduler and 20 epochs of linear warm-up. A batch
size of 1024, an initial learning rate of 0.001, and a
weight decay of 0.05 are used. We include most of
the augmentation and regularization strategies of 
in training, except for repeated augmentation and
EMA , which do not enhance performance. Note
that this is contrary to where repeated augmentation is crucial to stabilize the training of ViT.
• Pre-training on ImageNet-22K and ﬁne-tuning on
ImageNet-1K.
ImageNet-22K dataset, which contains 14.2 million
images and 22K classes. We employ an AdamW optimizer for 90 epochs using a linear decay learning rate
scheduler with a 5-epoch linear warm-up. A batch size
of 4096, an initial learning rate of 0.001, and a weight
decay of 0.01 are used. In ImageNet-1K ﬁne-tuning,
we train the models for 30 epochs with a batch size of
1024, a constant learning rate of 10−5, and a weight
decay of 10−8.
Results with regular ImageNet-1K training
Table 1(a)
presents comparisons to other backbones, including both
Transformer-based and ConvNet-based,
using regular
ImageNet-1K training.
Compared to the previous state-of-the-art Transformerbased architecture, i.e. DeiT , Swin Transformers noticeably surpass the counterpart DeiT architectures with
similar complexities:
+1.5% for Swin-T (81.3%) over
DeiT-S (79.8%) using 2242 input, and +1.5%/1.4% for
Swin-B (83.3%/84.5%) over DeiT-B (81.8%/83.1%) using
2242/3842 input, respectively.
Compared with the state-of-the-art ConvNets, i.e. Reg-
Net and EfﬁcientNet , the Swin Transformer
achieves a slightly better speed-accuracy trade-off.
Noting that while RegNet and EfﬁcientNet are obtained via a thorough architecture search, the proposed
Swin Transformer is adapted from the standard Transformer
and has strong potential for further improvement.
Results with ImageNet-22K pre-training
We also pretrain the larger-capacity Swin-B and Swin-L on ImageNet-
22K. Results ﬁne-tuned on ImageNet-1K image classiﬁcation are shown in Table 1(b). For Swin-B, the ImageNet-
22K pre-training brings 1.8%∼1.9% gains over training
on ImageNet-1K from scratch. Compared with the previous best results for ImageNet-22K pre-training, our models achieve signiﬁcantly better speed-accuracy trade-offs:
Swin-B obtains 86.4% top-1 accuracy, which is 2.4% higher
than that of ViT with similar inference throughput (84.7
vs. 85.9 images/sec) and slightly lower FLOPs (47.0G vs.
55.4G). The larger Swin-L model achieves 87.3% top-1 accuracy, +0.9% better than that of the Swin-B model.
(a) Regular ImageNet-1K trained models
size #param. FLOPs throughput
(image / s)
top-1 acc.
RegNetY-4G 2242
RegNetY-8G 2242
RegNetY-16G 2242
EffNet-B3 
EffNet-B4 
EffNet-B5 
EffNet-B6 
EffNet-B7 
ViT-B/16 
ViT-L/16 
307M 190.7G
DeiT-S 
DeiT-B 
DeiT-B 
(b) ImageNet-22K pre-trained models
size #param. FLOPs throughput
(image / s)
top-1 acc.
R-101x3 
388M 204.6G
R-152x4 
937M 840.5G
ViT-B/16 
ViT-L/16 
307M 190.7G
197M 103.9G
Table 1. Comparison of different backbones on ImageNet-1K classiﬁcation. Throughput is measured using the GitHub repository
of and a V100 GPU, following .
4.2. Object Detection on COCO
Object detection and instance segmentation experiments are conducted on COCO 2017, which contains
118K training, 5K validation and 20K test-dev images. An
ablation study is performed using the validation set, and a
system-level comparison is reported on test-dev. For the
ablation study, we consider four typical object detection
frameworks: Cascade Mask R-CNN , ATSS ,
RepPoints v2 , and Sparse RCNN in mmdetection . For these four frameworks, we utilize the same
settings: multi-scale training (resizing the input such
that the shorter side is between 480 and 800 while the longer
side is at most 1333), AdamW optimizer (initial learning rate of 0.0001, weight decay of 0.05, and batch size of
16), and 3x schedule (36 epochs). For system-level comparison, we adopt an improved HTC (denoted as HTC++)
with instaboost , stronger multi-scale training , 6x
schedule (72 epochs), soft-NMS , and ImageNet-22K
pre-trained model as initialization.
We compare our Swin Transformer to standard Con-
(a) Various frameworks
Backbone APbox APbox
75 #param. FLOPs FPS
Mask R-CNN
RepPointsV2
(b) Various backbones w. Cascade Mask R-CNN
APboxAPbox
75 APmaskAPmask
paramFLOPsFPS
DeiT-S† 48.0 67.2 51.7
80M 889G 10.4
46.3 64.3 50.5
82M 739G 18.0
Swin-T 50.5 69.3 54.9
86M 745G 15.3
X101-32 48.1 66.5 52.4
45.2 101M 819G 12.8
Swin-S 51.8 70.4 56.3
48.5 107M 838G 12.0
X101-64 48.3 66.4 52.3
45.1 140M 972G 10.4
Swin-B 51.9 70.9 56.5
48.7 145M 982G 11.6
(c) System-level Comparison
#param. FLOPs
APbox APmask APbox APmask
RepPointsV2* 
GCNet* 
RelationNet++* 
SpineNet-190 
164M 1885G
ResNeSt-200* 
EfﬁcientDet-D7 54.4
DetectoRS* 
YOLOv4 P7* 
Copy-paste 
185M 1440G
X101-64 (HTC++)
155M 1033G
Swin-B (HTC++)
160M 1043G
Swin-L (HTC++)
284M 1470G
Swin-L (HTC++)*
Table 2. Results on COCO object detection and instance segmentation.
†denotes that additional decovolution layers are used to
produce hierarchical feature maps. * indicates multi-scale testing.
vNets, i.e. ResNe(X)t, and previous Transformer networks,
e.g. DeiT. The comparisons are conducted by changing only
the backbones with other settings unchanged.
while Swin Transformer and ResNe(X)t are directly applicable to all the above frameworks because of their hierarchical feature maps, DeiT only produces a single resolution of feature maps and cannot be directly applied. For fair
comparison, we follow to construct hierarchical feature
maps for DeiT using deconvolution layers.
Comparison to ResNe(X)t
Table 2(a) lists the results of
Swin-T and ResNet-50 on the four object detection frameworks. Our Swin-T architecture brings consistent +3.4∼4.2
box AP gains over ResNet-50, with slightly larger model
size, FLOPs and latency.
Table 2(b) compares Swin Transformer and ResNe(X)t
#param. FLOPs FPS
mIoU score
DANet 
ResNet-101
1119G 15.2
DLab.v3+ ResNet-101
1021G 16.0
ACNet 
ResNet-101
ResNet-101
1249G 14.8
OCRNet 
ResNet-101
UperNet 
ResNet-101
1029G 20.1
OCRNet 
DLab.v3+ ResNeSt-101 46.9
1051G 11.9
DLab.v3+ ResNeSt-200 48.4
1099G 16.2
1038G 15.2
Table 3. Results of semantic segmentation on the ADE20K val
and test set. † indicates additional deconvolution layers are used
to produce hierarchical feature maps. ‡ indicates that the model is
pre-trained on ImageNet-22K.
under different model capacity using Cascade Mask R-
CNN. Swin Transformer achieves a high detection accuracy
of 51.9 box AP and 45.0 mask AP, which are signiﬁcant
gains of +3.6 box AP and +3.3 mask AP over ResNeXt101-
64x4d, which has similar model size, FLOPs and latency.
On a higher baseline of 52.3 box AP and 46.0 mask AP using an improved HTC framework, the gains by Swin Transformer are also high, at +4.1 box AP and +3.1 mask AP (see
Table 2(c)). Regarding inference speed, while ResNe(X)t is
built by highly optimized Cudnn functions, our architecture
is implemented with built-in PyTorch functions that are not
all well-optimized. A thorough kernel optimization is beyond the scope of this paper.
Comparison to DeiT
The performance of DeiT-S using the Cascade Mask R-CNN framework is shown in Table 2(b). The results of Swin-T are +2.5 box AP and +2.3
mask AP higher than DeiT-S with similar model size (86M
vs. 80M) and signiﬁcantly higher inference speed (15.3 FPS
vs. 10.4 FPS). The lower inference speed of DeiT is mainly
due to its quadratic complexity to input image size.
Comparison to previous state-of-the-art
Table 2(c)
compares our best results with those of previous state-ofthe-art models. Our best model achieves 58.7 box AP and
51.1 mask AP on COCO test-dev, surpassing the previous
best results by +2.7 box AP (Copy-paste without external data) and +2.6 mask AP (DetectoRS ).
4.3. Semantic Segmentation on ADE20K
ADE20K is a widely-used semantic segmentation dataset, covering a broad range of 150 semantic
top-1 top-5
w/o shifting
shifted windows
abs.+rel. pos.
rel. pos. w/o app.
Table 4. Ablation study on the shifted windows approach and different position embedding methods on three benchmarks, using
the Swin-T architecture. w/o shifting: all self-attention modules
adopt regular window partitioning, without shifting; abs. pos.: absolute position embedding term of ViT; rel. pos.: the default settings with an additional relative position bias term (see Eq. (4));
app.: the ﬁrst scaled dot-product term in Eq. (4).
categories. It has 25K images in total, with 20K for training,
2K for validation, and another 3K for testing. We utilize
UperNet in mmseg as our base framework for its
high efﬁciency. More details are presented in the Appendix.
Table 3 lists the mIoU, model size (#param),
FLOPs and FPS for different method/backbone pairs. From
these results, it can be seen that Swin-S is +5.3 mIoU higher
(49.3 vs. 44.0) than DeiT-S with similar computation cost.
It is also +4.4 mIoU higher than ResNet-101, and +2.4
mIoU higher than ResNeSt-101 . Our Swin-L model
with ImageNet-22K pre-training achieves 53.5 mIoU on the
val set, surpassing the previous best model by +3.2 mIoU
(50.3 mIoU by SETR which has a larger model size).
4.4. Ablation Study
In this section, we ablate important design elements in
the proposed Swin Transformer, using ImageNet-1K image
classiﬁcation, Cascade Mask R-CNN on COCO object detection, and UperNet on ADE20K semantic segmentation.
Shifted windows
Ablations of the shifted window approach on the three tasks are reported in Table 4. Swin-T
with the shifted window partitioning outperforms the counterpart built on a single window partitioning at each stage by
+1.1% top-1 accuracy on ImageNet-1K, +2.8 box AP/+2.2
mask AP on COCO, and +2.8 mIoU on ADE20K. The results indicate the effectiveness of using shifted windows to
build connections among windows in the preceding layers.
The latency overhead by shifted window is also small, as
shown in Table 5.
Relative position bias
Table 4 shows comparisons of different position embedding approaches. Swin-T with relative position bias yields +1.2%/+0.8% top-1 accuracy on
ImageNet-1K, +1.3/+1.5 box AP and +1.1/+1.3 mask AP
MSA in a stage (ms) Arch. (FPS)
sliding window (naive)
122.5 38.3 12.1 7.6 183 109 77
sliding window (kernel)
2.7 1.8 488 283 187
Performer 
1.8 1.5 638 370 241
window (w/o shifting)
1.2 0.9 770 444 280
shifted window (padding)
1.9 2.2 670 371 236
shifted window (cyclic)
1.3 1.0 755 437 278
Table 5. Real speed of different self-attention computation methods and implementations on a V100 GPU.
on COCO, and +2.3/+2.9 mIoU on ADE20K in relation to
those without position encoding and with absolute position
embedding, respectively, indicating the effectiveness of the
relative position bias. Also note that while the inclusion of
absolute position embedding improves image classiﬁcation
accuracy (+0.4%), it harms object detection and semantic
segmentation (-0.2 box/mask AP on COCO and -0.6 mIoU
on ADE20K).
While the recent ViT/DeiT models abandon translation
invariance in image classiﬁcation even though it has long
been shown to be crucial for visual modeling, we ﬁnd that
inductive bias that encourages certain translation invariance
is still preferable for general-purpose visual modeling, particularly for the dense prediction tasks of object detection
and semantic segmentation.
Different self-attention methods
The real speed of different self-attention computation methods and implementations are compared in Table 5. Our cyclic implementation
is more hardware efﬁcient than naive padding, particularly
for deeper stages. Overall, it brings a 13%, 18% and 18%
speed-up on Swin-T, Swin-S and Swin-B, respectively.
The self-attention modules built on the proposed
shifted window approach are 40.8×/2.5×, 20.2×/2.5×,
9.3×/2.1×, and 7.6×/1.8× more efﬁcient than those of sliding windows in naive/kernel implementations on four network stages, respectively. Overall, the Swin Transformer
architectures built on shifted windows are 4.1/1.5, 4.0/1.5,
3.6/1.5 times faster than variants built on sliding windows
for Swin-T, Swin-S, and Swin-B, respectively. Table 6 compares their accuracy on the three tasks, showing that they are
similarly accurate in visual modeling.
Compared to Performer , which is one of the fastest
Transformer architectures (see ), the proposed shifted
window based self-attention computation and the overall
Swin Transformer architectures are slightly faster (see Table 5), while achieving +2.3% top-1 accuracy compared to
Performer on ImageNet-1K using Swin-T (see Table 6).
5. Conclusion
This paper presents Swin Transformer, a new vision
Transformer which produces a hierarchical feature repre-
Backbone top-1 top-5 APbox APmask
sliding window
Performer 
shifted window
Table 6. Accuracy of Swin Transformer using different methods
for self-attention computation on three benchmarks.
sentation and has linear computational complexity with respect to input image size. Swin Transformer achieves the
state-of-the-art performance on COCO object detection and
ADE20K semantic segmentation, signiﬁcantly surpassing
previous best methods. We hope that Swin Transformer’s
strong performance on various vision problems will encourage uniﬁed modeling of vision and language signals.
As a key element of Swin Transformer, the shifted window based self-attention is shown to be effective and efﬁcient on vision problems, and we look forward to investigating its use in natural language processing as well.
Acknowledgement
We thank many colleagues at Microsoft for their help,
in particular, Li Dong and Furu Wei for useful discussions;
Bin Xiao, Lu Yuan and Lei Zhang for help on datasets.
A1. Detailed Architectures
The detailed architecture speciﬁcations are shown in Table 7, where an input image size of 224×224 is assumed for
all architectures. “Concat n × n” indicates a concatenation
of n × n neighboring features in a patch. This operation
results in a downsampling of the feature map by a rate of n.
“96-d” denotes a linear layer with an output dimension of
96. “win. sz. 7 × 7” indicates a multi-head self-attention
module with window size of 7 × 7.
A2. Detailed Experimental Settings
A2.1. Image classiﬁcation on ImageNet-1K
The image classiﬁcation is performed by applying a
global average pooling layer on the output feature map of
the last stage, followed by a linear classiﬁer. We ﬁnd this
strategy to be as accurate as using an additional class token as in ViT and DeiT . In evaluation, the top-1
accuracy using a single crop is reported.
Regular ImageNet-1K training
The training settings
mostly follow . For all model variants, we adopt a default input image resolution of 2242. For other resolutions
such as 3842, we ﬁne-tune the models trained at 2242 resolution, instead of training from scratch, to reduce GPU consumption.
When training from scratch with a 2242 input, we employ an AdamW optimizer for 300 epochs using a cosine decay learning rate scheduler with 20 epochs of linear
warm-up. A batch size of 1024, an initial learning rate of
0.001, a weight decay of 0.05, and gradient clipping with
a max norm of 1 are used. We include most of the augmentation and regularization strategies of in training,
including RandAugment , Mixup , Cutmix ,
random erasing and stochastic depth , but not repeated augmentation and Exponential Moving Average
(EMA) which do not enhance performance. Note that
this is contrary to where repeated augmentation is crucial to stabilize the training of ViT. An increasing degree of
stochastic depth augmentation is employed for larger models, i.e. 0.2, 0.3, 0.5 for Swin-T, Swin-S, and Swin-B, respectively.
For ﬁne-tuning on input with larger resolution, we employ an adamW optimizer for 30 epochs with a constant learning rate of 10−5, weight decay of 10−8, and
the same data augmentation and regularizations as the ﬁrst
stage except for setting the stochastic depth ratio to 0.1.
ImageNet-22K pre-training
We also pre-train on the
larger ImageNet-22K dataset, which contains 14.2 million
images and 22K classes. The training is done in two stages.
For the ﬁrst stage with 2242 input, we employ an AdamW
optimizer for 90 epochs using a linear decay learning rate
scheduler with a 5-epoch linear warm-up. A batch size of
4096, an initial learning rate of 0.001, and a weight decay
of 0.01 are used. In the second stage of ImageNet-1K ﬁnetuning with 2242/3842 input, we train the models for 30
epochs with a batch size of 1024, a constant learning rate of
10−5, and a weight decay of 10−8.
A2.2. Object detection on COCO
For an ablation study, we consider four typical object detection frameworks: Cascade Mask R-CNN ,
ATSS , RepPoints v2 , and Sparse RCNN in
mmdetection . For these four frameworks, we utilize
the same settings: multi-scale training (resizing the
input such that the shorter side is between 480 and 800
while the longer side is at most 1333), AdamW optimizer (initial learning rate of 0.0001, weight decay of 0.05,
and batch size of 16), and 3x schedule (36 epochs with the
learning rate decayed by 10× at epochs 27 and 33).
For system-level comparison, we adopt an improved
HTC (denoted as HTC++) with instaboost , stronger
multi-scale training (resizing the input such that the
shorter side is between 400 and 1400 while the longer side
is at most 1600), 6x schedule (72 epochs with the learning
rate decayed at epochs 63 and 69 by a factor of 0.1), soft-
NMS , and an extra global self-attention layer appended
at the output of last stage and ImageNet-22K pre-trained
downsp. rate
(output size)
concat 4×4, 96-d, LN
concat 4×4, 96-d, LN
concat 4×4, 128-d, LN
concat 4×4, 192-d, LN
 win. sz. 7×7,
dim 96, head 3
 win. sz. 7×7,
dim 96, head 3
 win. sz. 7×7,
dim 128, head 4
 win. sz. 7×7,
dim 192, head 6
concat 2×2, 192-d , LN
concat 2×2, 192-d , LN
concat 2×2, 256-d , LN
concat 2×2, 384-d , LN
 win. sz. 7×7,
dim 192, head 6
 win. sz. 7×7,
dim 192, head 6
 win. sz. 7×7,
dim 256, head 8
 win. sz. 7×7,
dim 384, head 12
concat 2×2, 384-d , LN
concat 2×2, 384-d , LN
concat 2×2, 512-d , LN
concat 2×2, 768-d , LN
 win. sz. 7×7,
dim 384, head 12
 win. sz. 7×7,
dim 384, head 12
 win. sz. 7×7,
dim 512, head 16
 win. sz. 7×7,
dim 768, head 24
concat 2×2, 768-d , LN
concat 2×2, 768-d , LN
concat 2×2, 1024-d , LN
concat 2×2, 1536-d , LN
 win. sz. 7×7,
dim 768, head 24
 win. sz. 7×7,
dim 768, head 24
win. sz. 7×7,
dim 1024, head 32
win. sz. 7×7,
dim 1536, head 48
Table 7. Detailed architecture speciﬁcations.
model as initialization. We adopt stochastic depth with ratio of 0.2 for all Swin Transformer models.
A2.3. Semantic segmentation on ADE20K
ADE20K is a widely-used semantic segmentation
dataset, covering a broad range of 150 semantic categories.
It has 25K images in total, with 20K for training, 2K for validation, and another 3K for testing. We utilize UperNet 
in mmsegmentation as our base framework for its high
efﬁciency.
In training, we employ the AdamW optimizer with
an initial learning rate of 6 × 10−5, a weight decay of 0.01,
a scheduler that uses linear learning rate decay, and a linear warmup of 1,500 iterations. Models are trained on 8
GPUs with 2 images per GPU for 160K iterations. For augmentations, we adopt the default setting in mmsegmentation
of random horizontal ﬂipping, random re-scaling within
ratio range [0.5, 2.0] and random photometric distortion.
Stochastic depth with ratio of 0.2 is applied for all Swin
Transformer models. Swin-T, Swin-S are trained on the
standard setting as the previous approaches with an input
of 512×512. Swin-B and Swin-L with ‡ indicate that these
two models are pre-trained on ImageNet-22K, and trained
with the input of 640×640.
In inference, a multi-scale test using resolutions that are
[0.5, 0.75, 1.0, 1.25, 1.5, 1.75]× of that in training is employed. When reporting test scores, both the training images and validation images are used for training, following
common practice .
A3. More Experiments
A3.1. Image classiﬁcation with different input size
Table 8 lists the performance of Swin Transformers with
different input image sizes from 2242 to 3842. In general,
a larger input resolution leads to better top-1 accuracy but
with slower inference speed.
throughput
(image / s)
throughput
(image / s)
throughput
(image / s)
Table 8. Swin Transformers with different input image size on
ImageNet-1K classiﬁcation.
Backbone Optimizer APbox APbox
75 APmask APmask
X101-32x4d
X101-64x4d
Table 9. Comparison of the SGD and AdamW optimizers for
ResNe(X)t backbones on COCO object detection using the Cascade Mask R-CNN framework.
A3.2. Different Optimizers for ResNe(X)t on COCO
Table 9 compares the AdamW and SGD optimizers of
the ResNe(X)t backbones on COCO object detection. The
Cascade Mask R-CNN framework is used in this comparison. While SGD is used as a default optimizer for Cascade Mask R-CNN framework, we generally observe improved accuracy by replacing it with an AdamW optimizer,
particularly for smaller backbones. We thus use AdamW
for ResNe(X)t backbones when compared to the proposed
Swin Transformer architectures.
A3.3. Swin MLP-Mixer
We apply the proposed hierarchical design and the
shifted window approach to the MLP-Mixer architectures , referred to as Swin-Mixer. Table 10 shows the
performance of Swin-Mixer compared to the original MLP-
Mixer architectures MLP-Mixer and a follow-up ap-
size #param. FLOPs throughput
(image / s)
top-1 acc.
MLP-Mixer-B/16 2242
ResMLP-S24 
ResMLP-B24 
Swin-T/D24
(Transformer)
Swin-Mixer-T/D24
Swin-Mixer-T/D12
Swin-Mixer-T/D6
Swin-Mixer-B/D24
(no shift)
Swin-Mixer-B/D24
Table 10. Performance of Swin MLP-Mixer on ImageNet-1K classiﬁcation. D indictes the number of channels per head. Throughput is measured using the GitHub repository of and a V100
GPU, following .
proach, ResMLP . Swin-Mixer performs signiﬁcantly
better than MLP-Mixer (81.3% vs. 76.4%) using slightly
smaller computation budget (10.4G vs. 12.7G). It also has
better speed accuracy trade-off compared to ResMLP .
These results indicate the proposed hierarchical design and
the shifted window approach are generalizable.